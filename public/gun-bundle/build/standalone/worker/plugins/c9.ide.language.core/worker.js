"no use strict";
!(function(window) {
if (typeof window.window != "undefined" && window.document)
    return;
if (window.require && window.define)
    return;

if (!window.console) {
    window.console = function() {
        var msgs = Array.prototype.slice.call(arguments, 0);
        postMessage({type: "log", data: msgs});
    };
    window.console.error =
    window.console.warn = 
    window.console.log =
    window.console.trace = window.console;
}
window.window = window;
window.ace = window;

window.onerror = function(message, file, line, col, err) {
    postMessage({type: "error", data: {
        message: message,
        data: err.data,
        file: file,
        line: line, 
        col: col,
        stack: err.stack
    }});
};

window.initSender = function initSender() {

    var EventEmitter = window.require("ace/lib/event_emitter").EventEmitter;
    var oop = window.require("ace/lib/oop");
    
    var Sender = function() {};
    
    (function() {
        
        oop.implement(this, EventEmitter);
                
        this.callback = function(data, callbackId) {
            postMessage({
                type: "call",
                id: callbackId,
                data: data
            });
        };
    
        this.emit = function(name, data) {
            postMessage({
                type: "event",
                name: name,
                data: data
            });
        };
        
    }).call(Sender.prototype);
    
    return new Sender();
};

var main = window.main = null;
var sender = window.sender = null;

window.updateRequireConfig = function(config) {
    window.require.config(config);
};

window.onmessage = function(e) {
    var msg = e.data;
    if (msg.event && sender) {
        sender._signal(msg.event, msg.data);
    }
    else if (msg.command) {
        if (main && main[msg.command])
            main[msg.command].apply(main, msg.args);
        else if (window[msg.command])
            window[msg.command].apply(window, msg.args);
        else
            throw new Error("Unknown command:" + msg.command);
    }
    else if (msg.init) {
        if (!window.require)
           importScripts(msg.requireConfig.requireSourceUrl);
        window.require.config(msg.requireConfig);
        sender = window.sender = window.initSender();
        var clazz = require(msg.module)[msg.classname];
        main = window.main = new clazz(sender);
    }
};
})(this);

(function() {

var MODULE_LOAD_URL = "/static/build/modules";

var global = (function() { return this; })();
if (!global && typeof window != "undefined") global = window; // can happen in strict mode

var commentRegExp = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg;
var cjsRequireRegExp = /require\s*\(\s*["']([^'"\s]+)["']\s*\)/g;

function getInlineDeps(fn) {
    var deps = [];
    if (fn.length) {
        fn.toString().replace(commentRegExp, "")
            .replace(cjsRequireRegExp, function (match, dep, index, str) {
                var i = index; 
                while (str.charCodeAt(i -= 1) <= 32) {}
                if (str.charAt(i) !== ".")
                    deps.push(dep);
            });
        deps = ["require", "exports", "module"].concat(deps);
    }
    return deps;
}

var define = function(name, deps, callback) {
    if (typeof name !== "string") {
        callback = deps;
        deps = name;
        name = null;
    }
    if (deps && !Array.isArray(deps)) {
        callback = deps;
        deps = null;
    }
    
    if (nextModule) {
        if (!name || name == nextModule.name) {
            name = nextModule.name;
            deps = deps || nextModule.deps;
            nextModule = null;
        }
    }
    
    if (!name)
        return defQueue.push([deps, callback]);
    
    if (define.loaded[name])
        return;
    
    if (!deps && typeof callback == "function")
        deps = getInlineDeps(callback);
    
    define.loaded[name] = {
        id: name,
        deps: normalizeNames(name, deps || []),
        factory: callback,
        exports: {},
        packaged: true
    };
    if (define.loading[name])
        delete define.loading[name];
    if (define.lastModule)
        define.pending.push(name);
    else
        define.lastModule = name;
};
var defQueue = [];
var nextModule;
var addToLoadQueue = function(missing, deps, callback, errback) {
    var toLoad = missing.length;
    var map = {};
    define.queue.push({
        deps: deps,
        map: map,
        toLoad: toLoad,
        callback: callback,
        errback: errback
    });
    
    for (var i = 0; i < missing.length; ++i) {
        var p = missing[i];
        map[p] = 1;
        if (!define.loading[p]) {
            require.load(p);
            define.loading[p] = 1;
        }
    }
};

var processLoadQueue = function(err, id) {
    var changed = false;
    if (err) {
        if (!id) id = err.id;
        define.errors[id] = err;
        define.queue.forEach(function(r) {
            if (r.map[id]) {
                r.toLoad = -1;
                if (r.errback) r.errback(err);
            }
        });
        if (define.lastModule == id)
            define.lastModule = null;
        define.pending = define.pending.filter(function(p) {
            return p != id;
        });
        changed = true;
    } else if (id && !defQueue.length && !define.loaded[id]) {
        defQueue = [config.shim && config.shim[id] || [[], null]];
    }
    
    if (defQueue.length) {
        if (defQueue.length > 1)
            throw new Error("more than one module in defqueue");
        define(id, defQueue[0][0], defQueue[0][1]);
        defQueue.length = 0;
    }
    
    var pending = define.pending;
    define.queue.forEach(function(r) {
        pending.forEach(function(id) {
            if (r.map[id])
                r.toLoad--;
        });
        if (r.map[define.lastModule])
            r.toLoad--;
        if (!r.toLoad) {
            changed = true;
            _require("", r.deps, r.callback, r.errback);
        }
    });
    
    define.lastModule = null;
    if (pending.length)
        define.pending = [];
    
    if (changed) {
        define.queue = define.queue.filter(function(r) {
            return r.toLoad > 0;
        });
    }
};

define.amd = {};
define.queue = [];
define.loaded = {};
define.errors = {};
define.loading = {};
define.pending = [];
define.modules = { require: 1, exports: 1, module: 1 };
define.fetchedUrls = {};

var activateModule = function(name) {
    var module = define.loaded[name];
    var exports = module.exports;
    if (typeof module.factory !== "function") {
        exports = module.factory;
    } else {
        var req = function(path, callback) {
            return _require(name, path, callback);
        };
        req.toUrl = function(namePlusExt, _1, _2, skipBalancers) {
            return require.toUrl(normalizeName(name, namePlusExt), null, null, skipBalancers);
        };
        req.config = require.config;
        
        var missing = checkMissing(module.deps);
        if (missing.length)
            return missing;
        
        module.define = define;
        var specialModules = {
            require: req,
            exports: exports,
            module: module,
        };
        
        define.modules[name] = exports;
        var args = module.deps.slice(0, module.factory.length);
        var returnValue = args.length
            ? module.factory.apply(module, args.map(function(name) { 
                return specialModules[name] || lookup(name);
            }))
            : module.factory(req, exports, module);
        
        exports = returnValue == undefined ? module.exports : returnValue;
    }
    delete define.loaded[name];
    define.modules[name] = exports;
};

var checkMissing = function(deps, seen, missing) {
    missing = missing || {};
    seen = seen || {};
    for (var i = 0; i < deps.length; ++i) {
        var depName = deps[i];
        if (!define.modules[depName]) {
            var dep = define.loaded[depName];
            if (!dep)
                missing[depName] = 1;
            else if (!missing[depName] && !seen[depName]) {
                seen[depName] = 1;
                checkMissing(dep.deps, seen, missing);
            }
        }
    }
    return Object.keys(missing);
};

var lookup = function(moduleName) {
    var mod = define.modules[moduleName];
    if (mod === undefined && define.loaded[moduleName]) {
        activateModule(moduleName);
        mod = define.modules[moduleName];
    }
    return mod;
};

var _require = function(parentId, moduleName, callback, errback) {
    if (typeof moduleName === "string") {
        var depName = normalizeName(parentId, moduleName);
        var module = lookup(depName);
        if (module !== undefined) {
            if (typeof callback == "function")
                callback(module);
            return module;
        } else if (typeof importScripts != "undefined") {
            addToLoadQueue([depName], [depName]);
            return lookup(depName);
        }
    } else if (Array.isArray(moduleName)) {
        var deps = normalizeNames(parentId, moduleName);
        var missing = checkMissing(deps);
        if (!missing.length) {
            var args = deps.map(lookup);
            return callback && callback.apply(null, args);
        } else {
            return addToLoadQueue(missing, deps, callback, errback);
        }
    }
};

var normalizeName = function(parentId, moduleName) {
    if (moduleName.indexOf("!") !== -1) {
        var chunks = moduleName.split("!");
        return normalizeName(parentId, chunks[0]) + "!" + normalizeName(parentId, chunks[1]);
    }
    if (moduleName.charAt(0) == ".") {
        var base = parentId.split("/").slice(0, -1).join("/");
        moduleName = (base || parentId) + "/" + moduleName;

        while (moduleName.indexOf(".") !== -1 && previous != moduleName) {
            var previous = moduleName;
            moduleName = moduleName.replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
        }
    }

    return moduleName;
};

var normalizeNames = function(parentId, moduleNames) {
    return moduleNames.map(function(name) {
        return normalizeName(parentId, name);
    });
};

var require = function(module, callback, errback) {
    return _require("", module, callback, errback);
};

var config = require.config = function(cfg) {
    if (cfg.baseUrl)
        config.baseUrl = cfg.baseUrl.replace(/\/*$/, "/");
    
    if (cfg.host)
        host = cfg.host;
    
    if (Array.isArray(cfg.packages)) {
        cfg.packages.forEach(function(pkg) {
            if (typeof pkg === "string") pkg = { name: pkg };
            config.packages[pkg.name] = {
                name: pkg.name,
                location: (pkg.location || pkg.name).replace(/\/*$/, "/"),
                main: (pkg.main || "main").replace(/\.js$/, "").replace(/^\.\//, "")
            };
        });
    } else if (cfg.packages) {
         config.packages = cfg.packages;
    }
    
    cfg.paths && Object.keys(cfg.paths).forEach(function(p) {
        config.paths[p] = cfg.paths[p];
    });
    
    if (cfg.useCache && global.caches && (location.protocol === "https:" || location.hostname == "localhost")) {
        config.useCache = true;
        checkCache();
    }
    
    if (cfg.transform)
        config.transform = cfg.transform;
    
    if (cfg.baseUrlLoadBalancers)
        config.baseUrlLoadBalancers = cfg.baseUrlLoadBalancers;
    
    if (cfg.MODULE_LOAD_URL)
        require.MODULE_LOAD_URL = cfg.MODULE_LOAD_URL;
};

require.resetConfig = function() {
    config.packages = Object.create(null);
    config.paths = Object.create(null);
    config.baseUrl = "";
    config.useCache = false;
    config.transform = "";
};

require.getConfig = function() {
    var script = document.querySelector("script[src*=mini_require]");
    return {
        packages: config.packages,
        paths: config.paths,
        baseUrl: config.baseUrl,
        useCache: config.useCache,
        transform: config.transform,
        host: host,
        requireSourceUrl: script && script.src,
        MODULE_LOAD_URL: require.MODULE_LOAD_URL,
    };
};

require.resetConfig();

define.undef = require.undef = function(module, recursive) {
    module = normalizeName("", module);
    if (recursive) {
        var root = (module + "/").replace(/\/+$/, "/");
        undefAll(root, define.errors);
        undefAll(root, define.loaded);
        undefAll(root, define.modules);
        undefAll(root, define.loading);
    }
    else {
        undefOne(module, require.toUrl(module, ".js"));
    }
};

function undefOne(module, path) {
    delete define.errors[module];
    delete define.loaded[module];
    delete define.modules[module];
    delete define.loading[module];
    delete define.fetchedUrls[path];
}

function undefAll(module, hash) {
    Object.keys(hash).forEach(function(key) {
        var i = key.indexOf("!") + 1;
        if (key.lastIndexOf(module, 0) == 0)
            undefOne(key, require.toUrl(key, ".js"));
        if (i) {
            var plugin = key.slice(0, i - 1);
            var resource = key.slice(i);
            if (resource.lastIndexOf(module, 0) == 0 || plugin.lastIndexOf(module, 0) == 0) {
                undefOne(key, require.toUrl(key, ""));
                undefOne(resource, require.toUrl(resource, ""));
            }
        }
    });
}

require.MODULE_LOAD_URL = MODULE_LOAD_URL;

require.toUrl = function(moduleName, ext, skipExt, skipBalancers) {
    var absRe = /^([\w\+\.\-]+:|\/)/;
    var index = moduleName.indexOf("!");
    if (index !== -1 || !ext || /^\//.test(moduleName))
        ext = "";
        
    var paths = config.paths;
    var pkgs = config.packages;
    
    var testPath = moduleName, tail = "";
    while (testPath) {
        if (paths[testPath]) {
            moduleName = paths[testPath] + tail;
            break;
        }
        if (pkgs[testPath]) {
            moduleName = pkgs[testPath].location + (tail || pkgs[testPath].main);
            break;
        }
        var i = testPath.lastIndexOf("/");
        if (i === -1) break;
        tail = testPath.substr(i) + tail;
        testPath = testPath.slice(0, i);
    }
    
    if (skipExt)
        return testPath; 
    
    var url = ext == ".js" && moduleName.slice(-3) == ext
        ? moduleName
        : moduleName + ext;
    if (!absRe.test(url)) {
        if (ext == ".js" && require.config.transform)
            url = ("~/" + require.config.transform + "/" + url).replace("//", "/");
        url = (config.baseUrl || require.MODULE_LOAD_URL + "/") + url;
    }
    if (url[0] === "/" && config.baseUrlLoadBalancers && !skipBalancers && !config.useCache) {
        var n = Math.abs(hashCode(url)) % config.baseUrlLoadBalancers.length;
        url = config.baseUrlLoadBalancers[n] + url;
    }
    if (url[0] == "/")
        url = host + url;
    return url;
};

function hashCode(string) {
    var result = 0, i, chr, len;
    if (string.length == 0) return result;
    for (i = 0, len = string.length; i < len; i++) {
        chr = string.charCodeAt(i);
        result = ((result << 5) - result) + chr;
        result |= 0; // Convert to 32bit integer
    }
    return result;
}

var loadScriptWithTag = function(path, id, callback) {
    if (typeof importScripts == "function") {
        nextModule = { name: id, deps: null };
        if (path[0] == "/")
            path = host + path;
        importScripts(path);
        return callback(null, id);
    }
    var head = document.head || document.documentElement;
    var s = document.createElement("script");
    s.src = path;
    s.charset = "utf-8";
    s.async = true;
    
    if (path.lastIndexOf(require.MODULE_LOAD_URL, 0) == 0 && path[0] != "/")
        s.crossOrigin = true;
    
    s.onload = s.onreadystatechange = function(_, isAbort) {
        if (isAbort || !s.readyState || s.readyState == "loaded" || s.readyState == "complete") {
            s.remove && s.remove();
            s = s.onload = s.onreadystatechange = null;
            if (!isAbort)
                callback(null, id);
        }
    };
    s.onerror = function(e) {
        processLoadQueue({
            message: "Error loading script " + id + ":" + path,
            id: id,
            path: path
        });
    };
    head.appendChild(s);
};

function loadText(path, cb) {
    var xhr = new window.XMLHttpRequest();
    xhr.open("GET", path, true);
    xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8");
    xhr.onload = function(e) {
        if (xhr.status > 399 && xhr.status < 600)
            return cb(xhr);
        cb(null, xhr.responseText, xhr);
    };
    xhr.onabort = xhr.onerror = function(e) { cb(e); };
    xhr.send("");
}
var host = location.protocol + "//" + location.hostname + (location.port ? ":" + location.port : "");
var loadScript = function(path, id, callback) {
    if (!config.useCache)
        return loadScriptWithTag(path, id, callback);
    if (!/^https?:/.test(path))
        path = host + path;
    var cb = function(e, val, deps) {
        if (e) return processLoadQueue({ id: id, path: path });
        
        nextModule = { name: id, deps: deps };
        window.eval(val + "\n//# sourceURL=" + path);
        callback(null, id);
        return define.loaded[id];
    };
    loadCached(path, cb);
};

var loadCached = function(path, cb) {
    if (!config.useCache)
        return loadText(path, cb);
    function loadNew() {
        loadText(path, function(e, val, xhr) {
            var m = cb(e, val);
            if (!e) {
                var ETAG = xhr.getResponseHeader("ETAG");
                if (!ETAG) return;
                var res = new Response(val);
                res.headers.set("ETAG", ETAG);
                var req = new Request(path);
                req.headers.set("ETAG", ETAG);
                if (m && m.deps)
                    res.headers.set("deps", m.deps.join(","));
                ideCache.put(req, res).catch(function() {
                    ideCache.delete(path);
                });
            }
        });
    }
    if (!ideCache && !ideCachePromiss) {
        checkCache();
    }
    if (ideCachePromiss) {
        return ideCachePromiss.then(function(i) {
            if (i) ideCache = i;
            loadCached(path, cb);
        });
    }
    ideCache.match(path).then(function(e) {
        if (!e)
            return loadNew();
        return e.text().then(function(val) {
            var deps = e.headers.get("deps");
            if (typeof deps == "string")
                deps = deps ? deps.split(",") : [];

            cb(null, val, deps);
        });
    }).catch(function() {
        loadNew();
        ideCache.delete(path);
    });
};

var ideCache;
var ideCachePromiss;
function checkCache() {
    var baseUrl;
    ideCachePromiss = config.useCache && window.caches.open("ide").catch(function(e) {
        console.error(e);
        config.useCache = ideCachePromiss = ideCache = null;
    }).then(function(ideCache_) {
        ideCache = ideCache_;
        return ideCache ? ideCache.keys() : [];
    }).then(function(keys) {
        baseUrl = config.baseUrl;
        if (baseUrl[0] == "/")
            baseUrl = host + baseUrl;
        var val = keys.map(function(r) {
            var url = r.url;
            if (url.startsWith(baseUrl))
                url = url.slice(baseUrl.length);
            else if (/^\w+:/.test(url))
                return "";
            return r.headers.get("etag") + " " + url;
        }).join("\n") + "\n";
        if (val.length <= 1) {
            ideCachePromiss = null;
            return ideCache;
        }
        return new Promise(function(resolve) {
            var checked = 0;
            var buffer = "";
            var toDelete = [];
            post(baseUrl + "__check__", val, function(t) {
                var e = t.slice(checked);
                checked = t.length;
                var parts = (buffer + e).split("\n");
                buffer = parts.pop();
                for (var i = 0; i < parts.length; i++) {
                    if (parts[i]) {
                        var del = ideCache.delete(baseUrl + parts[i]);
                        toDelete.push(del);
                        if (require.config.transform) {
                            del = ideCache.delete(baseUrl + ("~/" + require.config.transform) + parts[i]);
                            toDelete.push(del);
                        }
                    }
                }
            }, function(e, t) {
               ideCachePromiss = null;
               Promise.all(toDelete).then(function() {
                   resolve(ideCache);
               });
               setTimeout(function() {
                    setTimeout(function() {
                        config.useCache = false;
                    }, 5000);
               }, 5000);
            });
        });
    });
    return ideCachePromiss;
}

require.clearCache = function(callback) {
    ideCachePromiss = window.caches.open("ide").then(function(ideCache_) {
        ideCache = ideCache_;
        return ideCache.keys();
    }).then(function(keys) {
        var toDelete = keys.map(function(i) {
            ideCache.delete(i);
        });
        Promise.all(toDelete).then(function() {
           callback && callback();
        }, function(e) {
            callback && callback(e);
        });
    });
};

function post(path, val, progress, cb) {
    var xhr = new window.XMLHttpRequest();
    xhr.open("POST", path, true);
    xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8");
    xhr.onload = function(e) {
        if (xhr.status > 399 && xhr.status < 600)
            return cb(xhr);
        cb(null, xhr.responseText, xhr);
    };
    xhr.onreadystatechange = function(e) { progress(xhr.responseText, xhr); };
    xhr.onabort = xhr.onerror = function(e) { cb(e); };
    xhr.send(val);
}

require.load = function(module) {
    var i = module.indexOf("!") + 1;
    if (i) {
        var plugin = module.substring(0, i);
        module = module.substr(i);
        if (typeof require[plugin] == "function") {
            require[plugin](module, processLoadQueue);
        } else if (config.baseUrl) {
            if (require[plugin])
                return require[plugin][plugin + module] = 1;
            require[plugin] = Object.create(null);
            require[plugin][plugin + module] = 1;
            require([plugin.slice(0, -1)], function(p) {
                var pending = require[plugin];
                definePlugin(plugin, p);
                Object.keys(pending).forEach(function(p) {
                    delete define.loading[p];
                });
                require(Object.keys(pending));
            });
        } else {
            console.error("require plugin " + plugin + "missing");
        }
    } else {
        var url = require.toUrl(module, ".js");
        if (define.fetchedUrls[url] & 1)
            return false;
        define.fetchedUrls[url] |= 1;
        loadScript(url, module, processLoadQueue);
    }
};

function definePlugin(plugin, p) {
    require[plugin] = function(moduleName, processLoadQueue) {
        p.load(moduleName, require, function(value) {
            define(plugin + moduleName, [], function() {
                return value;
            });
            processLoadQueue();
        });
    };
}
require["vfs!"] = function(module, callback) {
    var url = require.MODULE_LOAD_URL + "/~node/" + module;
    if (define.fetchedUrls[url] & 4)
        return false;
    define.fetchedUrls[url] |= 4;
    define("vfs!" + module, [], {
        srcUrl: url,
        path: module
    });
    callback();
};
require["text!"] = function(module, callback) {
    var url = require.toUrl(module);
    if (define.fetchedUrls[url] & 2)
        return false;
    define.fetchedUrls[url] |= 2;
    var cb = function(e, val) {
        if (e) console.error("Couldn't load module " + module, e);
        define("text!" + module, [], val);
        callback();
    };
    loadCached(url, cb);
};
require["ace/requirejs/text!"] = function(module, callback) {
    var url = require.toUrl(module);
    if (define.fetchedUrls[url] & 2)
        return false;
    define.fetchedUrls[url] |= 2;
    var cb = function(e, val) {
        if (e) console.error("Couldn't load module " + module, e);
        define("ace/requirejs/text!" + module, [], val);
        callback();
    };
    loadCached(url, cb);
};
if (!global.define || !global.define.packaged) {
    define.original = global.define;
    global.define = define;
    global.define.packaged = true;
}

if (!global.require || !global.require.packaged) {
    global.require = require;
    global.require.packaged = true;
}

if (!global.requirejs) global.requirejs = require;

global.miniRequire = require;


})();

define("require",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;

var requirejs, require, define;
(function (global) {
    var req, s, head, baseElement, dataMain, src,
        interactiveScript, currentlyAddingScript, mainScript, subPath,
        version = '2.1.4',
        commentRegExp = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg,
        cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,
        jsSuffixRegExp = /\.js$/,
        currDirRegExp = /^\.\//,
        op = Object.prototype,
        ostring = op.toString,
        hasOwn = op.hasOwnProperty,
        ap = Array.prototype,
        apsp = ap.splice,
        isBrowser = !!(typeof window !== 'undefined' && navigator && document),
        isWebWorker = !isBrowser && typeof importScripts !== 'undefined',
        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?
                      /^complete$/ : /^(complete|loaded)$/,
        defContextName = '_',
        isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',
        contexts = {},
        cfg = {},
        globalDefQueue = [],
        useInteractive = false;

    function isFunction(it) {
        return ostring.call(it) === '[object Function]';
    }

    function isArray(it) {
        return ostring.call(it) === '[object Array]';
    }
    function each(ary, func) {
        if (ary) {
            var i;
            for (i = 0; i < ary.length; i += 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }
    function eachReverse(ary, func) {
        if (ary) {
            var i;
            for (i = ary.length - 1; i > -1; i -= 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    function getOwn(obj, prop) {
        return hasProp(obj, prop) && obj[prop];
    }
    function eachProp(obj, func) {
        var prop;
        for (prop in obj) {
            if (hasProp(obj, prop)) {
                if (func(obj[prop], prop)) {
                    break;
                }
            }
        }
    }
    function mixin(target, source, force, deepStringMixin) {
        if (source) {
            eachProp(source, function (value, prop) {
                if (force || !hasProp(target, prop)) {
                    if (deepStringMixin && typeof value !== 'string') {
                        if (!target[prop]) {
                            target[prop] = {};
                        }
                        mixin(target[prop], value, force, deepStringMixin);
                    } else {
                        target[prop] = value;
                    }
                }
            });
        }
        return target;
    }
    function bind(obj, fn) {
        return function () {
            return fn.apply(obj, arguments);
        };
    }

    function scripts() {
        return document.getElementsByTagName('script');
    }
    function getGlobal(value) {
        if (!value) {
            return value;
        }
        var g = global;
        each(value.split('.'), function (part) {
            g = g[part];
        });
        return g;
    }
    function makeError(id, msg, err, requireModules) {
        var e = new Error(msg + '\nhttp://requirejs.org/docs/errors.html#' + id);
        e.requireType = id;
        e.requireModules = requireModules;
        if (err) {
            e.originalError = err;
        }
        return e;
    }

    if (typeof define !== 'undefined') {
        return;
    }

    if (typeof requirejs !== 'undefined') {
        if (isFunction(requirejs)) {
            return;
        }
        cfg = requirejs;
        requirejs = undefined;
    }
    if (typeof require !== 'undefined' && !isFunction(require)) {
        cfg = require;
        require = undefined;
    }

    function newContext(contextName) {
        var inCheckLoaded, Module, context, handlers,
            checkLoadedTimeoutId,
            config = {
                waitSeconds: 7,
                baseUrl: './',
                paths: {},
                pkgs: {},
                shim: {},
                map: {},
                config: {}
            },
            registry = {},
            undefEvents = {},
            defQueue = [],
            defined = {},
            urlFetched = {},
            requireCounter = 1,
            unnormalizedCounter = 1;
        function trimDots(ary) {
            var i, part;
            for (i = 0; ary[i]; i += 1) {
                part = ary[i];
                if (part === '.') {
                    ary.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                        break;
                    } else if (i > 0) {
                        ary.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
        }
        function normalize(name, baseName, applyMap) {
            var pkgName, pkgConfig, mapValue, nameParts, i, j, nameSegment,
                foundMap, foundI, foundStarMap, starI,
                baseParts = baseName && baseName.split('/'),
                normalizedBaseParts = baseParts,
                map = config.map,
                starMap = map && map['*'];
            if (name && name.charAt(0) === '.') {
                if (baseName) {
                    if (getOwn(config.pkgs, baseName)) {
                        normalizedBaseParts = baseParts = [baseName];
                    } else {
                        normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                    }

                    name = normalizedBaseParts.concat(name.split('/'));
                    trimDots(name);
                    pkgConfig = getOwn(config.pkgs, (pkgName = name[0]));
                    name = name.join('/');
                    if (pkgConfig && name === pkgName + '/' + pkgConfig.main) {
                        name = pkgName;
                    }
                } else if (name.indexOf('./') === 0) {
                    name = name.substring(2);
                }
            }
            if (applyMap && (baseParts || starMap) && map) {
                nameParts = name.split('/');

                for (i = nameParts.length; i > 0; i -= 1) {
                    nameSegment = nameParts.slice(0, i).join('/');

                    if (baseParts) {
                        for (j = baseParts.length; j > 0; j -= 1) {
                            mapValue = getOwn(map, baseParts.slice(0, j).join('/'));
                            if (mapValue) {
                                mapValue = getOwn(mapValue, nameSegment);
                                if (mapValue) {
                                    foundMap = mapValue;
                                    foundI = i;
                                    break;
                                }
                            }
                        }
                    }

                    if (foundMap) {
                        break;
                    }
                    if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {
                        foundStarMap = getOwn(starMap, nameSegment);
                        starI = i;
                    }
                }

                if (!foundMap && foundStarMap) {
                    foundMap = foundStarMap;
                    foundI = starI;
                }

                if (foundMap) {
                    nameParts.splice(0, foundI, foundMap);
                    name = nameParts.join('/');
                }
            }

            return name;
        }

        function removeScript(name) {
            if (isBrowser) {
                each(scripts(), function (scriptNode) {
                    if (scriptNode.getAttribute('data-requiremodule') === name &&
                            scriptNode.getAttribute('data-requirecontext') === context.contextName) {
                        scriptNode.parentNode.removeChild(scriptNode);
                        return true;
                    }
                });
            }
        }

        function hasPathFallback(id) {
            var pathConfig = getOwn(config.paths, id);
            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {
                removeScript(id);
                pathConfig.shift();
                context.require.undef(id);
                context.require([id]);
                return true;
            }
        }
        function splitPrefix(name) {
            var prefix,
                index = name ? name.indexOf('!') : -1;
            if (index > -1) {
                prefix = name.substring(0, index);
                name = name.substring(index + 1, name.length);
            }
            return [prefix, name];
        }
        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
            var url, pluginModule, suffix, nameParts,
                prefix = null,
                parentName = parentModuleMap ? parentModuleMap.name : null,
                originalName = name,
                isDefine = true,
                normalizedName = '';
            if (!name) {
                isDefine = false;
                name = '_@r' + (requireCounter += 1);
            }

            nameParts = splitPrefix(name);
            prefix = nameParts[0];
            name = nameParts[1];

            if (prefix) {
                prefix = normalize(prefix, parentName, applyMap);
                pluginModule = getOwn(defined, prefix);
            }
            if (name) {
                if (prefix) {
                    if (pluginModule && pluginModule.normalize) {
                        normalizedName = pluginModule.normalize(name, function (name) {
                            return normalize(name, parentName, applyMap);
                        });
                    } else {
                        normalizedName = normalize(name, parentName, applyMap);
                    }
                } else {
                    normalizedName = normalize(name, parentName, applyMap);
                    nameParts = splitPrefix(normalizedName);
                    prefix = nameParts[0];
                    normalizedName = nameParts[1];
                    isNormalized = true;

                    url = context.nameToUrl(normalizedName);
                }
            }
            suffix = prefix && !pluginModule && !isNormalized ?
                     '_unnormalized' + (unnormalizedCounter += 1) :
                     '';

            return {
                prefix: prefix,
                name: normalizedName,
                parentMap: parentModuleMap,
                unnormalized: !!suffix,
                url: url,
                originalName: originalName,
                isDefine: isDefine,
                id: (prefix ?
                        prefix + '!' + normalizedName :
                        normalizedName) + suffix
            };
        }

        function getModule(depMap) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (!mod) {
                mod = registry[id] = new context.Module(depMap);
            }

            return mod;
        }

        function on(depMap, name, fn) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (hasProp(defined, id) &&
                    (!mod || mod.defineEmitComplete)) {
                if (name === 'defined') {
                    fn(defined[id]);
                }
            } else {
                getModule(depMap).on(name, fn);
            }
        }

        function onError(err, errback) {
            var ids = err.requireModules,
                notified = false;

            if (errback) {
                errback(err);
            } else {
                each(ids, function (id) {
                    var mod = getOwn(registry, id);
                    if (mod) {
                        mod.error = err;
                        if (mod.events.error) {
                            notified = true;
                            mod.emit('error', err);
                        }
                    }
                });

                if (!notified) {
                    req.onError(err);
                }
            }
        }
        function takeGlobalQueue() {
            if (globalDefQueue.length) {
                apsp.apply(defQueue,
                           [defQueue.length - 1, 0].concat(globalDefQueue));
                globalDefQueue = [];
            }
        }

        handlers = {
            'require': function (mod) {
                if (mod.require) {
                    return mod.require;
                } else {
                    return (mod.require = context.makeRequire(mod.map));
                }
            },
            'exports': function (mod) {
                mod.usingExports = true;
                if (mod.map.isDefine) {
                    if (mod.exports) {
                        return mod.exports;
                    } else {
                        return (mod.exports = defined[mod.map.id] = {});
                    }
                }
            },
            'module': function (mod) {
                if (mod.module) {
                    return mod.module;
                } else {
                    return (mod.module = {
                        id: mod.map.id,
                        uri: mod.map.url,
                        config: function () {
                            return (config.config && getOwn(config.config, mod.map.id)) || {};
                        },
                        exports: defined[mod.map.id]
                    });
                }
            }
        };

        function cleanRegistry(id) {
            delete registry[id];
        }

        function breakCycle(mod, traced, processed) {
            var id = mod.map.id;

            if (mod.error) {
                mod.emit('error', mod.error);
            } else {
                traced[id] = true;
                each(mod.depMaps, function (depMap, i) {
                    var depId = depMap.id,
                        dep = getOwn(registry, depId);
                    if (dep && !mod.depMatched[i] && !processed[depId]) {
                        if (getOwn(traced, depId)) {
                            mod.defineDep(i, defined[depId]);
                            mod.check(); //pass false?
                        } else {
                            breakCycle(dep, traced, processed);
                        }
                    }
                });
                processed[id] = true;
            }
        }

        function checkLoaded() {
            var map, modId, err, usingPathFallback,
                waitInterval = config.waitSeconds * 1000,
                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),
                noLoads = [],
                reqCalls = [],
                stillLoading = false,
                needCycleCheck = true;
            if (inCheckLoaded) {
                return;
            }

            inCheckLoaded = true;
            eachProp(registry, function (mod) {
                map = mod.map;
                modId = map.id;
                if (!mod.enabled) {
                    return;
                }

                if (!map.isDefine) {
                    reqCalls.push(mod);
                }

                if (!mod.error) {
                    if (!mod.inited && expired) {
                        if (hasPathFallback(modId)) {
                            usingPathFallback = true;
                            stillLoading = true;
                        } else {
                            noLoads.push(modId);
                            removeScript(modId);
                        }
                    } else if (!mod.inited && mod.fetched && map.isDefine) {
                        stillLoading = true;
                        if (!map.prefix) {
                            return (needCycleCheck = false);
                        }
                    }
                }
            });

            if (expired && noLoads.length) {
                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);
                err.contextName = context.contextName;
                return onError(err);
            }
            if (needCycleCheck) {
                each(reqCalls, function (mod) {
                    breakCycle(mod, {}, {});
                });
            }
            if ((!expired || usingPathFallback) && stillLoading) {
                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {
                    checkLoadedTimeoutId = setTimeout(function () {
                        checkLoadedTimeoutId = 0;
                        checkLoaded();
                    }, 50);
                }
            }

            inCheckLoaded = false;
        }

        Module = function (map) {
            this.events = getOwn(undefEvents, map.id) || {};
            this.map = map;
            this.shim = getOwn(config.shim, map.id);
            this.depExports = [];
            this.depMaps = [];
            this.depMatched = [];
            this.pluginMaps = {};
            this.depCount = 0;
        };

        Module.prototype = {
            init: function (depMaps, factory, errback, options) {
                options = options || {};
                if (this.inited) {
                    return;
                }

                this.factory = factory;

                if (errback) {
                    this.on('error', errback);
                } else if (this.events.error) {
                    errback = bind(this, function (err) {
                        this.emit('error', err);
                    });
                }
                this.depMaps = depMaps && depMaps.slice(0);

                this.errback = errback;
                this.inited = true;

                this.ignore = options.ignore;
                if (options.enabled || this.enabled) {
                    this.enable();
                } else {
                    this.check();
                }
            },

            defineDep: function (i, depExports) {
                if (!this.depMatched[i]) {
                    this.depMatched[i] = true;
                    this.depCount -= 1;
                    this.depExports[i] = depExports;
                }
            },

            fetch: function () {
                if (this.fetched) {
                    return;
                }
                this.fetched = true;

                context.startTime = (new Date()).getTime();

                var map = this.map;
                if (this.shim) {
                    context.makeRequire(this.map, {
                        enableBuildCallback: true
                    })(this.shim.deps || [], bind(this, function () {
                        return map.prefix ? this.callPlugin() : this.load();
                    }));
                } else {
                    return map.prefix ? this.callPlugin() : this.load();
                }
            },

            load: function () {
                var url = this.map.url;
                if (!urlFetched[url]) {
                    urlFetched[url] = true;
                    context.load(this.map.id, url);
                }
            },
            check: function () {
                if (!this.enabled || this.enabling) {
                    return;
                }

                var err, cjsModule,
                    id = this.map.id,
                    depExports = this.depExports,
                    exports = this.exports,
                    factory = this.factory;

                if (!this.inited) {
                    this.fetch();
                } else if (this.error) {
                    this.emit('error', this.error);
                } else if (!this.defining) {
                    this.defining = true;

                    if (this.depCount < 1 && !this.defined) {
                        if (isFunction(factory)) {
                            if (this.events.error) {
                                try {
                                    exports = context.execCb(id, factory, depExports, exports);
                                } catch (e) {
                                    err = e;
                                }
                            } else {
                                exports = context.execCb(id, factory, depExports, exports);
                            }

                            if (this.map.isDefine) {
                                cjsModule = this.module;
                                if (cjsModule &&
                                        cjsModule.exports !== undefined &&
                                        cjsModule.exports !== this.exports) {
                                    exports = cjsModule.exports;
                                } else if (exports === undefined && this.usingExports) {
                                    exports = this.exports;
                                }
                            }

                            if (err) {
                                err.requireMap = this.map;
                                err.requireModules = [this.map.id];
                                err.requireType = 'define';
                                return onError((this.error = err));
                            }

                        } else {
                            exports = factory;
                        }

                        this.exports = exports;

                        if (this.map.isDefine && !this.ignore) {
                            defined[id] = exports;

                            if (req.onResourceLoad) {
                                req.onResourceLoad(context, this.map, this.depMaps);
                            }
                        }
                        delete registry[id];

                        this.defined = true;
                    }
                    this.defining = false;

                    if (this.defined && !this.defineEmitted) {
                        this.defineEmitted = true;
                        this.emit('defined', this.exports);
                        this.defineEmitComplete = true;
                    }

                }
            },

            callPlugin: function () {
                var map = this.map,
                    id = map.id,
                    pluginMap = makeModuleMap(map.prefix);
                this.depMaps.push(pluginMap);

                on(pluginMap, 'defined', bind(this, function (plugin) {
                    var load, normalizedMap, normalizedMod,
                        name = this.map.name,
                        parentName = this.map.parentMap ? this.map.parentMap.name : null,
                        localRequire = context.makeRequire(map.parentMap, {
                            enableBuildCallback: true
                        });
                    if (this.map.unnormalized) {
                        if (plugin.normalize) {
                            name = plugin.normalize(name, function (name) {
                                return normalize(name, parentName, true);
                            }) || '';
                        }
                        normalizedMap = makeModuleMap(map.prefix + '!' + name,
                                                      this.map.parentMap);
                        on(normalizedMap,
                            'defined', bind(this, function (value) {
                                this.init([], function () { return value; }, null, {
                                    enabled: true,
                                    ignore: true
                                });
                            }));

                        normalizedMod = getOwn(registry, normalizedMap.id);
                        if (normalizedMod) {
                            this.depMaps.push(normalizedMap);

                            if (this.events.error) {
                                normalizedMod.on('error', bind(this, function (err) {
                                    this.emit('error', err);
                                }));
                            }
                            normalizedMod.enable();
                        }

                        return;
                    }

                    load = bind(this, function (value) {
                        this.init([], function () { return value; }, null, {
                            enabled: true
                        });
                    });

                    load.error = bind(this, function (err) {
                        this.inited = true;
                        this.error = err;
                        err.requireModules = [id];
                        eachProp(registry, function (mod) {
                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {
                                cleanRegistry(mod.map.id);
                            }
                        });

                        onError(err);
                    });
                    load.fromText = bind(this, function (text, textAlt) {
                        var moduleName = map.name,
                            moduleMap = makeModuleMap(moduleName),
                            hasInteractive = useInteractive;
                        if (textAlt) {
                            text = textAlt;
                        }
                        if (hasInteractive) {
                            useInteractive = false;
                        }
                        getModule(moduleMap);
                        if (hasProp(config.config, id)) {
                            config.config[moduleName] = config.config[id];
                        }

                        try {
                            req.exec(text);
                        } catch (e) {
                            return onError(makeError('fromtexteval',
                                             'fromText eval for ' + id +
                                            ' failed: ' + e,
                                             e,
                                             [id]));
                        }

                        if (hasInteractive) {
                            useInteractive = true;
                        }
                        this.depMaps.push(moduleMap);
                        context.completeLoad(moduleName);
                        localRequire([moduleName], load);
                    });
                    plugin.load(map.name, localRequire, load, config);
                }));

                context.enable(pluginMap, this);
                this.pluginMaps[pluginMap.id] = pluginMap;
            },

            enable: function () {
                this.enabled = true;
                this.enabling = true;
                each(this.depMaps, bind(this, function (depMap, i) {
                    var id, mod, handler;

                    if (typeof depMap === 'string') {
                        depMap = makeModuleMap(depMap,
                                               (this.map.isDefine ? this.map : this.map.parentMap),
                                               false,
                                               !this.skipMap);
                        this.depMaps[i] = depMap;

                        handler = getOwn(handlers, depMap.id);

                        if (handler) {
                            this.depExports[i] = handler(this);
                            return;
                        }

                        this.depCount += 1;

                        on(depMap, 'defined', bind(this, function (depExports) {
                            this.defineDep(i, depExports);
                            this.check();
                        }));

                        if (this.errback) {
                            on(depMap, 'error', this.errback);
                        }
                    }

                    id = depMap.id;
                    mod = registry[id];
                    if (!hasProp(handlers, id) && mod && !mod.enabled) {
                        context.enable(depMap, this);
                    }
                }));
                eachProp(this.pluginMaps, bind(this, function (pluginMap) {
                    var mod = getOwn(registry, pluginMap.id);
                    if (mod && !mod.enabled) {
                        context.enable(pluginMap, this);
                    }
                }));

                this.enabling = false;

                this.check();
            },

            on: function (name, cb) {
                var cbs = this.events[name];
                if (!cbs) {
                    cbs = this.events[name] = [];
                }
                cbs.push(cb);
            },

            emit: function (name, evt) {
                each(this.events[name], function (cb) {
                    cb(evt);
                });
                if (name === 'error') {
                    delete this.events[name];
                }
            }
        };

        function callGetModule(args) {
            if (!hasProp(defined, args[0])) {
                getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);
            }
        }

        function removeListener(node, func, name, ieName) {
            if (node.detachEvent && !isOpera) {
                if (ieName) {
                    node.detachEvent(ieName, func);
                }
            } else {
                node.removeEventListener(name, func, false);
            }
        }
        function getScriptData(evt) {
            var node = evt.currentTarget || evt.srcElement;
            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');
            removeListener(node, context.onScriptError, 'error');

            return {
                node: node,
                id: node && node.getAttribute('data-requiremodule')
            };
        }

        function intakeDefines() {
            var args;
            takeGlobalQueue();
            while (defQueue.length) {
                args = defQueue.shift();
                if (args[0] === null) {
                    return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' + args[args.length - 1]));
                } else {
                    callGetModule(args);
                }
            }
        }

        context = {
            config: config,
            contextName: contextName,
            registry: registry,
            defined: defined,
            urlFetched: urlFetched,
            defQueue: defQueue,
            Module: Module,
            makeModuleMap: makeModuleMap,
            nextTick: req.nextTick,
            configure: function (cfg) {
                if (cfg.baseUrl) {
                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {
                        cfg.baseUrl += '/';
                    }
                }
                var pkgs = config.pkgs,
                    shim = config.shim,
                    objs = {
                        paths: true,
                        config: true,
                        map: true
                    };

                eachProp(cfg, function (value, prop) {
                    if (objs[prop]) {
                        if (prop === 'map') {
                            mixin(config[prop], value, true, true);
                        } else {
                            mixin(config[prop], value, true);
                        }
                    } else {
                        config[prop] = value;
                    }
                });
                if (cfg.shim) {
                    eachProp(cfg.shim, function (value, id) {
                        if (isArray(value)) {
                            value = {
                                deps: value
                            };
                        }
                        if ((value.exports || value.init) && !value.exportsFn) {
                            value.exportsFn = context.makeShimExports(value);
                        }
                        shim[id] = value;
                    });
                    config.shim = shim;
                }
                if (cfg.packages) {
                    each(cfg.packages, function (pkgObj) {
                        var location;

                        pkgObj = typeof pkgObj === 'string' ? { name: pkgObj } : pkgObj;
                        location = pkgObj.location;
                        pkgs[pkgObj.name] = {
                            name: pkgObj.name,
                            location: location || pkgObj.name,
                            main: (pkgObj.main || 'main')
                                  .replace(currDirRegExp, '')
                                  .replace(jsSuffixRegExp, '')
                        };
                    });
                    config.pkgs = pkgs;
                }
                eachProp(registry, function (mod, id) {
                    if (!mod.inited && !mod.map.unnormalized) {
                        mod.map = makeModuleMap(id);
                    }
                });
                if (cfg.deps || cfg.callback) {
                    context.require(cfg.deps || [], cfg.callback);
                }
            },

            makeShimExports: function (value) {
                function fn() {
                    var ret;
                    if (value.init) {
                        ret = value.init.apply(global, arguments);
                    }
                    return ret || (value.exports && getGlobal(value.exports));
                }
                return fn;
            },

            makeRequire: function (relMap, options) {
                options = options || {};

                function localRequire(deps, callback, errback) {
                    var id, map, requireMod;

                    if (options.enableBuildCallback && callback && isFunction(callback)) {
                        callback.__requireJsBuild = true;
                    }

                    if (typeof deps === 'string') {
                        if (isFunction(callback)) {
                            return onError(makeError('requireargs', 'Invalid require call'), errback);
                        }
                        if (relMap && hasProp(handlers, deps)) {
                            return handlers[deps](registry[relMap.id]);
                        }
                        if (req.get) {
                            return req.get(context, deps, relMap);
                        }
                        map = makeModuleMap(deps, relMap, false, true);
                        id = map.id;

                        if (!hasProp(defined, id)) {
                            return onError(makeError('notloaded', 'Module name "' +
                                        id +
                                        '" has not been loaded yet for context: ' +
                                        contextName +
                                        (relMap ? '' : '. Use require([])')));
                        }
                        return defined[id];
                    }
                    intakeDefines();
                    context.nextTick(function () {
                        intakeDefines();

                        requireMod = getModule(makeModuleMap(null, relMap));
                        requireMod.skipMap = options.skipMap;

                        requireMod.init(deps, callback, errback, {
                            enabled: true
                        });

                        checkLoaded();
                    });

                    return localRequire;
                }

                mixin(localRequire, {
                    isBrowser: isBrowser,
                    toUrl: function (moduleNamePlusExt) {
                        var ext, url,
                            index = moduleNamePlusExt.lastIndexOf('.'),
                            segment = moduleNamePlusExt.split('/')[0],
                            isRelative = segment === '.' || segment === '..';
                        if (index !== -1 && (!isRelative || index > 1)) {
                            ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);
                            moduleNamePlusExt = moduleNamePlusExt.substring(0, index);
                        }

                        url = context.nameToUrl(normalize(moduleNamePlusExt,
                                                relMap && relMap.id, true), ext || '.fake');
                        return ext ? url : url.substring(0, url.length - 5);
                    },

                    defined: function (id) {
                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);
                    },

                    specified: function (id) {
                        id = makeModuleMap(id, relMap, false, true).id;
                        return hasProp(defined, id) || hasProp(registry, id);
                    }
                });
                if (!relMap) {
                    localRequire.undef = function (id) {
                        takeGlobalQueue();

                        var map = makeModuleMap(id, relMap, true),
                            mod = getOwn(registry, id);

                        delete defined[id];
                        delete urlFetched[map.url];
                        delete undefEvents[id];

                        if (mod) {
                            if (mod.events.defined) {
                                undefEvents[id] = mod.events;
                            }

                            cleanRegistry(id);
                        }
                    };
                }

                return localRequire;
            },
            enable: function (depMap) {
                var mod = getOwn(registry, depMap.id);
                if (mod) {
                    getModule(depMap).enable();
                }
            },
            completeLoad: function (moduleName) {
                var found, args, mod,
                    shim = getOwn(config.shim, moduleName) || {},
                    shExports = shim.exports;

                takeGlobalQueue();

                while (defQueue.length) {
                    args = defQueue.shift();
                    if (args[0] === null) {
                        args[0] = moduleName;
                        if (found) {
                            break;
                        }
                        found = true;
                    } else if (args[0] === moduleName) {
                        found = true;
                    }

                    callGetModule(args);
                }
                mod = getOwn(registry, moduleName);

                if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {
                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {
                        if (hasPathFallback(moduleName)) {
                            return;
                        } else {
                            return onError(makeError('nodefine',
                                             'No define call for ' + moduleName,
                                             null,
                                             [moduleName]));
                        }
                    } else {
                        callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);
                    }
                }

                checkLoaded();
            },
            nameToUrl: function (moduleName, ext) {
                var paths, pkgs, pkg, pkgPath, syms, i, parentModule, url,
                    parentPath;
                if (req.jsExtRegExp.test(moduleName)) {
                    url = moduleName + (ext || '');
                } else {
                    paths = config.paths;
                    pkgs = config.pkgs;

                    syms = moduleName.split('/');
                    for (i = syms.length; i > 0; i -= 1) {
                        parentModule = syms.slice(0, i).join('/');
                        pkg = getOwn(pkgs, parentModule);
                        parentPath = getOwn(paths, parentModule);
                        if (parentPath) {
                            if (isArray(parentPath)) {
                                parentPath = parentPath[0];
                            }
                            syms.splice(0, i, parentPath);
                            break;
                        } else if (pkg) {
                            if (moduleName === pkg.name) {
                                pkgPath = pkg.location + '/' + pkg.main;
                            } else {
                                pkgPath = pkg.location;
                            }
                            syms.splice(0, i, pkgPath);
                            break;
                        }
                    }
                    url = syms.join('/');
                    url += (ext || (/\?/.test(url) ? '' : '.js'));
                    url = (url.charAt(0) === '/' || url.match(/^[\w\+\.\-]+:/) ? '' : config.baseUrl) + url;
                }

                return config.urlArgs ? url +
                                        ((url.indexOf('?') === -1 ? '?' : '&') +
                                         config.urlArgs) : url;
            },
            load: function (id, url) {
                req.load(context, id, url);
            },
            execCb: function (name, callback, args, exports) {
                return callback.apply(exports, args);
            },
            onScriptLoad: function (evt) {
                if (evt.type === 'load' ||
                        (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {
                    interactiveScript = null;
                    var data = getScriptData(evt);
                    context.completeLoad(data.id);
                }
            },
            onScriptError: function (evt) {
                var data = getScriptData(evt);
                if (!hasPathFallback(data.id)) {
                    return onError(makeError('scripterror', 'Script error', evt, [data.id]));
                }
            }
        };

        context.require = context.makeRequire();
        return context;
    }
    req = requirejs = function (deps, callback, errback, optional) {
        var context, config,
            contextName = defContextName;
        if (!isArray(deps) && typeof deps !== 'string') {
            config = deps;
            if (isArray(callback)) {
                deps = callback;
                callback = errback;
                errback = optional;
            } else {
                deps = [];
            }
        }

        if (config && config.context) {
            contextName = config.context;
        }

        context = getOwn(contexts, contextName);
        if (!context) {
            context = contexts[contextName] = req.s.newContext(contextName);
        }

        if (config) {
            context.configure(config);
        }

        return context.require(deps, callback, errback);
    };
    req.config = function (config) {
        return req(config);
    };
    req.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {
        setTimeout(fn, 4);
    } : function (fn) { fn(); };
    if (!require) {
        require = req;
    }

    req.version = version;
    req.jsExtRegExp = /^\/|:|\?|\.js$/;
    req.isBrowser = isBrowser;
    s = req.s = {
        contexts: contexts,
        newContext: newContext
    };
    req({});
    each([
        'toUrl',
        'undef',
        'defined',
        'specified'
    ], function (prop) {
        req[prop] = function () {
            var ctx = contexts[defContextName];
            return ctx.require[prop].apply(ctx, arguments);
        };
    });

    if (isBrowser) {
        head = s.head = document.getElementsByTagName('head')[0];
        baseElement = document.getElementsByTagName('base')[0];
        if (baseElement) {
            head = s.head = baseElement.parentNode;
        }
    }
    req.onError = function (err) {
        throw err;
    };
    req.load = function (context, moduleName, url) {
        var config = (context && context.config) || {},
            node;
        if (isBrowser) {
            node = config.xhtml ?
                    document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
                    document.createElement('script');
            node.type = config.scriptType || 'text/javascript';
            node.charset = 'utf-8';
            node.async = true;

            node.setAttribute('data-requirecontext', context.contextName);
            node.setAttribute('data-requiremodule', moduleName);
            if (node.attachEvent &&
                    !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&
                    !isOpera) {
                useInteractive = true;

                node.attachEvent('onreadystatechange', context.onScriptLoad);
            } else {
                node.addEventListener('load', context.onScriptLoad, false);
                node.addEventListener('error', context.onScriptError, false);
            }
            node.src = url;
            currentlyAddingScript = node;
            if (baseElement) {
                head.insertBefore(node, baseElement);
            } else {
                head.appendChild(node);
            }
            currentlyAddingScript = null;

            return node;
        } else if (isWebWorker) {
            importScripts(url);
            context.completeLoad(moduleName);
        }
    };

    function getInteractiveScript() {
        if (interactiveScript && interactiveScript.readyState === 'interactive') {
            return interactiveScript;
        }

        eachReverse(scripts(), function (script) {
            if (script.readyState === 'interactive') {
                return (interactiveScript = script);
            }
        });
        return interactiveScript;
    }
    if (isBrowser) {
        eachReverse(scripts(), function (script) {
            if (!head) {
                head = script.parentNode;
            }
            dataMain = script.getAttribute('data-main');
            if (dataMain) {
                if (!cfg.baseUrl) {
                    src = dataMain.split('/');
                    mainScript = src.pop();
                    subPath = src.length ? src.join('/') + '/' : './';

                    cfg.baseUrl = subPath;
                    dataMain = mainScript;
                }
                dataMain = dataMain.replace(jsSuffixRegExp, '');
                cfg.deps = cfg.deps ? cfg.deps.concat(dataMain) : [dataMain];

                return true;
            }
        });
    }
    define = function (name, deps, callback) {
        var node, context;
        if (typeof name !== 'string') {
            callback = deps;
            deps = name;
            name = null;
        }
        if (!isArray(deps)) {
            callback = deps;
            deps = [];
        }
        if (!deps.length && isFunction(callback)) {
            if (callback.length) {
                callback
                    .toString()
                    .replace(commentRegExp, '')
                    .replace(cjsRequireRegExp, function (match, dep) {
                        deps.push(dep);
                    });
                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);
            }
        }
        if (useInteractive) {
            node = currentlyAddingScript || getInteractiveScript();
            if (node) {
                if (!name) {
                    name = node.getAttribute('data-requiremodule');
                }
                context = contexts[node.getAttribute('data-requirecontext')];
            }
        }
        (context ? context.defQueue : globalDefQueue).push([name, deps, callback]);
    };

    define.amd = {
        jQuery: true
    };
    req.exec = function (text) {
        return eval(text);
    };
    req(cfg);
}(this));

});

define("acorn/dist/acorn",["require", "exports", "module"], function(require, exports, module) {

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.acorn = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/src\\expression.js":[function(_dereq_,module,exports){
//
//
"use strict";

var _tokentype = _dereq_("./tokentype");

var _state = _dereq_("./state");

var pp = _state.Parser.prototype;
pp.checkPropClash = function (prop, propHash) {
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) return;
  var key = prop.key;var name = undefined;
  switch (key.type) {
    case "Identifier":
      name = key.name;break;
    case "Literal":
      name = String(key.value);break;
    default:
      return;
  }
  var kind = prop.kind;

  if (this.options.ecmaVersion >= 6) {
    if (name === "__proto__" && kind === "init") {
      if (propHash.proto) this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
      propHash.proto = true;
    }
    return;
  }
  name = "$" + name;
  var other = propHash[name];
  if (other) {
    var isGetSet = kind !== "init";
    if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init)) this.raiseRecoverable(key.start, "Redefinition of property");
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};
pp.parseExpression = function (noIn, refDestructuringErrors) {
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
  if (this.type === _tokentype.types.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(_tokentype.types.comma)) node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors));
    return this.finishNode(node, "SequenceExpression");
  }
  return expr;
};
pp.parseMaybeAssign = function (noIn, refDestructuringErrors, afterLeftParse) {
  if (this.inGenerator && this.isContextual("yield")) return this.parseYield();

  var validateDestructuring = false;
  if (!refDestructuringErrors) {
    refDestructuringErrors = { shorthandAssign: 0, trailingComma: 0 };
    validateDestructuring = true;
  }
  var startPos = this.start,
      startLoc = this.startLoc;
  if (this.type == _tokentype.types.parenL || this.type == _tokentype.types.name) this.potentialArrowAt = this.start;
  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
  if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);
  if (this.type.isAssign) {
    if (validateDestructuring) this.checkPatternErrors(refDestructuringErrors, true);
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    node.left = this.type === _tokentype.types.eq ? this.toAssignable(left) : left;
    refDestructuringErrors.shorthandAssign = 0; // reset because shorthand default was used correctly
    this.checkLVal(left);
    this.next();
    node.right = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "AssignmentExpression");
  } else {
    if (validateDestructuring) this.checkExpressionErrors(refDestructuringErrors, true);
  }
  return left;
};
pp.parseMaybeConditional = function (noIn, refDestructuringErrors) {
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseExprOps(noIn, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
  if (this.eat(_tokentype.types.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(_tokentype.types.colon);
    node.alternate = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "ConditionalExpression");
  }
  return expr;
};
pp.parseExprOps = function (noIn, refDestructuringErrors) {
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false);
  if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
  return this.parseExprOp(expr, startPos, startLoc, -1, noIn);
};
pp.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {
  var prec = this.type.binop;
  if (prec != null && (!noIn || this.type !== _tokentype.types._in)) {
    if (prec > minPrec) {
      var logical = this.type === _tokentype.types.logicalOR || this.type === _tokentype.types.logicalAND;
      var op = this.value;
      this.next();
      var startPos = this.start,
          startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
    }
  }
  return left;
};

pp.buildBinary = function (startPos, startLoc, left, right, op, logical) {
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
};
pp.parseMaybeUnary = function (refDestructuringErrors, sawUnary) {
  var startPos = this.start,
      startLoc = this.startLoc,
      expr = undefined;
  if (this.type.prefix) {
    var node = this.startNode(),
        update = this.type === _tokentype.types.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) this.checkLVal(node.argument);else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") this.raiseRecoverable(node.start, "Deleting local variable in strict mode");else sawUnary = true;
    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors);
    if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node = this.startNodeAt(startPos, startLoc);
      node.operator = this.value;
      node.prefix = false;
      node.argument = expr;
      this.checkLVal(expr);
      this.next();
      expr = this.finishNode(node, "UpdateExpression");
    }
  }

  if (!sawUnary && this.eat(_tokentype.types.starstar)) return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false);else return expr;
};
pp.parseExprSubscripts = function (refDestructuringErrors) {
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors);
  var skipArrowSubscripts = expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")";
  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) return expr;
  return this.parseSubscripts(expr, startPos, startLoc);
};

pp.parseSubscripts = function (base, startPos, startLoc, noCalls) {
  for (;;) {
    if (this.eat(_tokentype.types.dot)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.property = this.parseIdent(true);
      node.computed = false;
      base = this.finishNode(node, "MemberExpression");
    } else if (this.eat(_tokentype.types.bracketL)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.property = this.parseExpression();
      node.computed = true;
      this.expect(_tokentype.types.bracketR);
      base = this.finishNode(node, "MemberExpression");
    } else if (!noCalls && this.eat(_tokentype.types.parenL)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.callee = base;
      node.arguments = this.parseExprList(_tokentype.types.parenR, false);
      base = this.finishNode(node, "CallExpression");
    } else if (this.type === _tokentype.types.backQuote) {
      var node = this.startNodeAt(startPos, startLoc);
      node.tag = base;
      node.quasi = this.parseTemplate();
      base = this.finishNode(node, "TaggedTemplateExpression");
    } else {
      return base;
    }
  }
};
pp.parseExprAtom = function (refDestructuringErrors) {
  var node = undefined,
      canBeArrow = this.potentialArrowAt == this.start;
  switch (this.type) {
    case _tokentype.types._super:
      if (!this.inFunction) this.raise(this.start, "'super' outside of function or class");

    case _tokentype.types._this:
      var type = this.type === _tokentype.types._this ? "ThisExpression" : "Super";
      node = this.startNode();
      this.next();
      return this.finishNode(node, type);

    case _tokentype.types.name:
      if (this.value == "async" && /^[ \t]*(function\b|\(|\w+[ \t]*=>)/.test(this.input.slice(this.end))) {
        node = this.startNode();
        this.next();
        this.potentialArrowAt = this.start;
        return this.parseExprAtom(refDestructuringErrors);
      }
      if (this.value == "await" && /^[ \t]+[\w\x1f-\uffff]/.test(this.input.slice(this.end))) {
        node = this.startNode();
        this.next();
        return this.parseExprAtom(refDestructuringErrors);
      }

      var startPos = this.start,
          startLoc = this.startLoc;
      var id = this.parseIdent(this.type !== _tokentype.types.name);
      if (canBeArrow && !this.canInsertSemicolon() && this.eat(_tokentype.types.arrow)) return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id]);
      return id;

    case _tokentype.types.regexp:
      var value = this.value;
      node = this.parseLiteral(value.value);
      node.regex = { pattern: value.pattern, flags: value.flags };
      return node;

    case _tokentype.types.num:case _tokentype.types.string:
      return this.parseLiteral(this.value);

    case _tokentype.types._null:case _tokentype.types._true:case _tokentype.types._false:
      node = this.startNode();
      node.value = this.type === _tokentype.types._null ? null : this.type === _tokentype.types._true;
      node.raw = this.type.keyword;
      this.next();
      return this.finishNode(node, "Literal");

    case _tokentype.types.parenL:
      return this.parseParenAndDistinguishExpression(canBeArrow);

    case _tokentype.types.bracketL:
      node = this.startNode();
      this.next();
      node.elements = this.parseExprList(_tokentype.types.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node, "ArrayExpression");

    case _tokentype.types.braceL:
      return this.parseObj(false, refDestructuringErrors);

    case _tokentype.types._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, false);

    case _tokentype.types._class:
      return this.parseClass(this.startNode(), false);

    case _tokentype.types._new:
      return this.parseNew();

    case _tokentype.types.backQuote:
      return this.parseTemplate();

    default:
      this.unexpected();
  }
};

pp.parseLiteral = function (value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  this.next();
  return this.finishNode(node, "Literal");
};

pp.parseParenExpression = function () {
  this.expect(_tokentype.types.parenL);
  var val = this.parseExpression();
  this.expect(_tokentype.types.parenR);
  return val;
};

pp.parseParenAndDistinguishExpression = function (canBeArrow) {
  var startPos = this.start,
      startLoc = this.startLoc,
      val = undefined;
  if (this.options.ecmaVersion >= 6) {
    this.next();

    var innerStartPos = this.start,
        innerStartLoc = this.startLoc;
    var exprList = [],
        first = true;
    var refDestructuringErrors = { shorthandAssign: 0, trailingComma: 0 },
        spreadStart = undefined,
        innerParenStart = undefined;
    while (this.type !== _tokentype.types.parenR) {
      first ? first = false : this.expect(_tokentype.types.comma);
      if (this.type === _tokentype.types.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRest()));
        break;
      } else {
        if (this.type === _tokentype.types.parenL && !innerParenStart) {
          innerParenStart = this.start;
        }
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.start,
        innerEndLoc = this.startLoc;
    this.expect(_tokentype.types.parenR);

    if (canBeArrow && !this.canInsertSemicolon() && this.eat(_tokentype.types.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, true);
      if (innerParenStart) this.unexpected(innerParenStart);
      return this.parseParenArrowList(startPos, startLoc, exprList);
    }

    if (!exprList.length) this.unexpected(this.lastTokStart);
    if (spreadStart) this.unexpected(spreadStart);
    this.checkExpressionErrors(refDestructuringErrors, true);

    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }

  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression");
  } else {
    return val;
  }
};

pp.parseParenItem = function (item) {
  return item;
};

pp.parseParenArrowList = function (startPos, startLoc, exprList) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);
};
var empty = [];

pp.parseNew = function () {
  var node = this.startNode();
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(_tokentype.types.dot)) {
    node.meta = meta;
    node.property = this.parseIdent(true);
    if (node.property.name !== "target") this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target");
    if (!this.inFunction) this.raiseRecoverable(node.start, "new.target can only be used in functions");
    return this.finishNode(node, "MetaProperty");
  }
  var startPos = this.start,
      startLoc = this.startLoc;
  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
  if (this.eat(_tokentype.types.parenL)) node.arguments = this.parseExprList(_tokentype.types.parenR, false);else node.arguments = empty;
  return this.finishNode(node, "NewExpression");
};
pp.parseTemplateElement = function () {
  var elem = this.startNode();
  elem.value = {
    raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
    cooked: this.value
  };
  this.next();
  elem.tail = this.type === _tokentype.types.backQuote;
  return this.finishNode(elem, "TemplateElement");
};

pp.parseTemplate = function () {
  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement();
  node.quasis = [curElt];
  while (!curElt.tail) {
    this.expect(_tokentype.types.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(_tokentype.types.braceR);
    node.quasis.push(curElt = this.parseTemplateElement());
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral");
};
pp.parseObj = function (isPattern, refDestructuringErrors) {
  var node = this.startNode(),
      first = true,
      propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(_tokentype.types.braceR)) {
    if (!first) {
      this.expect(_tokentype.types.comma);
      if (this.afterTrailingComma(_tokentype.types.braceR)) break;
    } else first = false;

    var prop = this.startNode(),
        isGenerator = undefined,
        startPos = undefined,
        startLoc = undefined;
    if (this.options.ecmaVersion >= 6) {
      prop.method = false;
      prop.shorthand = false;
      if (isPattern || refDestructuringErrors) {
        startPos = this.start;
        startLoc = this.startLoc;
      }
      if (!isPattern) isGenerator = this.eat(_tokentype.types.star);
    }
    this.parsePropertyName(prop);
    this.parsePropertyValue(prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors);
    this.checkPropClash(prop, propHash);
    node.properties.push(this.finishNode(prop, "Property"));
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
};

pp.parsePropertyValue = function (prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors) {
  if (this.eat(_tokentype.types.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === _tokentype.types.parenL) {
    if (isPattern) this.unexpected();
    prop.kind = "init";
    prop.method = true;
    prop.value = this.parseMethod(isGenerator);
  } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type != _tokentype.types.comma && this.type != _tokentype.types.braceR)) {
    if (isGenerator || isPattern) this.unexpected();
    prop.kind = prop.key.name;
    this.parsePropertyName(prop);
    prop.value = this.parseMethod(false);
    var paramCount = prop.kind === "get" ? 0 : 1;
    if (prop.value.params.length !== paramCount) {
      var start = prop.value.start;
      if (prop.kind === "get") this.raiseRecoverable(start, "getter should have no params");else this.raiseRecoverable(start, "setter should have exactly one param");
    }
    if (prop.kind === "set" && prop.value.params[0].type === "RestElement") this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    prop.kind = "init";
    if (isPattern) {
      if (this.keywords.test(prop.key.name) || (this.strict ? this.reservedWordsStrictBind : this.reservedWords).test(prop.key.name) || this.inGenerator && prop.key.name == "yield") this.raiseRecoverable(prop.key.start, "Binding " + prop.key.name);
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else if (this.type === _tokentype.types.eq && refDestructuringErrors) {
      if (!refDestructuringErrors.shorthandAssign) refDestructuringErrors.shorthandAssign = this.start;
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else {
      prop.value = prop.key;
    }
    prop.shorthand = true;
  } else this.unexpected();
};

pp.parsePropertyName = function (prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(_tokentype.types.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(_tokentype.types.bracketR);
      return prop.key;
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === _tokentype.types.num || this.type === _tokentype.types.string ? this.parseExprAtom() : this.parseIdent(true);
};
pp.initFunction = function (node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) {
    node.generator = false;
    node.expression = false;
  }
};
pp.parseMethod = function (isGenerator) {
  var node = this.startNode(),
      oldInGen = this.inGenerator;
  this.inGenerator = isGenerator;
  this.initFunction(node);
  this.expect(_tokentype.types.parenL);
  node.params = this.parseBindingList(_tokentype.types.parenR, false, false);
  if (this.options.ecmaVersion >= 6) node.generator = isGenerator;
  this.parseFunctionBody(node, false);
  this.inGenerator = oldInGen;
  return this.finishNode(node, "FunctionExpression");
};
pp.parseArrowExpression = function (node, params) {
  var oldInGen = this.inGenerator;
  this.inGenerator = false;
  this.initFunction(node);
  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true);
  this.inGenerator = oldInGen;
  return this.finishNode(node, "ArrowFunctionExpression");
};
pp.parseFunctionBody = function (node, isArrowFunction) {
  var isExpression = isArrowFunction && this.type !== _tokentype.types.braceL;

  if (isExpression) {
    node.body = this.parseMaybeAssign();
    node.expression = true;
  } else {
    var oldInFunc = this.inFunction,
        oldLabels = this.labels;
    this.inFunction = true;this.labels = [];
    node.body = this.parseBlock(true);
    node.expression = false;
    this.inFunction = oldInFunc;this.labels = oldLabels;
  }
  if (this.strict || !isExpression && node.body.body.length && this.isUseStrict(node.body.body[0])) {
    var oldStrict = this.strict;
    this.strict = true;
    if (node.id) this.checkLVal(node.id, true);
    this.checkParams(node);
    this.strict = oldStrict;
  } else if (isArrowFunction) {
    this.checkParams(node);
  }
};
pp.checkParams = function (node) {
  var nameHash = {};
  for (var i = 0; i < node.params.length; i++) {
    this.checkLVal(node.params[i], true, nameHash);
  }
};
pp.parseExprList = function (close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [],
      first = true;
  while (!this.eat(close)) {
    if (!first) {
      this.expect(_tokentype.types.comma);
      if (this.type === close && refDestructuringErrors && !refDestructuringErrors.trailingComma) {
        refDestructuringErrors.trailingComma = this.lastTokStart;
      }
      if (allowTrailingComma && this.afterTrailingComma(close)) break;
    } else first = false;

    var elt = undefined;
    if (allowEmpty && this.type === _tokentype.types.comma) elt = null;else if (this.type === _tokentype.types.ellipsis) elt = this.parseSpread(refDestructuringErrors);else elt = this.parseMaybeAssign(false, refDestructuringErrors);
    elts.push(elt);
  }
  return elts;
};
pp.parseIdent = function (liberal) {
  var node = this.startNode();
  if (liberal && this.options.allowReserved == "never") liberal = false;
  if (this.type === _tokentype.types.name) {
    if (!liberal && (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) && (this.options.ecmaVersion >= 6 || this.input.slice(this.start, this.end).indexOf("\\") == -1)) this.raiseRecoverable(this.start, "The keyword '" + this.value + "' is reserved");
    if (!liberal && this.inGenerator && this.value === "yield") this.raiseRecoverable(this.start, "Can not use 'yield' as identifier inside a generator");
    node.name = this.value;
  } else if (liberal && this.type.keyword) {
    node.name = this.type.keyword;
  } else {
    this.unexpected();
  }
  this.next();
  return this.finishNode(node, "Identifier");
};
pp.parseYield = function () {
  var node = this.startNode();
  this.next();
  if (this.type == _tokentype.types.semi || this.canInsertSemicolon() || this.type != _tokentype.types.star && !this.type.startsExpr) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(_tokentype.types.star);
    node.argument = this.parseMaybeAssign();
  }
  return this.finishNode(node, "YieldExpression");
};

},{"./state":"/src\\state.js","./tokentype":"/src\\tokentype.js"}],"/src\\identifier.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;
exports.isIdentifierStart = isIdentifierStart;
exports.isIdentifierChar = isIdentifierChar;
var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  7: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};

exports.reservedWords = reservedWords;
var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

var keywords = {
  5: ecma5AndLessKeywords,
  6: ecma5AndLessKeywords + " const class extends export import super"
};

exports.keywords = keywords;
function isIdentifierStart(code, astral) {
  if (code < 65) return code === 36;
  if (code < 91) return true;
  if (code < 97) return code === 95;
  if (code < 123) return true;
  return code >= 0xaa;
}
function isIdentifierChar(code, astral) {
  if (code < 48) return code === 36;
  if (code < 58) return true;
  if (code < 65) return false;
  if (code < 91) return true;
  if (code < 97) return code === 95;
  if (code < 123) return true;
  return code >= 0xaa;
}

},{}],"/src\\index.js":[function(_dereq_,module,exports){
//
//
//
//
//
//
//
"use strict";

exports.__esModule = true;
exports.parse = parse;
exports.parseExpressionAt = parseExpressionAt;
exports.tokenizer = tokenizer;

var _state = _dereq_("./state");

_dereq_("./parseutil");

_dereq_("./statement");

_dereq_("./lval");

_dereq_("./expression");

_dereq_("./location");

exports.Parser = _state.Parser;
exports.plugins = _state.plugins;

var _options = _dereq_("./options");

exports.defaultOptions = _options.defaultOptions;

var _locutil = _dereq_("./locutil");

exports.Position = _locutil.Position;
exports.SourceLocation = _locutil.SourceLocation;
exports.getLineInfo = _locutil.getLineInfo;

var _node = _dereq_("./node");

exports.Node = _node.Node;

var _tokentype = _dereq_("./tokentype");

exports.TokenType = _tokentype.TokenType;
exports.tokTypes = _tokentype.types;

var _tokencontext = _dereq_("./tokencontext");

exports.TokContext = _tokencontext.TokContext;
exports.tokContexts = _tokencontext.types;

var _identifier = _dereq_("./identifier");

exports.isIdentifierChar = _identifier.isIdentifierChar;
exports.isIdentifierStart = _identifier.isIdentifierStart;

var _tokenize = _dereq_("./tokenize");

exports.Token = _tokenize.Token;

var _whitespace = _dereq_("./whitespace");

exports.isNewLine = _whitespace.isNewLine;
exports.lineBreak = _whitespace.lineBreak;
exports.lineBreakG = _whitespace.lineBreakG;
var version = "3.0.2";

exports.version = version;
//
function parse(input, options) {
  return new _state.Parser(options, input).parse();
}
function parseExpressionAt(input, pos, options) {
  var p = new _state.Parser(options, input, pos);
  p.nextToken();
  return p.parseExpression();
}
function tokenizer(input, options) {
  return new _state.Parser(options, input);
}

},{"./expression":"/src\\expression.js","./identifier":"/src\\identifier.js","./location":"/src\\location.js","./locutil":"/src\\locutil.js","./lval":"/src\\lval.js","./node":"/src\\node.js","./options":"/src\\options.js","./parseutil":"/src\\parseutil.js","./state":"/src\\state.js","./statement":"/src\\statement.js","./tokencontext":"/src\\tokencontext.js","./tokenize":"/src\\tokenize.js","./tokentype":"/src\\tokentype.js","./whitespace":"/src\\whitespace.js"}],"/src\\location.js":[function(_dereq_,module,exports){
"use strict";

var _state = _dereq_("./state");

var _locutil = _dereq_("./locutil");

var pp = _state.Parser.prototype;
pp.raise = function (pos, message) {
  var loc = _locutil.getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos;err.loc = loc;err.raisedAt = this.pos;
  throw err;
};

pp.raiseRecoverable = pp.raise;

pp.curPosition = function () {
  if (this.options.locations) {
    return new _locutil.Position(this.curLine, this.pos - this.lineStart);
  }
};

},{"./locutil":"/src\\locutil.js","./state":"/src\\state.js"}],"/src\\locutil.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;
exports.getLineInfo = getLineInfo;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _whitespace = _dereq_("./whitespace");
var Position = (function () {
  function Position(line, col) {


    this.line = line;
    this.column = col;
  }

  Position.prototype.offset = function offset(n) {
    return new Position(this.line, this.column + n);
  };

  return Position;
})();

exports.Position = Position;

var SourceLocation = function SourceLocation(p, start, end) {


  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) this.source = p.sourceFile;
};

exports.SourceLocation = SourceLocation;
function getLineInfo(input, offset) {
  for (var line = 0, cur = 0;;) {
    _whitespace.lineBreakG.lastIndex = cur;
    var match = _whitespace.lineBreakG.exec(input);
    if (match && match.index < offset) {
      ++line;
      cur = match.index + match[0].length;
    } else {
      return new Position(line, offset - cur);
    }
  }
}

},{"./whitespace":"/src\\whitespace.js"}],"/src\\lval.js":[function(_dereq_,module,exports){
"use strict";

var _tokentype = _dereq_("./tokentype");

var _state = _dereq_("./state");

var _util = _dereq_("./util");

var pp = _state.Parser.prototype;
pp.toAssignable = function (node, isBinding) {
  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
      case "Identifier":
      case "ObjectPattern":
      case "ArrayPattern":
        break;

      case "ObjectExpression":
        node.type = "ObjectPattern";
        for (var i = 0; i < node.properties.length; i++) {
          var prop = node.properties[i];
          if (prop.kind !== "init") this.raise(prop.key.start, "Object pattern can't contain getter or setter");
          this.toAssignable(prop.value, isBinding);
        }
        break;

      case "ArrayExpression":
        node.type = "ArrayPattern";
        this.toAssignableList(node.elements, isBinding);
        break;

      case "AssignmentExpression":
        if (node.operator === "=") {
          node.type = "AssignmentPattern";
          delete node.operator
          ;
        } else {
          this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
          break;
        }

      case "AssignmentPattern":
        if (node.right.type === "YieldExpression") this.raise(node.right.start, "Yield expression cannot be a default value");
        break;

      case "ParenthesizedExpression":
        node.expression = this.toAssignable(node.expression, isBinding);
        break;

      case "MemberExpression":
        if (!isBinding) break;

      default:
        this.raise(node.start, "Assigning to rvalue");
    }
  }
  return node;
};
pp.toAssignableList = function (exprList, isBinding) {
  var end = exprList.length;
  if (end) {
    var last = exprList[end - 1];
    if (last && last.type == "RestElement") {
      --end;
    } else if (last && last.type == "SpreadElement") {
      last.type = "RestElement";
      var arg = last.argument;
      this.toAssignable(arg, isBinding);
      if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern") this.unexpected(arg.start);
      --end;
    }

    if (isBinding && last.type === "RestElement" && last.argument.type !== "Identifier") this.unexpected(last.argument.start);
  }
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt) this.toAssignable(elt, isBinding);
  }
  return exprList;
};
pp.parseSpread = function (refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(refDestructuringErrors);
  return this.finishNode(node, "SpreadElement");
};

pp.parseRest = function (allowNonIdent) {
  var node = this.startNode();
  this.next();
  if (allowNonIdent) node.argument = this.type === _tokentype.types.name ? this.parseIdent() : this.unexpected();else node.argument = this.type === _tokentype.types.name || this.type === _tokentype.types.bracketL ? this.parseBindingAtom() : this.unexpected();

  return this.finishNode(node, "RestElement");
};
pp.parseBindingAtom = function () {
  if (this.options.ecmaVersion < 6) return this.parseIdent();
  switch (this.type) {
    case _tokentype.types.name:
      return this.parseIdent();

    case _tokentype.types.bracketL:
      var node = this.startNode();
      this.next();
      node.elements = this.parseBindingList(_tokentype.types.bracketR, true, true);
      return this.finishNode(node, "ArrayPattern");

    case _tokentype.types.braceL:
      return this.parseObj(true);

    default:
      this.unexpected();
  }
};

pp.parseBindingList = function (close, allowEmpty, allowTrailingComma, allowNonIdent) {
  var elts = [],
      first = true;
  while (!this.eat(close)) {
    if (first) first = false;else this.expect(_tokentype.types.comma);
    if (allowEmpty && this.type === _tokentype.types.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
      break;
    } else if (this.type === _tokentype.types.ellipsis) {
      var rest = this.parseRest(allowNonIdent);
      this.parseBindingListItem(rest);
      elts.push(rest);
      this.expect(close);
      break;
    } else {
      var elem = this.parseMaybeDefault(this.start, this.startLoc);
      this.parseBindingListItem(elem);
      elts.push(elem);
    }
  }
  return elts;
};

pp.parseBindingListItem = function (param) {
  return param;
};
pp.parseMaybeDefault = function (startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(_tokentype.types.eq)) return left;
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern");
};
pp.checkLVal = function (expr, isBinding, checkClashes) {
  switch (expr.type) {
    case "Identifier":
      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) this.raiseRecoverable(expr.start, (isBinding ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
      if (checkClashes) {
        if (_util.has(checkClashes, expr.name)) this.raiseRecoverable(expr.start, "Argument name clash");
        checkClashes[expr.name] = true;
      }
      break;

    case "MemberExpression":
      if (isBinding) this.raiseRecoverable(expr.start, (isBinding ? "Binding" : "Assigning to") + " member expression");
      break;

    case "ObjectPattern":
      for (var i = 0; i < expr.properties.length; i++) {
        this.checkLVal(expr.properties[i].value, isBinding, checkClashes);
      }break;

    case "ArrayPattern":
      for (var i = 0; i < expr.elements.length; i++) {
        var elem = expr.elements[i];
        if (elem) this.checkLVal(elem, isBinding, checkClashes);
      }
      break;

    case "AssignmentPattern":
      this.checkLVal(expr.left, isBinding, checkClashes);
      break;

    case "RestElement":
      this.checkLVal(expr.argument, isBinding, checkClashes);
      break;

    case "ParenthesizedExpression":
      this.checkLVal(expr.expression, isBinding, checkClashes);
      break;

    default:
      this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " rvalue");
  }
};

},{"./state":"/src\\state.js","./tokentype":"/src\\tokentype.js","./util":"/src\\util.js"}],"/src\\node.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _state = _dereq_("./state");

var _locutil = _dereq_("./locutil");

var Node = function Node(parser, pos, loc) {


  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations) this.loc = new _locutil.SourceLocation(parser, loc);
  if (parser.options.directSourceFile) this.sourceFile = parser.options.directSourceFile;
  if (parser.options.ranges) this.range = [pos, 0];
};

exports.Node = Node;
var pp = _state.Parser.prototype;

pp.startNode = function () {
  return new Node(this, this.start, this.startLoc);
};

pp.startNodeAt = function (pos, loc) {
  return new Node(this, pos, loc);
};
function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  if (this.options.locations) node.loc.end = loc;
  if (this.options.ranges) node.range[1] = pos;
  return node;
}

pp.finishNode = function (node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
};
pp.finishNodeAt = function (node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc);
};

},{"./locutil":"/src\\locutil.js","./state":"/src\\state.js"}],"/src\\options.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;
exports.getOptions = getOptions;

var _util = _dereq_("./util");

var _locutil = _dereq_("./locutil");
var defaultOptions = {
  ecmaVersion: 6,
  sourceType: "script",
  onInsertedSemicolon: null,
  onTrailingComma: null,
  allowReserved: null,
  allowReturnOutsideFunction: false,
  allowImportExportEverywhere: false,
  allowHashBang: false,
  locations: true,
  onToken: null,
  onComment: null,
  //
  ranges: false,
  program: null,
  sourceFile: null,
  directSourceFile: null,
  preserveParens: false,
  plugins: {}
};

exports.defaultOptions = defaultOptions;
function getOptions(opts) {
  var options = {};
  for (var opt in defaultOptions) {
    options[opt] = opts && _util.has(opts, opt) ? opts[opt] : defaultOptions[opt];
  }if (options.allowReserved == null) options.allowReserved = options.ecmaVersion < 5;

  if (_util.isArray(options.onToken)) {
    (function () {
      var tokens = options.onToken;
      options.onToken = function (token) {
        return tokens.push(token);
      };
    })();
  }
  if (_util.isArray(options.onComment)) options.onComment = pushComment(options, options.onComment);

  return options;
}

function pushComment(options, array) {
  return function (block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text,
      start: start,
      end: end
    };
    if (options.locations) comment.loc = new _locutil.SourceLocation(this, startLoc, endLoc);
    if (options.ranges) comment.range = [start, end];
    array.push(comment);
  };
}

},{"./locutil":"/src\\locutil.js","./util":"/src\\util.js"}],"/src\\parseutil.js":[function(_dereq_,module,exports){
"use strict";

var _tokentype = _dereq_("./tokentype");

var _state = _dereq_("./state");

var _whitespace = _dereq_("./whitespace");

var pp = _state.Parser.prototype;
pp.isUseStrict = function (stmt) {
  return this.options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && stmt.expression.raw.slice(1, -1) === "use strict";
};
pp.eat = function (type) {
  if (this.type === type) {
    this.next();
    return true;
  } else {
    return false;
  }
};
pp.isContextual = function (name) {
  return this.type === _tokentype.types.name && this.value === name;
};
pp.eatContextual = function (name) {
  return this.value === name && this.eat(_tokentype.types.name);
};
pp.expectContextual = function (name) {
  if (!this.eatContextual(name)) this.unexpected();
};
pp.canInsertSemicolon = function () {
  return this.type === _tokentype.types.eof || this.type === _tokentype.types.braceR || _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};

pp.insertSemicolon = function () {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon) this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
    return true;
  }
};
pp.semicolon = function () {
  if (!this.eat(_tokentype.types.semi) && !this.insertSemicolon()) this.unexpected();
};

pp.afterTrailingComma = function (tokType) {
  if (this.type == tokType) {
    if (this.options.onTrailingComma) this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
    this.next();
    return true;
  }
};
pp.expect = function (type) {
  this.eat(type) || this.unexpected();
};
pp.unexpected = function (pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};

pp.checkPatternErrors = function (refDestructuringErrors, andThrow) {
  var pos = refDestructuringErrors && refDestructuringErrors.trailingComma;
  if (!andThrow) return !!pos;
  if (pos) this.raise(pos, "Trailing comma is not permitted in destructuring patterns");
};

pp.checkExpressionErrors = function (refDestructuringErrors, andThrow) {
  var pos = refDestructuringErrors && refDestructuringErrors.shorthandAssign;
  if (!andThrow) return !!pos;
  if (pos) this.raise(pos, "Shorthand property assignments are valid only in destructuring patterns");
};

},{"./state":"/src\\state.js","./tokentype":"/src\\tokentype.js","./whitespace":"/src\\whitespace.js"}],"/src\\state.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _identifier = _dereq_("./identifier");

var _tokentype = _dereq_("./tokentype");

var _whitespace = _dereq_("./whitespace");

var _options = _dereq_("./options");
var plugins = {};

exports.plugins = plugins;
function keywordRegexp(words) {
  return new RegExp("^(" + words.replace(/ /g, "|") + ")$");
}

var Parser = (function () {
  function Parser(options, input, startPos) {


    this.options = options = _options.getOptions(options);
    this.sourceFile = options.sourceFile;
    this.keywords = keywordRegexp(_identifier.keywords[options.ecmaVersion >= 6 ? 6 : 5]);
    var reserved = options.allowReserved ? "" : _identifier.reservedWords[options.ecmaVersion] + (options.sourceType == "module" ? " await" : "");
    this.reservedWords = keywordRegexp(reserved);
    var reservedStrict = (reserved ? reserved + " " : "") + _identifier.reservedWords.strict;
    this.reservedWordsStrict = keywordRegexp(reservedStrict);
    this.reservedWordsStrictBind = keywordRegexp(reservedStrict + " " + _identifier.reservedWords.strictBind);
    this.input = String(input);
    this.containsEsc = false;
    this.loadPlugins(options.plugins);
    if (startPos) {
      this.pos = startPos;
      this.lineStart = Math.max(0, this.input.lastIndexOf("\n", startPos));
      this.curLine = this.input.slice(0, this.lineStart).split(_whitespace.lineBreak).length;
    } else {
      this.pos = this.lineStart = 0;
      this.curLine = 0;
    }
    this.type = _tokentype.types.eof;
    this.value = null;
    this.start = this.end = this.pos;
    this.startLoc = this.endLoc = this.curPosition();
    this.lastTokEndLoc = this.lastTokStartLoc = null;
    this.lastTokStart = this.lastTokEnd = this.pos;
    this.context = this.initialContext();
    this.exprAllowed = true;
    this.strict = this.inModule = options.sourceType === "module";
    this.potentialArrowAt = -1;
    this.inFunction = this.inGenerator = false;
    this.labels = [];
    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") this.skipLineComment(2);
  }
  Parser.prototype.isKeyword = function isKeyword(word) {
    return this.keywords.test(word);
  };

  Parser.prototype.isReservedWord = function isReservedWord(word) {
    return this.reservedWords.test(word);
  };

  Parser.prototype.extend = function extend(name, f) {
    this[name] = f(this[name]);
  };

  Parser.prototype.loadPlugins = function loadPlugins(pluginConfigs) {
    for (var _name in pluginConfigs) {
      var plugin = plugins[_name];
      if (!plugin) throw new Error("Plugin '" + _name + "' not found");
      plugin(this, pluginConfigs[_name]);
    }
  };

  Parser.prototype.parse = function parse() {
    var node = this.options.program || this.startNode();
    this.nextToken();
    return this.parseTopLevel(node);
  };

  return Parser;
})();

exports.Parser = Parser;

},{"./identifier":"/src\\identifier.js","./options":"/src\\options.js","./tokentype":"/src\\tokentype.js","./whitespace":"/src\\whitespace.js"}],"/src\\statement.js":[function(_dereq_,module,exports){
"use strict";

var _tokentype = _dereq_("./tokentype");

var _state = _dereq_("./state");

var _whitespace = _dereq_("./whitespace");

var _identifier = _dereq_("./identifier");

var pp = _state.Parser.prototype;
pp.parseTopLevel = function (node) {
  var first = true;
  if (!node.body) node.body = [];
  while (this.type !== _tokentype.types.eof) {
    var stmt = this.parseStatement(true, true);
    node.body.push(stmt);
    if (first) {
      if (this.isUseStrict(stmt)) this.setStrict(true);
      first = false;
    }
  }
  this.next();
  if (this.options.ecmaVersion >= 6) {
    node.sourceType = this.options.sourceType;
  }
  return this.finishNode(node, "Program");
};

var loopLabel = { kind: "loop" },
    switchLabel = { kind: "switch" };

pp.isLet = function () {
  if (this.type !== _tokentype.types.name || this.options.ecmaVersion < 6 || this.value != "let") return false;
  _whitespace.skipWhiteSpace.lastIndex = this.pos;
  var skip = _whitespace.skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length,
      nextCh = this.input.charCodeAt(next);
  if (nextCh === 91 || nextCh == 123) return true; // '{' and '['
  if (_identifier.isIdentifierStart(nextCh, true)) {
    for (var pos = next + 1; _identifier.isIdentifierChar(this.input.charCodeAt(pos, true)); ++pos) {}
    var ident = this.input.slice(next, pos);
    if (!this.isKeyword(ident)) return true;
  }
  return false;
};
//
pp.parseStatement = function (declaration, topLevel) {
  var starttype = this.type,
      node = this.startNode(),
      kind = undefined;

  if (this.isLet()) {
    starttype = _tokentype.types._var;
    kind = "let";
  }
  switch (starttype) {
    case _tokentype.types._break:case _tokentype.types._continue:
      return this.parseBreakContinueStatement(node, starttype.keyword);
    case _tokentype.types._debugger:
      return this.parseDebuggerStatement(node);
    case _tokentype.types._do:
      return this.parseDoStatement(node);
    case _tokentype.types._for:
      return this.parseForStatement(node);
    case _tokentype.types._function:
      if (!declaration && this.options.ecmaVersion >= 6) this.unexpected();
      return this.parseFunctionStatement(node);
    case _tokentype.types._class:
      if (!declaration) this.unexpected();
      return this.parseClass(node, true);
    case _tokentype.types._if:
      return this.parseIfStatement(node);
    case _tokentype.types._return:
      return this.parseReturnStatement(node);
    case _tokentype.types._switch:
      return this.parseSwitchStatement(node);
    case _tokentype.types._throw:
      return this.parseThrowStatement(node);
    case _tokentype.types._try:
      return this.parseTryStatement(node);
    case _tokentype.types._const:case _tokentype.types._var:
      kind = kind || this.value;
      if (!declaration && kind != "var") this.unexpected();
      return this.parseVarStatement(node, kind);
    case _tokentype.types._while:
      return this.parseWhileStatement(node);
    case _tokentype.types._with:
      return this.parseWithStatement(node);
    case _tokentype.types.braceL:
      return this.parseBlock();
    case _tokentype.types.semi:
      return this.parseEmptyStatement(node);
    case _tokentype.types._export:
    case _tokentype.types._import:
      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) this.raise(this.start, "'import' and 'export' may only appear at the top level");
        if (!this.inModule) this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
      }
      return starttype === _tokentype.types._import ? this.parseImport(node) : this.parseExport(node);
    case _tokentype.types.at:
      this.next();
      return this.parseExpression();
    default:
      var maybeName = this.value,
          expr = this.parseExpression();
      if (starttype === _tokentype.types.name && expr.type === "Identifier" && this.eat(_tokentype.types.colon)) return this.parseLabeledStatement(node, maybeName, expr);else return this.parseExpressionStatement(node, expr);
  }
};

pp.parseBreakContinueStatement = function (node, keyword) {
  var isBreak = keyword == "break";
  this.next();
  if (this.eat(_tokentype.types.semi) || this.insertSemicolon()) node.label = null;else if (this.type !== _tokentype.types.name) this.unexpected();else {
    node.label = this.parseIdent();
    this.semicolon();
  }
  for (var i = 0; i < this.labels.length; ++i) {
    var lab = this.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
      if (node.label && isBreak) break;
    }
  }
  if (i === this.labels.length) this.raise(node.start, "Unsyntactic " + keyword);
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
};

pp.parseDebuggerStatement = function (node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement");
};

pp.parseDoStatement = function (node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.labels.pop();
  this.expect(_tokentype.types._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6) this.eat(_tokentype.types.semi);else this.semicolon();
  return this.finishNode(node, "DoWhileStatement");
};
pp.parseForStatement = function (node) {
  this.next();
  this.labels.push(loopLabel);
  this.expect(_tokentype.types.parenL);
  if (this.type === _tokentype.types.semi) return this.parseFor(node, null);
  var isLet = this.isLet();
  if (this.type === _tokentype.types._var || this.type === _tokentype.types._const || isLet) {
    var _init = this.startNode(),
        kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(_init, true, kind);
    this.finishNode(_init, "VariableDeclaration");
    if ((this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && _init.declarations.length === 1 && !(kind !== "var" && _init.declarations[0].init)) return this.parseForIn(node, _init);
    return this.parseFor(node, _init);
  }
  var refDestructuringErrors = { shorthandAssign: 0, trailingComma: 0 };
  var init = this.parseExpression(true, refDestructuringErrors);
  if (this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) {
    this.checkPatternErrors(refDestructuringErrors, true);
    this.toAssignable(init);
    this.checkLVal(init);
    return this.parseForIn(node, init);
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  return this.parseFor(node, init);
};

pp.parseFunctionStatement = function (node) {
  this.next();
  return this.parseFunction(node, true);
};

pp.parseIfStatement = function (node) {
  this.next();
  node.test = this.parseParenExpression();
  node.consequent = this.parseStatement(false);
  node.alternate = this.eat(_tokentype.types._else) ? this.parseStatement(false) : null;
  return this.finishNode(node, "IfStatement");
};

pp.parseReturnStatement = function (node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction) this.raise(this.start, "'return' outside of function");
  this.next();
  if (this.eat(_tokentype.types.semi) || this.insertSemicolon()) node.argument = null;else {
    node.argument = this.parseExpression();this.semicolon();
  }
  return this.finishNode(node, "ReturnStatement");
};

pp.parseSwitchStatement = function (node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(_tokentype.types.braceL);
  this.labels.push(switchLabel);
  for (var cur, sawDefault = false; this.type != _tokentype.types.braceR;) {
    if (this.type === _tokentype.types._case || this.type === _tokentype.types._default) {
      var isCase = this.type === _tokentype.types._case;
      if (cur) this.finishNode(cur, "SwitchCase");
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
        sawDefault = true;
        cur.test = null;
      }
      this.expect(_tokentype.types.colon);
    } else {
      if (!cur) this.unexpected();
      cur.consequent.push(this.parseStatement(true));
    }
  }
  if (cur) this.finishNode(cur, "SwitchCase");
  this.next(); // Closing brace
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement");
};

pp.parseThrowStatement = function (node) {
  this.next();
  if (_whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) this.raise(this.lastTokEnd, "Illegal newline after throw");
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement");
};
var empty = [];

pp.parseTryStatement = function (node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === _tokentype.types._catch) {
    var clause = this.startNode();
    this.next();
    this.expect(_tokentype.types.parenL);
    clause.param = this.parseBindingAtom();
    this.checkLVal(clause.param, true);
    this.expect(_tokentype.types.parenR);
    clause.body = this.parseBlock();
    node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(_tokentype.types._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer) this.raise(node.start, "Missing catch or finally clause");
  return this.finishNode(node, "TryStatement");
};

pp.parseVarStatement = function (node, kind) {
  this.next();
  this.parseVar(node, false, kind);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration");
};

pp.parseWhileStatement = function (node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, "WhileStatement");
};

pp.parseWithStatement = function (node) {
  if (this.strict) this.raise(this.start, "'with' in strict mode");
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement(false);
  return this.finishNode(node, "WithStatement");
};

pp.parseEmptyStatement = function (node) {
  this.next();
  return this.finishNode(node, "EmptyStatement");
};

pp.parseLabeledStatement = function (node, maybeName, expr) {
  for (var i = 0; i < this.labels.length; ++i) {
    if (this.labels[i].name === maybeName) this.raise(expr.start, "Label '" + maybeName + "' is already declared");
  }var kind = this.type.isLoop ? "loop" : this.type === _tokentype.types._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label = this.labels[i];
    if (label.statementStart == node.start) {
      label.statementStart = this.start;
      label.kind = kind;
    } else break;
  }
  this.labels.push({ name: maybeName, kind: kind, statementStart: this.start });
  node.body = this.parseStatement(true);
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement");
};

pp.parseExpressionStatement = function (node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement");
};
pp.parseBlock = function (allowStrict) {
  var node = this.startNode(),
      first = true,
      oldStrict = undefined;
  node.body = [];
  this.expect(_tokentype.types.braceL);
  while (!this.eat(_tokentype.types.braceR)) {
    var stmt = this.parseStatement(true);
    node.body.push(stmt);
    if (first && allowStrict && this.isUseStrict(stmt)) {
      oldStrict = this.strict;
      this.setStrict(this.strict = true);
    }
    first = false;
  }
  if (oldStrict === false) this.setStrict(false);
  return this.finishNode(node, "BlockStatement");
};
pp.parseFor = function (node, init) {
  node.init = init;
  this.expect(_tokentype.types.semi);
  node.test = this.type === _tokentype.types.semi ? null : this.parseExpression();
  this.expect(_tokentype.types.semi);
  node.update = this.type === _tokentype.types.parenR ? null : this.parseExpression();
  this.expect(_tokentype.types.parenR);
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, "ForStatement");
};
pp.parseForIn = function (node, init) {
  var type = this.type === _tokentype.types._in ? "ForInStatement" : "ForOfStatement";
  this.next();
  node.left = init;
  node.right = this.parseExpression();
  this.expect(_tokentype.types.parenR);
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, type);
};
pp.parseVar = function (node, isFor, kind) {
  node.declarations = [];
  node.kind = kind;
  for (;;) {
    var decl = this.startNode();
    this.parseVarId(decl);
    if (this.eat(_tokentype.types.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (kind === "const" && !(this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      this.unexpected();
    } else if (decl.id.type != "Identifier" && !(isFor && (this.type === _tokentype.types._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(_tokentype.types.comma)) break;
  }
  return node;
};

pp.parseVarId = function (decl) {
  decl.id = this.parseBindingAtom();
  this.checkLVal(decl.id, true);
};
pp.parseFunction = function (node, isStatement, allowExpressionBody) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 6) node.generator = this.eat(_tokentype.types.star);
  var oldInGen = this.inGenerator;
  this.inGenerator = node.generator;
  if (isStatement || this.type === _tokentype.types.name) node.id = this.parseIdent();
  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody);
  this.inGenerator = oldInGen;
  return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
};

pp.parseFunctionParams = function (node) {
  this.expect(_tokentype.types.parenL);
  node.params = this.parseBindingList(_tokentype.types.parenR, false, false, true);
};
pp.parseClass = function (node, isStatement) {
  this.next();
  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(_tokentype.types.braceL);
  var decorators = [];
  while (!this.eat(_tokentype.types.braceR)) {
    if (this.eat(_tokentype.types.semi)) continue;
    if (this.type == _tokentype.types.at) {
      this.next();
      var expr = this.parseMaybeAssign(true);
      decorators.push(expr);
      continue;
    }
    var method = this.startNode();
    var isGenerator = this.eat(_tokentype.types.star);
    var isMaybeStatic = this.type === _tokentype.types.name && this.value === "static";
    this.parsePropertyName(method);
    method["static"] = isMaybeStatic && this.type !== _tokentype.types.parenL;
    if (method["static"]) {
      if (isGenerator) this.unexpected();
      isGenerator = this.eat(_tokentype.types.star);
      this.parsePropertyName(method);
    }
    method.kind = "method";
    var isGetSet = false;
    if (!method.computed) {
      var key = method.key;

      if (!isGenerator && key.type === "Identifier" && this.type !== _tokentype.types.parenL && (key.name === "get" || key.name === "set")) {
        isGetSet = true;
        method.kind = key.name;
        key = this.parsePropertyName(method);
      }
      if (!method["static"] && (key.type === "Identifier" && key.name === "constructor" || key.type === "Literal" && key.value === "constructor")) {
        if (hadConstructor) this.raise(key.start, "Duplicate constructor in the same class");
        if (isGetSet) this.raise(key.start, "Constructor can't have get/set modifier");
        if (isGenerator) this.raise(key.start, "Constructor can't be a generator");
        method.kind = "constructor";
        hadConstructor = true;
      }
    }
    this.parseClassMethod(classBody, method, isGenerator);
    if (decorators.length) {
      var body = method.value.body.body;
      if (body) body.unshift.apply(body, decorators);
      decorators = [];
    }
    if (isGetSet) {
      var paramCount = method.kind === "get" ? 0 : 1;
      if (method.value.params.length !== paramCount) {
        var start = method.value.start;
        if (method.kind === "get") this.raiseRecoverable(start, "getter should have no params");else this.raiseRecoverable(start, "setter should have exactly one param");
      }
      if (method.kind === "set" && method.value.params[0].type === "RestElement") this.raise(method.value.params[0].start, "Setter cannot use rest params");
    }
  }
  node.body = this.finishNode(classBody, "ClassBody");
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};

pp.parseClassMethod = function (classBody, method, isGenerator) {
  method.value = this.parseMethod(isGenerator);
  classBody.body.push(this.finishNode(method, "MethodDefinition"));
};

pp.parseClassId = function (node, isStatement) {
  node.id = this.type === _tokentype.types.name ? this.parseIdent() : isStatement ? this.unexpected() : null;
};

pp.parseClassSuper = function (node) {
  node.superClass = this.eat(_tokentype.types._extends) ? this.parseExprSubscripts() : null;
};
pp.parseExport = function (node) {
  this.next();
  if (this.eat(_tokentype.types.star)) {
    this.expectContextual("from");
    node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
    this.semicolon();
    return this.finishNode(node, "ExportAllDeclaration");
  }
  if (this.eat(_tokentype.types._default)) {
    var parens = this.type == _tokentype.types.parenL;
    var expr = this.parseMaybeAssign();
    var needsSemi = true;
    if (!parens && (expr.type == "FunctionExpression" || expr.type == "ClassExpression")) {
      needsSemi = false;
      if (expr.id) {
        expr.type = expr.type == "FunctionExpression" ? "FunctionDeclaration" : "ClassDeclaration";
      }
    }
    node.declaration = expr;
    if (needsSemi) this.semicolon();
    return this.finishNode(node, "ExportDefaultDeclaration");
  }
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseStatement(true);
    node.specifiers = [];
    node.source = null;
  } else {
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers();
    if (this.eatContextual("from")) {
      node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
    } else {
      for (var i = 0; i < node.specifiers.length; i++) {
        if (this.keywords.test(node.specifiers[i].local.name) || this.reservedWords.test(node.specifiers[i].local.name)) {
          this.unexpected(node.specifiers[i].local.start);
        }
      }

      node.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration");
};

pp.shouldParseExportStatement = function () {
  return this.type.keyword || this.isLet();
};
pp.parseExportSpecifiers = function () {
  var nodes = [],
      first = true;
  this.expect(_tokentype.types.braceL);
  while (!this.eat(_tokentype.types.braceR)) {
    if (!first) {
      this.expect(_tokentype.types.comma);
      if (this.afterTrailingComma(_tokentype.types.braceR)) break;
    } else first = false;

    var node = this.startNode();
    node.local = this.parseIdent(this.type === _tokentype.types._default);
    node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
    nodes.push(this.finishNode(node, "ExportSpecifier"));
  }
  return nodes;
};
pp.parseImport = function (node) {
  this.next();
  if (this.type === _tokentype.types.string) {
    node.specifiers = empty;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration");
};
pp.parseImportSpecifiers = function () {
  var nodes = [],
      first = true;
  if (this.type === _tokentype.types.name) {
    var node = this.startNode();
    node.local = this.parseIdent();
    this.checkLVal(node.local, true);
    nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
    if (!this.eat(_tokentype.types.comma)) return nodes;
  }
  if (this.type === _tokentype.types.star) {
    var node = this.startNode();
    this.next();
    this.expectContextual("as");
    node.local = this.parseIdent();
    this.checkLVal(node.local, true);
    nodes.push(this.finishNode(node, "ImportNamespaceSpecifier"));
    return nodes;
  }
  this.expect(_tokentype.types.braceL);
  while (!this.eat(_tokentype.types.braceR)) {
    if (!first) {
      this.expect(_tokentype.types.comma);
      if (this.afterTrailingComma(_tokentype.types.braceR)) break;
    } else first = false;

    var node = this.startNode();
    node.imported = this.parseIdent(true);
    if (this.eatContextual("as")) {
      node.local = this.parseIdent();
    } else {
      node.local = node.imported;
      if (this.isKeyword(node.local.name)) this.unexpected(node.local.start);
      if (this.reservedWordsStrict.test(node.local.name)) this.raise(node.local.start, "The keyword '" + node.local.name + "' is reserved");
    }
    this.checkLVal(node.local, true);
    nodes.push(this.finishNode(node, "ImportSpecifier"));
  }
  return nodes;
};

},{"./identifier":"/src\\identifier.js","./state":"/src\\state.js","./tokentype":"/src\\tokentype.js","./whitespace":"/src\\whitespace.js"}],"/src\\tokencontext.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _state = _dereq_("./state");

var _tokentype = _dereq_("./tokentype");

var _whitespace = _dereq_("./whitespace");

var TokContext = function TokContext(token, isExpr, preserveSpace, override) {


  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
};

exports.TokContext = TokContext;
var types = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", true),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function (p) {
    return p.readTmplToken();
  }),
  f_expr: new TokContext("function", true)
};

exports.types = types;
var pp = _state.Parser.prototype;

pp.initialContext = function () {
  return [types.b_stat];
};

pp.braceIsBlock = function (prevType) {
  if (prevType === _tokentype.types.colon) {
    var _parent = this.curContext();
    if (_parent === types.b_stat || _parent === types.b_expr) return !_parent.isExpr;
  }
  if (prevType === _tokentype.types._return) return _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  if (prevType === _tokentype.types._else || prevType === _tokentype.types.semi || prevType === _tokentype.types.eof || prevType === _tokentype.types.parenR) return true;
  if (prevType == _tokentype.types.braceL) return this.curContext() === types.b_stat;
  return !this.exprAllowed;
};

pp.updateContext = function (prevType) {
  var update = undefined,
      type = this.type;
  if (type.keyword && prevType == _tokentype.types.dot) this.exprAllowed = false;else if (update = type.updateContext) update.call(this, prevType);else this.exprAllowed = type.beforeExpr;
};
_tokentype.types.parenR.updateContext = _tokentype.types.braceR.updateContext = function () {
  if (this.context.length == 1) {
    this.exprAllowed = true;
    return;
  }
  var out = this.context.pop();
  if (out === types.b_stat && this.curContext() === types.f_expr) {
    this.context.pop();
    this.exprAllowed = false;
  } else if (out === types.b_tmpl) {
    this.exprAllowed = true;
  } else {
    this.exprAllowed = !out.isExpr;
  }
};

_tokentype.types.braceL.updateContext = function (prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
  this.exprAllowed = true;
};

_tokentype.types.dollarBraceL.updateContext = function () {
  this.context.push(types.b_tmpl);
  this.exprAllowed = true;
};

_tokentype.types.parenL.updateContext = function (prevType) {
  var statementParens = prevType === _tokentype.types._if || prevType === _tokentype.types._for || prevType === _tokentype.types._with || prevType === _tokentype.types._while;
  this.context.push(statementParens ? types.p_stat : types.p_expr);
  this.exprAllowed = true;
};

_tokentype.types.incDec.updateContext = function () {};

_tokentype.types._function.updateContext = function () {
  if (this.curContext() !== types.b_stat) this.context.push(types.f_expr);
  this.exprAllowed = false;
};

_tokentype.types.backQuote.updateContext = function () {
  if (this.curContext() === types.q_tmpl) this.context.pop();else this.context.push(types.q_tmpl);
  this.exprAllowed = false;
};
},{"./state":"/src\\state.js","./tokentype":"/src\\tokentype.js","./whitespace":"/src\\whitespace.js"}],"/src\\tokenize.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _identifier = _dereq_("./identifier");

var _tokentype = _dereq_("./tokentype");

var _state = _dereq_("./state");

var _locutil = _dereq_("./locutil");

var _whitespace = _dereq_("./whitespace");
var Token = function Token(p) {


  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations) this.loc = new _locutil.SourceLocation(p, p.startLoc, p.endLoc);
  if (p.options.ranges) this.range = [p.start, p.end];
};

exports.Token = Token;
var pp = _state.Parser.prototype;
var isRhino = typeof Packages == "object" && Object.prototype.toString.call(Packages) == "[object JavaPackage]";
pp.next = function () {
  if (this.options.onToken) this.options.onToken(new Token(this));

  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};

pp.getToken = function () {
  this.next();
  return new Token(this);
};
if (typeof Symbol !== "undefined") pp[Symbol.iterator] = function () {
  var self = this;
  return { next: function next() {
      var token = self.getToken();
      return {
        done: token.type === _tokentype.types.eof,
        value: token
      };
    } };
};
pp.setStrict = function (strict) {
  this.strict = strict;
  if (this.type !== _tokentype.types.num && this.type !== _tokentype.types.string) return;
  this.pos = this.start;
  if (this.options.locations) {
    while (this.pos < this.lineStart) {
      this.lineStart = this.input.lastIndexOf("\n", this.lineStart - 2) + 1;
      --this.curLine;
    }
  }
  this.nextToken();
};

pp.curContext = function () {
  return this.context[this.context.length - 1];
};
pp.nextToken = function () {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) this.skipSpace();

  this.start = this.pos;
  if (this.options.locations) this.startLoc = this.curPosition();
  if (this.pos >= this.input.length) return this.finishToken(_tokentype.types.eof);

  if (curContext.override) return curContext.override(this);else this.readToken(this.fullCharCodeAtPos());
};

pp.readToken = function (code) {
  if (_identifier.isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */) return this.readWord();

  return this.getTokenFromCode(code);
};

pp.fullCharCodeAtPos = function () {
  var code = this.input.charCodeAt(this.pos);
  if (code <= 0xd7ff || code >= 0xe000) return code;
  var next = this.input.charCodeAt(this.pos + 1);
  return (code << 10) + next - 0x35fdc00;
};

pp.skipBlockComment = function () {
  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos,
      end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) this.raise(this.pos - 2, "Unterminated comment");
  this.pos = end + 2;
  if (this.options.locations) {
    _whitespace.lineBreakG.lastIndex = start;
    var match = undefined;
    while ((match = _whitespace.lineBreakG.exec(this.input)) && match.index < this.pos) {
      ++this.curLine;
      this.lineStart = match.index + match[0].length;
    }
  }
  if (this.options.onComment) this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
};

pp.skipLineComment = function (startSkip) {
  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
    ++this.pos;
    ch = this.input.charCodeAt(this.pos);
  }
  if (this.options.onComment) this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
};
pp.skipSpace = function () {
  loop: while (this.pos < this.input.length) {
    var ch = this.input.charCodeAt(this.pos);
    switch (ch) {
      case 32:case 160:
        ++this.pos;
        break;
      case 13:
        if (this.input.charCodeAt(this.pos + 1) === 10) {
          ++this.pos;
        }
      case 10:case 8232:case 8233:
        ++this.pos;
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        break;
      case 47:
        switch (this.input.charCodeAt(this.pos + 1)) {
          case 42:
            this.skipBlockComment();
            break;
          case 47:
            this.skipLineComment(2);
            break;
          default:
            break loop;
        }
        break;
      default:
        if (ch > 8 && ch < 14 || ch >= 5760 && _whitespace.nonASCIIwhitespace.test(String.fromCharCode(ch))) {
          ++this.pos;
        } else {
          break loop;
        }
    }
  }
};
pp.finishToken = function (type, val) {
  this.end = this.pos;
  if (this.options.locations) this.endLoc = this.curPosition();
  var prevType = this.type;
  this.type = type;
  this.value = val;

  this.updateContext(prevType);
};
//
//
pp.readToken_dot = function () {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) return this.readNumber(true);
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
    this.pos += 3;
    return this.finishToken(_tokentype.types.ellipsis);
  } else {
    ++this.pos;
    return this.finishToken(_tokentype.types.dot);
  }
};

pp.readToken_slash = function () {
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) {
    ++this.pos;return this.readRegexp();
  }
  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
  return this.finishOp(_tokentype.types.slash, 1);
};

pp.readToken_mult_modulo_exp = function (code) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? _tokentype.types.star : _tokentype.types.modulo;
  if (this.options.ecmaVersion >= 7 && next === 42) {
    ++size;
    tokentype = _tokentype.types.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }

  if (next === 61) return this.finishOp(_tokentype.types.assign, size + 1);
  return this.finishOp(tokentype, size);
};

pp.readToken_pipe_amp = function (code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) return this.finishOp(code === 124 ? _tokentype.types.logicalOR : _tokentype.types.logicalAND, 2);
  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
  return this.finishOp(code === 124 ? _tokentype.types.bitwiseOR : _tokentype.types.bitwiseAND, 1);
};

pp.readToken_caret = function () {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
  return this.finishOp(_tokentype.types.bitwiseXOR, 1);
};

pp.readToken_plus_min = function (code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (next == 45 && this.input.charCodeAt(this.pos + 2) == 62 && _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) {
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken();
    }
    return this.finishOp(_tokentype.types.incDec, 2);
  }
  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
  return this.finishOp(_tokentype.types.plusMin, 1);
};

pp.readToken_lt_gt = function (code) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code) {
    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(_tokentype.types.assign, size + 1);
    return this.finishOp(_tokentype.types.bitShift, size);
  }
  if (next == 33 && code == 60 && this.input.charCodeAt(this.pos + 2) == 45 && this.input.charCodeAt(this.pos + 3) == 45) {
    if (this.inModule) this.unexpected();
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken();
  }
  if (next === 61) size = 2;
  return this.finishOp(_tokentype.types.relational, size);
};

pp.readToken_eq_excl = function (code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) return this.finishOp(_tokentype.types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
    this.pos += 2;
    return this.finishToken(_tokentype.types.arrow);
  }
  return this.finishOp(code === 61 ? _tokentype.types.eq : _tokentype.types.prefix, 1);
};

pp.getTokenFromCode = function (code) {
  switch (code) {
    case 46:
      return this.readToken_dot();
    case 40:
      ++this.pos;return this.finishToken(_tokentype.types.parenL);
    case 41:
      ++this.pos;return this.finishToken(_tokentype.types.parenR);
    case 59:
      ++this.pos;return this.finishToken(_tokentype.types.semi);
    case 44:
      ++this.pos;return this.finishToken(_tokentype.types.comma);
    case 91:
      ++this.pos;return this.finishToken(_tokentype.types.bracketL);
    case 93:
      ++this.pos;return this.finishToken(_tokentype.types.bracketR);
    case 123:
      ++this.pos;return this.finishToken(_tokentype.types.braceL);
    case 125:
      ++this.pos;return this.finishToken(_tokentype.types.braceR);
    case 58:
      ++this.pos;return this.finishToken(_tokentype.types.colon);
    case 63:
      ++this.pos;return this.finishToken(_tokentype.types.question);

    case 96:
      if (this.options.ecmaVersion < 6) break;
      ++this.pos;
      return this.finishToken(_tokentype.types.backQuote);

    case 48:
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 120 || next === 88) return this.readRadixNumber(16); // '0x', '0X' - hex number
      if (this.options.ecmaVersion >= 6) {
        if (next === 111 || next === 79) return this.readRadixNumber(8); // '0o', '0O' - octal number
        if (next === 98 || next === 66) return this.readRadixNumber(2) // '0b', '0B' - binary number
        ;
      }
    case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
      return this.readNumber(false);
    case 34:case 39:
      return this.readString(code);
    case 47:
      return this.readToken_slash();

    case 37:case 42:
      return this.readToken_mult_modulo_exp(code);

    case 124:case 38:
      return this.readToken_pipe_amp(code);

    case 94:
      return this.readToken_caret();

    case 43:case 45:
      return this.readToken_plus_min(code);

    case 60:case 62:
      return this.readToken_lt_gt(code);

    case 61:case 33:
      return this.readToken_eq_excl(code);

    case 126:
      return this.finishOp(_tokentype.types.prefix, 1);
    case 64:
      ++this.pos;return this.finishToken(_tokentype.types.at);
  }

  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};

pp.finishOp = function (type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str);
};
function tryCreateRegexp(src, flags, throwErrorAt, parser) {
  try {
    return new RegExp(src, flags);
  } catch (e) {
    if (throwErrorAt !== undefined) {
      if (e instanceof SyntaxError) parser.raise(throwErrorAt, "Error parsing regular expression: " + e.message);
      throw e;
    }
  }
}

var regexpUnicodeSupport = false; // !!tryCreateRegexp("\uffff", "u");

pp.readRegexp = function () {
  var _this = this;

  var escaped = undefined,
      inClass = undefined,
      start = this.pos;
  for (;;) {
    if (this.pos >= this.input.length) this.raise(start, "Unterminated regular expression");
    var ch = this.input.charAt(this.pos);
    if (_whitespace.lineBreak.test(ch)) this.raise(start, "Unterminated regular expression");
    if (!escaped) {
      if (ch === "[") inClass = true;else if (ch === "]" && inClass) inClass = false;else if (ch === "/" && !inClass) break;
      escaped = ch === "\\";
    } else escaped = false;
    ++this.pos;
  }
  var content = this.input.slice(start, this.pos);
  ++this.pos;
  var mods = this.readWord1();
  var tmp = content;
  if (mods) {
    var validFlags = /^[gim]*$/;
    if (this.options.ecmaVersion >= 6) validFlags = /^[gimuy]*$/;
    if (!validFlags.test(mods)) this.raise(start, "Invalid regular expression flag");
    if (mods.indexOf("u") >= 0 && !regexpUnicodeSupport) {
      tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, function (_match, code, offset) {
        code = Number("0x" + code);
        if (code > 0x10FFFF) _this.raise(start + offset + 3, "Code point out of bounds");
        return "x";
      });
      tmp = tmp.replace(/\\u([a-fA-F0-9]{4})|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
    }
  }
  var value = null;
  if (!isRhino) {
    tryCreateRegexp(tmp, undefined, start, this);
    value = tryCreateRegexp(content, mods);
  }
  return this.finishToken(_tokentype.types.regexp, { pattern: content, flags: mods, value: value });
};
pp.readInt = function (radix, len) {
  var start = this.pos,
      total = 0;
  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
    var code = this.input.charCodeAt(this.pos),
        val = undefined;
    if (code >= 97) val = code - 97 + 10 // a
    ;else if (code >= 65) val = code - 65 + 10 // A
    ;else if (code >= 48 && code <= 57) val = code - 48 // 0-9
    ;else val = Infinity;
    if (val >= radix) break;
    ++this.pos;
    total = total * radix + val;
  }
  if (this.pos === start || len != null && this.pos - start !== len) return null;

  return total;
};

pp.readRadixNumber = function (radix) {
  this.pos += 2; // 0x
  var val = this.readInt(radix);
  if (val == null) this.raise(this.start + 2, "Expected number in radix " + radix);
  if (_identifier.isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
  return this.finishToken(_tokentype.types.num, val);
};
pp.readNumber = function (startsWithDot) {
  var start = this.pos,
      isFloat = false,
      octal = this.input.charCodeAt(this.pos) === 48;
  if (!startsWithDot && this.readInt(10) === null) this.raise(start, "Invalid number");
  var next = this.input.charCodeAt(this.pos);
  if (next === 46) {
    ++this.pos;
    this.readInt(10);
    isFloat = true;
    next = this.input.charCodeAt(this.pos);
  }
  if (next === 69 || next === 101) {
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) ++this.pos; // '+-'
    if (this.readInt(10) === null) this.raise(start, "Invalid number");
    isFloat = true;
  }
  if (_identifier.isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");

  var str = this.input.slice(start, this.pos),
      val = undefined;
  if (isFloat) val = parseFloat(str);else if (!octal || str.length === 1) val = parseInt(str, 10);else if (/[89]/.test(str) || this.strict) this.raise(start, "Invalid number");else val = parseInt(str, 8);
  return this.finishToken(_tokentype.types.num, val);
};
pp.readCodePoint = function () {
  var ch = this.input.charCodeAt(this.pos),
      code = undefined;

  if (ch === 123) {
    if (this.options.ecmaVersion < 6) this.unexpected();
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code > 0x10FFFF) this.raise(codePos, "Code point out of bounds");
  } else {
    code = this.readHexChar(4);
  }
  return code;
};

function codePointToString(code) {
  if (code <= 0xFFFF) return String.fromCharCode(code);
  code -= 0x10000;
  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);
}

pp.readString = function (quote) {
  var out = "",
      chunkStart = ++this.pos;
  for (;;) {
    if (this.pos >= this.input.length) this.raise(this.start, "Unterminated string constant");
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote) break;
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else {
      if (_whitespace.isNewLine(ch)) this.raise(this.start, "Unterminated string constant");
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(_tokentype.types.string, out);
};
pp.readTmplToken = function () {
  var out = "",
      chunkStart = this.pos;
  for (;;) {
    if (this.pos >= this.input.length) this.raise(this.start, "Unterminated template");
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
      if (this.pos === this.start && this.type === _tokentype.types.template) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(_tokentype.types.dollarBraceL);
        } else {
          ++this.pos;
          return this.finishToken(_tokentype.types.backQuote);
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(_tokentype.types.template, out);
    }
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (_whitespace.isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) ++this.pos;
        case 10:
          out += "\n";
          break;
        default:
          out += String.fromCharCode(ch);
          break;
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};
pp.readEscapedChar = function (inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
    case 110:
      return "\n"; // 'n' -> '\n'
    case 114:
      return "\r"; // 'r' -> '\r'
    case 120:
      return String.fromCharCode(this.readHexChar(2)); // 'x'
    case 117:
      return codePointToString(this.readCodePoint()); // 'u'
    case 116:
      return "\t"; // 't' -> '\t'
    case 98:
      return "\b"; // 'b' -> '\b'
    case 118:
      return "\u000b"; // 'v' -> '\u000b'
    case 102:
      return "\f"; // 'f' -> '\f'
    case 13:
      if (this.input.charCodeAt(this.pos) === 10) ++this.pos; // '\r\n'
    case 10:
      if (this.options.locations) {
        this.lineStart = this.pos;++this.curLine;
      }
      return "";
    default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        if (octalStr !== "0" && (this.strict || inTemplate)) {
          this.raise(this.pos - 2, "Octal literal in strict mode");
        }
        this.pos += octalStr.length - 1;
        return String.fromCharCode(octal);
      }
      return String.fromCharCode(ch);
  }
};
pp.readHexChar = function (len) {
  var codePos = this.pos;
  var n = this.readInt(16, len);
  if (n === null) this.raise(codePos, "Bad character escape sequence");
  return n;
};
//
pp.readWord1 = function () {
  this.containsEsc = false;
  var word = "",
      first = true,
      chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (_identifier.isIdentifierChar(ch, astral)) {
      this.pos += ch <= 0xffff ? 1 : 2;
    } else if (ch === 92) {
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) != 117) // "u"
        this.raise(this.pos, "Expecting Unicode escape sequence \\uXXXX");
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first ? _identifier.isIdentifierStart : _identifier.isIdentifierChar)(esc, astral)) this.raise(escStart, "Invalid Unicode escape");
      word += codePointToString(esc);
      chunkStart = this.pos;
    } else {
      break;
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos);
};
pp.readWord = function () {
  var word = this.readWord1();
  var type = _tokentype.types.name;
  if ((this.options.ecmaVersion >= 6 || !this.containsEsc) && this.keywords.test(word)) type = _tokentype.keywords[word];
  return this.finishToken(type, word);
};

},{"./identifier":"/src\\identifier.js","./locutil":"/src\\locutil.js","./state":"/src\\state.js","./tokentype":"/src\\tokentype.js","./whitespace":"/src\\whitespace.js"}],"/src\\tokentype.js":[function(_dereq_,module,exports){
//
//
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TokenType = function TokenType(label) {
  var conf = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];


  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};

exports.TokenType = TokenType;

function binop(name, prec) {
  return new TokenType(name, { beforeExpr: true, binop: prec });
}
var beforeExpr = { beforeExpr: true },
    startsExpr = { startsExpr: true };

var types = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  eof: new TokenType("eof"),
  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),

  at: new TokenType("@", { beforeExpr: true, startsExpr: true }),
  //
  //
  //
  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
  prefix: new TokenType("prefix", { beforeExpr: true, prefix: true, startsExpr: true }),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=", 6),
  relational: binop("</>", 7),
  bitShift: binop("<</>>", 8),
  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", { beforeExpr: true })
};

exports.types = types;
var keywords = {};

exports.keywords = keywords;
function kw(name) {
  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  options.keyword = name;
  keywords[name] = types["_" + name] = new TokenType(name, options);
}

kw("break");
kw("case", beforeExpr);
kw("catch");
kw("continue");
kw("debugger");
kw("default", beforeExpr);
kw("do", { isLoop: true, beforeExpr: true });
kw("else", beforeExpr);
kw("finally");
kw("for", { isLoop: true });
kw("function", startsExpr);
kw("if");
kw("return", beforeExpr);
kw("switch");
kw("throw", beforeExpr);
kw("try");
kw("var");
kw("const");
kw("while", { isLoop: true });
kw("with");
kw("new", { beforeExpr: true, startsExpr: true });
kw("this", startsExpr);
kw("super", startsExpr);
kw("class");
kw("extends", beforeExpr);
kw("export");
kw("import");
kw("null", startsExpr);
kw("true", startsExpr);
kw("false", startsExpr);
kw("in", { beforeExpr: true, binop: 7 });
kw("instanceof", { beforeExpr: true, binop: 7 });
kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true });
kw("void", { beforeExpr: true, prefix: true, startsExpr: true });
kw("delete", { beforeExpr: true, prefix: true, startsExpr: true });

},{}],"/src\\util.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;
exports.isArray = isArray;
exports.has = has;

function isArray(obj) {
  return Object.prototype.toString.call(obj) === "[object Array]";
}
function has(obj, propName) {
  return Object.prototype.hasOwnProperty.call(obj, propName);
}

},{}],"/src\\whitespace.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;
exports.isNewLine = isNewLine;
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
exports.lineBreak = lineBreak;
var lineBreakG = new RegExp(lineBreak.source, "g");

exports.lineBreakG = lineBreakG;

function isNewLine(code) {
  return code === 10 || code === 13 || code === 0x2028 || code == 0x2029;
}

var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

exports.nonASCIIwhitespace = nonASCIIwhitespace;
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
exports.skipWhiteSpace = skipWhiteSpace;

},{}]},{},["/src\\index.js"])("/src\\index.js")
});
});

define("acorn/dist/acorn_loose",["require", "exports", "module", "./acorn"], function(require, exports, module) {

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.acorn || (g.acorn = {})).loose = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/src\\index.js":[function(_dereq_,module,exports){
"use strict";

module.exports = typeof acorn != 'undefined' ? acorn : require("./acorn");

},{}],"/src\\loose\\expression.js":[function(_dereq_,module,exports){
"use strict";

var _state = _dereq_("./state");

var _parseutil = _dereq_("./parseutil");

var _ = _dereq_("..");

var lp = _state.LooseParser.prototype;

lp.checkLVal = function (expr) {
  if (!expr) return expr;
  switch (expr.type) {
    case "Identifier":
    case "MemberExpression":
      return expr;

    case "ParenthesizedExpression":
      expr.expression = this.checkLVal(expr.expression);
      return expr;

    default:
      return this.dummyIdent();
  }
};

lp.parseExpression = function (noIn) {
  var start = this.storeCurrentPos();
  var expr = this.parseMaybeAssign(noIn);
  if (this.tok.type === _.tokTypes.comma) {
    var node = this.startNodeAt(start);
    node.expressions = [expr];
    while (this.eat(_.tokTypes.comma)) node.expressions.push(this.parseMaybeAssign(noIn));
    return this.finishNode(node, "SequenceExpression");
  }
  return expr;
};

lp.parseParenExpression = function () {
  this.pushCx();
  this.expect(_.tokTypes.parenL);
  var val = this.parseExpression();
  this.popCx();
  this.expect(_.tokTypes.parenR);
  return val;
};

lp.parseMaybeAssign = function (noIn) {
  if (this.toks.isContextual("yield")) {
    var node = this.startNode();
    this.next();
    if (this.semicolon() || this.canInsertSemicolon() || this.tok.type != _.tokTypes.star && !this.tok.type.startsExpr) {
      node.delegate = false;
      node.argument = null;
    } else {
      node.delegate = this.eat(_.tokTypes.star);
      node.argument = this.parseMaybeAssign();
    }
    return this.finishNode(node, "YieldExpression");
  }

  var start = this.storeCurrentPos();
  var left = this.parseMaybeConditional(noIn);
  if (this.tok.type.isAssign) {
    var node = this.startNodeAt(start);
    node.operator = this.tok.value;
    node.left = this.tok.type === _.tokTypes.eq ? this.toAssignable(left) : this.checkLVal(left);
    this.next();
    node.right = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "AssignmentExpression");
  }
  return left;
};

lp.parseMaybeConditional = function (noIn) {
  var start = this.storeCurrentPos();
  var expr = this.parseExprOps(noIn);
  if (this.eat(_.tokTypes.question)) {
    var node = this.startNodeAt(start);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    node.alternate = this.expect(_.tokTypes.colon) ? this.parseMaybeAssign(noIn) : this.dummyIdent();
    return this.finishNode(node, "ConditionalExpression");
  }
  return expr;
};

lp.parseExprOps = function (noIn) {
  var start = this.storeCurrentPos();
  var indent = this.curIndent,
      line = this.curLineStart;
  return this.parseExprOp(this.parseMaybeUnary(false), start, -1, noIn, indent, line);
};

lp.parseExprOp = function (left, start, minPrec, noIn, indent, line) {
  if (this.curLineStart != line && this.curIndent < indent && this.tokenStartsLine()) return left;
  var prec = this.tok.type.binop;
  if (prec != null && (!noIn || this.tok.type !== _.tokTypes._in)) {
    if (prec > minPrec) {
      var node = this.startNodeAt(start);
      node.left = left;
      node.operator = this.tok.value;
      this.next();
      if (this.curLineStart != line && this.curIndent < indent && this.tokenStartsLine()) {
        node.right = this.dummyIdent();
      } else {
        var rightStart = this.storeCurrentPos();
        node.right = this.parseExprOp(this.parseMaybeUnary(false), rightStart, prec, noIn, indent, line);
      }
      this.finishNode(node, /&&|\|\|/.test(node.operator) ? "LogicalExpression" : "BinaryExpression");
      return this.parseExprOp(node, start, minPrec, noIn, indent, line);
    }
  }
  return left;
};

lp.parseMaybeUnary = function (sawUnary) {
  var start = this.storeCurrentPos(),
      expr = undefined;
  if (this.tok.type.prefix) {
    var node = this.startNode(),
        update = this.tok.type === _.tokTypes.incDec;
    if (!update) sawUnary = true;
    node.operator = this.tok.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(true);
    if (update) node.argument = this.checkLVal(node.argument);
    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else if (this.tok.type === _.tokTypes.ellipsis) {
    var node = this.startNode();
    this.next();
    node.argument = this.parseMaybeUnary(sawUnary);
    expr = this.finishNode(node, "SpreadElement");
  } else {
    expr = this.parseExprSubscripts();
    while (this.tok.type.postfix && !this.canInsertSemicolon()) {
      var node = this.startNodeAt(start);
      node.operator = this.tok.value;
      node.prefix = false;
      node.argument = this.checkLVal(expr);
      this.next();
      expr = this.finishNode(node, "UpdateExpression");
    }
  }

  if (!sawUnary && this.eat(_.tokTypes.starstar)) {
    var node = this.startNodeAt(start);
    node.operator = "**";
    node.left = expr;
    node.right = this.parseMaybeUnary(false);
    return this.finishNode(node, "BinaryExpression");
  }

  return expr;
};

lp.parseExprSubscripts = function () {
  var start = this.storeCurrentPos();
  return this.parseSubscripts(this.parseExprAtom(), start, false, this.curIndent, this.curLineStart);
};

lp.parseSubscripts = function (base, start, noCalls, startIndent, line) {
  for (;;) {
    if (this.curLineStart != line && this.curIndent <= startIndent && this.tokenStartsLine()) {
      if (this.tok.type == _.tokTypes.dot && this.curIndent == startIndent) --startIndent;else return base;
    }

    if (this.eat(_.tokTypes.dot)) {
      var node = this.startNodeAt(start);
      node.object = base;
      if (this.curLineStart != line && this.curIndent <= startIndent && this.tokenStartsLine()) node.property = this.dummyIdent();else node.property = this.parsePropertyAccessor() || this.dummyIdent();
      node.computed = false;
      base = this.finishNode(node, "MemberExpression");
    } else if (this.tok.type == _.tokTypes.bracketL) {
      this.pushCx();
      this.next();
      var node = this.startNodeAt(start);
      node.object = base;
      node.property = this.parseExpression();
      node.computed = true;
      this.popCx();
      this.expect(_.tokTypes.bracketR);
      base = this.finishNode(node, "MemberExpression");
    } else if (!noCalls && this.tok.type == _.tokTypes.parenL) {
      var node = this.startNodeAt(start);
      node.callee = base;
      node.arguments = this.parseExprList(_.tokTypes.parenR);
      base = this.finishNode(node, "CallExpression");
    } else if (this.tok.type == _.tokTypes.backQuote) {
      var node = this.startNodeAt(start);
      node.tag = base;
      node.quasi = this.parseTemplate();
      base = this.finishNode(node, "TaggedTemplateExpression");
    } else {
      return base;
    }
  }
};

lp.parseExprAtom = function () {
  var node = undefined;
  switch (this.tok.type) {
    case _.tokTypes._this:
    case _.tokTypes._super:
      var type = this.tok.type === _.tokTypes._this ? "ThisExpression" : "Super";
      node = this.startNode();
      this.next();
      return this.finishNode(node, type);

    case _.tokTypes.name:
      if (this.tok.value == "async" && /^[ \t]*(function\b|\(|\w+[ \t]*=>)/.test(this.input.slice(this.tok.end))) {
        node = this.startNode();
        this.next();
        return this.parseExprAtom();
      }
      if (this.tok.value == "await" && /^[ \t]+[\w\x1f-\uffff]/.test(this.input.slice(this.tok.end))) {
        node = this.startNode();
        this.next();
        return this.parseExprAtom();
      }
      var start = this.storeCurrentPos();
      var id = this.parseIdent();
      return this.eat(_.tokTypes.arrow) ? this.parseArrowExpression(this.startNodeAt(start), [id]) : id;

    case _.tokTypes.regexp:
      node = this.startNode();
      var val = this.tok.value;
      node.regex = { pattern: val.pattern, flags: val.flags };
      node.value = val.value;
      node.raw = this.input.slice(this.tok.start, this.tok.end);
      this.next();
      return this.finishNode(node, "Literal");

    case _.tokTypes.num:case _.tokTypes.string:
      node = this.startNode();
      node.value = this.tok.value;
      node.raw = this.input.slice(this.tok.start, this.tok.end);
      this.next();
      return this.finishNode(node, "Literal");

    case _.tokTypes._null:case _.tokTypes._true:case _.tokTypes._false:
      node = this.startNode();
      node.value = this.tok.type === _.tokTypes._null ? null : this.tok.type === _.tokTypes._true;
      node.raw = this.tok.type.keyword;
      this.next();
      return this.finishNode(node, "Literal");

    case _.tokTypes.parenL:
      var parenStart = this.storeCurrentPos();
      this.next();
      var inner = this.parseExpression();
      this.expect(_.tokTypes.parenR);
      if (this.eat(_.tokTypes.arrow)) {
        return this.parseArrowExpression(this.startNodeAt(parenStart), inner.expressions || (_parseutil.isDummy(inner) ? [] : [inner]));
      }
      if (this.options.preserveParens) {
        var par = this.startNodeAt(parenStart);
        par.expression = inner;
        inner = this.finishNode(par, "ParenthesizedExpression");
      }
      return inner;

    case _.tokTypes.bracketL:
      node = this.startNode();
      node.elements = this.parseExprList(_.tokTypes.bracketR, true);
      return this.finishNode(node, "ArrayExpression");

    case _.tokTypes.braceL:
      return this.parseObj();

    case _.tokTypes._class:
      return this.parseClass();

    case _.tokTypes._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, false);

    case _.tokTypes._new:
      return this.parseNew();

    case _.tokTypes.backQuote:
      return this.parseTemplate();

    default:
      return this.dummyIdent();
  }
};

lp.parseNew = function () {
  var node = this.startNode(),
      startIndent = this.curIndent,
      line = this.curLineStart;
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(_.tokTypes.dot)) {
    node.meta = meta;
    node.property = this.parseIdent(true);
    return this.finishNode(node, "MetaProperty");
  }
  var start = this.storeCurrentPos();
  node.callee = this.parseSubscripts(this.parseExprAtom(), start, true, startIndent, line);
  if (this.tok.type == _.tokTypes.parenL) {
    node.arguments = this.parseExprList(_.tokTypes.parenR);
  } else {
    node.arguments = [];
  }
  return this.finishNode(node, "NewExpression");
};

lp.parseTemplateElement = function () {
  var elem = this.startNode();
  elem.value = {
    raw: this.input.slice(this.tok.start, this.tok.end).replace(/\r\n?/g, "\n"),
    cooked: this.tok.value
  };
  this.next();
  elem.tail = this.tok.type === _.tokTypes.backQuote;
  return this.finishNode(elem, "TemplateElement");
};

lp.parseTemplate = function () {
  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement();
  node.quasis = [curElt];
  while (!curElt.tail) {
    this.next();
    node.expressions.push(this.parseExpression());
    if (this.expect(_.tokTypes.braceR)) {
      curElt = this.parseTemplateElement();
    } else {
      curElt = this.startNode();
      curElt.value = { cooked: "", raw: "" };
      curElt.tail = true;
    }
    node.quasis.push(curElt);
  }
  this.expect(_.tokTypes.backQuote);
  return this.finishNode(node, "TemplateLiteral");
};

lp.parseObj = function () {
  var node = this.startNode();
  node.properties = [];
  this.pushCx();
  var indent = this.curIndent + 1,
      line = this.curLineStart;
  this.eat(_.tokTypes.braceL);
  if (this.curIndent + 1 < indent) {
    indent = this.curIndent;line = this.curLineStart;
  }
  while (!this.closes(_.tokTypes.braceR, indent, line)) {
    var prop = this.startNode(),
        isGenerator = undefined,
        start = undefined;
    if (this.options.ecmaVersion >= 6) {
      start = this.storeCurrentPos();
      prop.method = false;
      prop.shorthand = false;
      isGenerator = this.eat(_.tokTypes.star);
    }
    this.parsePropertyName(prop);
    if (_parseutil.isDummy(prop.key)) {
      if (_parseutil.isDummy(this.parseMaybeAssign())) this.next();this.eat(_.tokTypes.comma);continue;
    }
    if (this.eat(_.tokTypes.colon)) {
      prop.kind = "init";
      prop.value = this.parseMaybeAssign();
    } else if (this.options.ecmaVersion >= 6 && (this.tok.type === _.tokTypes.parenL || this.tok.type === _.tokTypes.braceL)) {
      prop.kind = "init";
      prop.method = true;
      prop.value = this.parseMethod(isGenerator);
    } else if (this.options.ecmaVersion >= 5 && prop.key.type === "Identifier" && !prop.computed && (prop.key.name === "get" || prop.key.name === "set") && (this.tok.type != _.tokTypes.comma && this.tok.type != _.tokTypes.braceR)) {
      prop.kind = prop.key.name;
      this.parsePropertyName(prop);
      prop.value = this.parseMethod(false);
    } else {
      prop.kind = "init";
      if (this.options.ecmaVersion >= 6) {
        if (this.eat(_.tokTypes.eq)) {
          var assign = this.startNodeAt(start);
          assign.operator = "=";
          assign.left = prop.key;
          assign.right = this.parseMaybeAssign();
          prop.value = this.finishNode(assign, "AssignmentExpression");
        } else {
          prop.value = prop.key;
        }
      } else {
        prop.value = this.dummyIdent();
      }
      prop.shorthand = true;
    }
    node.properties.push(this.finishNode(prop, "Property"));
    this.eat(_.tokTypes.comma);
  }
  this.popCx();
  if (!this.eat(_.tokTypes.braceR)) {
    this.last.end = this.tok.start;
    if (this.options.locations) this.last.loc.end = this.tok.loc.start;
  }
  return this.finishNode(node, "ObjectExpression");
};

lp.parsePropertyName = function (prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(_.tokTypes.bracketL)) {
      prop.computed = true;
      prop.key = this.parseExpression();
      this.expect(_.tokTypes.bracketR);
      return;
    } else {
      prop.computed = false;
    }
  }
  var key = this.tok.type === _.tokTypes.num || this.tok.type === _.tokTypes.string ? this.parseExprAtom() : this.parseIdent();
  prop.key = key || this.dummyIdent();
};

lp.parsePropertyAccessor = function () {
  if (this.tok.type === _.tokTypes.name || this.tok.type.keyword) return this.parseIdent();
};

lp.parseIdent = function () {
  var name = this.tok.type === _.tokTypes.name ? this.tok.value : this.tok.type.keyword;
  if (!name) return this.dummyIdent();
  var node = this.startNode();
  this.next();
  node.name = name;
  return this.finishNode(node, "Identifier");
};

lp.initFunction = function (node) {
  node.id = null;
  node.params = [];
  if (this.options.ecmaVersion >= 6) {
    node.generator = false;
    node.expression = false;
  }
};
lp.toAssignable = function (node, binding) {
  if (!node || node.type == "Identifier" || node.type == "MemberExpression" && !binding) {} else if (node.type == "ParenthesizedExpression") {
    node.expression = this.toAssignable(node.expression, binding);
  } else if (this.options.ecmaVersion < 6) {
    return this.dummyIdent();
  } else if (node.type == "ObjectExpression") {
    node.type = "ObjectPattern";
    var props = node.properties;
    for (var i = 0; i < props.length; i++) {
      props[i].value = this.toAssignable(props[i].value, binding);
    }
  } else if (node.type == "ArrayExpression") {
    node.type = "ArrayPattern";
    this.toAssignableList(node.elements, binding);
  } else if (node.type == "SpreadElement") {
    node.type = "RestElement";
    node.argument = this.toAssignable(node.argument, binding);
  } else if (node.type == "AssignmentExpression") {
    node.type = "AssignmentPattern";
    delete node.operator;
  } else {
    return this.dummyIdent();
  }
  return node;
};

lp.toAssignableList = function (exprList, binding) {
  for (var i = 0; i < exprList.length; i++) {
    exprList[i] = this.toAssignable(exprList[i], binding);
  }return exprList;
};

lp.parseFunctionParams = function (params) {
  params = this.parseExprList(_.tokTypes.parenR);
  return this.toAssignableList(params, true);
};

lp.parseMethod = function (isGenerator) {
  var node = this.startNode();
  this.initFunction(node);
  node.params = this.parseFunctionParams();
  node.generator = isGenerator || false;
  node.expression = this.options.ecmaVersion >= 6 && this.tok.type !== _.tokTypes.braceL;
  node.body = node.expression ? this.parseMaybeAssign() : this.parseBlock();
  return this.finishNode(node, "FunctionExpression");
};

lp.parseArrowExpression = function (node, params) {
  this.initFunction(node);
  node.params = this.toAssignableList(params, true);
  node.expression = this.tok.type !== _.tokTypes.braceL;
  node.body = node.expression ? this.parseMaybeAssign() : this.parseBlock();
  return this.finishNode(node, "ArrowFunctionExpression");
};

lp.parseExprList = function (close, allowEmpty) {
  this.pushCx();
  var indent = this.curIndent,
      line = this.curLineStart,
      elts = [];
  this.next(); // Opening bracket
  while (!this.closes(close, indent + 1, line)) {
    if (this.eat(_.tokTypes.comma)) {
      elts.push(allowEmpty ? null : this.dummyIdent());
      continue;
    }
    var elt = this.parseMaybeAssign();
    if (_parseutil.isDummy(elt)) {
      if (this.closes(close, indent, line)) break;
      this.next();
    } else {
      elts.push(elt);
    }
    this.eat(_.tokTypes.comma);
  }
  this.popCx();
  if (!this.eat(close)) {
    this.last.end = this.tok.start;
    if (this.options.locations) this.last.loc.end = this.tok.loc.start;
  }
  return elts;
};
},{"..":"/src\\index.js","./parseutil":"/src\\loose\\parseutil.js","./state":"/src\\loose\\state.js"}],"/src\\loose\\index.js":[function(_dereq_,module,exports){
//
//
//
//
//
//
//
"use strict";

exports.__esModule = true;
exports.parse_dammit = parse_dammit;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

var _ = _dereq_("..");

var acorn = _interopRequireWildcard(_);

var _state = _dereq_("./state");

_dereq_("./tokenize");

_dereq_("./statement");

_dereq_("./expression");

exports.LooseParser = _state.LooseParser;
exports.pluginsLoose = _state.pluginsLoose;

acorn.defaultOptions.tabSize = 4;

function parse_dammit(input, options) {
  var p = new _state.LooseParser(input, options);
  p.next();
  return p.parseTopLevel();
}

acorn.parse_dammit = parse_dammit;
acorn.LooseParser = _state.LooseParser;
acorn.pluginsLoose = _state.pluginsLoose;

},{"..":"/src\\index.js","./expression":"/src\\loose\\expression.js","./state":"/src\\loose\\state.js","./statement":"/src\\loose\\statement.js","./tokenize":"/src\\loose\\tokenize.js"}],"/src\\loose\\parseutil.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;
exports.isDummy = isDummy;

function isDummy(node) {
  return node.name == "✖";
}

},{}],"/src\\loose\\state.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _ = _dereq_("..");
var pluginsLoose = {};

exports.pluginsLoose = pluginsLoose;

var LooseParser = (function () {
  function LooseParser(input, options) {


    this.toks = _.tokenizer(input, options);
    this.options = this.toks.options;
    this.input = this.toks.input;
    this.tok = this.last = { type: _.tokTypes.eof, start: 0, end: 0 };
    if (this.options.locations) {
      var here = this.toks.curPosition();
      this.tok.loc = new _.SourceLocation(this.toks, here, here);
    }
    this.ahead = []; // Tokens ahead
    this.context = []; // Indentation contexted
    this.curIndent = 0;
    this.curLineStart = 0;
    this.nextLineStart = this.lineEnd(this.curLineStart) + 1;
    this.options.pluginsLoose = options.pluginsLoose || {};
    this.loadPlugins(this.options.pluginsLoose);
  }

  LooseParser.prototype.startNode = function startNode() {
    return new _.Node(this.toks, this.tok.start, this.options.locations ? this.tok.loc.start : null);
  };

  LooseParser.prototype.storeCurrentPos = function storeCurrentPos() {
    return this.options.locations ? [this.tok.start, this.tok.loc.start] : this.tok.start;
  };

  LooseParser.prototype.startNodeAt = function startNodeAt(pos) {
    if (this.options.locations) {
      return new _.Node(this.toks, pos[0], pos[1]);
    } else {
      return new _.Node(this.toks, pos);
    }
  };

  LooseParser.prototype.finishNode = function finishNode(node, type) {
    node.type = type;
    node.end = this.last.end;
    if (this.options.locations) node.loc.end = this.last.loc.end;
    if (this.options.ranges) node.range[1] = this.last.end;
    return node;
  };

  LooseParser.prototype.dummyNode = function dummyNode(type) {
    var dummy = this.startNode();
    dummy.type = type;
    dummy.end = dummy.start;
    if (this.options.locations) dummy.loc.end = dummy.loc.start;
    if (this.options.ranges) dummy.range[1] = dummy.start;
    this.last = { type: _.tokTypes.name, start: dummy.start, end: dummy.start, loc: dummy.loc };
    return dummy;
  };

  LooseParser.prototype.dummyIdent = function dummyIdent() {
    var dummy = this.dummyNode("Identifier");
    dummy.name = "✖";
    return dummy;
  };

  LooseParser.prototype.dummyString = function dummyString() {
    var dummy = this.dummyNode("Literal");
    dummy.value = dummy.raw = "✖";
    return dummy;
  };

  LooseParser.prototype.eat = function eat(type) {
    if (this.tok.type === type) {
      this.next();
      return true;
    } else {
      return false;
    }
  };

  LooseParser.prototype.isContextual = function isContextual(name) {
    return this.tok.type === _.tokTypes.name && this.tok.value === name;
  };

  LooseParser.prototype.eatContextual = function eatContextual(name) {
    return this.tok.value === name && this.eat(_.tokTypes.name);
  };

  LooseParser.prototype.canInsertSemicolon = function canInsertSemicolon() {
    return this.tok.type === _.tokTypes.eof || this.tok.type === _.tokTypes.braceR || _.lineBreak.test(this.input.slice(this.last.end, this.tok.start));
  };

  LooseParser.prototype.semicolon = function semicolon() {
    return this.eat(_.tokTypes.semi);
  };

  LooseParser.prototype.expect = function expect(type) {
    if (this.eat(type)) return true;
    for (var i = 1; i <= 2; i++) {
      if (this.lookAhead(i).type == type) {
        for (var j = 0; j < i; j++) {
          this.next();
        }return true;
      }
    }
  };

  LooseParser.prototype.pushCx = function pushCx() {
    this.context.push(this.curIndent);
  };

  LooseParser.prototype.popCx = function popCx() {
    this.curIndent = this.context.pop();
  };

  LooseParser.prototype.lineEnd = function lineEnd(pos) {
    while (pos < this.input.length && !_.isNewLine(this.input.charCodeAt(pos))) ++pos;
    return pos;
  };

  LooseParser.prototype.indentationAfter = function indentationAfter(pos) {
    for (var count = 0;; ++pos) {
      var ch = this.input.charCodeAt(pos);
      if (ch === 32) ++count;else if (ch === 9) count += this.options.tabSize;else return count;
    }
  };

  LooseParser.prototype.closes = function closes(closeTok, indent, line, blockHeuristic) {
    if (this.tok.type === closeTok || this.tok.type === _.tokTypes.eof) return true
    ;
  };

  LooseParser.prototype.tokenStartsLine = function tokenStartsLine() {
    for (var p = this.tok.start - 1; p >= this.curLineStart; --p) {
      var ch = this.input.charCodeAt(p);
      if (ch !== 9 && ch !== 32) return false;
    }
    return true;
  };

  LooseParser.prototype.extend = function extend(name, f) {
    this[name] = f(this[name]);
  };

  LooseParser.prototype.loadPlugins = function loadPlugins(pluginConfigs) {
    for (var _name in pluginConfigs) {
      var plugin = pluginsLoose[_name];
      if (!plugin) throw new Error("Plugin '" + _name + "' not found");
      plugin(this, pluginConfigs[_name]);
    }
  };

  return LooseParser;
})();

exports.LooseParser = LooseParser;

},{"..":"/src\\index.js"}],"/src\\loose\\statement.js":[function(_dereq_,module,exports){
"use strict";

var _state = _dereq_("./state");

var _parseutil = _dereq_("./parseutil");

var _ = _dereq_("..");

var lp = _state.LooseParser.prototype;

lp.parseTopLevel = function () {
  var node = this.startNodeAt(this.options.locations ? [0, _.getLineInfo(this.input, 0)] : 0);
  node.body = [];
  while (this.tok.type !== _.tokTypes.eof) node.body.push(this.parseStatement());
  this.last = this.tok;
  if (this.options.ecmaVersion >= 6) {
    node.sourceType = this.options.sourceType;
  }
  return this.finishNode(node, "Program");
};

lp.parseStatement = function () {
  var starttype = this.tok.type,
      node = this.startNode(),
      kind = undefined;

  if (this.toks.isLet()) {
    starttype = _.tokTypes._var;
    kind = "let";
  }

  switch (starttype) {
    case _.tokTypes._break:case _.tokTypes._continue:
      this.next();
      var isBreak = starttype === _.tokTypes._break;
      if (this.semicolon() || this.canInsertSemicolon()) {
        node.label = null;
      } else {
        node.label = this.tok.type === _.tokTypes.name ? this.parseIdent() : null;
        this.semicolon();
      }
      return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");

    case _.tokTypes._debugger:
      this.next();
      this.semicolon();
      return this.finishNode(node, "DebuggerStatement");

    case _.tokTypes._do:
      this.next();
      node.body = this.parseStatement();
      node.test = this.eat(_.tokTypes._while) ? this.parseParenExpression() : this.dummyIdent();
      this.semicolon();
      return this.finishNode(node, "DoWhileStatement");

    case _.tokTypes._for:
      this.next();
      this.pushCx();
      this.expect(_.tokTypes.parenL);
      if (this.tok.type === _.tokTypes.semi) return this.parseFor(node, null);
      var isLet = this.toks.isLet();
      if (isLet || this.tok.type === _.tokTypes._var || this.tok.type === _.tokTypes._const) {
        var _init = this.parseVar(true, isLet ? "let" : this.tok.value);
        if (_init.declarations.length === 1 && (this.tok.type === _.tokTypes._in || this.isContextual("of"))) {
          return this.parseForIn(node, _init);
        }
        return this.parseFor(node, _init);
      }
      var init = this.parseExpression(true);
      if (this.tok.type === _.tokTypes._in || this.isContextual("of")) return this.parseForIn(node, this.toAssignable(init));
      return this.parseFor(node, init);

    case _.tokTypes._function:
      this.next();
      return this.parseFunction(node, true);

    case _.tokTypes._if:
      this.next();
      node.test = this.parseParenExpression();
      node.consequent = this.parseStatement();
      node.alternate = this.eat(_.tokTypes._else) ? this.parseStatement() : null;
      return this.finishNode(node, "IfStatement");

    case _.tokTypes._return:
      this.next();
      if (this.eat(_.tokTypes.semi) || this.canInsertSemicolon()) node.argument = null;else {
        node.argument = this.parseExpression();this.semicolon();
      }
      return this.finishNode(node, "ReturnStatement");

    case _.tokTypes._switch:
      var blockIndent = this.curIndent,
          line = this.curLineStart;
      this.next();
      node.discriminant = this.parseParenExpression();
      node.cases = [];
      this.pushCx();
      this.expect(_.tokTypes.braceL);

      var cur = undefined;
      while (!this.closes(_.tokTypes.braceR, blockIndent, line, true)) {
        if (this.tok.type === _.tokTypes._case || this.tok.type === _.tokTypes._default) {
          var isCase = this.tok.type === _.tokTypes._case;
          if (cur) this.finishNode(cur, "SwitchCase");
          node.cases.push(cur = this.startNode());
          cur.consequent = [];
          this.next();
          if (isCase) cur.test = this.parseExpression();else cur.test = null;
          this.expect(_.tokTypes.colon);
        } else {
          if (!cur) {
            node.cases.push(cur = this.startNode());
            cur.consequent = [];
            cur.test = null;
          }
          cur.consequent.push(this.parseStatement());
        }
      }
      if (cur) this.finishNode(cur, "SwitchCase");
      this.popCx();
      this.eat(_.tokTypes.braceR);
      return this.finishNode(node, "SwitchStatement");

    case _.tokTypes._throw:
      this.next();
      node.argument = this.parseExpression();
      this.semicolon();
      return this.finishNode(node, "ThrowStatement");

    case _.tokTypes._try:
      this.next();
      node.block = this.parseBlock();
      node.handler = null;
      if (this.tok.type === _.tokTypes._catch) {
        var clause = this.startNode();
        this.next();
        this.expect(_.tokTypes.parenL);
        clause.param = this.toAssignable(this.parseExprAtom(), true);
        this.expect(_.tokTypes.parenR);
        clause.body = this.parseBlock();
        node.handler = this.finishNode(clause, "CatchClause");
      }
      node.finalizer = this.eat(_.tokTypes._finally) ? this.parseBlock() : null;
      if (!node.handler && !node.finalizer) return node.block;
      return this.finishNode(node, "TryStatement");

    case _.tokTypes._var:
    case _.tokTypes._const:
      return this.parseVar(false, kind || this.tok.value);

    case _.tokTypes._while:
      this.next();
      node.test = this.parseParenExpression();
      node.body = this.parseStatement();
      return this.finishNode(node, "WhileStatement");

    case _.tokTypes._with:
      this.next();
      node.object = this.parseParenExpression();
      node.body = this.parseStatement();
      return this.finishNode(node, "WithStatement");

    case _.tokTypes.braceL:
      return this.parseBlock();

    case _.tokTypes.semi:
      this.next();
      return this.finishNode(node, "EmptyStatement");

    case _.tokTypes._class:
      return this.parseClass(true);

    case _.tokTypes._import:
      return this.parseImport();

    case _.tokTypes._export:
      return this.parseExport();
    case _.tokTypes.at:
      this.next();
      return this.parseExpression();

    default:
      var expr = this.parseExpression();
      if (_parseutil.isDummy(expr)) {
        this.next();
        if (this.tok.type === _.tokTypes.eof) return this.finishNode(node, "EmptyStatement");
        return this.parseStatement();
      } else if (starttype === _.tokTypes.name && expr.type === "Identifier" && this.eat(_.tokTypes.colon)) {
        node.body = this.parseStatement();
        node.label = expr;
        return this.finishNode(node, "LabeledStatement");
      } else {
        node.expression = expr;
        this.semicolon();
        return this.finishNode(node, "ExpressionStatement");
      }
  }
};

lp.parseBlock = function () {
  var node = this.startNode();
  this.pushCx();
  this.expect(_.tokTypes.braceL);
  var blockIndent = this.curIndent,
      line = this.curLineStart;
  node.body = [];
  while (!this.closes(_.tokTypes.braceR, blockIndent, line, true)) node.body.push(this.parseStatement());
  this.popCx();
  this.eat(_.tokTypes.braceR);
  return this.finishNode(node, "BlockStatement");
};

lp.parseFor = function (node, init) {
  node.init = init;
  node.test = node.update = null;
  if (this.eat(_.tokTypes.semi) && this.tok.type !== _.tokTypes.semi) node.test = this.parseExpression();
  if (this.eat(_.tokTypes.semi) && this.tok.type !== _.tokTypes.parenR) node.update = this.parseExpression();
  this.popCx();
  this.expect(_.tokTypes.parenR);
  node.body = this.parseStatement();
  return this.finishNode(node, "ForStatement");
};

lp.parseForIn = function (node, init) {
  var type = this.tok.type === _.tokTypes._in ? "ForInStatement" : "ForOfStatement";
  this.next();
  node.left = init;
  node.right = this.parseExpression();
  this.popCx();
  this.expect(_.tokTypes.parenR);
  node.body = this.parseStatement();
  return this.finishNode(node, type);
};

lp.parseVar = function (noIn, kind) {
  var node = this.startNode();
  node.kind = kind;
  this.next();
  node.declarations = [];
  do {
    var decl = this.startNode();
    decl.id = this.options.ecmaVersion >= 6 ? this.toAssignable(this.parseExprAtom(), true) : this.parseIdent();
    decl.init = this.eat(_.tokTypes.eq) ? this.parseMaybeAssign(noIn) : null;
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
  } while (this.eat(_.tokTypes.comma));
  if (!node.declarations.length) {
    var decl = this.startNode();
    decl.id = this.dummyIdent();
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
  }
  if (!noIn) this.semicolon();
  return this.finishNode(node, "VariableDeclaration");
};

lp.parseClass = function (isStatement) {
  var node = this.startNode();
  this.next();
  if (this.tok.type === _.tokTypes.name) node.id = this.parseIdent();else if (isStatement) node.id = this.dummyIdent();else node.id = null;
  node.superClass = this.eat(_.tokTypes._extends) ? this.parseExpression() : null;
  node.body = this.startNode();
  node.body.body = [];
  this.pushCx();
  var indent = this.curIndent + 1,
      line = this.curLineStart;
  this.eat(_.tokTypes.braceL);
  var decorators = [];
  if (this.curIndent + 1 < indent) {
    indent = this.curIndent;line = this.curLineStart;
  }
  while (!this.closes(_.tokTypes.braceR, indent, line)) {
    if (this.semicolon()) continue;
    if (this.tok.type == _.tokTypes.at) {
      this.next();
      var expr = this.parseMaybeAssign(true);
      decorators.push(expr);
      continue;
    }
    var method = this.startNode(),
        isGenerator = undefined;
    if (this.options.ecmaVersion >= 6) {
      method["static"] = false;
      isGenerator = this.eat(_.tokTypes.star);
    }
    this.parsePropertyName(method);
    if (_parseutil.isDummy(method.key)) {
      if (_parseutil.isDummy(this.parseMaybeAssign())) this.next();this.eat(_.tokTypes.comma);continue;
    }
    if (method.key.type === "Identifier" && !method.computed && method.key.name === "static" && (this.tok.type != _.tokTypes.parenL && this.tok.type != _.tokTypes.braceL)) {
      method["static"] = true;
      isGenerator = this.eat(_.tokTypes.star);
      this.parsePropertyName(method);
    } else {
      method["static"] = false;
    }
    if (this.options.ecmaVersion >= 5 && method.key.type === "Identifier" && !method.computed && (method.key.name === "get" || method.key.name === "set") && this.tok.type !== _.tokTypes.parenL && this.tok.type !== _.tokTypes.braceL) {
      method.kind = method.key.name;
      this.parsePropertyName(method);
      method.value = this.parseMethod(false);
    } else {
      if (!method.computed && !method["static"] && !isGenerator && (method.key.type === "Identifier" && method.key.name === "constructor" || method.key.type === "Literal" && method.key.value === "constructor")) {
        method.kind = "constructor";
      } else {
        method.kind = "method";
      }
      method.value = this.parseMethod(isGenerator);
    }

    if (decorators.length) {
      var body = method.value.body.body;
      if (body) body.unshift.apply(body, decorators);
      decorators = [];
    }
    node.body.body.push(this.finishNode(method, "MethodDefinition"));
  }
  this.popCx();
  if (!this.eat(_.tokTypes.braceR)) {
    this.last.end = this.tok.start;
    if (this.options.locations) this.last.loc.end = this.tok.loc.start;
  }
  this.semicolon();
  this.finishNode(node.body, "ClassBody");
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};

lp.parseFunction = function (node, isStatement) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 6) {
    node.generator = this.eat(_.tokTypes.star);
  }
  if (this.tok.type === _.tokTypes.name) node.id = this.parseIdent();else if (isStatement) node.id = this.dummyIdent();
  node.params = this.parseFunctionParams();
  node.body = this.parseBlock();
  return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
};

lp.parseExport = function () {
  var node = this.startNode();
  this.next();
  if (this.eat(_.tokTypes.star)) {
    node.source = this.eatContextual("from") ? this.parseExprAtom() : null;
    return this.finishNode(node, "ExportAllDeclaration");
  }
  if (this.eat(_.tokTypes._default)) {
    var expr = this.parseMaybeAssign();
    if (expr.id) {
      switch (expr.type) {
        case "FunctionExpression":
          expr.type = "FunctionDeclaration";break;
        case "ClassExpression":
          expr.type = "ClassDeclaration";break;
      }
    }
    node.declaration = expr;
    this.semicolon();
    return this.finishNode(node, "ExportDefaultDeclaration");
  }
  if (this.tok.type.keyword || this.toks.isLet()) {
    node.declaration = this.parseStatement();
    node.specifiers = [];
    node.source = null;
  } else {
    node.declaration = null;
    node.specifiers = this.parseExportSpecifierList();
    node.source = this.eatContextual("from") ? this.parseExprAtom() : null;
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration");
};

lp.parseImport = function () {
  var node = this.startNode();
  this.next();
  if (this.tok.type === _.tokTypes.string) {
    node.specifiers = [];
    node.source = this.parseExprAtom();
    node.kind = "";
  } else {
    var elt = undefined;
    if (this.tok.type === _.tokTypes.name && this.tok.value !== "from") {
      elt = this.startNode();
      elt.local = this.parseIdent();
      this.finishNode(elt, "ImportDefaultSpecifier");
      this.eat(_.tokTypes.comma);
    }
    node.specifiers = this.parseImportSpecifierList();
    node.source = this.eatContextual("from") && this.tok.type == _.tokTypes.string ? this.parseExprAtom() : this.dummyString();
    if (elt) node.specifiers.unshift(elt);
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration");
};

lp.parseImportSpecifierList = function () {
  var elts = [];
  if (this.tok.type === _.tokTypes.star) {
    var elt = this.startNode();
    this.next();
    if (this.eatContextual("as")) elt.local = this.parseIdent();
    elts.push(this.finishNode(elt, "ImportNamespaceSpecifier"));
  } else {
    var indent = this.curIndent,
        line = this.curLineStart,
        continuedLine = this.nextLineStart;
    this.pushCx();
    this.eat(_.tokTypes.braceL);
    if (this.curLineStart > continuedLine) continuedLine = this.curLineStart;
    while (!this.closes(_.tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {
      var elt = this.startNode();
      if (this.eat(_.tokTypes.star)) {
        elt.local = this.eatContextual("as") ? this.parseIdent() : this.dummyIdent();
        this.finishNode(elt, "ImportNamespaceSpecifier");
      } else {
        if (this.isContextual("from")) break;
        elt.imported = this.parseIdent();
        if (_parseutil.isDummy(elt.imported)) break;
        elt.local = this.eatContextual("as") ? this.parseIdent() : elt.imported;
        this.finishNode(elt, "ImportSpecifier");
      }
      elts.push(elt);
      this.eat(_.tokTypes.comma);
    }
    this.eat(_.tokTypes.braceR);
    this.popCx();
  }
  return elts;
};

lp.parseExportSpecifierList = function () {
  var elts = [];
  var indent = this.curIndent,
      line = this.curLineStart,
      continuedLine = this.nextLineStart;
  this.pushCx();
  this.eat(_.tokTypes.braceL);
  if (this.curLineStart > continuedLine) continuedLine = this.curLineStart;
  while (!this.closes(_.tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {
    if (this.isContextual("from")) break;
    var elt = this.startNode();
    elt.local = this.parseIdent();
    if (_parseutil.isDummy(elt.local)) break;
    elt.exported = this.eatContextual("as") ? this.parseIdent() : elt.local;
    this.finishNode(elt, "ExportSpecifier");
    elts.push(elt);
    this.eat(_.tokTypes.comma);
  }
  this.eat(_.tokTypes.braceR);
  this.popCx();
  return elts;
};

},{"..":"/src\\index.js","./parseutil":"/src\\loose\\parseutil.js","./state":"/src\\loose\\state.js"}],"/src\\loose\\tokenize.js":[function(_dereq_,module,exports){
"use strict";

var _ = _dereq_("..");

var _state = _dereq_("./state");

var lp = _state.LooseParser.prototype;

function isSpace(ch) {
  return ch < 14 && ch > 8 || ch === 32 || ch === 160 || _.isNewLine(ch);
}

lp.next = function () {
  this.last = this.tok;
  if (this.ahead.length) this.tok = this.ahead.shift();else this.tok = this.readToken();

  if (this.tok.start >= this.nextLineStart) {
    while (this.tok.start >= this.nextLineStart) {
      this.curLineStart = this.nextLineStart;
      this.nextLineStart = this.lineEnd(this.curLineStart) + 1;
    }
    this.curIndent = this.indentationAfter(this.curLineStart);
  }
};

lp.readToken = function () {
  for (;;) {
    try {
      this.toks.next();
      if (this.toks.type === _.tokTypes.dot && this.input.substr(this.toks.end, 1) === "." && this.options.ecmaVersion >= 6) {
        this.toks.end++;
        this.toks.type = _.tokTypes.ellipsis;
      }
      return new _.Token(this.toks);
    } catch (e) {
      if (!(e instanceof SyntaxError)) throw e;
      var msg = e.message,
          pos = e.raisedAt,
          replace = true;
      if (/unterminated/i.test(msg)) {
        pos = this.lineEnd(e.pos + 1);
        if (/string/.test(msg)) {
          replace = { start: e.pos, end: pos, type: _.tokTypes.string, value: this.input.slice(e.pos + 1, pos) };
        } else if (/regular expr/i.test(msg)) {
          var re = this.input.slice(e.pos, pos);
          try {
            re = new RegExp(re);
          } catch (e) {}
          replace = { start: e.pos, end: pos, type: _.tokTypes.regexp, value: re };
        } else if (/template/.test(msg)) {
          replace = { start: e.pos, end: pos,
            type: _.tokTypes.template,
            value: this.input.slice(e.pos, pos) };
        } else {
          replace = false;
        }
      } else if (/invalid (unicode|regexp|number)|expecting unicode|octal literal|is reserved|directly after number|expected number in radix/i.test(msg)) {
        while (pos < this.input.length && !isSpace(this.input.charCodeAt(pos))) ++pos;
      } else if (/character escape|expected hexadecimal/i.test(msg)) {
        while (pos < this.input.length) {
          var ch = this.input.charCodeAt(pos++);
          if (ch === 34 || ch === 39 || _.isNewLine(ch)) break;
        }
      } else if (/unexpected character/i.test(msg)) {
        pos++;
        replace = false;
      } else if (/regular expression/i.test(msg)) {
        replace = true;
      } else {
        throw e;
      }
      this.resetTo(pos);
      if (replace === true) replace = { start: pos, end: pos, type: _.tokTypes.name, value: "✖" };
      if (replace) {
        if (this.options.locations) replace.loc = new _.SourceLocation(this.toks, _.getLineInfo(this.input, replace.start), _.getLineInfo(this.input, replace.end));
        return replace;
      }
    }
  }
};

lp.resetTo = function (pos) {
  this.toks.pos = pos;
  var ch = this.input.charAt(pos - 1);
  this.toks.exprAllowed = !ch || /[\[\{\(,;:?\/*=+\-~!|&%^<>]/.test(ch) || /[enwfd]/.test(ch) && /\b(keywords|case|else|return|throw|new|in|(instance|type)of|delete|void)$/.test(this.input.slice(pos - 10, pos));

  if (this.options.locations) {
    this.toks.curLine = 1;
    this.toks.lineStart = _.lineBreakG.lastIndex = 0;
    var match = undefined;
    while ((match = _.lineBreakG.exec(this.input)) && match.index < pos) {
      ++this.toks.curLine;
      this.toks.lineStart = match.index + match[0].length;
    }
  }
};

lp.lookAhead = function (n) {
  while (n > this.ahead.length) this.ahead.push(this.readToken());
  return this.ahead[n - 1];
};

},{"..":"/src\\index.js","./state":"/src\\loose\\state.js"}]},{},["/src\\loose\\index.js"])("/src\\loose\\index.js")
});
});

define("treehugger/tree",[], function(require, exports, module) {

function inRange(p, pos, exclusive) {
    if(p && p.sl <= pos.line && pos.line <= p.el) {
        if(p.sl < pos.line && pos.line < p.el)
            return true;
        else if(p.sl == pos.line && pos.line < p.el)
            return p.sc <= pos.col;
        else if(p.sl == pos.line && p.el === pos.line)
            return p.sc <= pos.col && pos.col <= p.ec + (exclusive ? 1 : 0);
        else if(p.sl < pos.line && p.el === pos.line)
            return pos.col <= p.ec + (exclusive ? 1 : 0);
    }
}
function Node() {
}

Node.prototype.toPrettyString = function(prefix) {
    prefix = prefix || "";
    return prefix + this.toString();
};

Node.prototype.setAnnotation = function(name, value) {
    this.annos = this.annos || {};
    this.annos[name] = value;
};

Node.prototype.getAnnotation = function(name) {
    return this.annos ? this.annos[name] : undefined;
};

Node.prototype.$pos = null;
Node.prototype.getPos = function() {
    if(this.annos && this.annos.pos) {
        return this.annos.pos;
    } else {
        var p = this.$pos;
        return p && {
            sl : p.start.line, sc : p.start.column,
            el : p.end.line, ec : p.end.column
        };
    }
};

Node.prototype.findNode = function(pos) {
    var p = this.getPos();
    if(inRange(p, pos)) {
        return this;
    } else {
        return null;
    }
};
function ConsNode(cons, children) {
    this.cons = cons;
    for(var i = 0; i < children.length; i++) {
        this[i] = children[i];
    }
    this.length = children.length;
}

ConsNode.prototype = new Node();
ConsNode.prototype.toString = function(prefix) {
    try {
        var s = this.cons + "(";
        for ( var i = 0; i < this.length; i++) {
            s += this[i].toString() + ",";
        }
        if (this.length > 0) {
            s = s.substring(0, s.length - 1);
        }
        return s + ")";
    } catch(e) {
        console.error("Something went wrong: ", this, e);
    }
};
ConsNode.prototype.toPrettyString = function(prefix) {
    prefix = prefix || "";
    try {
        if(this.length === 0) {
            return prefix + this.cons + "()";
        }
        if(this.length === 1 && (this[0] instanceof StringNode || this[0] instanceof NumNode)) {
            return prefix + this.cons + "(" + this[0].toString() + ")";
        }
        var s = prefix + this.cons + "(\n";
        for ( var i = 0; i < this.length; i++) {
            s += this[i].toPrettyString(prefix + "    ") + ",\n";
        }
        s = s.substring(0, s.length - 2);
        s += "\n";
        return s + prefix + ")";
    } catch(e) {
        console.error("Something went wrong: ", this, e);
    }
};
ConsNode.prototype.match = function(t, matches) {
    matches = matches || {};
    if (t instanceof ConsNode) {
        if (this.cons === t.cons) {
            if (this.length === t.length) {
                for ( var i = 0; i < this.length; i++) {
                    if (!this[i].match(t[i], matches)) {
                        return false;
                    }
                }
                return matches;
            }
        }
    }
    return false;
};
ConsNode.prototype.build = function(values) {
    var children = [];
    for ( var i = 0; i < this.length; i++) {
        children.push(this[i].build(values));
    }
    return new ConsNode(this.cons, children);
};
ConsNode.prototype.toJSON = function() {
    var l = [];
    for(var i = 0; i < this.length; i++) {
        l.push(this[i]);
    }
    return {cons: this.cons, children: l};
};

ConsNode.prototype.getPos = function() {
    if (this.$pos && this.$pos.start && this.$pos.end) {
        var p = this.$pos;
        return {sl : p.start.line, sc : p.start.column,
                el : p.end.line, ec : p.end.column};
    }

    var nodePos = this.getAnnotation("pos");
    var result = nodePos
        ? {sl : nodePos.sl, sc : nodePos.sc, el : nodePos.el, ec : nodePos.ec}
        : {sl : Number.MAX_VALUE, sc : Number.MAX_VALUE, el : 0, ec : 0};
    
    var hasSl = false;
    var hasSc = false;
    
    for (var i = 0; i < this.length; i++) {
        var p = this[i].getPos();

        if (p) {
            if (p.sl < Number.MAX_VALUE && !hasSl) {
                result.sl = p.sl;
                hasSl = true;
            }
            if (p.sc < Number.MAX_VALUE && !hasSc) {
                result.sc = p.sc;
                hasSc = true;
            }
            result.el = p.el || result.el;
            result.ec = p.ec || result.ec;
        }
    }
    
    return result;
};

ConsNode.prototype.$pos = null;

ConsNode.prototype.findNode = function(pos) {
    var p = this.getPos();

    if(inRange(p, pos)) {
        for(var i = 0; i < this.length; i++) {
            var p2 = this[i].getPos();
            if(inRange(p2, pos)) {
                var node = this[i].findNode(pos);
                if(node)
                    return node instanceof StringNode ? this : node;
                else
                    return this[i];
            }
        }
    } else {
        return null;
    }
};
exports.cons = function(name, children) {
    return new ConsNode(name, children);
};
function ListNode (children) {
    for(var i = 0; i < children.length; i++)
        this[i] = children[i];
    this.length = children.length;
}

ListNode.prototype = new Node();

ListNode.prototype.toString = function() {
    var s = "[";
    for (var i = 0; i < this.length; i++)
        s += this[i].toString() + ",";
    if (this.length > 0)
        s = s.substring(0, s.length - 1);
    return s + "]";
};

ListNode.prototype.toPrettyString = function(prefix) {
    prefix = prefix || "";
    try {
        if(this.length === 0)
            return prefix + "[]";
        var s = prefix + "[\n";
        for ( var i = 0; i < this.length; i++)
            s += this[i].toPrettyString(prefix + "  ") + ",\n";
        s = s.substring(0, s.length - 2);
        s += "\n";
        return s + prefix + "]";
    } catch(e) {
        console.error("Something went wrong: ", this);
    }
};

ListNode.prototype.match = function(t, matches) {
    matches = matches || {};
    if (t instanceof ListNode) {
        if (this.length === t.length) {
            for ( var i = 0; i < this.length; i++)
                if (!this[i].match(t[i], matches))
                    return false;
            return matches;
        }
        else
            return false;
    }
    else
        return false;
};

ListNode.prototype.build = function(values) {
    var children = [];
    for (var i = 0; i < this.length; i++)
        children.push(this[i].build(values));
    return new ListNode(children);
};

ListNode.prototype.getPos = ConsNode.prototype.getPos;
ListNode.prototype.findNode = ConsNode.prototype.findNode;
ListNode.prototype.forEach = function(fn) {
    for(var i = 0; i < this.length; i++) {
        fn.call(this[i], this[i], i);
    }
};
ListNode.prototype.isEmpty = function() {
    return this.length === 0;
};
ListNode.prototype.contains = function(el) {
    for(var i = 0; i < this.length; i++)
        if(el.match(this[i]))
            return true;
    return false;
};
ListNode.prototype.concat = function(l) {
    var ar = [];
    for(var i = 0; i < this.length; i++)
        ar.push(this[i]);
    for(i = 0; i < l.length; i++)
        ar.push(l[i]);
    return exports.list(ar);
};

ListNode.prototype.toJSON = function() {
    var l = [];
    for(var i = 0; i < this.length; i++)
        l.push(this[i]);
    return l;
};
ListNode.prototype.removeDuplicates = function() {
    var newList = [];
    lbl: for(var i = 0; i < this.length; i++) {
        for(var j = 0; j < newList.length; j++)
            if(newList[j].match(this[i]))
                continue lbl;
        newList.push(this[i]);
    }
    return new exports.list(newList);
};

ListNode.prototype.toArray = ListNode.prototype.toJSON;
exports.list = function(elements) {
    return new ListNode(elements);
};

function NumNode (value) {
    this.value = value;
}

NumNode.prototype = new Node();

NumNode.prototype.toString = function() {
    return ""+this.value;
};

NumNode.prototype.match = function(t, matches) {
    matches = matches || {};
    if (t instanceof NumNode)
        return this.value === t.value ? matches : false;
    else
        return false;
};

NumNode.prototype.build = function(values) {
    return this;
};

exports.num = function(value) {
    return new NumNode(value);
};

function StringNode (value) {
    this.value = value;
}

StringNode.prototype = new Node();

StringNode.prototype.toString = function() {
    return '"' + this.value + '"';
};

StringNode.prototype.match = function(t, matches) {
    matches = matches || {};
    if (t instanceof StringNode)
        return this.value === t.value ? matches : false;
    else
        return false;
};

StringNode.prototype.build = function(values) {
    return this;
};

exports.string = function(value) {
    return new StringNode(value);
};

function PlaceholderNode(id) {
    this.id = id;
}

PlaceholderNode.prototype = new Node();

PlaceholderNode.prototype.toString = function() {
    return this.id;
};

PlaceholderNode.prototype.match = function(t, matches) {
    matches = matches || {};
    if(this.id === '_')
        return matches;
    if(matches[this.id]) // already bound
        return matches[this.id].match(t);
    else {
        matches[this.id] = t;
        return matches;
    }
};

PlaceholderNode.prototype.build = function(values) {
    return values[this.id];
};

exports.placeholder = function(n) {
    return new PlaceholderNode(n);
};


function parse (s) {
    var idx = 0;
    function accept (str) {
        for ( var i = 0; i < str.length && idx + i < s.length; i++) {
            if (str[i] != s[idx + i]) {
                return false;
            }
        }
        return i == str.length;
    }
    function lookAheadLetter() {
        return s[idx] >= 'a' && s[idx] <= 'z' || s[idx] >= 'A' && s[idx] <= 'Z' || s[idx] === '_' || s[idx] >= '0' && s[idx] <= '9';
    }
    function skipWhitespace () {
        while (idx < s.length && (s[idx] === " " || s[idx] === "\n" || s[idx] === "\r" || s[idx] === "\t")) {
            idx++;
        }
    }
    function parseInt () {
        var pos = idx;
        if (s[idx] >= '0' && s[idx] <= '9') {
            var ns = s[idx];
            idx++;
            while (idx < s.length && s[idx] >= '0' && s[idx] <= '9') {
                ns += s[idx];
                idx++;
            }
            skipWhitespace();
            return new NumNode(+ns, pos);
        } else {
            return null;
        }
    }
    function parseString () {
        var pos = idx;
        if (accept('"')) {
            var ns = "";
            idx++;
            while (!accept('"') || (accept('"') && s[idx - 1] == '\\')) {
                ns += s[idx];
                idx++;
            }
            var ns2 = '';
            for ( var i = 0; i < ns.length; i++) {
                if (ns[i] == "\\") {
                    i++;
                    switch (ns[i]) {
                        case 'n':
                            ns2 += "\n";
                            break;
                        case 't':
                            ns2 += "\t";
                            break;
                        default:
                            ns2 += ns[i];
                    }
                } else {
                    ns2 += ns[i];
                }
            }
            idx++;
            skipWhitespace();
            return new StringNode(ns2, pos);
        } else {
          return null;
        }
    }
    function parsePlaceholder() {
        var pos = idx;
        if (lookAheadLetter() && s[idx].toLowerCase() === s[idx]) {
            var ns = "";
            while (lookAheadLetter() && idx < s.length) {
                ns += s[idx];
                idx++;
            }
            skipWhitespace();
            return new PlaceholderNode(ns, pos);
        }
        else {
            return null;
        }
    }
    function parseList() {
        var pos = idx;
        if (accept('[')) {
            var items = [];
            idx++;
            skipWhitespace();
            while (!accept(']') && idx < s.length) {
                items.push(parseExp());
                if (accept(',')) {
                    idx++; // skip comma
                    skipWhitespace();
                }
            }
            idx++;
            skipWhitespace();
            return new ListNode(items, pos);
        }
        else {
            return null;
        }
    }
    function parseCons () {
        var pos = idx;
        var ns = "";
        while (!accept('(')) {
            ns += s[idx];
            idx++;
        }
        idx++; // skip (
        var items = [];
        while (!accept(')') && idx < s.length) {
            items.push(parseExp());
            if (accept(',')) {
                idx++; // skip comma
                skipWhitespace();
            }
        }
        idx++;
        skipWhitespace();
        return new ConsNode(ns, items, pos);
    }

    function parseExp() {
        var r = parseInt();
        if (r) return r;
        r = parseString();
        if (r) return r;
        r = parseList();
        if (r) return r;
        r = parsePlaceholder();
        if (r) return r;
        return parseCons();
    }
    return parseExp();
}

var parseCache = {};
function parseCached (s) {
    if(typeof s !== 'string') {
        return null;
    }
    if(s.length > 200) {
        return parse();
    }
    return parseCache[s] || (parseCache[s] = parse(s));
}

exports.Node = Node;
exports.ConsNode = ConsNode;
exports.ListNode = ListNode;
exports.NumNode = NumNode;
exports.StringNode = StringNode;
exports.PlaceholderNode = PlaceholderNode;
exports.parse = parseCached;
exports.inRange = inRange;

});

define("treehugger/js/parse",[], function(require, exports, module) {

var parser = require("acorn/dist/acorn_loose");
var tree = require('treehugger/tree');
exports.parse = function(s) {
    var result = parser.parse_dammit(
        s,
        {
            locations: true,
            ecmaVersion: 6,
            allowReturnOutsideFunction: true
        }
    );
    var node = exports.transform(result);
    if(result.error)
        node.setAnnotation("error", result.error);
    return node;
};


function setIdPos(n, resultNode) {
    if(n.loc) {        
        resultNode.setAnnotation("pos", {
            sl: n.loc.start.line, sc: n.loc.start.column,
            el: n.loc.end.line, ec: n.loc.end.column
        }); 
    }
    return resultNode;
}
function id(n, val) {
    var s = tree.string(val || (n && n.name) || "");
    s.$pos = n && n.loc;
    return s;
}

exports.transform = function transform(n) {
    if (!n) {
        return tree.cons("None", []);
    }
    if (Array.isArray(n)) {
        return tree.list(n.map(transform));
    }
    var nodeName = n.type;
    
    var resultNode;
    
    switch(nodeName) {
        case "Program":
            resultNode = tree.list(n.body.map(transform));
            break;
        case "VariableDeclaration":
            if (n.kind === "var") {
                var VarDecls = "VarDecls", VarDeclInit = "VarDeclInit", VarDecl = "VarDecl";
            } else if (n.kind === "let") {
                var VarDecls = "LetDecls", VarDeclInit = "LetDeclInit", VarDecl = "LetDecl";
            } else if (n.kind === "const") {
                var VarDecls = "ConstDecls", VarDeclInit = "ConstDeclInit", VarDecl = "ConstDecl";
            }
            resultNode = tree.cons(VarDecls, [tree.list(n.declarations.map(function(varNode) {
                var idNode = id(varNode.id);
                if(varNode.init)
                    return tree.cons(VarDeclInit, [idNode, transform(varNode.init)]);
                else
                    return tree.cons(VarDecl, [idNode]);
            }))]);
            break;
        case "ExpressionStatement":
            return transform(n.expression);
        case "CallExpression":
            resultNode = tree.cons("Call", [transform(n.callee), tree.list(n.arguments.map(transform))]);
            break;
        case "ReturnStatement":
            resultNode = tree.cons("Return", [transform(n.argument)]);
            break;
        case "NewExpression":
            resultNode = tree.cons("New", [transform(n.callee), tree.list(n.arguments.map(transform))]);
            break;
        case "ObjectExpression":
            resultNode = tree.cons("ObjectInit", [tree.list(n.properties.map(function(propInit) {
                var key = propInit.key;
                var result = tree.cons("PropertyInit", [id(key, key.name || key.value), transform(propInit.value)]);
                result.kind = propInit.kind;
                return result;
            }))]);
            break;
        case "ArrayExpression":
            resultNode = tree.cons("Array", [tree.list(n.elements.map(transform))]);
            break;
        case "ConditionalExpression":
            resultNode = tree.cons("TernaryIf", [transform(n.test), transform(n.consequent), transform(n.alternate)]);
            break;
        case "LabeledStatement":
            resultNode = tree.cons("Label", [id(n.label), transform(n.body)]);
            break;
        case "AssignmentExpression":
            if(n.operator != "=") {
                resultNode = tree.cons("OpAssign", [tree.string(n.operator[0]), transform(n.left), transform(n.right)]);
            } else {
                resultNode = tree.cons("Assign", [transform(n.left), transform(n.right)]);
            }
            break;
        case "MemberExpression":
            resultNode = n.computed
                ? tree.cons("Index", [transform(n.object), transform(n.property)])
                : tree.cons("PropAccess", [transform(n.object), id(n.property)]);
            break;
        case "Identifier":
            resultNode = tree.cons("Var", [id(n)]);
            break;
        case "ThisExpression":
            resultNode = tree.cons("Var", [tree.string("this")]);
            break;
        case "FunctionDeclaration":
            resultNode = tree.cons("Function", [id(n.id), tree.list(n.params.map(function(arg) {
                return setIdPos(arg, tree.cons("FArg", [id(arg)]));
            })), tree.list(n.body.body.map(transform))]);
            break;
        case "FunctionExpression":
            var funName = id(n.id);
            var fargs = tree.list(n.params.map(function(arg) {
                return setIdPos(arg, tree.cons("FArg", [id(arg)]));
            }));
            resultNode = tree.cons("Function", [funName, fargs, tree.list((n.body.body||[]).map(transform))]);
            break;
        case "LogicalExpression":
        case "BinaryExpression":
            resultNode = tree.cons("Op", [tree.string(n.operator), transform(n.left), transform(n.right)]);
            break;
        case "UpdateExpression":
        case "UnaryExpression":
            resultNode = tree.cons(n.prefix ? "PrefixOp" : "PostfixOp", [tree.string(n.operator), transform(n.argument)]);
            break;
        case "sub":
            resultNode = tree.cons("Index", [transform(n[1]), transform(n[2])]);
            break;
        case "ForStatement":
            resultNode = tree.cons("For", [transform(n.init), transform(n.test), transform(n.update), transform(n.body)]);
            break;
        case "ForInStatement":
            resultNode = tree.cons("ForIn", [transform(n.left), transform(n.right), transform(n.body)]);
            break;
        case "ForOfStatement":
            resultNode = tree.cons("ForOf", [transform(n.left), transform(n.right), transform(n.body)]);
            break;
        case "WhileStatement":
            resultNode = tree.cons("While", [transform(n.test), transform(n.body)]);
            break;
        case "DoWhileStatement": 
            resultNode = tree.cons("Do", [transform(n.body), transform(n.test)]);
            break;
        case "SwitchStatement":
            resultNode = tree.cons("Switch", [transform(n.discriminant), tree.list(n.cases.map(function(opt) {
                return tree.cons("Case", [transform(opt.test), tree.list(opt.consequent.map(transform))]);
            }))]);
            break;
        case "ContinueStatement":
            resultNode = tree.cons("Continue", [id(n.label)]);
            break;
        case "BreakStatement":
            resultNode = tree.cons("Break", [id(n.label)]);
            break;
        case "SequenceExpression":  // todo can we get rid of nesting?
            resultNode = n.expressions.reduceRight(function(a, b) {                
                return a ? tree.cons("Seq", [transform(b), a]) : transform(b);
            }, "");
            break;
        case "IfStatement":
            resultNode = tree.cons("If", [transform(n.test), transform(n.consequent), transform(n.alternate)]);
            break;
        case "EmptyStatement":
        case "BlockStatement":
            resultNode = tree.cons("Block", [tree.list(n.body ? n.body.map(transform) : [])]);
            break;
        case "ThrowStatement":
            resultNode = tree.cons("Throw", [transform(n.argument)]);
            break;
        case "DebuggerStatement":
            resultNode = tree.cons("Debugger", [transform(n.argument)]);
            break;
        case "TryStatement":
            resultNode = tree.cons("Try", [tree.list(n.block.body.map(transform)),
                tree.list(n.handler ? [tree.cons("Catch", [
                    id(n.handler.param), tree.list(n.handler.body.body.map(transform))
                ])] : []),
                n.finalizer ? tree.list(n.finalizer.body.map(transform)) : tree.cons("None", [])
            ]);
            break;
        case "WithStatement":
            resultNode = tree.cons("With", [transform(n.object), tree.list((n.body.body||[]).map(transform))]);
            break;
        case "Literal":
            var litType = typeof n.value;
            if (litType == "number") {
                resultNode = tree.cons("Num", [id(n, n.raw)]);
            } else if (litType == "string") {
                resultNode = tree.cons("String", [id(n, n.value)]);
            } else {
                var val = n.raw;
                if (val[0] == "/") {
                    var i = val.lastIndexOf("/");
                    resultNode = tree.cons("RegExp", [tree.string(val.slice(1, i)), tree.string(val.substr(i + 1))]);
                } else {
                    resultNode = tree.cons("Var", [tree.string(n.value + "")]);
                }
            }
            break;
        case "ERROR":
            resultNode = tree.cons("ERROR", []);
            break;
        case "ArrowFunctionExpression":
            resultNode = tree.cons("Arrow", [tree.list(n.params.map(function(arg) {
                return setIdPos(arg, tree.cons("FArg", [id(arg)]));
            })), tree.list(n.body.body ? n.body.body.map(transform) : transform(n.body))]);
            break;
        case "YieldExpression":
            resultNode = tree.cons("Yield", [transform(n.argument)]);
            break; 
        case "ImportDeclaration":
            resultNode = tree.cons("ImportDecls", [
                tree.list(n.specifiers.map(transform)),
                transform(n.source)
            ]);
            break;
        case "ImportSpecifier":
            resultNode = tree.cons("ImportDecl", [transform(n.id), transform(n.name)]);
            break;
        case "ExportSpecifier":
            resultNode = tree.cons("ExporDecl", [transform(n.id), transform(n.name)]);
            break;
        case "ImportBatchSpecifier":
            resultNode = tree.cons("ImportBatchDecl", [transform(n.name)]);
            break;
        case "ExportDeclaration":
            resultNode = tree.cons("ExportDecl", [
                n.default ? tree.list([tree.cons("Default", [])]) : tree.list([]),
                n.declaration ? transform(n.declaration) : transform(n.specifiers),
                transform(n.source)
            ]);
            break;
        case "SpreadElement":
            resultNode = tree.cons("Spread", [transform(n.argument)]);
            break;
        case "ArrayPattern":
            resultNode = tree.cons("ArrayPattern", transform(n.elements));
            break;
        case "ClassDeclaration":
            resultNode = tree.cons("Class", [id(n.id), id(n.superClass), transform(n.body)]);
            break;
        case "ClassBody":
            resultNode = tree.list(transform(n.body));
            break;
        case "MethodDefinition":
            resultNode = tree.cons("Method", [id(n.key), transform(n.value)]);
            break;
        case "ComprehensionBlock":
        case "ComprehensionExpression":
        default:
            resultNode = tree.cons(tree.string(nodeName), [tree.string(JSON.stringify(n, function(key, val) {
                if (key !== "loc") 
                    return val;
            }, 4))]);
    }

    resultNode.setAnnotation("origin", n);
    resultNode.$pos = n.loc;
    return resultNode;
};
});

define("treehugger/traverse",[], function(require, exports, module) {

var tree = require('treehugger/tree');

if (!Function.prototype.curry) {
    Function.prototype.curry = function() {
        var fn = this,
            args = Array.prototype.slice.call(arguments);
        return function() {
            return fn.apply(this, args.concat(Array.prototype.slice.call(arguments)));
        };
    };
}

function normalizeArgs(args) {
    if (args.length === 1 && args[0].apply) { // basic, one function, shortcut!
        return args[0];
    }
    args = Array.prototype.slice.call(args, 0);
    if (args[0] && Object.prototype.toString.call(args[0]) === '[object Array]') {
        args = args[0];
    }
    return function normalizeArgsHelper() {
        var result;
        for (var i = 0; i < args.length; i++) {
            if (typeof args[i] === 'string') {
                var parsedPattern = tree.parse(args[i]);
                var bindings = parsedPattern.match(this);
                if (bindings) {
                    while (args[i + 1]) {
                        if (args[i + 1].apply)
                            break;
                        i++;
                    }
                    if (args[i + 1] && args[i + 1].apply) {
                        result = args[i + 1].call(this, bindings, this);
                        i++;
                    }
                    else
                        result = this;
                    if (result)
                        return result;
                }
                else if (args[i + 1] && args[i + 1].apply)
                    i++;
            }
            else if (args[i].apply) {
                result = args[i].call(this, this);
                if (result)
                    return result;
            }
            else
                throw Error("Invalid argument: ", args[i]);
        }
        return false;
    };
}

exports.traverseAll = function(fn) {
    var result, i;
    fn = normalizeArgs(arguments);
    if (this instanceof tree.ConsNode || this instanceof tree.ListNode) {
        for (i = 0; i < this.length; i++) {
            result = fn.call(this[i]);
            if (!result)
                return false;
        }
    }
    return this;
};
function seq() {
    var fn;
    var t = this;
    for (var i = 0; i < arguments.length; i++) {
        fn = arguments[i];
        t = fn.call(t);
        if (!t)
            return false;
    }
    return this;
}
exports.attempt = function(fn) {
    fn = normalizeArgs(arguments);
    var result = fn.call(this);
    return !result ? this : result;
};

exports.debug = function(pretty) {
    console.log(pretty ? this.toPrettyString("") : this.toString());
    return this;
};
function traverseTopDown(fn) {
    var result, i;
    result = fn.call(this);
    if(result)
        return result;
    if (this instanceof tree.ConsNode || this instanceof tree.ListNode) {
        for (i = 0; i < this.length; i++) {
            traverseTopDown.call(this[i], fn);
        }
    }
    return this;
}

exports.traverseTopDown = function(fn) {
    fn = normalizeArgs(arguments);
    return traverseTopDown.call(this, fn);
};
exports.traverseUp = function(fn) {
    fn = normalizeArgs(arguments);
    var result = fn.call(this);
    if(result)
        return result;
    if (!this.parent)
        return false;
    return this.parent.traverseUp(fn);
};

exports.collectTopDown = function(fn) {
    fn = normalizeArgs(arguments);
    var results = [];
    this.traverseTopDown(function() {
        var r = fn.call(this);
        if (r) {
            results.push(r);
        }
        return r;
    });
    return tree.list(results);
};

exports.map = function(fn) {
    fn = normalizeArgs(arguments);
    var result, results = [];
    for (var i = 0; i < this.length; i++) {
        result = fn.call(this[i], this[i]);
        if (result) {
            results.push(result);
        }
        else {
            throw Error("Mapping failed: ", this[i]);
        }
    }
    return tree.list(results);
};

exports.each = function(fn) {
    fn = normalizeArgs(arguments);
    for (var i = 0; i < this.length; i++) {
        fn.call(this[i], this[i]);
    }
};
exports.filter = function(fn) {
    fn = normalizeArgs(arguments);
    var matching = [];
    this.forEach(function(el) {
        var result = fn.call(el);
        if (result) {
            matching.push(result);
        }
    });
    return tree.list(matching);
};

exports.rewrite = function(fn) {
    fn = normalizeArgs(arguments);
    return fn.call(this);
};

exports.isMatch = function(pattern) {
    return !!this.rewrite(pattern);
};
for (var p in exports) {
    if (exports.hasOwnProperty(p)) {
        tree.Node.prototype[p] = exports[p];
    }
}

exports.addParentPointers = function(node) {
    return node.traverseTopDown(function() {
        var that = this;
        this.traverseAll(function() {
            this.parent = that;
            return this;
        });
    });
};

});

define("plugins/c9.ide.language/base_handler",[], function(require, exports, module) {

module.exports = {
    HANDLES_ANY: 0,
    HANDLES_EDITOR: 1,
    HANDLES_IMMEDIATE: 2,
    HANDLES_EDITOR_AND_IMMEDIATE: 3,
    language: null,
    path: null,
    workspaceDir: null,
    doc: null,
    $disableZeroLengthCompletion: false,
    $recacheCompletionLength: null,
    isFeatureEnabled: function(name) {
        return !disabledFeatures[name];
    },
    $getIdentifierRegex: function() {
        return null;
    },
    getEmitter: function(overridePath) {
        throw new Error("getEmitter() is not available yet, please call after init()");
    },
    handlesLanguage: function(language) {
        throw new Error("base_handler.handlesLanguage() is not overridden");
    },
    handlesEditor: function() {
        return this.HANDLES_EDITOR;
    },
    getMaxFileSizeSupported: function() {
        return 10 * 1000 * 80;
    },
    getIdentifierRegex: function() {
        return null;
    },
    getCompletionRegex: function() {
        return null;
    },
    getTooltipRegex: function() {
        return null;
    },
    getCacheCompletionRegex: function() {
        return null;
    },
    parse: function(docValue, options, callback) {
        callback();
    },
    findNode: function(ast, pos, callback) {
        callback();
    },
    getPos: function(node, callback) {
        callback();
    },
    init: function(callback) {
        callback();
    },
    onUpdate: function(doc, callback) {
        callback();
    },
    onDocumentOpen: function(path, doc, oldPath, callback) {
        callback();
    },
    onDocumentClose: function(path, callback) {
        callback();
    },
    onCursorMove: function(doc, ast, cursorPos, options, callback) {
        callback();
    },
    tooltip: function(doc, ast, cursorPos, options, callback) {
        callback();
    },
    highlightOccurrences: function(doc, ast, cursorPos, options, callback) {
        callback();
    },
    getRefactorings: function(doc, ast, cursorPos, options, callback) {
        callback();
    },
    outline: function(doc, ast, callback) {
        callback();
    },
    hierarchy: function(doc, cursorPos, callback) {
        callback();
    },
    complete: function(doc, ast, pos, options, callback) {
        callback();
    },
    predictNextCompletion: function(doc, ast, pos, options, callback) {
        callback();
    },
    analyze: function(doc, ast, options, callback) {
        callback();
    },
    getRenamePositions: function(doc, ast, pos, options, callback) {
        callback();
    },
    onRenameBegin: function(doc, callback) {
        callback();
    },
    commitRename: function(doc, oldName, newName, isGeneric, callback) {
        callback();
    },
    onRenameCancel: function(callback) {
        callback();
    },
    codeFormat: function(doc, callback) {
        callback();
    },
    jumpToDefinition: function(doc, ast, pos, options, callback) {
        callback();
    },
    getQuickfixes: function(doc, ast, pos, options, callback) {
        callback();
    },
    getInspectExpression: function(doc, ast, pos, options, callback) {
        callback();
    }
};
for (var f in module.exports) {
    if (typeof module.exports[f] === "function")
        module.exports[f].base_handler = true;
}

});

define("plugins/c9.ide.test.mocha/mocha_outline_worker",[], function(require, exports, module) {

var parser = require("treehugger/js/parse");
var traverse = require("treehugger/traverse");
var baseLanguageHandler = require("plugins/c9.ide.language/base_handler");

var handler = module.exports = Object.create(baseLanguageHandler);

handler.init = function() {
    handler.sender.on("mocha_outline", function(e) {
        var code = e.data.code.replace(/^(#!.*\n)/, "//$1");
        var ast = parser.parse(code);
        
        handler.sender.emit("mocha_outline_result", {
            id: e.data.id, // Some unique id for this request
            result: getTestCases(ast)
        });
    });
};

handler.handlesLanguage = function() {
    return false;
};
function parseBDD(ast, items) {
    ast.traverseTopDown( 
        'Call(Var("before"), _)', function(b, node) {
            items.push({
                label: "before all",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("beforeEach"), _)', function(b, node) {
            items.push({
                label: "before each",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("after"), _)', function(b, node) {
            items.push({
                label: "after all",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("afterEach"), _)', function(b, node) {
            items.push({
                label: "before each",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("it"), [String(description), _])', function(b, node) {
            items.push({
                label: b.description.value,
                kind: "it",
                type: "test",
                selpos: b.description.getPos(),
                pos: node.getPos()
            });
            return true;
        },
        'Call(PropAccess(Var("it"), "only"), [String(description), _])', function(b, node) {
            items.push({
                label: b.description.value,
                kind: "it",
                type: "test",
                selpos: b.description.getPos(),
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("describe"), [String(description), body])', function(b, node) {
            items.push({
                label: b.description.value,
                items: parseBDD(b.body, []),
                type: "testset",
                isOpen: true,
                selpos: b.description.getPos(),
                pos: node.getPos()
            });
            return node;
        },
        'Call(PropAccess(Var("describe"), "only"), [String(description), body])', function(b, node) {
            items.push({
                label: b.description.value,
                items: parseBDD(b.body, []),
                type: "testset",
                isOpen: true,
                selpos: b.description.getPos(),
                pos: node.getPos()
            });
            return node;
        },
        'Call(Var("context"), [String(description), body])', function(b, node) {
            items.push({
                label: b.description.value,
                items: parseBDD(b.body, []),
                type: "testset",
                isOpen: true,
                selpos: b.description.getPos(),
                pos: node.getPos()
            });
            return node;
        },
        'Call(PropAccess(Var("context"), "only"), [String(description), body])', function(b, node) {
            items.push({
                label: b.description.value,
                items: parseBDD(b.body, []),
                type: "testset",
                isOpen: true,
                selpos: b.description.getPos(),
                pos: node.getPos()
            });
            return node;
        }
    );
    
    return items;
}

function parseTDD(ast, items) {
    ast.traverseTopDown( 
        'Call(Var("setup"), _)', function(b, node) {
            items.push({
                label: "setup",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("teardown"), _)', function(b, node) {
            items.push({
                label: "teardown",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("suiteSetup"), _)', function(b, node) {
            items.push({
                label: "suite setup",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("suiteTeardown"), _)', function(b, node) {
            items.push({
                label: "suite teardown",
                type: "prepare",
                pos: node.getPos()
            });
        },
        'Call(Var("test"), [String(description), _])', function(b, node) {
            items.push({
                label: b.description.value,
                type: "test",
                selpos: b.description.getPos(),
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("suite"), [String(description), body])', function(b, node) {
            items.push({
                label: b.description.value,
                items: parseTDD(b.body, []),
                type: "testset",
                isOpen: true,
                selpos: b.description.getPos(),
                pos: node.getPos()
            });
            return node;
        }
    );
    
    return items;
}

function parseExports(ast, items) {
    ast.traverseTopDown(
        'Assign(PropAccess(Var("module"), "exports"), body)', function(b) {
            parseExports(b.body, items); 
            return true;
        },
        'PropertyInit("before", _)', function(b, node) {
            items.push({
                label: "before all",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'PropertyInit("after", _)', function(b, node) {
            items.push({
                label: "after all",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'PropertyInit("beforeEach", _)', function(b, node) {
            items.push({
                label: "before each",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'PropertyInit("afterEach", _)', function(b, node) {
            items.push({
                label: "after each",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'PropertyInit(name, ObjectInit(body))', function(b, node) {
           items.push({
                label: b.name.value,
                items: parseExports(b.body, []),
                type: "testset",
                isOpen: true,
                selpos: b.name.getPos(),
                pos: node.getPos()
            });
           return true;
        },
        'PropertyInit(name, Function(_))', function(b, node) {
           items.push({
                label: b.name.value,
                type: "test",
                selpos: b.name.getPos(),
                pos: node.getPos()
            });
            return true;
        }
    );
    
    return items;
}

function parseQUnit(ast, items) {
    var context = items;
    
    ast.traverseTopDown( 
        'Call(Var("before"), _)', function(b, node) {
            context.push({
                label: "before all",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("after"), _)', function(b, node) {
            context.push({
                label: "after all",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("beforeEach"), _)', function(b, node) {
            context.push({
                label: "before each",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("afterEach"), _)', function(b, node) {
            context.push({
                label: "after each",
                type: "prepare",
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("test"), [String(description), _])', function(b, node) {
            context.push({
                label: b.description.value,
                type: "test",
                selpos: b.description.getPos(),
                pos: node.getPos()
            });
            return true;
        },
        'Call(Var("suite"), [String(description)])', function(b, node) {
            context.push({
                label: b.description.value,
                items: context = [],
                type: "testset",
                isOpen: true,
                selpos: b.description.getPos(),
                pos: node.getPos()
            });
            return node;
        }
    );
}

function getTestCases(ast) {
    var items = [];
    ast.traverseTopDown(
        'Call(Var("describe"), [_, body])', function(b, node) {
            parseBDD(ast, items);
            return true;
        },
        'Call(Var("suite"), [_, body])', function(b, node) {
            parseTDD(ast, items);
            return true;
        },
        'Assign(PropAccess(Var("module"), "exports"), body)', function(b) {
            parseExports(b.body, items);
            return true;
        },
        'Call(Var("suite"), [_])', function(b, node) {
            parseQUnit(ast, items);
            return true;
        }
    );
    
    return items;
}

});

define("ace/lib/es6-shim",[], function(require, exports, module) {
    function defineProp(obj, name, val) {
        Object.defineProperty(obj, name, {
            value: val,
            enumerable: false,
            writable: true,
            configurable: true,
        });
    }
    if (!String.prototype.startsWith) {
        defineProp(String.prototype, "startsWith", function(searchString, position) {
            position = position || 0;
            return this.lastIndexOf(searchString, position) === position;
        });
    }
    if (!String.prototype.endsWith) {
        defineProp(String.prototype, "endsWith", function(searchString, position) {
            var subjectString = this;
            if (position === undefined || position > subjectString.length) {
                position = subjectString.length;
            }
            position -= searchString.length;
            var lastIndex = subjectString.indexOf(searchString, position);
            return lastIndex !== -1 && lastIndex === position;
        });
    }
    if (!String.prototype.repeat) {
        defineProp(String.prototype, "repeat", function(count) {
            var result = "";
            var string = this;
            while (count > 0) {
                if (count & 1)
                    result += string;
        
                if (count >>= 1)
                    string += string;
            }
            return result;
        });
    }
    if (!String.prototype.includes) {
        defineProp(String.prototype, "includes", function(str, position) {
            return this.indexOf(str, position) != -1;
        });
    }
    if (!Object.assign) {
        Object.assign = function(target) {
            if (target === undefined || target === null) {
                throw new TypeError("Cannot convert undefined or null to object");
            }

            var output = Object(target);
            for (var index = 1; index < arguments.length; index++) {
                var source = arguments[index];
                if (source !== undefined && source !== null) {
                    Object.keys(source).forEach(function(key) {
                        output[key] = source[key];
                    });
                }
            }
            return output;
        };
    }
    if (!Array.prototype.find) {
        defineProp(Array.prototype, "find", function(predicate) {
            var len = this.length;
            var thisArg = arguments[1];
            for (var k = 0; k < len; k++) {
                var kValue = this[k];
                if (predicate.call(thisArg, kValue, k, this)) {
                    return kValue;
                }
            }
        });
    }
    if (!Array.prototype.findIndex) {
        defineProp(Array.prototype, "findIndex", function(predicate) {
            var len = this.length;
            var thisArg = arguments[1];
            for (var k = 0; k < len; k++) {
                var kValue = this[k];
                if (predicate.call(thisArg, kValue, k, this)) {
                    return k;
                }
            }
        });
    }
    if (!Array.prototype.includes) {
        defineProp(Array.prototype, "includes", function(item, position) {
            return this.indexOf(item, position) != -1;
        });
    }
    if (!Array.prototype.fill) {
        defineProp(Array.prototype, "fill", function(value) {
            var O = this;
            var len = O.length >>> 0;
            var start = arguments[1];
            var relativeStart = start >> 0;
            var k = relativeStart < 0 ?
                Math.max(len + relativeStart, 0) :
                Math.min(relativeStart, len);
            var end = arguments[2];
            var relativeEnd = end === undefined ?
                len : end >> 0;
            var final = relativeEnd < 0 ?
                Math.max(len + relativeEnd, 0) :
                Math.min(relativeEnd, len);
            while (k < final) {
                O[k] = value;
                k++;
            }
            return O;
        });
    }
    if (!Array.of) {
        defineProp(Array, "of", function() {
            return Array.prototype.slice.call(arguments);
        });
    }
});

define("ace/lib/oop",[], function(require, exports, module) {
"use strict";

exports.inherits = function(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
};

exports.mixin = function(obj, mixin) {
    for (var key in mixin) {
        obj[key] = mixin[key];
    }
    return obj;
};

exports.implement = function(proto, mixin) {
    exports.mixin(proto, mixin);
};

});

define("ace/range",[], function(require, exports, module) {
"use strict";
var comparePoints = function(p1, p2) {
    return p1.row - p2.row || p1.column - p2.column;
};
var Range = function(startRow, startColumn, endRow, endColumn) {
    this.start = {
        row: startRow,
        column: startColumn
    };

    this.end = {
        row: endRow,
        column: endColumn
    };
};

(function() {
    this.isEqual = function(range) {
        return this.start.row === range.start.row &&
            this.end.row === range.end.row &&
            this.start.column === range.start.column &&
            this.end.column === range.end.column;
    };
    this.toString = function() {
        return ("Range: [" + this.start.row + "/" + this.start.column +
            "] -> [" + this.end.row + "/" + this.end.column + "]");
    };

    this.contains = function(row, column) {
        return this.compare(row, column) == 0;
    };
    this.compareRange = function(range) {
        var cmp,
            end = range.end,
            start = range.start;

        cmp = this.compare(end.row, end.column);
        if (cmp == 1) {
            cmp = this.compare(start.row, start.column);
            if (cmp == 1) {
                return 2;
            } else if (cmp == 0) {
                return 1;
            } else {
                return 0;
            }
        } else if (cmp == -1) {
            return -2;
        } else {
            cmp = this.compare(start.row, start.column);
            if (cmp == -1) {
                return -1;
            } else if (cmp == 1) {
                return 42;
            } else {
                return 0;
            }
        }
    };
    this.comparePoint = function(p) {
        return this.compare(p.row, p.column);
    };
    this.containsRange = function(range) {
        return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
    };
    this.intersects = function(range) {
        var cmp = this.compareRange(range);
        return (cmp == -1 || cmp == 0 || cmp == 1);
    };
    this.isEnd = function(row, column) {
        return this.end.row == row && this.end.column == column;
    };
    this.isStart = function(row, column) {
        return this.start.row == row && this.start.column == column;
    };
    this.setStart = function(row, column) {
        if (typeof row == "object") {
            this.start.column = row.column;
            this.start.row = row.row;
        } else {
            this.start.row = row;
            this.start.column = column;
        }
    };
    this.setEnd = function(row, column) {
        if (typeof row == "object") {
            this.end.column = row.column;
            this.end.row = row.row;
        } else {
            this.end.row = row;
            this.end.column = column;
        }
    };
    this.inside = function(row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column) || this.isStart(row, column)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    };
    this.insideStart = function(row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    };
    this.insideEnd = function(row, column) {
        if (this.compare(row, column) == 0) {
            if (this.isStart(row, column)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    };
    this.compare = function(row, column) {
        if (!this.isMultiLine()) {
            if (row === this.start.row) {
                return column < this.start.column ? -1 : (column > this.end.column ? 1 : 0);
            }
        }

        if (row < this.start.row)
            return -1;

        if (row > this.end.row)
            return 1;

        if (this.start.row === row)
            return column >= this.start.column ? 0 : -1;

        if (this.end.row === row)
            return column <= this.end.column ? 0 : 1;

        return 0;
    };
    this.compareStart = function(row, column) {
        if (this.start.row == row && this.start.column == column) {
            return -1;
        } else {
            return this.compare(row, column);
        }
    };
    this.compareEnd = function(row, column) {
        if (this.end.row == row && this.end.column == column) {
            return 1;
        } else {
            return this.compare(row, column);
        }
    };
    this.compareInside = function(row, column) {
        if (this.end.row == row && this.end.column == column) {
            return 1;
        } else if (this.start.row == row && this.start.column == column) {
            return -1;
        } else {
            return this.compare(row, column);
        }
    };
    this.clipRows = function(firstRow, lastRow) {
        if (this.end.row > lastRow)
            var end = {row: lastRow + 1, column: 0};
        else if (this.end.row < firstRow)
            var end = {row: firstRow, column: 0};

        if (this.start.row > lastRow)
            var start = {row: lastRow + 1, column: 0};
        else if (this.start.row < firstRow)
            var start = {row: firstRow, column: 0};

        return Range.fromPoints(start || this.start, end || this.end);
    };
    this.extend = function(row, column) {
        var cmp = this.compare(row, column);

        if (cmp == 0)
            return this;
        else if (cmp == -1)
            var start = {row: row, column: column};
        else
            var end = {row: row, column: column};

        return Range.fromPoints(start || this.start, end || this.end);
    };

    this.isEmpty = function() {
        return (this.start.row === this.end.row && this.start.column === this.end.column);
    };
    this.isMultiLine = function() {
        return (this.start.row !== this.end.row);
    };
    this.clone = function() {
        return Range.fromPoints(this.start, this.end);
    };
    this.collapseRows = function() {
        if (this.end.column == 0)
            return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row-1), 0);
        else
            return new Range(this.start.row, 0, this.end.row, 0);
    };
    this.toScreenRange = function(session) {
        var screenPosStart = session.documentToScreenPosition(this.start);
        var screenPosEnd = session.documentToScreenPosition(this.end);

        return new Range(
            screenPosStart.row, screenPosStart.column,
            screenPosEnd.row, screenPosEnd.column
        );
    };
    this.moveBy = function(row, column) {
        this.start.row += row;
        this.start.column += column;
        this.end.row += row;
        this.end.column += column;
    };

}).call(Range.prototype);
Range.fromPoints = function(start, end) {
    return new Range(start.row, start.column, end.row, end.column);
};
Range.comparePoints = comparePoints;

Range.comparePoints = function(p1, p2) {
    return p1.row - p2.row || p1.column - p2.column;
};


exports.Range = Range;
});

define("ace/apply_delta",[], function(require, exports, module) {
"use strict";

function throwDeltaError(delta, errorText){
    console.log("Invalid Delta:", delta);
    throw "Invalid Delta: " + errorText;
}

function positionInDocument(docLines, position) {
    return position.row    >= 0 && position.row    <  docLines.length &&
           position.column >= 0 && position.column <= docLines[position.row].length;
}

function validateDelta(docLines, delta) {
    if (delta.action != "insert" && delta.action != "remove")
        throwDeltaError(delta, "delta.action must be 'insert' or 'remove'");
    if (!(delta.lines instanceof Array))
        throwDeltaError(delta, "delta.lines must be an Array");
    if (!delta.start || !delta.end)
       throwDeltaError(delta, "delta.start/end must be an present");
    var start = delta.start;
    if (!positionInDocument(docLines, delta.start))
        throwDeltaError(delta, "delta.start must be contained in document");
    var end = delta.end;
    if (delta.action == "remove" && !positionInDocument(docLines, end))
        throwDeltaError(delta, "delta.end must contained in document for 'remove' actions");
    var numRangeRows = end.row - start.row;
    var numRangeLastLineChars = (end.column - (numRangeRows == 0 ? start.column : 0));
    if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars)
        throwDeltaError(delta, "delta.range must match delta lines");
}

exports.applyDelta = function(docLines, delta, doNotValidate) {
    var row = delta.start.row;
    var startColumn = delta.start.column;
    var line = docLines[row] || "";
    switch (delta.action) {
        case "insert":
            var lines = delta.lines;
            if (lines.length === 1) {
                docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
            } else {
                var args = [row, 1].concat(delta.lines);
                docLines.splice.apply(docLines, args);
                docLines[row] = line.substring(0, startColumn) + docLines[row];
                docLines[row + delta.lines.length - 1] += line.substring(startColumn);
            }
            break;
        case "remove":
            var endColumn = delta.end.column;
            var endRow = delta.end.row;
            if (row === endRow) {
                docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
            } else {
                docLines.splice(
                    row, endRow - row + 1,
                    line.substring(0, startColumn) + docLines[endRow].substring(endColumn)
                );
            }
            break;
    }
};
});

define("ace/lib/event_emitter",[], function(require, exports, module) {
"use strict";

var EventEmitter = {};
var stopPropagation = function() { this.propagationStopped = true; };
var preventDefault = function() { this.defaultPrevented = true; };

EventEmitter._emit =
EventEmitter._dispatchEvent = function(eventName, e) {
    this._eventRegistry || (this._eventRegistry = {});
    this._defaultHandlers || (this._defaultHandlers = {});

    var listeners = this._eventRegistry[eventName] || [];
    var defaultHandler = this._defaultHandlers[eventName];
    if (!listeners.length && !defaultHandler)
        return;

    if (typeof e != "object" || !e)
        e = {};

    if (!e.type)
        e.type = eventName;
    if (!e.stopPropagation)
        e.stopPropagation = stopPropagation;
    if (!e.preventDefault)
        e.preventDefault = preventDefault;

    listeners = listeners.slice();
    for (var i=0; i<listeners.length; i++) {
        listeners[i](e, this);
        if (e.propagationStopped)
            break;
    }
    
    if (defaultHandler && !e.defaultPrevented)
        return defaultHandler(e, this);
};


EventEmitter._signal = function(eventName, e) {
    var listeners = (this._eventRegistry || {})[eventName];
    if (!listeners)
        return;
    listeners = listeners.slice();
    for (var i=0; i<listeners.length; i++)
        listeners[i](e, this);
};

EventEmitter.once = function(eventName, callback) {
    var _self = this;
    callback && this.addEventListener(eventName, function newCallback() {
        _self.removeEventListener(eventName, newCallback);
        callback.apply(null, arguments);
    });
};


EventEmitter.setDefaultHandler = function(eventName, callback) {
    var handlers = this._defaultHandlers;
    if (!handlers)
        handlers = this._defaultHandlers = {_disabled_: {}};
    
    if (handlers[eventName]) {
        var old = handlers[eventName];
        var disabled = handlers._disabled_[eventName];
        if (!disabled)
            handlers._disabled_[eventName] = disabled = [];
        disabled.push(old);
        var i = disabled.indexOf(callback);
        if (i != -1) 
            disabled.splice(i, 1);
    }
    handlers[eventName] = callback;
};
EventEmitter.removeDefaultHandler = function(eventName, callback) {
    var handlers = this._defaultHandlers;
    if (!handlers)
        return;
    var disabled = handlers._disabled_[eventName];
    
    if (handlers[eventName] == callback) {
        if (disabled)
            this.setDefaultHandler(eventName, disabled.pop());
    } else if (disabled) {
        var i = disabled.indexOf(callback);
        if (i != -1)
            disabled.splice(i, 1);
    }
};

EventEmitter.on =
EventEmitter.addEventListener = function(eventName, callback, capturing) {
    this._eventRegistry = this._eventRegistry || {};

    var listeners = this._eventRegistry[eventName];
    if (!listeners)
        listeners = this._eventRegistry[eventName] = [];

    if (listeners.indexOf(callback) == -1)
        listeners[capturing ? "unshift" : "push"](callback);
    return callback;
};

EventEmitter.off =
EventEmitter.removeListener =
EventEmitter.removeEventListener = function(eventName, callback) {
    this._eventRegistry = this._eventRegistry || {};

    var listeners = this._eventRegistry[eventName];
    if (!listeners)
        return;

    var index = listeners.indexOf(callback);
    if (index !== -1)
        listeners.splice(index, 1);
};

EventEmitter.removeAllListeners = function(eventName) {
    if (this._eventRegistry) this._eventRegistry[eventName] = [];
};

exports.EventEmitter = EventEmitter;

});

define("ace/anchor",[], function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var EventEmitter = require("./lib/event_emitter").EventEmitter;

var Anchor = exports.Anchor = function(doc, row, column) {
    this.$onChange = this.onChange.bind(this);
    this.attach(doc);
    
    if (typeof column == "undefined")
        this.setPosition(row.row, row.column);
    else
        this.setPosition(row, column);
};

(function() {

    oop.implement(this, EventEmitter);
    this.getPosition = function() {
        return this.$clipPositionToDocument(this.row, this.column);
    };
    this.getDocument = function() {
        return this.document;
    };
    this.$insertRight = false;
    this.onChange = function(delta) {
        if (delta.start.row == delta.end.row && delta.start.row != this.row)
            return;

        if (delta.start.row > this.row)
            return;
            
        var point = $getTransformedPoint(delta, {row: this.row, column: this.column}, this.$insertRight);
        this.setPosition(point.row, point.column, true);
    };
    
    function $pointsInOrder(point1, point2, equalPointsInOrder) {
        var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;
        return (point1.row < point2.row) || (point1.row == point2.row && bColIsAfter);
    }
            
    function $getTransformedPoint(delta, point, moveIfEqual) {
        var deltaIsInsert = delta.action == "insert";
        var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row    - delta.start.row);
        var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
        var deltaStart = delta.start;
        var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.
        if ($pointsInOrder(point, deltaStart, moveIfEqual)) {
            return {
                row: point.row,
                column: point.column
            };
        }
        if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {
            return {
                row: point.row + deltaRowShift,
                column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)
            };
        }
        return {
            row: deltaStart.row,
            column: deltaStart.column
        };
    }
    this.setPosition = function(row, column, noClip) {
        var pos;
        if (noClip) {
            pos = {
                row: row,
                column: column
            };
        } else {
            pos = this.$clipPositionToDocument(row, column);
        }

        if (this.row == pos.row && this.column == pos.column)
            return;

        var old = {
            row: this.row,
            column: this.column
        };

        this.row = pos.row;
        this.column = pos.column;
        this._signal("change", {
            old: old,
            value: pos
        });
    };
    this.detach = function() {
        this.document.removeEventListener("change", this.$onChange);
    };
    this.attach = function(doc) {
        this.document = doc || this.document;
        this.document.on("change", this.$onChange);
    };
    this.$clipPositionToDocument = function(row, column) {
        var pos = {};

        if (row >= this.document.getLength()) {
            pos.row = Math.max(0, this.document.getLength() - 1);
            pos.column = this.document.getLine(pos.row).length;
        }
        else if (row < 0) {
            pos.row = 0;
            pos.column = 0;
        }
        else {
            pos.row = row;
            pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
        }

        if (column < 0)
            pos.column = 0;

        return pos;
    };

}).call(Anchor.prototype);

});

define("ace/document",[], function(require, exports, module) {
"use strict";

var oop = require("./lib/oop");
var applyDelta = require("./apply_delta").applyDelta;
var EventEmitter = require("./lib/event_emitter").EventEmitter;
var Range = require("./range").Range;
var Anchor = require("./anchor").Anchor;

var Document = function(textOrLines) {
    this.$lines = [""];
    if (textOrLines.length === 0) {
        this.$lines = [""];
    } else if (Array.isArray(textOrLines)) {
        this.insertMergedLines({row: 0, column: 0}, textOrLines);
    } else {
        this.insert({row: 0, column:0}, textOrLines);
    }
};

(function() {

    oop.implement(this, EventEmitter);
    this.setValue = function(text) {
        var len = this.getLength() - 1;
        this.remove(new Range(0, 0, len, this.getLine(len).length));
        this.insert({row: 0, column: 0}, text);
    };
    this.getValue = function() {
        return this.getAllLines().join(this.getNewLineCharacter());
    };
    this.createAnchor = function(row, column) {
        return new Anchor(this, row, column);
    };
    if ("aaa".split(/a/).length === 0) {
        this.$split = function(text) {
            return text.replace(/\r\n|\r/g, "\n").split("\n");
        };
    } else {
        this.$split = function(text) {
            return text.split(/\r\n|\r|\n/);
        };
    }


    this.$detectNewLine = function(text) {
        var match = text.match(/^.*?(\r\n|\r|\n)/m);
        this.$autoNewLine = match ? match[1] : "\n";
        this._signal("changeNewLineMode");
    };
    this.getNewLineCharacter = function() {
        switch (this.$newLineMode) {
          case "windows":
            return "\r\n";
          case "unix":
            return "\n";
          default:
            return this.$autoNewLine || "\n";
        }
    };

    this.$autoNewLine = "";
    this.$newLineMode = "auto";
    this.setNewLineMode = function(newLineMode) {
        if (this.$newLineMode === newLineMode)
            return;

        this.$newLineMode = newLineMode;
        this._signal("changeNewLineMode");
    };
    this.getNewLineMode = function() {
        return this.$newLineMode;
    };
    this.isNewLine = function(text) {
        return (text == "\r\n" || text == "\r" || text == "\n");
    };
    this.getLine = function(row) {
        return this.$lines[row] || "";
    };
    this.getLines = function(firstRow, lastRow) {
        return this.$lines.slice(firstRow, lastRow + 1);
    };
    this.getAllLines = function() {
        return this.getLines(0, this.getLength());
    };
    this.getLength = function() {
        return this.$lines.length;
    };
    this.getTextRange = function(range) {
        return this.getLinesForRange(range).join(this.getNewLineCharacter());
    };
    this.getLinesForRange = function(range) {
        var lines;
        if (range.start.row === range.end.row) {
            lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];
        } else {
            lines = this.getLines(range.start.row, range.end.row);
            lines[0] = (lines[0] || "").substring(range.start.column);
            var l = lines.length - 1;
            if (range.end.row - range.start.row == l)
                lines[l] = lines[l].substring(0, range.end.column);
        }
        return lines;
    };
    this.insertLines = function(row, lines) {
        console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead.");
        return this.insertFullLines(row, lines);
    };
    this.removeLines = function(firstRow, lastRow) {
        console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead.");
        return this.removeFullLines(firstRow, lastRow);
    };
    this.insertNewLine = function(position) {
        console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.");
        return this.insertMergedLines(position, ["", ""]);
    };
    this.insert = function(position, text) {
        if (this.getLength() <= 1)
            this.$detectNewLine(text);
        
        return this.insertMergedLines(position, this.$split(text));
    };
    this.insertInLine = function(position, text) {
        var start = this.clippedPos(position.row, position.column);
        var end = this.pos(position.row, position.column + text.length);
        
        this.applyDelta({
            start: start,
            end: end,
            action: "insert",
            lines: [text]
        }, true);
        
        return this.clonePos(end);
    };
    
    this.clippedPos = function(row, column) {
        var length = this.getLength();
        if (row === undefined) {
            row = length;
        } else if (row < 0) {
            row = 0;
        } else if (row >= length) {
            row = length - 1;
            column = undefined;
        }
        var line = this.getLine(row);
        if (column == undefined)
            column = line.length;
        column = Math.min(Math.max(column, 0), line.length);
        return {row: row, column: column};
    };
    
    this.clonePos = function(pos) {
        return {row: pos.row, column: pos.column};
    };
    
    this.pos = function(row, column) {
        return {row: row, column: column};
    };
    
    this.$clipPosition = function(position) {
        var length = this.getLength();
        if (position.row >= length) {
            position.row = Math.max(0, length - 1);
            position.column = this.getLine(length - 1).length;
        } else {
            position.row = Math.max(0, position.row);
            position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);
        }
        return position;
    };
    this.insertFullLines = function(row, lines) {
        row = Math.min(Math.max(row, 0), this.getLength());
        var column = 0;
        if (row < this.getLength()) {
            lines = lines.concat([""]);
            column = 0;
        } else {
            lines = [""].concat(lines);
            row--;
            column = this.$lines[row].length;
        }
        this.insertMergedLines({row: row, column: column}, lines);
    };
    this.insertMergedLines = function(position, lines) {
        var start = this.clippedPos(position.row, position.column);
        var end = {
            row: start.row + lines.length - 1,
            column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length
        };
        
        this.applyDelta({
            start: start,
            end: end,
            action: "insert",
            lines: lines
        });
        
        return this.clonePos(end);
    };
    this.remove = function(range) {
        var start = this.clippedPos(range.start.row, range.start.column);
        var end = this.clippedPos(range.end.row, range.end.column);
        this.applyDelta({
            start: start,
            end: end,
            action: "remove",
            lines: this.getLinesForRange({start: start, end: end})
        });
        return this.clonePos(start);
    };
    this.removeInLine = function(row, startColumn, endColumn) {
        var start = this.clippedPos(row, startColumn);
        var end = this.clippedPos(row, endColumn);
        
        this.applyDelta({
            start: start,
            end: end,
            action: "remove",
            lines: this.getLinesForRange({start: start, end: end})
        }, true);
        
        return this.clonePos(start);
    };
    this.removeFullLines = function(firstRow, lastRow) {
        firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
        lastRow  = Math.min(Math.max(0, lastRow ), this.getLength() - 1);
        var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;
        var deleteLastNewLine  = lastRow  < this.getLength() - 1;
        var startRow = ( deleteFirstNewLine ? firstRow - 1                  : firstRow                    );
        var startCol = ( deleteFirstNewLine ? this.getLine(startRow).length : 0                           );
        var endRow   = ( deleteLastNewLine  ? lastRow + 1                   : lastRow                     );
        var endCol   = ( deleteLastNewLine  ? 0                             : this.getLine(endRow).length ); 
        var range = new Range(startRow, startCol, endRow, endCol);
        var deletedLines = this.$lines.slice(firstRow, lastRow + 1);
        
        this.applyDelta({
            start: range.start,
            end: range.end,
            action: "remove",
            lines: this.getLinesForRange(range)
        });
        return deletedLines;
    };
    this.removeNewLine = function(row) {
        if (row < this.getLength() - 1 && row >= 0) {
            this.applyDelta({
                start: this.pos(row, this.getLine(row).length),
                end: this.pos(row + 1, 0),
                action: "remove",
                lines: ["", ""]
            });
        }
    };
    this.replace = function(range, text) {
        if (!(range instanceof Range))
            range = Range.fromPoints(range.start, range.end);
        if (text.length === 0 && range.isEmpty())
            return range.start;
        if (text == this.getTextRange(range))
            return range.end;

        this.remove(range);
        var end;
        if (text) {
            end = this.insert(range.start, text);
        }
        else {
            end = range.start;
        }
        
        return end;
    };
    this.applyDeltas = function(deltas) {
        for (var i=0; i<deltas.length; i++) {
            this.applyDelta(deltas[i]);
        }
    };
    this.revertDeltas = function(deltas) {
        for (var i=deltas.length-1; i>=0; i--) {
            this.revertDelta(deltas[i]);
        }
    };
    this.applyDelta = function(delta, doNotValidate) {
        var isInsert = delta.action == "insert";
        if (isInsert ? delta.lines.length <= 1 && !delta.lines[0]
            : !Range.comparePoints(delta.start, delta.end)) {
            return;
        }
        
        if (isInsert && delta.lines.length > 20000) {
            this.$splitAndapplyLargeDelta(delta, 20000);
        }
        else {
            applyDelta(this.$lines, delta, doNotValidate);
            this._signal("change", delta);
        }
    };
    
    this.$splitAndapplyLargeDelta = function(delta, MAX) {
        var lines = delta.lines;
        var l = lines.length - MAX + 1;
        var row = delta.start.row; 
        var column = delta.start.column;
        for (var from = 0, to = 0; from < l; from = to) {
            to += MAX - 1;
            var chunk = lines.slice(from, to);
            chunk.push("");
            this.applyDelta({
                start: this.pos(row + from, column),
                end: this.pos(row + to, column = 0),
                action: delta.action,
                lines: chunk
            }, true);
        }
        delta.lines = lines.slice(from);
        delta.start.row = row + from;
        delta.start.column = column;
        this.applyDelta(delta, true);
    };
    this.revertDelta = function(delta) {
        this.applyDelta({
            start: this.clonePos(delta.start),
            end: this.clonePos(delta.end),
            action: (delta.action == "insert" ? "remove" : "insert"),
            lines: delta.lines.slice()
        });
    };
    this.indexToPosition = function(index, startRow) {
        var lines = this.$lines || this.getAllLines();
        var newlineLength = this.getNewLineCharacter().length;
        for (var i = startRow || 0, l = lines.length; i < l; i++) {
            index -= lines[i].length + newlineLength;
            if (index < 0)
                return {row: i, column: index + lines[i].length + newlineLength};
        }
        return {row: l-1, column: index + lines[l-1].length + newlineLength};
    };
    this.positionToIndex = function(pos, startRow) {
        var lines = this.$lines || this.getAllLines();
        var newlineLength = this.getNewLineCharacter().length;
        var index = 0;
        var row = Math.min(pos.row, lines.length);
        for (var i = startRow || 0; i < row; ++i)
            index += lines[i].length + newlineLength;

        return index + pos.column;
    };

}).call(Document.prototype);

exports.Document = Document;
});

define("ace/lib/lang",[], function(require, exports, module) {
"use strict";

exports.last = function(a) {
    return a[a.length - 1];
};

exports.stringReverse = function(string) {
    return string.split("").reverse().join("");
};

exports.stringRepeat = function (string, count) {
    var result = '';
    while (count > 0) {
        if (count & 1)
            result += string;

        if (count >>= 1)
            string += string;
    }
    return result;
};

var trimBeginRegexp = /^\s\s*/;
var trimEndRegexp = /\s\s*$/;

exports.stringTrimLeft = function (string) {
    return string.replace(trimBeginRegexp, '');
};

exports.stringTrimRight = function (string) {
    return string.replace(trimEndRegexp, '');
};

exports.copyObject = function(obj) {
    var copy = {};
    for (var key in obj) {
        copy[key] = obj[key];
    }
    return copy;
};

exports.copyArray = function(array){
    var copy = [];
    for (var i=0, l=array.length; i<l; i++) {
        if (array[i] && typeof array[i] == "object")
            copy[i] = this.copyObject(array[i]);
        else 
            copy[i] = array[i];
    }
    return copy;
};

exports.deepCopy = function deepCopy(obj) {
    if (typeof obj !== "object" || !obj)
        return obj;
    var copy;
    if (Array.isArray(obj)) {
        copy = [];
        for (var key = 0; key < obj.length; key++) {
            copy[key] = deepCopy(obj[key]);
        }
        return copy;
    }
    if (Object.prototype.toString.call(obj) !== "[object Object]")
        return obj;
    
    copy = {};
    for (var key in obj)
        copy[key] = deepCopy(obj[key]);
    return copy;
};

exports.arrayToMap = function(arr) {
    var map = {};
    for (var i=0; i<arr.length; i++) {
        map[arr[i]] = 1;
    }
    return map;

};

exports.createMap = function(props) {
    var map = Object.create(null);
    for (var i in props) {
        map[i] = props[i];
    }
    return map;
};
exports.arrayRemove = function(array, value) {
  for (var i = 0; i <= array.length; i++) {
    if (value === array[i]) {
      array.splice(i, 1);
    }
  }
};

exports.escapeRegExp = function(str) {
    return str.replace(/([.*+?^${}()|[\]\/\\])/g, '\\$1');
};

exports.escapeHTML = function(str) {
    return ("" + str).replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
};

exports.getMatchOffsets = function(string, regExp) {
    var matches = [];

    string.replace(regExp, function(str) {
        matches.push({
            offset: arguments[arguments.length-2],
            length: str.length
        });
    });

    return matches;
};
exports.deferredCall = function(fcn) {
    var timer = null;
    var callback = function() {
        timer = null;
        fcn();
    };

    var deferred = function(timeout) {
        deferred.cancel();
        timer = setTimeout(callback, timeout || 0);
        return deferred;
    };

    deferred.schedule = deferred;

    deferred.call = function() {
        this.cancel();
        fcn();
        return deferred;
    };

    deferred.cancel = function() {
        clearTimeout(timer);
        timer = null;
        return deferred;
    };
    
    deferred.isPending = function() {
        return timer;
    };

    return deferred;
};


exports.delayedCall = function(fcn, defaultTimeout) {
    var timer = null;
    var callback = function() {
        timer = null;
        fcn();
    };

    var _self = function(timeout) {
        if (timer == null)
            timer = setTimeout(callback, timeout || defaultTimeout);
    };

    _self.delay = function(timeout) {
        timer && clearTimeout(timer);
        timer = setTimeout(callback, timeout || defaultTimeout);
    };
    _self.schedule = _self;

    _self.call = function() {
        this.cancel();
        fcn();
    };

    _self.cancel = function() {
        timer && clearTimeout(timer);
        timer = null;
    };

    _self.isPending = function() {
        return timer;
    };

    return _self;
};
});

define("ace/worker/mirror",[], function(require, exports, module) {
"use strict";

var Range = require("../range").Range;
var Document = require("../document").Document;
var lang = require("../lib/lang");
    
var Mirror = exports.Mirror = function(sender) {
    this.sender = sender;
    var doc = this.doc = new Document("");
    
    var deferredUpdate = this.deferredUpdate = lang.delayedCall(this.onUpdate.bind(this));
    
    var _self = this;
    sender.on("change", function(e) {
        var data = e.data;
        if (data[0].start) {
            doc.applyDeltas(data);
        } else {
            for (var i = 0; i < data.length; i += 2) {
                var d, err; 
                if (Array.isArray(data[i+1])) {
                    d = {action: "insert", start: data[i], lines: data[i+1]};
                } else {
                    d = {action: "remove", start: data[i], end: data[i+1]};
                }
                
                if ((d.action == "insert" ? d.start : d.end).row >= doc.$lines.length) {
                    err = new Error("Invalid delta");
                    err.data = {
                        path: _self.$path,
                        linesLength: doc.$lines.length,
                        start: d.start,
                        end: d.end
                    };
                    throw err;
                }

                doc.applyDelta(d, true);
            }
        }
        if (_self.$timeout)
            return deferredUpdate.schedule(_self.$timeout);
        _self.onUpdate();
    });
};

(function() {
    
    this.$timeout = 500;
    
    this.setTimeout = function(timeout) {
        this.$timeout = timeout;
    };
    
    this.setValue = function(value) {
        this.doc.setValue(value);
        this.deferredUpdate.schedule(this.$timeout);
    };
    
    this.getValue = function(callbackId) {
        this.sender.callback(this.doc.getValue(), callbackId);
    };
    
    this.onUpdate = function() {
    };
    
    this.isPending = function() {
        return this.deferredUpdate.isPending();
    };
    
}).call(Mirror.prototype);

});

define("plugins/c9.ide.language.core/syntax_detector",[], function(require, exports, module) {

var mixedLanguages = {
    php: {
        "default": "html",
        "php-start": /<\?(?:php|\=)?/,
        "php-end": /\?>/,
        "css-start": /<style[^>]*>/,
        "css-end": /<\/style>/,
        "javascript-start": /<script(?:\"[^\"]*\"|'[^']*'|[^'">])*>/,
        "javascript-end": /<\/script>/
    },
    html: {
        "css-start": /<style[^>]*>/,
        "css-end": /<\/style>/,
        "javascript-start": /<script(?:\"[^\"]*\"|'[^']*'|[^'">])*>/,
        "javascript-end": /<\/script>/
    }
};
mixedLanguages.handlebars = mixedLanguages.html;
var scriptTypeTests = {
    javascript: function(v) {
        var m = /type\s*=\s*("[^"]+"|'[^']+'|[^\s'">]+)/.exec(v);
        if (m && !/javascript|ecmascript/i.test(m[1]))
            return false;
        return true;
    }
};
function getSyntaxRegions(doc, originalSyntax) {
     if (!mixedLanguages[originalSyntax])
        return [{
            syntax: originalSyntax,
            sl: 0,
            sc: 0,
            el: doc.getLength() - 1,
            ec: doc.getLine(doc.getLength() - 1).length
        }];

    var lines = doc.getAllLines();
    var type = mixedLanguages[originalSyntax];
    var defaultSyntax = type["default"] || originalSyntax;
    var starters = Object.keys(type).filter(function (m) {
        return m.indexOf("-start") === m.length - 6;
    });
    var syntax = defaultSyntax;
    var regions = [{ syntax: syntax, sl: 0, sc: 0 }];
    var starter, endLang;
    var tempS, tempM;
    var i, m, cut, inLine = 0;

    for (var row = 0; row < lines.length; row++) {
        var line = lines[row];
        m = null;
        if (endLang) {
            m = endLang.exec(line);
            if (m) {
                endLang = null;
                syntax = defaultSyntax;
                regions[regions.length - 1].el = row;
                regions[regions.length - 1].ec = m.index + inLine;
                regions.push({
                    syntax: syntax,
                    sl: row,
                    sc: m.index + inLine
                });
                cut = m.index + m[0].length;
                lines[row] = line.substring(cut);
                inLine += cut;
                row--; // continue processing of the line
            }
            else {
                inLine = 0;
            }
        }
        else {
            for (i = 0; i < starters.length; i++) {
                tempS = starters[i];
                tempM = type[tempS].exec(line);
                if (tempM && (!m || m.index > tempM.index)) {
                    m = tempM;
                    starter = tempS;
                }
            }
            if (m) {
                syntax = starter.replace("-start", "");
                if (scriptTypeTests[syntax] && !scriptTypeTests[syntax](m[0]))
                    syntax = defaultSyntax;
                endLang = type[syntax + "-end"];
                regions[regions.length - 1].el = row;
                regions[regions.length - 1].ec = inLine + m.index + m[0].length;
                regions.push({
                    syntax: syntax,
                    sl: row,
                    sc: inLine + m.index + m[0].length
                });
                cut = m.index + m[0].length;
                lines[row] = line.substring(m.index + m[0].length);
                row--; // continue processing of the line
                inLine += cut;
            }
            else {
                inLine = 0;
            }
        }
    }
    regions[regions.length - 1].el = lines.length;
    regions[regions.length - 1].ec = lines[lines.length - 1].length;
    return regions;
}

function getContextSyntaxPart(doc, pos, originalSyntax) {
     if (!mixedLanguages[originalSyntax]) {
        var value;
        var result = {
            language: originalSyntax,
            region: getSyntaxRegions(doc, originalSyntax)[0],
            index: 0,
            getLine: function(l) {
                return doc.getLine(l);
            },
            getLines: function(firstRow, lastRow) {
                return doc.getLines(firstRow, lastRow);
            },
            getAllLines: function() {
                return doc.getAllLines();
            },
            getValue: function() {
                if (!value)
                    value = doc.getValue();
                return value;
            },
            getLength: function() {
                return doc.getLength();
            }
        };
        result.__defineGetter__("value", function() {
            console.error("part.value is deprecated: use getValue() instead");
            return this.getValue();
        });
        return result;
    }
    var regions = getSyntaxRegions(doc, originalSyntax);
    for (var i = 0; i < regions.length; i++) {
        var region = regions[i];
        if ((pos.row > region.sl && pos.row < region.el) ||
            (pos.row === region.sl && pos.column >= region.sc && pos.column <= region.ec))
            return regionToCodePart(doc, region, i);
    }
    return null; // should never happen
}

function getContextSyntax(doc, pos, originalSyntax) {
    var part = getContextSyntaxPart(doc, pos, originalSyntax);
    return part && part.language; // should never happen
}

function regionToCodePart(doc, region, index) {
    var lines = doc.getLines(region.sl, region.el);
    if (!lines.length) {
        console.error("region and document state are not consistent!!!");
        lines = [""];
    }
    var allLines;
    var value;
    var result = {
        language: region.syntax,
        region: region,
        index: index,
        getLines: function(firstRow, lastRow) {
            return this.getAllLines().slice(firstRow, lastRow + 1);
        },
        getLine: function(l) {
            if (region.sl === region.el)
                return lines[0].substring(region.sc, region.ec);
            if (l === 0)
                return lines[0].substring(region.sc);
            if (l === lines.length - 1)
                return lines[lines.length - 1].substring(0, region.ec);
            return lines[l];
        },
        getAllLines: function() {
            if (!allLines)
                allLines = region.sl === region.el
                    ? [lines[0].substring(region.sc, region.ec)]
                    : [lines[0].substring(region.sc)].concat(lines.slice(1, lines.length - 1)).concat([lines[lines.length - 1].substring(0, region.ec)]);
            return allLines;
        },
        getValue: function() {
            if (!value)
                value = this.getAllLines().join(doc.getNewLineCharacter());
            return value;
        },
        getLength: function() {
            return region.el - region.sl + 1;
        }
    };
    result.__defineGetter__("value", function() {
        console.error("part.value is deprecated: use getValue() instead");
        return this.getValue();
    });
    return result;
}

function getCodeParts(doc, originalSyntax) {
    var regions = getSyntaxRegions(doc, originalSyntax);
    return regions.map(function (region, i) {
        return regionToCodePart(doc, region, i);
    });
}

function posToRegion(region, pos) {
    if ("row" in pos)
        return {
            row: pos.row - region.sl,
            column: pos.column,
            path: pos.path
        };
    return {
        sl: pos.sl - region.sl,
        column: pos.sc,
        el: pos.el - region.sl,
        ec: pos.ec,
        path: pos.path
    };
}

function posFromRegion(region, pos) {
    if ("row" in pos)
        return {
            row: pos.row + region.sl,
            column: pos.column,
            path: pos.path
        };
    return {
        sl: pos.sl + region.sl,
        sc: pos.sc,
        el: pos.el + region.sl,
        ec: pos.ec,
        path: pos.path
    };
}

exports.getContextSyntax = getContextSyntax;
exports.getContextSyntaxPart = getContextSyntaxPart;
exports.getSyntaxRegions = getSyntaxRegions;
exports.getCodeParts = getCodeParts;
exports.posToRegion = posToRegion;
exports.posFromRegion = posFromRegion;

});

define("plugins/c9.ide.language/complete_util",[], function(require, exports, module) {

var ID_REGEX = /[a-zA-Z_0-9\$]/;
var REQUIRE_ID_REGEX = /(?!["'])./;
var staticPrefix = "";

function retrievePrecedingIdentifier(line, offset, regex) {
    regex = regex || ID_REGEX;
    var buf = [];
    for (var i = offset - 1; i >= 0 && line; i--) {
        if (regex.test(line[i]))
            buf.push(line[i]);
        else
            break;
    }
    return buf.reverse().join("");
}

function retrieveFollowingIdentifier(line, offset, regex) {
    regex = regex || ID_REGEX;
    var buf = [];
    for (var i = offset; line && i < line.length; i++) {
        if (regex.test(line[i]))
            buf.push(line[i]);
        else
            break;
    }
    return buf.join("");
}

function prefixBinarySearch(items, prefix) {
    var startIndex = 0;
    var stopIndex = items.length - 1;
    var middle = Math.floor((stopIndex + startIndex) / 2);
    
    while (stopIndex > startIndex && middle >= 0 && items[middle].indexOf(prefix) !== 0) {
        if (prefix < items[middle]) {
            stopIndex = middle - 1;
        }
        else if (prefix > items[middle]) {
            startIndex = middle + 1;
        }
        middle = Math.floor((stopIndex + startIndex) / 2);
    }
    while (middle > 0 && items[middle - 1].indexOf(prefix) === 0)
        middle--;
    return middle >= 0 ? middle : 0; // ensure we're not returning a negative index
}

function findCompletions(prefix, allIdentifiers) {
    allIdentifiers.sort();
    var startIdx = prefixBinarySearch(allIdentifiers, prefix);
    var matches = [];
    for (var i = startIdx; i < allIdentifiers.length && allIdentifiers[i].indexOf(prefix) === 0; i++)
        matches.push(allIdentifiers[i]);
    return matches;
}

function fetchTextSync(path) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', staticPrefix + "/" + path, false);
    try {
        xhr.send();
    }
    catch (e) {
        return false;
    }
    if (xhr.status === 200 || xhr.responseText) // when loading from file:// status is always 0
        return xhr.responseText;
    else
        return false;
}

function fetchText(path, callback) {
    var xhr = new XMLHttpRequest();
    try {
        xhr.open('GET', staticPrefix + "/" + path, true);
    } catch (e) {
        return done(e);
    }
    xhr.onload = function (e) {
        if (xhr.readyState !== 4)
            return;
        if (xhr.status !== 200 && xhr.status !== 0)
            return done(new Error(xhr.statusText));
        done(null, xhr.responseText);
    };
    xhr.onerror = done;
    xhr.send(null);
    
    function done(err, result) {
        callback && callback(err, result);
        callback = null;
        if (err) {
            err.data = { path: path };
            setTimeout(function() { throw err; });
        }
    }
}

function setStaticPrefix(url) {
    staticPrefix = url;
}
function canCompleteForChangedLine(oldLine, newLine, oldPos, newPos, identifierRegex) {
    if (newLine.indexOf(oldLine.substr(0, oldPos.column)) !== 0)
        return false;
    
    for (var i = oldPos.column; i < newPos.column; i++) {
        if (!identifierRegex.test(newLine[i]))
            return false;
    }
    return true;
}

function precededByIdentifier(line, column, postfix, ace) {
    var id = retrievePrecedingIdentifier(line, column);
    if (postfix) id += postfix;
    return id !== "" && !(id[0] >= '0' && id[0] <= '9') 
        && (inCompletableCodeContext(line, column, id, ace) 
        || isRequireJSCall(line, column, id, ace));
}

function isRequireJSCall(line, column, identifier, ace, noQuote) {
    if (["javascript", "jsx"].indexOf(ace.getSession().syntax) === -1)
        return false;
    var id = identifier == null ? retrievePrecedingIdentifier(line, column, REQUIRE_ID_REGEX) : identifier;
    var LENGTH = 'require("'.length - (noQuote ? 1 : 0);
    var start = column - id.length - LENGTH;
    var substr = line.substr(start, LENGTH) + (noQuote ? '"' : '');

    return start >= 0 && substr.match(/require\(["']/)
        || line.substr(start + 1, LENGTH).match(/require\(["']/);
}
function inCompletableCodeContext(line, column, id, ace) {
    if (["javascript", "jsx"].indexOf(ace.getSession().syntax) === -1)
        return true;
    var isJavaScript = true;
    var inMode = null;
    for (var i = 0; i < column; i++) {
        if (line[i] === '"' && !inMode)
            inMode = '"';
        else if (line[i] === '"' && inMode === '"' && line[i - 1] !== "\\")
            inMode = null;
        else if (line[i] === "'" && !inMode)
            inMode = "'";
        else if (line[i] === "'" && inMode === "'" && line[i - 1] !== "\\")
            inMode = null;
        else if (line[i] === "/" && line[i + 1] === "/") {
            inMode = '//';
            i++;
        }
        else if (line[i] === "/" && line[i + 1] === "*" && !inMode) {
            if (line.substr(i + 2, 6) === "global")
                continue;
            inMode = '/*';
            i++;
        }
        else if (line[i] === "*" && line[i + 1] === "/" && inMode === "/*") {
            inMode = null;
            i++;
        }
        else if (line[i] === "/" && !inMode && isJavaScript)
            inMode = "/";
        else if (line[i] === "/" && inMode === "/" && line[i - 1] !== "\\")
            inMode = null;
    }
    return inMode != "/";
}
exports.precededByIdentifier = precededByIdentifier;
exports.isRequireJSCall = isRequireJSCall;
exports.retrievePrecedingIdentifier = retrievePrecedingIdentifier;
exports.retrieveFollowingIdentifier = retrieveFollowingIdentifier;
exports.findCompletions = findCompletions;
exports.fetchText = fetchText;
exports.fetchTextSync = fetchTextSync;
exports.setStaticPrefix = setStaticPrefix;
exports.DEFAULT_ID_REGEX = ID_REGEX;
exports.canCompleteForChangedLine = canCompleteForChangedLine;
});

define("plugins/c9.ide.language.generic/local_completer",[], function(require, exports, module) {

var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');
var completeUtil = require("plugins/c9.ide.language/complete_util");

var MAX_SIZE_BYTES = 5 * 1000 * 1000;
var DEFAULT_SPLIT_REGEX = /[^a-zA-Z_0-9\$]+/;
var MAX_SCORE = 1000000;
var TRUNCATE_LINES = 10000;

var completer = module.exports = Object.create(baseLanguageHandler);
    
completer.handlesLanguage = function(language) {
    return true;
};

completer.handlesEditor = function() {
    return this.HANDLES_ANY;
};

completer.getMaxFileSizeSupported = function() {
    return MAX_SIZE_BYTES;
};
function wordDistanceAnalyzer(doc, pos, prefix, suffix) {
    var splitRegex = getSplitRegex(pos);
    var linesBefore = doc.getLines(Math.max(0, pos.row - TRUNCATE_LINES / 2), pos.row - 1);
    var linesAfter = doc.getLines(pos.row + 1, Math.min(doc.getLength(), pos.row + TRUNCATE_LINES / 2));
    var textBefore = linesBefore.join("\n");
    var textAfter = linesAfter.join("\n");
    var line = getFilteredLine(doc.getLine(pos.row), pos.column, prefix, suffix);
    var identifiers = textBefore.split(splitRegex);
    var prefixPosition = identifiers.length;
    identifiers = identifiers.concat(line.split(splitRegex), textAfter.split(splitRegex));
    var identDict = Object.create(null);
    for (var i = 0; i < identifiers.length; i++) {
        var ident = identifiers[i];
        if (ident.length === 0)
            continue;
        var distance = Math.max(prefixPosition, i) - Math.min(prefixPosition, i);
        if (identDict[ident])
            identDict[ident] = Math.max(MAX_SCORE - distance, identDict[ident]);
        else
            identDict[ident] = MAX_SCORE - distance;
        
    }
    return identDict;
}

function getSplitRegex(pos) {
    var idRegex = completer.$getIdentifierRegex(pos);
    if (!idRegex || !idRegex.source.match(/\[[^^][^\]]*\]/))
        return DEFAULT_SPLIT_REGEX;
    return new RegExp("[^" + idRegex.source.substr(1, idRegex.source.length - 2) + "]+");
}

function getFilteredLine(line, column, prefix, suffix) {
    return line.substr(0, column - prefix.length)
        + line.substr(column + suffix.length);
}

function analyze(doc, pos) {
    var line = doc.getLine(pos.row);
    var prefix = completeUtil.retrievePrecedingIdentifier(line, pos.column, completer.$getIdentifierRegex());
    var suffix = completeUtil.retrieveFollowingIdentifier(line, pos.column, completer.$getIdentifierRegex());
    return wordDistanceAnalyzer(doc, pos, prefix, suffix);
}
    
completer.complete = function(doc, fullAst, pos, options, callback) {
    var identDict = analyze(doc, pos);
    var line = doc.getLine(pos.row);
    var regex = this.$getIdentifierRegex(pos);
    var identifier = completeUtil.retrievePrecedingIdentifier(line, pos.column, regex);
    var fullIdentifier = identifier + completeUtil.retrieveFollowingIdentifier(line, pos.column, regex);
         
    var allIdentifiers = [];
    for (var ident in identDict) {
        allIdentifiers.push(ident);
    }
    var matches = completeUtil.findCompletions(identifier, allIdentifiers);
    
    matches = matches.slice(0, 100); // limits results for performance

    var allowSlashes = regex && regex.source.match(/^\[.*\/.*]/);
    var allowDollars = regex && regex.source.match(/\$\$/);
    
    callback(null, matches.filter(function(m) {
        if (allowDollars) {
            return !m.match(allowSlashes ? /^([0-9_\/]|\/[^\/])/ : /^[0-9_\/]/);
        }  
        else {
            return !m.match(allowSlashes ? /^([0-9$_\/]|\/[^\/])/ : /^[0-9$_\/]/);
        }
    }).map(function(m) {
        return {
          name: m,
          replaceText: m,
          icon: null,
          score: m === fullIdentifier ? MAX_SCORE : identDict[m],
          isGeneric: true,
          priority: 0,
          $source: "local"
        };
    }));
};

});

define("plugins/c9.ide.language.generic/open_files_local_completer",[], function(require, exports, module) {

var completeUtil = require("plugins/c9.ide.language/complete_util");

var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');

var analysisCache = {}; // path => {identifier: 3, ...}
var globalWordIndex = {}; // word => frequency
var globalWordFiles = {}; // word => [path]
var precachedPath;
var precachedDoc;

var completer = module.exports = Object.create(baseLanguageHandler);

completer.handlesLanguage = function(language) {
    return true;
};

completer.handlesEditor = function() {
    return this.HANDLES_ANY;
};

completer.getMaxFileSizeSupported = function() {
    return 1000 * 1000;
};

function frequencyAnalyzer(path, text, identDict, fileDict) {
    var identifiers = text.split(/[^a-zA-Z_0-9\$]+/);
    for (var i = 0; i < identifiers.length; i++) {
        var ident = identifiers[i];
        if (!ident)
            continue;
            
        if (Object.prototype.hasOwnProperty.call(identDict, ident)) {
            identDict[ident]++;
            fileDict[ident][path] = true;
        }
        else {
            identDict[ident] = 1;
            fileDict[ident] = {};
            fileDict[ident][path] = true;
        }
    }
    return identDict;
}

function removeDocumentFromCache(path) {
    var analysis = analysisCache[path];
    if (!analysis) return;

    for (var id in analysis) {
        globalWordIndex[id] -= analysis[id];
        delete globalWordFiles[id][path];
        if (globalWordIndex[id] === 0) {
            delete globalWordIndex[id];
            delete globalWordFiles[id];
        }
    }
    delete analysisCache[path];
}

function analyzeDocument(path, allCode) {
    if (!analysisCache[path]) {
        if (allCode.size > 80 * 10000) {
            delete analysisCache[path];
            return;
        }
        analysisCache[path] = frequencyAnalyzer(path, allCode, {}, {});
        frequencyAnalyzer(path, allCode, globalWordIndex, globalWordFiles);
    }
}

completer.onDocumentOpen = function(path, doc, oldPath, callback) {
    if (!analysisCache[path]) {
        analyzeDocument(path, doc.getValue());
    }
    callback();
};
    
completer.onDocumentClose = function(path, callback) {
    removeDocumentFromCache(path);
    if (path == precachedPath)
        precachedDoc = null;
    callback();
};

completer.analyze = function(doc, ast, callback) {
    if (precachedDoc && this.path !== precachedPath) {
        removeDocumentFromCache(precachedPath);
        analyzeDocument(precachedPath, precachedDoc);
        precachedDoc = null;
    }
    precachedPath = this.path;
    precachedDoc = doc;
    callback();
};

completer.complete = function(doc, fullAst, pos, options, callback) {
    var line = doc.getLine(pos.row);
    var regex = this.$getIdentifierRegex(pos);
    var identifier = completeUtil.retrievePrecedingIdentifier(line, pos.column, regex);
    var identDict = globalWordIndex;
    
    var allIdentifiers = [];
    for (var ident in identDict) {
        allIdentifiers.push(ident);
    }
    var matches = completeUtil.findCompletions(identifier, allIdentifiers);
    
    var currentPath = options.path;
    matches = matches.filter(function(m) {
        return !globalWordFiles[m][currentPath];
    });
    
    matches = matches.slice(0, 100); // limits results for performance

    callback(null, matches.filter(function(m) {
        return !m.match(/^[0-9$_\/]/);
    }).map(function(m) {
        var path = Object.keys(globalWordFiles[m])[0] || "[unknown]";
        var pathParts = path.split("/");
        var foundInFile = pathParts[pathParts.length - 1];
        return {
          name: m,
          replaceText: m,
          icon: null,
          score: identDict[m],
          meta: foundInFile,
          priority: 0,
          isGeneric: true,
          $source: "open_files",
        };
    }));
};

});

//
//
//
define("util",[], function(require, exports, module) {

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};
function inspect(obj, opts) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    ctx.showHidden = opts;
  } else if (opts) {
    exports._extend(ctx, opts);
  }
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;
inspect.colors = {
  'bold': [1, 22],
  'italic': [3, 23],
  'underline': [4, 24],
  'inverse': [7, 27],
  'white': [37, 39],
  'grey': [90, 39],
  'black': [30, 39],
  'blue': [34, 39],
  'cyan': [36, 39],
  'green': [32, 39],
  'magenta': [35, 39],
  'red': [31, 39],
  'yellow': [33, 39]
};
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      value.inspect !== exports.inspect &&
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) && objectToString(e) === '[object Error]';
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

function isBuffer(arg) {
  return false;
}
exports.isBuffer = isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};
exports.inherits = function(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
};

exports._extend = function(origin, add) {
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

});

//
//
//
//
//
define("assert",[], function(require, exports, module) {
var util = require('util');
var pSlice = Array.prototype.slice;
var assert = module.exports = ok;
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  this.message = options.message || getMessage(this);
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    var err = new Error();
    this.stack = err.stack;
  }
};
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && (isNaN(value) || !isFinite(value))) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}
function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}
assert.fail = fail;
function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;
assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};
assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};
assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;
  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  if (a.prototype !== b.prototype) return false;
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  try {
    var ka = Object.keys(a),
        kb = Object.keys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  if (ka.length != kb.length)
    return false;
  ka.sort();
  kb.sort();
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}
assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};
assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};
assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}
assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};
assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

});

define("c9/assert",[], function(require, exports, module) {
        
    var assert = function(value, message) {
        if (!value)
            throw new Error("Assertion failed: " + (message || value));
    };
    
    var assertEqual = function(value1, value2, message) {
        if (value1 != value2)
            throw new Error("Assertion failed. " + (message || "") + " got\n  " + value1 + "expected\n  " + value2);
    };
    
    module.exports = function(value, message) {
        assert(value, message);
    };
    
    module.exports.equal = function(value1, value2, message) {
        assertEqual(value1, value2, message);
    };
    
    if (typeof process === "undefined")
        return;
        
    if (process.versions && process.versions['node-webkit'])
        return;
    require(["assert"], function(nodeAssert) {
        assert = nodeAssert;
        assertEqual = nodeAssert.equal;
    });
    if (Error.captureStackTrace) {
        assert = require("assert");
        assertEqual = assert.equal;
    }
});

define("plugins/c9.ide.language.core/worker",[], function(require, exports, module) {
require("ace/lib/es6-shim");

var oop = require("ace/lib/oop");
var Mirror = require("ace/worker/mirror").Mirror;
var tree = require('treehugger/tree');
var EventEmitter = require("ace/lib/event_emitter").EventEmitter;
var syntaxDetector = require("plugins/c9.ide.language.core/syntax_detector");
var completeUtil = require("plugins/c9.ide.language/complete_util");
var localCompleter = require("plugins/c9.ide.language.generic/local_completer");
var openFilesCompleter = require("plugins/c9.ide.language.generic/open_files_local_completer");
var base_handler = require("plugins/c9.ide.language/base_handler");
var assert = require("c9/assert");

var isInWebWorker = typeof window == "undefined" || !window.location || !window.document;

var WARNING_LEVELS = {
    error: 3,
    warning: 2,
    info: 1
};

var UPDATE_TIMEOUT_MIN = !isInWebWorker && window.c9Test ? 5 : 200;
var UPDATE_TIMEOUT_MAX = 15000;
var DEBUG = !isInWebWorker; // set to true by setDebug() for c9.dev/cloud9beta.com
var STATS = false;
disabledFeatures = {};

var ServerProxy = function(sender) {

  this.emitter = Object.create(EventEmitter);
  this.emitter.emit = this.emitter._dispatchEvent;

  this.send = function(data) {
      sender.emit("serverProxy", data);
  };

  this.once = function(messageType, messageSubtype, callback) {
    var channel = messageType;
    if (messageSubtype)
       channel += (":" + messageSubtype);
    this.emitter.once(channel, callback);
  };

  this.subscribe = function(messageType, messageSubtype, callback) {
    var channel = messageType;
    if (messageSubtype)
       channel += (":" + messageSubtype);
    this.emitter.addEventListener(channel, callback);
  };

  this.unsubscribe = function(messageType, messageSubtype, f) {
    var channel = messageType;
    if (messageSubtype)
       channel += (":" + messageSubtype);
    this.emitter.removeEventListener(channel, f);
  };

  this.onMessage = function(msg) {
    var channel = msg.type;
    if (msg.subtype)
      channel += (":" + msg.subtype);
    this.emitter.emit(channel, msg.body);
  };
};

exports.createUIWorkerClient = function() {
    var emitter = Object.create(require("ace/lib/event_emitter").EventEmitter);
    var result = new LanguageWorker(emitter);
    result.on = function(name, f) {
        emitter.on.call(result, name, f);
    };
    result.once = function(name, f) {
        emitter.once.call(result, name, f);
    };
    result.removeEventListener = function(f) {
        emitter.removeEventListener.call(result, f);
    };
    result.call = function(cmd, args, callback) {
        if (callback) {
            var id = this.callbackId++;
            this.callbacks[id] = callback;
            args.push(id);
        }
        this.send(cmd, args);
    };
    result.send = function(cmd, args) {
        setTimeout(function() { result[cmd].apply(result, args); }, 0);
    };
    result.emit = function(event, data) {
        emitter._dispatchEvent.call(emitter, event, data);
    };
    emitter.emit = function(event, data) {
        emitter._dispatchEvent.call(result, event, { data: data });
    };
    result.changeListener = function(e) {
        this.emit("change", { data: [e.data]});
    }; 
    return result;
};

var LanguageWorker = exports.LanguageWorker = function(sender) {
    var _self = this;
    this.$keys = {};
    this.handlers = [];
    this.$warningLevel = "info";
    this.$openDocuments = {};
    this.$initedRegexes = {};
    this.lastUpdateTime = 0;
    sender.once = EventEmitter.once;
    this.serverProxy = new ServerProxy(sender);

    Mirror.call(this, sender);
    this.setTimeout(0);
    exports.sender = sender;
    exports.$lastWorker = this;

    sender.on("hierarchy", function(event) {
        _self.hierarchy(event);
    });
    sender.on("code_format", function(event) {
        _self.codeFormat();
    });
    sender.on("outline", applyEventOnce(function(event) {
        _self.outline(event);
    }));
    sender.on("complete", applyEventOnce(function(data) {
        _self.complete(data);
    }), true);
    sender.on("documentClose", function(event) {
        _self.documentClose(event);
    });
    sender.on("analyze", applyEventOnce(function(event) {
        _self.analyze(false, function() {});
    }));
    sender.on("cursormove", function(event) {
        _self.onCursorMove(event);
    });
    sender.on("inspect", applyEventOnce(function(event) {
        _self.inspect(event);
    }));
    sender.on("jumpToDefinition", applyEventOnce(function(event) {
        _self.jumpToDefinition(event);
    }));
    sender.on("quickfixes", applyEventOnce(function(event) {
        _self.quickfix(event);
    }));
    sender.on("isJumpToDefinitionAvailable", applyEventOnce(function(event) {
        _self.isJumpToDefinitionAvailable(event);
    }));
    sender.on("refactorings", function(event) {
        _self.getRefactorings(event);
    });
    sender.on("renamePositions", function(event) {
        _self.getRenamePositions(event);
    });
    sender.on("onRenameBegin", function(event) {
        _self.onRenameBegin(event);
    });
    sender.on("commitRename", function(event) {
        _self.commitRename(event);
    });
    sender.on("onRenameCancel", function(event) {
        _self.onRenameCancel(event);
    });
    sender.on("serverProxy", function(event) {
        _self.serverProxy.onMessage(event.data);
    });
    sender.on("quickfix_key", function(e) {
        _self.$keys.quickfix = e.data;
    });
};
function applyEventOnce(eventHandler, waitForMirror) {
    var timer;
    var mirror = this;
    return function(e) {
        var _arguments = [].slice.apply(arguments);
        if (timer && !(e && e.data.predictOnly))
            clearTimeout(timer);
        timer = setTimeout(function() {
            if (waitForMirror && mirror.isPending())
                return setTimeout(function() { applyEventOnce(eventHandler, true); }, 0);
            eventHandler.apply(eventHandler, _arguments);
        }, 0);
    };
}

oop.inherits(LanguageWorker, Mirror);

var asyncForEach = module.exports.asyncForEach = function(array, fn, test, callback) {
    if (!callback) {
        callback = test;
        test = null;
    }

    array = array.slice(); // copy before use
    
    var nested = false, callNext = true;
    loop();
    
    function loop() {
        while (callNext && !nested) {
            callNext = false;
            while (array.length > 0 && test && !test(array[0]))
                array.shift();

            var item = array.shift();
            if (!item)
                return callback && callback();

            nested = true;
            fn(item, loop);
            nested = false;
        }
        callNext = true;
    }
};

function startTime() {
    if (!STATS)
        return;
    
    return Date.now();
}

function endTime(t, message, indent) {
    if (!STATS)
        return;

    var spaces = indent ? indent * 2 : 0;
    var time = String(Date.now() - t);
    spaces += Math.max(4 - time.length, 0);
    var prefix = "";
    for (var i = 0; i < spaces; i++)
        prefix += " ";

    console.log(prefix + time, message);
}

(function() {
    
    var identifierRegexes = {};
    var cacheCompletionRegexes = {};
    
    this.enableFeature = function(name, value) {
        disabledFeatures[name] = !value;
    };

    this.setWarningLevel = function(level) {
        this.$warningLevel = level;
    };
    
    this.setStaticPrefix = completeUtil.setStaticPrefix;

    this.setDebug = function(value) {
        DEBUG = value;
    };
    this.register = function(path, contents, callback) {
        var _self = this;
        function onRegistered(handler) {
            handler.$source = path;
            handler.proxy = _self.serverProxy;
            handler.sender = _self.sender;
            handler.$isInited = false;
            handler.getEmitter = function(overridePath) {
                return _self.$createEmitter(overridePath || path);
            };
            _self.completionCache = _self.completionPrediction = null;
            _self.handlers.push(handler);
            _self.$initHandler(handler, null, true, function() {
                _self.sender.emit("registered", { path: path });
                callback && callback();
            });
        }
        if (contents) {
            try {
                eval.call(null, contents);
            } catch (e) {
                console.error("Could not load language handler " + path + ": " + e);
                _self.sender.emit("registered", { path: path, err: e });
                callback && callback(e);
                throw e;
            }
        }
        require([path], function(handler) {
            if (!handler) {
                _self.sender.emit("registered", { path: path, err: "Could not load" });
                callback && callback("Could not load");
                throw new Error("Could not load language handler " + path);
            }
            onRegistered(handler);
        }, function(e) {
            console.error("Could not load language handler " + path + ": " + e);
            _self.sender.emit("registered", { path: path, err: e.message });
            callback && callback(e);
        });
    };
    
    this.$createEmitter = function(path) {
        var sender = this.sender;
        return {
            on: function(event, listener) {
                sender.on(path + "/" + event, function(e) {
                    listener(e.data);
                });
            },
            once: function(event, listener) {
                sender.once(path + "/" + event, function(e) {
                    listener(e.data);
                });
            },
            off: function(event, listener) {
                sender.off(path + "/" + event, listener);
            },
            emit: function(event, data) {
                sender.emit(path + "/" + event, data);
            }
        };
    };
    
    this.unregister = function(modulePath, callback) {
        this.handlers = this.handlers.filter(function(h) {
            return h.$source !== modulePath;
        });
        if (window.require)
            window.require.undef(modulePath, true);
        callback && callback();
    };

    this.asyncForEachHandler = function(options, fn, callback) {
        var that = this;
        var part = options.part;
        var method = options.method;
        var ignoreSize = options.ignoreSize;
        asyncForEach(
            this.handlers,
            fn,
            function(handler) {
                return that.isHandlerMatch(handler, part, method, ignoreSize);
            },
            callback
        );
    };
    
    this.isHandlerMatch = function(handler, part, method, ignoreSize) {
        if (!handler[method]) {
            reportError(new Error("Handler " + handler.$source + " does not have method " + method), {
                keys: Object.keys(handler),
                protoKeys: handler.__proto__ && Object.keys(handler.__proto__)
            });
            return false;
        }
        if (handler[method].base_handler)
            return;
        switch (handler.handlesEditor()) {
            case base_handler.HANDLES_EDITOR: 
                if (this.immediateWindow)
                    return;
                break; 
            case base_handler.HANDLES_IMMEDIATE:
                if (!this.immediateWindow)
                    return;
        }
        if (!handler.handlesLanguage(part ? part.language : this.$language, part))
            return;
        var docLength = ignoreSize ? null : part
            ? part.getValue().length
            : this.doc.$lines.reduce(function(t, l) { return t + l.length; }, 0);
        return ignoreSize || docLength < handler.getMaxFileSizeSupported();
    };

    this.parse = function(part, callback, allowCached, forceCached) {
        var value = (part || this.doc).getValue();
        var language = part ? part.language : this.$language;

        if (allowCached && this.cachedAsts) {
            var cached = this.cachedAsts[part.index];
            if (cached && cached.ast && cached.part.language === language)
                return callback(cached.ast);
        }
        if (forceCached)
            return callback(null);

        var resultAst = null;
        this.asyncForEachHandler(
            { part: part, method: "parse" },
            function parseNext(handler, next) {
                if (handler.parse.length === 2) // legacy signature
                    return handler.parse(value, handleCallbackError(function onParse(ast) {
                        if (ast) resultAst = ast;
                        next();
                    }));

                handler.parse(value, {}, handleCallbackError(function onParse(ast) {
                    if (ast)
                        resultAst = ast;
                    next();
                }));
            },
            function() {
                callback(resultAst);
            }
        );
    };
    this.findNode = function(ast, pos, callback) {
        if (!ast)
            return callback();
        assert(!pos.line, "Internal error: providing line/col instead of row/column");
        
        var _self = this;
        var part = syntaxDetector.getContextSyntaxPart(_self.doc, pos, _self.$language);
        if (!part)
            return; // cursor position no longer current
        var posInPart = syntaxDetector.posToRegion(part.region, pos);
        var result;
        this.asyncForEachHandler(
            { part: part, method: "findNode" },
            function(handler, next) {
                handler.findNode(ast, posInPart, handleCallbackError(function(node) {
                    if (node)
                        result = node;
                    next();
                }));
            },
            function() { callback(result); }
        );
    };

    this.outline = function(event) {
        var _self = this;
        this.getOutline(function(result, isUnordered) {
            _self.sender.emit(
                "outline",
                {
                    body: result && (result.body || result.items) || [],
                    path: _self.$path,
                    isUnordered: isUnordered
                }
            );
        });
    };
    
    this.getOutline = function(callback) {
        var _self = this;
        var result;
        var isUnordered = false;
        var applySort = false;
        this.parse(null, function(ast) {
            _self.asyncForEachHandler({ method: "outline" }, function(handler, next) {
                if (handler.outline.length === 3) // legacy signature
                    return handler.outline(_self.doc, ast, handleCallbackError(processResult));
                handler.outline(_self.doc, ast, {}, handleCallbackError(processResult));
                    
                function processResult(outline) {
                    if (!outline)
                        return next();
                    if (!result || (!outline.isGeneric && result.isGeneric)) {
                        result = outline;
                        isUnordered = outline.isUnordered;
                        return next();
                    }
                    if (result && outline.isGeneric && !result.isGeneric) {
                        return next();
                    }
                    applySort = true;
                    [].push.apply(result.items, outline.items);
                    result.isGeneric = outline.isGeneric;
                    next();
                }
            }, function() {
                if (applySort && result)
                    result.items = result.items.sort(function(a, b) {
                        return a.pos.sl - b.pos.sl;
                    });
                
                callback(result, isUnordered);
            });
        });
    };

    this.hierarchy = function(event) {
        var data = event.data;
        var _self = this;
        asyncForEach(this.handlers, function(handler, next) {
            if (_self.isHandlerMatch(handler, null, "hierarchy")) {
                handler.hierarchy(_self.doc, data.pos, handleCallbackError(function(hierarchy) {
                    if (hierarchy)
                        return _self.sender.emit("hierarchy", hierarchy);
                    else
                        next();
                }));
            }
            else
                next();
        });
    };

    this.codeFormat = function() {
        var _self = this;
        asyncForEach(_self.handlers, function(handler, next) {
            if (_self.isHandlerMatch(handler, null, "codeFormat", true)) {
                handler.codeFormat(_self.doc, function(optionalErr, newSource) {
                    if (typeof optionalErr === "string")
                        newSource = optionalErr;
                    else if (optionalErr)
                        console.error(optionalErr.stack || optionalErr);
                    if (newSource)
                        return _self.sender.emit("code_format", newSource);
                    else
                        next();
                });
            }
            else
                next();
        });
    };

    this.scheduleEmit = function(messageType, data) {
        data.path = this.$path;
        this.sender.emit(messageType, data);
    };
    function filterMarkersAroundError(ast, markers) {
        if (!ast || !ast.getAnnotation)
            return;
        var error = ast.getAnnotation("error");
        if (!error)
            return;
        for (var i = 0; i < markers.length; i++) {
            var marker = markers[i];
            if (marker.type !== 'error' && marker.pos.sl >= error.line && marker.pos.el <= error.line + 2) {
                markers.splice(i, 1);
                i--;
            }
        }
    }

    this.analyze = function(minimalAnalysis, callback) {
        var _self = this;
        var parts = syntaxDetector.getCodeParts(this.doc, this.$language);
        var markers = [];
        var cachedAsts = {};
        var t0 = startTime();
        asyncForEach(parts, function analyzePart(part, nextPart) {
            var partMarkers = [];
            _self.part = part;
            _self.$lastAnalyzer = "parse()";
            _self.parse(part, function analyzeParsed(ast) {
                cachedAsts[part.index] = { part: part, ast: ast };

                _self.asyncForEachHandler(
                    { part: part, method: "analyze" },
                    function(handler, next) {
                        handler.language = part.language;
                        var t = startTime();
                        _self.$lastAnalyzer = handler.$source + ".analyze()";
                        
                        if (handler.analyze.length === 3 || /^[^)]+minimalAnalysis/.test(handler.analyze.toString())) {
                            return handler.analyze(part.getValue(), ast, handleCallbackError(doNext), minimalAnalysis);
                        }
                        
                        handler.analyze(part.getValue(), ast, { path: _self.$path, minimalAnalysis: minimalAnalysis }, handleCallbackError(doNext));
                        
                        function doNext(result) {
                            endTime(t, "Analyze: " + handler.$source.replace("plugins/", ""));
                            if (result)
                                partMarkers = partMarkers.concat(result);
                            next();
                        }
                    },
                    function() {
                        filterMarkersAroundError(ast, partMarkers);
                        var region = part.region;
                        partMarkers.forEach(function(marker) {
                            if (marker.skipMixed)
                                return;
                            var pos = marker.pos;
                            if (!pos)
                                return console.error("Invalid marker, no position:", marker);
                            pos.sl = pos.el = pos.sl + region.sl;
                            if (pos.sl === region.sl) {
                                pos.sc += region.sc;
                                pos.ec += region.sc;
                            }
                        });
                        markers = markers.concat(partMarkers);
                        nextPart();
                    }
                );
            });
        }, function() {
            endTime(t0, "Analyzed all");
            _self.cachedAsts = cachedAsts;
            if (!minimalAnalysis) {
                _self.scheduleEmit("markers", _self.filterMarkersBasedOnLevel(markers));
            }
            callback();
        });
    };

    this.filterMarkersBasedOnLevel = function(markers) {
        if (disabledFeatures.hints)
            return [];
        for (var i = 0; i < markers.length; i++) {
            var marker = markers[i];
            if (marker.level && WARNING_LEVELS[marker.level] < WARNING_LEVELS[this.$warningLevel]) {
                markers.splice(i, 1);
                i--;
            }
        }
        return markers;
    };

    this.getPart = function (pos) {
        return syntaxDetector.getContextSyntaxPart(this.doc, pos, this.$language);
    };
    this.inspect = function (event) {
        var _self = this;
        var pos = { row: event.data.row, column: event.data.column };
        var part = this.getPart({ row: event.data.row, column: event.data.col });
        if (!part)
            return; // cursor position no longer current
        var partPos = syntaxDetector.posToRegion(part.region, pos);
        this.parse(part, function(ast) {
            _self.findNode(ast, pos, function(node) {
                _self.getPos(node, function(fullPos) {
                    if (!fullPos) {
                        var postfix = completeUtil.retrieveFollowingIdentifier(_self.doc.getLine(pos.row), pos.column);
                        var prefix = completeUtil.retrievePrecedingIdentifier(_self.doc.getLine(pos.row), pos.column);
                        fullPos = { sl: partPos.row, sc: partPos.column - prefix.length, el: partPos.row, ec: partPos.column + postfix.length };
                    }
                    _self.nodeToString(node, function(result) {
                        var lastResult = {
                            pos: fullPos,
                            value: result
                        };
                        var rejected;
                        asyncForEach(_self.handlers, function(handler, next) {
                            if (_self.isHandlerMatch(handler, part, "getInspectExpression")) {
                                handler.language = part.language;
                                handler.getInspectExpression(part, ast, partPos, { node: node, path: _self.$path }, handleCallbackError(function(result) {
                                    if (result) {
                                        result.pos = syntaxDetector.posFromRegion(part.region, result.pos);
                                        lastResult = result || lastResult;
                                    }
                                    else if (!rejected) {
                                        lastResult = {};
                                        rejected = true;
                                    }
                                    next();
                                }));
                            }
                            else {
                                next();
                            }
                        }, function () {
                            if (!lastResult.pos && !lastResult.value)
                                return _self.scheduleEmit("inspect", lastResult);
                            var pos = lastResult.pos;
                            var text = _self.doc.getTextRange({ start: { column: pos.sc, row: pos.sl }, end: { column: pos.ec, row: pos.el }});
                            if (text != lastResult.value) {
                                console.warn("inspect expected ", text, " got ", lastResult.value);
                                lastResult.value = text;
                            }
                            _self.scheduleEmit("inspect", lastResult);
                        });
                    });
                });
            });
        }, true);
    };
    
    this.nodeToString = function(node, callback) {
        if (!node)
            return callback();
        var _self = this;
        this.getPos(node, function(pos) {
            if (!pos)
                return callback();
            var doc = _self.doc;
            if (pos.sl === pos.el)
                return callback(doc.getLine(pos.sl).substring(pos.sc, pos.ec));
            
            var result = doc.getLine(pos.sl).substr(pos.sc);
            for (var i = pos.sl + 1; i < pos.el; i++) {
                result += doc.getLine(i);
            }
            result += doc.getLine(pos.el).substr(0, pos.ec);
            callback(result);
        });
    };
    
    this.getPos = function(node, callback) {
        if (!node)
            return callback();
        var done = false;
        var _self = this;
        this.handlers.forEach(function (h) {
            if (!done && _self.isHandlerMatch(h, null, "getPos", true)) {
                h.getPos(node, function(result) {
                    if (!result)
                        return;
                    done = true;
                    callback(result);
                });
            }
        });
        if (!done)
            callback();
    };
    
    this.getIdentifierRegex = function(pos) {
        var part = pos && this.getPart(pos);
        return identifierRegexes[part ? part.language : this.$language] || completeUtil.DEFAULT_ID_REGEX;
    };
    
    this.getCacheCompletionRegex = function(pos) {
        var part = pos && this.getPart(pos);
        return cacheCompletionRegexes[part ? part.language : this.$language] || completeUtil.DEFAULT_ID_REGEX;
    };
    this.onCursorMove = function(event) {
        var _self = this;
        var pos = event.data.pos;
        var part = this.getPart(pos);
        if (!part)
            return; // cursor position no longer current
        var line = this.doc.getLine(pos.row);
        
        if (line != event.data.line) {
            return this.scheduleEmit("hint", { line: null });
        }

        var result = {
            markers: [],
            hint: null,
            displayPos: null
        };
        
        this.initAllRegexes(part.language);
        
        var posInPart = syntaxDetector.posToRegion(part.region, pos);
        this.parse(part, function(ast) {
            if (!ast)
                return callHandlers(ast, null);
            _self.findNode(ast, pos, function(currentNode) {
                callHandlers(ast, currentNode);
            });
        }, true, true);
        
        function callHandlers(ast, currentNode) {
            asyncForEach(_self.handlers,
                function(handler, next) {
                    if ((pos != _self.lastCurrentPosUnparsed || pos.force) && _self.isHandlerMatch(handler, part, "onCursorMove")) {
                        handler.onCursorMove(part, ast, posInPart, { node: currentNode, path: _self.$path }, handleCallbackError(function(response) {
                            processCursorMoveResponse(response, part, result);
                            next();
                        }));
                    }
                    else {
                        next();
                    }
                },
                function() {
                    _self.lastCurrentPosUnparsed = pos;
                    if (result.markers.length) {
                        _self.scheduleEmit("highlightMarkers", disabledFeatures.instanceHighlight
                            ? []
                            : result.markers
                        );
                        event.data.addedMarkers = result.markers;
                    }
                    if (result.hint !== null) {
                        _self.scheduleEmit("hint", {
                            pos: result.pos,
                            displayPos: result.displayPos,
                            message: result.hint,
                            line: line
                        });
                    }
                    _self.onCursorMoveAnalyzed(event);
                }
            );
        }
    };
    this.onCursorMoveAnalyzed = function(event) {
        var _self = this;
        var pos = event.data.pos;
        var part = this.getPart(pos);
        if (!part)
            return; // cursor position no longer current
        var line = this.doc.getLine(pos.row);
        
        if (line != event.data.line) {
            return this.scheduleEmit("hint", { line: null });
        }
        if (this.updateScheduled) {
            this.postponedCursorMove = event;
            if (event.data.now)
                this.onUpdate(true);
            return;
        }

        var result = {
            markers: event.data.addedMarkers || [],
            hint: null,
            displayPos: null
        };

        var posInPart = syntaxDetector.posToRegion(part.region, pos);
        this.parse(part, function(ast) {
            _self.findNode(ast, pos, function(currentNode) {
                if (pos != _self.lastCurrentPos || currentNode !== _self.lastCurrentNode || pos.force) {
                    callHandlers(ast, currentNode);
                }
            });
        }, true);
        
        function callHandlers(ast, currentNode) {
            asyncForEach(_self.handlers, function(handler, next) {
                if (_self.updateScheduled) {
                    _self.postponedCursorMove = event;
                    return;
                }
                if (_self.isHandlerMatch(handler, part, "tooltip") || _self.isHandlerMatch(handler, part, "highlightOccurrences")) {
                    assert(!handler.onCursorMovedNode, "handler implements onCursorMovedNode; no longer exists");
                    asyncForEach(["tooltip", "highlightOccurrences"], function(method, nextMethod) {
                        handler[method](part, ast, posInPart, { node: currentNode, path: _self.$path }, function(response) {
                            result = processCursorMoveResponse(response, part, result);
                            nextMethod();
                        });
                    }, next);
                }
                else {
                    next();
                }
            }, function() {
                _self.scheduleEmit("highlightMarkers", disabledFeatures.instanceHighlight
                    ? []
                    : result.markers
                );
                _self.lastCurrentNode = currentNode;
                _self.lastCurrentPos = pos;
                _self.scheduleEmit("hint", {
                    pos: result.pos,
                    displayPos: result.displayPos,
                    message: result.hint,
                    line: line
                });
            });
        }
    };
        
    function processCursorMoveResponse(response, part, result) {
        if (!response)
            return result;
        if (response.markers && (!result.markers.found || !response.isGeneric)) {
            if (result.markers.isGeneric)
                result.markers = [];
            result.markers = result.markers.concat(response.markers.map(function (m) {
                var start = syntaxDetector.posFromRegion(part.region, { row: m.pos.sl, column: m.pos.sc });
                var end = syntaxDetector.posFromRegion(part.region, { row: m.pos.el, column: m.pos.ec });
                m.pos = {
                    sl: start.row,
                    sc: start.column,
                    el: end.row,
                    ec: end.column
                };
                return m;
            }));
            result.markers.found = true;
            result.markers.isGeneric = response.isGeneric;
        }
        if (response.hint) {
            if (result.hint)
                result.hint += "\n" + response.hint;
            else
                result.hint = response.hint;
        }
        if (response.pos)
            result.pos = response.pos;
        if (response.displayPos)
            result.displayPos = response.displayPos;
        
        return result;
    }

    this.$getDefinitionDeclarations = function (row, col, callback) {
        var pos = { row: row, column: col };
        var allResults = [];

        var _self = this;
        var part = this.getPart(pos);
        if (!part)
            return; // cursor position no longer current
        var posInPart = syntaxDetector.posToRegion(part.region, pos);

        this.parse(part, function(ast) {
            _self.findNode(ast, pos, function(currentNode) {
                asyncForEach(_self.handlers, function jumptodefNext(handler, next) {
                    if (_self.isHandlerMatch(handler, part, "jumpToDefinition")) {
                        handler.jumpToDefinition(part, ast, posInPart, { node: currentNode, path: _self.$path, language: _self.$language }, handleCallbackError(function(results) {
                            handler.path = _self.$path;
                            if (results)
                                allResults = allResults.concat(results);
                            next();
                        }));
                    }
                    else {
                        next();
                    }
                }, function () {
                    callback(allResults.map(function (pos) {
                        var globalPos = syntaxDetector.posFromRegion(part.region, pos);
                        pos.row = globalPos.row;
                        pos.column = globalPos.column;
                        return pos;
                    }));
                });
            });
        }, true);
    };

    this.jumpToDefinition = function(event) {
        var _self = this;
        var pos = event.data;
        var line = this.doc.getLine(pos.row);
        var regex = this.getIdentifierRegex(pos);
        var identifier = completeUtil.retrievePrecedingIdentifier(line, pos.column, regex)
            + completeUtil.retrieveFollowingIdentifier(line, pos.column, regex);

        _self.$getDefinitionDeclarations(pos.row, pos.column, function(results) {
            _self.sender.emit(
                "definition",
                {
                    pos: pos,
                    results: results || [],
                    path: _self.$path,
                    identifier: identifier
                }
            );
        });
    };
    
    this.quickfix = function(event) {
        var _self = this;
        var pos = event.data;
        var part = this.getPart(pos);
        if (!part)
            return; // cursor position no longer current
        var partPos = syntaxDetector.posToRegion(part.region, pos);
        var allResults = [];
        
        this.parse(part, function(ast) {
            _self.findNode(ast, pos, function(currentNode) {
                asyncForEach(_self.handlers, function(handler, next) {
                    if (_self.isHandlerMatch(handler, part, "getQuickfixes")) {
                        handler.getQuickfixes(part, ast, partPos, { node: currentNode, path: _self.$path }, handleCallbackError(function(results) {
                            if (results)
                                allResults = allResults.concat(results);
                            next();
                        }));
                    }
                    else {
                        next();
                    }
                }, function() {
                    _self.sender.emit("quickfixes_result", {
                        path: _self.$path,
                        results: allResults
                    });
                });
            });
        });
    };

    this.isJumpToDefinitionAvailable = function(event) {
        var _self = this;
        var pos = event.data;

        _self.$getDefinitionDeclarations(pos.row, pos.column, function(results) {
            _self.sender.emit(
                "isJumpToDefinitionAvailableResult",
                { value: !!(results && results.length), path: _self.$path, pos: pos }
            );
        });
    };
    
    this.getRefactorings = function(event) {
        var _self = this;
        var pos = event.data;
        var part = this.getPart(pos);
        if (!part)
            return; // cursor position no longer current
        var partPos = syntaxDetector.posToRegion(part.region, pos);
        
        this.parse(part, function(ast) {
            _self.findNode(ast, pos, function(currentNode) {
                var result;
                asyncForEach(_self.handlers, function(handler, next) {
                    if (_self.isHandlerMatch(handler, part, "getRefactorings")) {
                        handler.getRefactorings(part, ast, partPos, { node: currentNode, path: _self.$path }, handleCallbackError(function(response) {
                            if (response) {
                                assert(!response.enableRefactorings, "Use refactorings instead of enableRefactorings");
                                if (!result || result.isGeneric)
                                    result = response;
                            }
                            next();
                        }));
                    }
                    else {
                        next();
                    }
                }, function() {
                    _self.sender.emit("refactoringsResult", result && result.refactorings || []);
                });
            });
        });
    };

    this.getRenamePositions = function(event) {
        var _self = this;
        var pos = event.data;
        var part = this.getPart(pos);
        if (!part)
            return; // cursor position no longer current
        var partPos = syntaxDetector.posToRegion(part.region, pos);

        function posFromRegion(pos) {
            return syntaxDetector.posFromRegion(part.region, pos);
        }

        this.parse(part, function(ast) {
            _self.findNode(ast, pos, function(currentNode) {
                var result;
                asyncForEach(_self.handlers, function(handler, next) {
                    if (_self.isHandlerMatch(handler, part, "getRenamePositions")) {
                        assert(!handler.getVariablePositions, "handler implements getVariablePositions, should implement getRenamePositions instead");
                        handler.getRenamePositions(part, ast, partPos, { node: currentNode, path: _self.$path }, handleCallbackError(function(response) {
                            if (response) {
                                if (!result || result.isGeneric)
                                    result = response;
                            }
                            next();
                        }));
                    }
                    else {
                        next();
                    }
                }, function() {
                    if (!result)
                        return _self.sender.emit("renamePositionsResult");
                    result.uses = (result.uses || []).map(posFromRegion);
                    result.declarations = (result.declarations || []).map(posFromRegion);
                    result.others = (result.others || []).map(posFromRegion);
                    result.pos = posFromRegion(result.pos);
                    _self.sender.emit("renamePositionsResult", result);
                });
            });
        }, true);
    };

    this.onRenameBegin = function(event) {
        var _self = this;
        this.handlers.forEach(function(handler) {
            if (_self.isHandlerMatch(handler, null, "onRenameBegin"))
                handler.onRenameBegin(_self.doc, function() {});
        });
    };

    this.commitRename = function(event) {
        var _self = this;
        var oldId = event.data.oldId;
        var newName = event.data.newName;
        var isGeneric = event.data.isGeneric;
        var commited = false;
        
        if (oldId.value === newName)
          return this.sender.emit("commitRenameResult", {});

        asyncForEach(this.handlers, function(handler, next) {
            if (_self.isHandlerMatch(handler, null, "commitRename")) {
                handler.commitRename(_self.doc, oldId, newName, isGeneric, handleCallbackError(function(response) {
                    if (response) {
                        commited = true;
                        _self.sender.emit("commitRenameResult", { err: response, oldName: oldId.value, newName: newName });
                    } else {
                        next();
                    }
                }));
            }
            else
                next();
            },
            function() {
                if (!commited)
                    _self.sender.emit("commitRenameResult", {});
            }
        );
    };

    this.onRenameCancel = function(event) {
        var _self = this;
        asyncForEach(this.handlers, function(handler, next) {
            if (_self.isHandlerMatch(handler, null, "onRenameCancel")) {
                handler.onRenameCancel(handleCallbackError(function() {
                    next();
                }));
            }
            else {
                next();
            }
        });
    };

    var updateRunning;
    var updateWatchDog;
    this.onUpdate = function(now) {
        var _self = this;
        
        if (updateRunning) {
            this.updateAgain = { now: now || this.updateAgain && this.updateAgain.now };
            return;
        }
        
        if (this.updateScheduled && !now) {
            return;
        }
        this.updateAgain = null;
        clearTimeout(updateWatchDog);
        clearTimeout(this.updateScheduled);
        this.updateScheduled = null;

        updateWatchDog = setTimeout(function() {
            if (DEBUG)
                return console.error("Warning: worker analysis taking too long or failed to call back (" + _self.$lastAnalyzer + ")");
            _self.updateScheduled = updateRunning = null;
            console.error("Warning: worker analysis taking too long or failed to call back (" + _self.$lastAnalyzer + "), rescheduling");
        }, UPDATE_TIMEOUT_MAX + this.lastUpdateTime);
        
        if (now) {
            doUpdate(function() {
                _self.onUpdate();
            });
            return;
        }
        
        this.updateScheduled = setTimeout(function() {
            _self.updateScheduled = null;
            doUpdate(function() {
                if (_self.updateAgain)
                    _self.onUpdate(_self.updateAgain.now);
            });
        }, UPDATE_TIMEOUT_MIN + Math.min(this.lastUpdateTime, UPDATE_TIMEOUT_MAX));
        
        function doUpdate(done) {
            updateRunning = true;
            var beginUpdate = new Date().getTime();
            _self.asyncForEachHandler(
                { method: "onUpdate" },
                function(handler, next) {
                    var t = startTime();
                    handler.onUpdate(_self.doc, handleCallbackError(function() {
                        endTime(t, "Update: " + handler.$source);
                        next();
                    }));
                },
                function() {
                    _self.analyze(now, function() {
                        if (_self.postponedCursorMove) {
                            _self.onCursorMoveAnalyzed(_self.postponedCursorMove);
                            _self.postponedCursorMove = null;
                        }
                        _self.lastUpdateTime = DEBUG ? 0 : new Date().getTime() - beginUpdate;
                        clearTimeout(updateWatchDog);
                        updateRunning = false;
                        done && done();
                    });
                }
            );
        }
    };
    
    this.$documentToString = function(document) {
        if (!document)
            return "";
        if (Array.isArray(document))
            return document.join("\n");
        if (typeof document == "string")
            return document;
        var array = [];
        for (var i = 0; i < document.byteLength; i++) {
            array.push(document[i]);
        }
        return array.join("\n");
    };

    this.switchFile = function(path, immediateWindow, language, document, pos, workspaceDir) {
        var _self = this;
        var oldPath = this.$path;
        var code = this.$documentToString(document);
        this.$workspaceDir = workspaceDir === "" ? "/" : workspaceDir;
        this.$path = path;
        this.$language = language;
        this.doc.$language = language;
        this.immediateWindow = immediateWindow;
        this.lastCurrentNode = null;
        this.lastCurrentPos = null;
        this.lastCurrentPosUnparsed = null;
        this.cachedAsts = null;
        this.setValue(code);
        this.lastUpdateTime = 0;
        asyncForEach(this.handlers, function(handler, next) {
            _self.$initHandler(handler, oldPath, false, next);
        }, function() {
            _self.onUpdate(true);
        });
    };

    this.$initHandler = function(handler, oldPath, onDocumentOpen, callback) {
        var _self = this;
        handler.path = this.$path;
        handler.language = this.$language;
        handler.workspaceDir = this.$workspaceDir;
        handler.doc = this.doc;
        handler.sender = this.sender;
        handler.completeUpdate = this.completeUpdate.bind(this);
        handler.immediateWindow = this.immediateWindow;
        handler.$getIdentifierRegex = this.getIdentifierRegex.bind(this);
        this.initRegexes(handler, this.$language);
        if (!handler.$isInited) {
            handler.$isInited = true;
            handler.init(handleCallbackError(function() {
                if (handler.handlesLanguage(_self.$language))
                    handler.onDocumentOpen(_self.$path, _self.doc, oldPath, function() {});
                handler.$isInitCompleted = true;
                callback();
            }));
        }
        else if (onDocumentOpen) {
            if (handler.handlesLanguage(_self.$language))
                handler.onDocumentOpen(_self.$path, _self.doc, oldPath, function() {});
            callback();
        }
        else {
            callback();
        }
    };
    
    this.initAllRegexes = function(language) {
        if (this.$initedRegexes[language])
            return;
        this.$initedRegexes[language] = true;
        var that = this;
        this.handlers.forEach(function(h) {
            that.initRegexes(h, language);
        });
    };
    
    this.initRegexes = function(handler, language) {
        if (!handler.handlesLanguage(language))
            return;
        if (handler.getIdentifierRegex()) {
            this.sender.emit("setIdentifierRegex", { language: language, identifierRegex: handler.getIdentifierRegex() });
            identifierRegexes[language] = handler.getIdentifierRegex();
        }
        if (handler.getCacheCompletionRegex()) {
            var regex = handler.getCacheCompletionRegex();
            if (!/\$$/.test(regex.source))
                regex = new RegExp(regex.source + "$");
            this.sender.emit("setCacheCompletionRegex", { language: language, cacheCompletionRegex: regex });
            cacheCompletionRegexes[language] = regex;
        }
        if (handler.getCompletionRegex())
            this.sender.emit("setCompletionRegex", { language: language, completionRegex: handler.getCompletionRegex() });
        if (handler.getTooltipRegex())
            this.sender.emit("setTooltipRegex", { language: language, tooltipRegex: handler.getTooltipRegex() });
    };

    this.documentOpen = function(path, immediateWindow, language, document) {
        this.$openDocuments["_" + path] = path;
        var _self = this;
        var code = this.$documentToString(document);
        var doc = { getValue: function() { return code; } };
        asyncForEach(_self.handlers, function(handler, next) {
            if (!handler.handlesLanguage(language))
                return next();
            handler.onDocumentOpen(path, doc, _self.path, next);
        });
    };
    
    this.documentClose = function(event) {
        var path = event.data;
        delete this.$openDocuments["_" + path];
        this.asyncForEachHandler({ method: "onDocumentClose" }, function(handler, next) {
            handler.onDocumentClose(path, next);
        }, function() {});
    };
    function removeDuplicateMatches(matches) {
        matches.sort(function(a, b) {
            if (a.name < b.name)
                return -1;
            else if (a.name > b.name)
                return 1;
            else
                return 0;
        });
        for (var i = 0; i < matches.length - 1; i++) {
            var a = matches[i];
            var b = matches[i + 1];
            
            if (a.name === b.name || (a.id || a.name) === (b.id || b.name)) {
                if (a.isContextual && !b.isContextual)
                    matches.splice(i + 1, 1);
                else if (!a.isContextual && b.isContextual)
                    matches.splice(i, 1);
                else if (a.isGeneric && !b.isGeneric)
                    matches.splice(i, 1);
                else if (!a.isGeneric && b.isGeneric)
                    matches.splice(i + 1, 1);
                else if (a.priority < b.priority)
                    matches.splice(i, 1);
                else if (a.priority > b.priority)
                    matches.splice(i + 1, 1);
                else if (a.score < b.score)
                    matches.splice(i, 1);
                else if (a.score > b.score)
                    matches.splice(i + 1, 1);
                else
                    matches.splice(i, 1);
                i--;
            }
        }
    }

    this.complete = function(event) {
        var _self = this;
        var options = event.data;
        var pos = options.pos;
        
        _self.waitForCompletionSync(options, function doComplete(identifierRegex) {
            var cacheCompletionRegex = _self.getCacheCompletionRegex(pos);
            var overrideLine = cacheCompletionRegex && _self.tryShortenCompletionPrefix(_self.doc.getLine(pos.row), pos.column, identifierRegex);
            var overridePos = overrideLine != null && { row: pos.row, column: pos.column - 1 };
        
            var newCache = _self.tryCachedCompletion(overridePos || pos, overrideLine, identifierRegex, cacheCompletionRegex, options);
            if (!newCache || options.predictOnly) {
                if (options.predictOnly || _self.completionCache.result)
                    _self.predictNextCompletion(_self.completionCache, pos, identifierRegex, cacheCompletionRegex, options);
                return;
            }
            
            _self.completionCache = newCache;
            _self.getCompleteHandlerResult(overridePos || pos, overrideLine, identifierRegex, options, function(result) {
                if (!result) return;
                _self.sender.emit("complete", result);
                newCache.setResult(result);
                _self.predictNextCompletion(newCache, pos, identifierRegex, cacheCompletionRegex, options);
            });
        });
    };
    
    this.tryShortenCompletionPrefix = function(line, offset, identifierRegex) {
        for (var i = 0; i < this.handlers.length; i++) {
            if (this.handlers[i].$disableZeroLengthCompletion && this.handlers[i].handlesLanguage(this.$language))
                return;
        }
        if (identifierRegex.test(line[offset - 1] || "") && !identifierRegex.test(line[offset - 2] || ""))
            return line.substr(0, offset - 1) + line.substr(offset);
    };
    this.getCompleteHandlerResult = function(pos, overrideLine, identifierRegex, options, callback) {
        var _self = this;
        var matches = [];
        var hadError = false;
        var originalLine = _self.doc.getLine(pos.row);
        var line = overrideLine != null ? overrideLine : originalLine;
        var part = syntaxDetector.getContextSyntaxPart(_self.doc, pos, _self.$language);
        if (!part)
            return callback(); // cursor position not current
        var partPos = syntaxDetector.posToRegion(part.region, pos);
        var tStart = startTime();
        
        startOverrideLine();
        _self.parse(part, function(ast) {
            endTime(tStart, "Complete: parser");
            _self.findNode(ast, pos, function(currentNode) {
                var handlerOptions = {
                    noDoc: options.noDoc,
                    node: currentNode,
                    language: _self.$language,
                    path: _self.$path,
                    line: line,
                    get identifierPrefix() {
                        return completeUtil.retrievePrecedingIdentifier(line, pos.column, identifierRegex);
                    },
                };
                _self.asyncForEachHandler(
                    { part: part, method: "complete" },
                    function(handler, next) {
                        handler.language = part.language;
                        handler.workspaceDir = _self.$workspaceDir;
                        handler.path = _self.$path;
                        var t = startTime();

                        var originalLine2 = _self.doc.getLine(pos.row);
                        startOverrideLine();
                        handler.complete(part, ast, partPos, handlerOptions, handleCallbackError(function(completions, handledErr) {
                            endTime(t, "Complete: " + handler.$source.replace("plugins/", ""), 1);
                            if (completions && completions.length)
                                matches = matches.concat(completions);
                            hadError = !!(hadError || handledErr);
                            next();
                        }));
                        endOverrideLine(originalLine2);
                    },
                    function() {
                        removeDuplicateMatches(matches);
                        matches.sort(function(a, b) {
                            if (a.priority < b.priority)
                                return 1;
                            else if (a.priority > b.priority)
                                return -1;
                            else if (a.score < b.score)
                                return 1;
                            else if (a.score > b.score)
                                return -1;
                            else if (a.id && a.id === b.id) {
                                if (a.isFunction)
                                    return -1;
                                else if (b.isFunction)
                                    return 1;
                            }
                            if (a.name < b.name)
                                return -1;
                            else if (a.name > b.name)
                                return 1;
                            else
                                return 0;
                        });
                        endTime(tStart, "COMPLETED!");
                        callback({
                            pos: pos,
                            matches: matches,
                            isUpdate: options.isUpdate,
                            noDoc: options.noDoc,
                            hadError: hadError,
                            line: line,
                            path: _self.$path,
                            forceBox: options.forceBox,
                            deleteSuffix: options.deleteSuffix
                        }
                    );
                });
            });
        });
        endOverrideLine(originalLine);
        function startOverrideLine() {
            if (overrideLine != null)
                _self.doc.$lines[pos.row] = overrideLine;
            
            _self.$overrideLine = overrideLine;
            _self.$lastCompleteRow = pos.row;
        }
        
        function endOverrideLine(line) {
            _self.$overrideLine = null;
            _self.doc.$lines[pos.row] = line;
        }
    };
    this.tryCachedCompletion = function(pos, overrideLine, identifierRegex, cacheCompletionRegex, options) {
        var that = this;
        var cacheKey = this.getCompleteCacheKey(pos, overrideLine, identifierRegex, cacheCompletionRegex, options);
        
        if (options.isUpdate) {
            if (cacheKey.isCompatible(this.completionCache))
                return this.completionCache;
            if (cacheKey.isCompatible(this.completionPrediction))
                return this.completionPrediction;
        }
    
        if (cacheKey.isCompatible(this.completionCache) && !isRecompletionRequired(this.completionCache)) {
            if (this.completionCache.result)
                cacheHit(this.completionCache);
            else
                this.completionCache.resultCallbacks.push(cacheHit);
            return;
        }
    
        if (cacheKey.isCompatible(this.completionPrediction) && !isRecompletionRequired(this.completionPrediction)) {
            this.completionCache = this.completionPrediction;
            if (this.completionCache.result)
                cacheHit(this.completionCache);
            else
                this.completionCache.resultCallbacks.push(cacheHit);
            return;
        }
        
        return cacheKey;
            
        function cacheHit(cache) {
            if (options.predictOnly)
                return;
                
            updateLocalCompletions(that.doc, that.$path, pos, cache.result.matches, function sendCached(err, matches) {
                if (err) {
                    console.error(err);
                    matches = cache.result.matches;
                }
                that.sender.emit("complete", {
                    line: overrideLine != null ? overrideLine : that.doc.getLine(pos.row),
                    forceBox: options.forceBox,
                    isUpdate: options.isUpdate,
                    matches: matches,
                    path: that.$path,
                    pos: pos,
                    noDoc: cache.result.noDoc,
                    deleteSuffix: options.deleteSuffix,
                });
            });
        }
        
        function isRecompletionRequired(cache) {
            var recomputeLength = -1;
            var recomputeAtOffset1 = false;
            for (var i = 0; i < that.handlers.length; i++) {
                if (that.handlers[i].$recacheCompletionLength && that.handlers[i].handlesLanguage(that.$language))
                    recomputeLength = that.handlers[i].$recacheCompletionLength;
                if (that.handlers[i].$disableZeroLengthCompletion && that.handlers[i].handlesLanguage(that.$language))
                    recomputeAtOffset1 = true;
            }
            
            if (recomputeAtOffset1 && cacheKey.prefix.length >= 1 && cache.prefix.length === 0)
                return true;
            
            return cacheKey.prefix.length >= recomputeLength && cache.prefix.length < recomputeLength;
        }
    };
    this.predictNextCompletion = function(cacheKey, pos, identifierRegex, cacheCompletionRegex, options) {
        if (options.isUpdate)
            return;
        
        var _self = this;
        var predictedString;
        var showEarly;
        var line = _self.doc.getLine(pos.row);
        var prefix = completeUtil.retrievePrecedingIdentifier(line, pos.column, identifierRegex);
        
        this.asyncForEachHandler(
            { method: "predictNextCompletion" },
            function preparePredictionInput(handler, next) {
                var handlerOptions = {
                    matches: options.predictOnly ? [] : getFilteredMatches(),
                    path: _self.$path,
                    language: _self.$language,
                    line: line,
                    identifierPrefix: prefix,
                };
                handler.predictNextCompletion(_self.doc, null, pos, handlerOptions, handleCallbackError(function(result) {
                    if (result != null) {
                        predictedString = result.predicted;
                        showEarly = result.showEarly;
                    }
                    next();
                }));
            },
            function computePrediction() {
                if (predictedString == null)
                    return;
                
                var predictedLine = line.substr(0, pos.column - prefix.length)
                    + predictedString
                    + line.substr(pos.column);
                var predictedPos = { row: pos.row, column: pos.column - prefix.length + predictedString.length };
                
                var predictionKey = _self.getCompleteCacheKey(predictedPos, predictedLine, identifierRegex, cacheCompletionRegex, options);
                if (_self.completionPrediction && _self.completionPrediction.isCompatible(predictionKey))
                    return;
                if (_self.completionCache && _self.completionCache.isCompatible(predictionKey))
                    return;
                _self.completionPrediction = predictionKey;

                _self.getCompleteHandlerResult(predictedPos, predictedLine, identifierRegex, options, function(result) {
                    predictionKey.setResult(result);
                    if (showEarly && cacheKey.isCompatible(_self.completionCache))
                        showPredictionsEarly(result);
                });
            }
        );
        
        var filteredMatches;
        function getFilteredMatches() {
            if (filteredMatches)
                return filteredMatches;
            var prefix = completeUtil.retrievePrecedingIdentifier(line, pos.column, identifierRegex);
            filteredMatches = cacheKey.result.matches.filter(function(m) {
                m.replaceText = m.replaceText || m.name;
                return m.replaceText.indexOf(prefix) === 0;
            });
            return filteredMatches;
        }
        
        function showPredictionsEarly(prediction) {
            var newMatches = prediction.matches.filter(function(m) { return m.isContextual; });
            if (!newMatches.length)
                return;
            [].push.apply(_self.completionCache.result.matches, newMatches.map(function(m) {
                m = Object.assign({}, m);
                m.replaceText = predictedString + m.replaceText;
                m.name = predictedString + m.name;
                return m;
            }));
            _self.sender.emit("complete", _self.completionCache.result);
        }
    };
    this.getCompleteCacheKey = function(pos, overrideLine, identifierRegex, cacheCompletionRegex, options) {
        var worker = this;
        var doc = this.doc;
        var path = this.$path;
        var originalLine = doc.getLine(pos.row);
        var line = overrideLine != null ? overrideLine : originalLine;
        var prefix = completeUtil.retrievePrecedingIdentifier(line, pos.column, identifierRegex);
        var suffix = completeUtil.retrieveFollowingIdentifier(line, pos.column, identifierRegex);
        var completeLine = removeCacheCompletionPrefix(
            line.substr(0, pos.column - prefix.length) + line.substr(pos.column + suffix.length));
        
        var completeLines = doc.$lines.slice();
        completeLines[pos.row] = null;
        
        var completePos = { row: pos.row, column: pos.column - prefix.length };
        return {
            result: null,
            resultCallbacks: [],
            line: completeLine,
            lines: completeLines,
            pos: completePos,
            prefix: prefix,
            path: path,
            noDoc: options.noDoc,
            setResult: function(result) {
                var cacheKey = this;
                this.result = result;
                this.resultCallbacks.forEach(function(c) {
                    c(cacheKey);
                });
                if (result.hadError && worker.completionCache === this)
                    worker.completionCache = null;
                if (result.hadError && worker.completionPrediction === this)
                    worker.completionPrediction = null;
            },
            isCompatible: function(other) {
                return other
                    && other.path === this.path
                    && other.pos.row === this.pos.row
                    && other.pos.column === this.pos.column
                    && other.line === this.line
                    && (!other.noDoc || this.noDoc)
                    && this.prefix.indexOf(other.prefix) === 0 // match if they're like foo and we're fooo
                    && other.lines.length === completeLines.length
                    && other.lines[this.pos.row - 1] === completeLines[this.pos.row - 1]
                    && other.lines[this.pos.row + 1] === completeLines[this.pos.row + 1]
                    && other.lines.every(function(l, i) {
                        return l === completeLines[i];
                    });
            }
        };
        
        function removeCacheCompletionPrefix(line) {
            if (!cacheCompletionRegex)
                return line;
            var match = cacheCompletionRegex.exec(line.substr(0, pos.column - prefix.length));
            if (!match)
                return line;
            pos = { row: pos.row, column: pos.column - match[0].length };
            return line.substr(0, line.length - match[0].length);
        }
    };
    this.waitForCompletionSync = function(options, runCompletion) {
        var _self = this;
        var pos = options.pos;
        var line = _self.doc.getLine(pos.row);
        this.waitForCompletionSyncThread = this.waitForCompletionSyncThread || 0;
        var threadId = ++this.waitForCompletionSyncThread;
        var identifierRegex = this.getIdentifierRegex(pos);
        if (!completeUtil.canCompleteForChangedLine(line, options.line, pos, pos, identifierRegex)) {
            setTimeout(function() {
                if (threadId !== _self.waitForCompletionSyncThread)
                    return;
                line = _self.doc.getLine(pos.row);
                if (!completeUtil.canCompleteForChangedLine(line, options.line, pos, pos, identifierRegex)) {
                    setTimeout(function() {
                        if (threadId !== _self.waitForCompletionSyncThread)
                            return;
                        line = _self.doc.getLine(pos.row);
                        if (!completeUtil.canCompleteForChangedLine(line, options.line, pos, pos, identifierRegex)) {
                            if (!line) { // sanity check
                                console.log("worker: seeing an empty line in my copy of the document, won't complete");
                            }
                            return console.log("worker: dropped completion request as my copy of the document said: " + line); // ugh give up already
                        }
                        runCompletion(identifierRegex);
                    }, 20);
                    return;
                }
                runCompletion(identifierRegex);
            }, 5);
            return;
        }
        runCompletion(identifierRegex);
    };
    this.completeUpdate = function(pos, line) {
        assert(line !== undefined);
        this.completionCache = null;
        if (!isInWebWorker) { // Avoid making the stack too deep in ?noworker=1 mode
            var _self = this;
            setTimeout(function onCompleteUpdate() {
                _self.complete({ data: { pos: pos, line: line, isUpdate: true }});
            }, 0);
        }
        else {
            this.complete({ data: { pos: pos, line: line, isUpdate: true, forceBox: true }});
        }
    };
    function updateLocalCompletions(doc, path, pos, matches, callback) {
        if (matches.some(function(m) {
            return m.isContextual;
        }))
            return callback(null, matches);

        localCompleter.complete(doc, null, pos, null, function(err, results1) {
            if (err) return callback(err);
            openFilesCompleter.complete(doc, null, pos, { path: path }, function(err, results2) {
                if (err) console.error(err);

                callback(null, matches.filter(function(m) {
                    return m.$source !== "local" && m.$source !== "open_files";
                }).concat(results1, results2));
            });
        });
    }
    
    function reportError(exception, data) {
        if (data)
            exception.data = data;
        setTimeout(function() {
            throw exception; // throw bare exception so it gets reported
        });
    }
    
    function handleCallbackError(callback) {
        return function(optionalErr, result) {
            if (optionalErr &&
                (optionalErr instanceof Error || typeof optionalErr === "string" || optionalErr.stack || optionalErr.code)) {
                if (optionalErr.code !== "ESUPERSEDED")
                    console.error(optionalErr.stack || optionalErr);
                return callback(null, optionalErr);
            }
            callback(optionalErr || result);
        };
    }

}).call(LanguageWorker.prototype);

});

define("plugins/c9.ide.language.javascript/JSResolver",[], function(require, exports, module) {
  "use strict";

  var Range = require("ace/range").Range;

  var JSResolver = function(value, ast) {
    this.addResolutions = function(markers) {
      var _self = this;
      markers.forEach(function(curMarker) {
        curMarker.resolutions = _self.getResolutions(curMarker);
      });
    };
    
    this.getResolutions = function(marker) {
      var type = this.getType(marker);
      if (type) {
        if (typeof this[type] === 'function') {
          return this[type](marker);
        }
      }
      return [];
    }; 

    this.getType = function(marker) {
        var msg = marker.message;
        if (msg.indexOf("Missing semicolon") !== -1) {
            return "missingSemicolon";
        }
        else if (msg.indexOf("Unnecessary semicolon") !== -1) {
            return "unnecessarySemicolon";
        }
    }; 
    
    this.missingSemicolon = function(marker) {
        var message = "Add semicolon";
        var image = "";
        var row = marker.pos.sl;
        var column = marker.pos.sc;
        
        var lines = value.split("\n");
        var before = lines[row].substring(0, column);
        var after = lines[row].substring(column);
        var preview = "<b>Add semicolon</b><p>" + before + "<b>; </b>" + after + "</p>";
        
        var insert = ";";
        if (after.length) {
            insert += " ";
        }

        var delta = {
            action: "insert",
            range: new Range(row, column, row, column + insert.length),
            text: insert
        };
        
        return [{
            message: message,
            image: image,
            previewHtml: preview,
            deltas: [delta]
        }];
    };
    
    this.unnecessarySemicolon = function(marker) {
        var message = "Remove semicolon";
        var image = "";
        var row = marker.pos.sl;
        var column = marker.pos.sc;
        
        var lines = value.split("\n");
        var before = lines[row].substring(0, column);
        var after = lines[row].substring(column + 1);
        var preview = "<b>Remove semicolon</b><p>" + before + "<del>;</del>" + after + "</p>";

        var delta = {
            action: "removeText",
            range: new Range(row, column, row, column + 1)
        };
        
        return [{
            message: message,
            image: image,
            preview: preview,
            deltas: [delta]
        }];
    };

  };

  exports.JSResolver = JSResolver;

});

define("plugins/c9.ide.language.javascript/scope_analyzer",[], function(require, exports, module) {

var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');
var completeUtil = require("plugins/c9.ide.language/complete_util");
var handler = module.exports = Object.create(baseLanguageHandler);
var JSResolver = require('plugins/c9.ide.language.javascript/JSResolver').JSResolver;
require("treehugger/traverse"); // add traversal functions to trees

var CALLBACK_METHODS = ["forEach", "map", "reduce", "filter", "every", "some",
    "__defineGetter__", , "__defineSetter__"];
var CALLBACK_FUNCTIONS = ["require", "setTimeout", "setInterval"];
var PROPER = module.exports.PROPER = 80;
var MAYBE_PROPER = module.exports.MAYBE_PROPER = 1;
var NOT_PROPER = module.exports.NOT_PROPER = 0;
var KIND_EVENT = module.exports.KIND_EVENT = "event";
var KIND_PACKAGE = module.exports.KIND_PACKAGE = "package";
var KIND_HIDDEN = module.exports.KIND_HIDDEN = "hidden";
var KIND_DEFAULT = module.exports.KIND_DEFAULT = undefined;
var IN_CALLBACK_DEF = 1;
var IN_CALLBACK_BODY = 2;
var IN_CALLBACK_BODY_MAYBE = 3;

var lastValue;
var lastAST;
var GLOBALS = {
    "true": true,
    "false": true,
    "undefined": true,
    "null": true,
    "arguments": true,
    "Infinity": true,
    onmessage: true,
    postMessage: true,
    importScripts: true,
    "continue": true,
    "return": true,
    "else": true,
    ArrayBuffer: true,
    Attr: true,
    Audio: true,
    addEventListener: true,
    applicationCache: true,
    blur: true,
    clearInterval: true,
    clearTimeout: true,
    close: true,
    closed: true,
    DataView: true,
    defaultStatus: true,
    document: true,
    event: true,
    FileReader: true,
    Float32Array: true,
    Float64Array: true,
    FormData: true,
    getComputedStyle: true,
    Int16Array: true,
    Int32Array: true,
    Int8Array: true,
    parent: true,
    print: true,
    removeEventListener: true,
    resizeBy: true,
    resizeTo: true,
    self: true,
    screen: true,
    scroll: true,
    scrollBy: true,
    scrollTo: true,
    sessionStorage: true,
    setInterval: true,
    setTimeout: true,
    SharedWorker: true,
    Uint16Array: true,
    Uint32Array: true,
    Uint8Array: true,
    WebSocket: true,
    window: true,
    Worker: true,
    XMLHttpRequest: true,
    alert: true,
    confirm: true,
    console: true,
    prompt: true,
    define: true,
    __filename: true,
    __dirname: true,
    Buffer: true,
    exports: true,
    GLOBAL: true,
    global: true,
    module: true,
    process: true,
    require: true,
    Array: true,
    Boolean: true,
    Date: true,
    decodeURI: true,
    decodeURIComponent: true,
    encodeURI: true,
    encodeURIComponent: true,
    Error: true,
    'eval': true,
    EvalError: true,
    Function: true,
    hasOwnProperty: true,
    isFinite: true,
    isNaN: true,
    JSON: true,
    Math: true,
    Number: true,
    Object: true,
    parseInt: true,
    parseFloat: true,
    RangeError: true,
    ReferenceError: true,
    RegExp: true,
    String: true,
    requestAnimationFrame: true,
    SyntaxError: true,
    TypeError: true,
    URIError: true,
    escape: true,
    unescape: true,
    Match: true,
    MeteorSubscribeHandle: true,
    Accounts: true,
    Blaze: true,
    DDP: true,
    EJSON: true,
    Meteor: true,
    Mongo: true,
    Tracker: true,
    Assets: true,
    App: true,
    Plugin: true,
    Package: true,
    Npm: true,
    Cordova: true,
    currentUser: true,
    loggingIn: true,
    Template: true,
    MethodInvocation: true,
    Subscription: true,
    CompileStep: true,
    check: true,
    Email: true,
    HTTP: true,
    ReactiveVar: true,
    Session: true,
    PackageAPI: true,
};

var KEYWORDS = [
    "break",
    "const",
    "continue",
    "delete",
    "do",
    "while",
    "export",
    "for",
    "in",
    "function",
    "if",
    "else",
    "import",
    "instanceof",
    "new",
    "return",
    "switch",
    "this",
    "throw",
    "try",
    "catch",
    "typeof",
    "void",
    "with",
    "debugger"
];
handler.GLOBALS = GLOBALS;

handler.addGlobals = function(globals) {
    globals.forEach(function(g) {
        GLOBALS[g] = true;
    });
};

handler.handlesLanguage = function(language) {
    return language === "javascript" || language === "jsx";
};
 
handler.getResolutions = function(value, ast, markers, callback) {
    var resolver = new JSResolver(value, ast);
    resolver.addResolutions(markers);
    callback(markers);
};

handler.getMaxFileSizeSupported = function() {
    return .25 * 10 * 1000 * 80;
};

var scopeId = 0;

var Variable = module.exports.Variable = function Variable(declaration) {
    this.declarations = [];
    if (declaration)
        this.declarations.push(declaration);
    this.uses = [];
    this.values = [];
};

Variable.prototype.addUse = function(node) {
    this.uses.push(node);
};

Variable.prototype.addDeclaration = function(node) {
    this.declarations.push(node);
};

Variable.prototype.markProperDeclaration = function(confidence) {
    if (!confidence)
        return;
    else if (!this.properDeclarationConfidence)
        this.properDeclarationConfidence = confidence;
    else if (this.properDeclarationConfidence < PROPER)
        this.properDeclarationConfidence += confidence;
};

Variable.prototype.isProperDeclaration = function() {
    return this.properDeclarationConfidence > MAYBE_PROPER;
};
var Scope = module.exports.Scope = function Scope(parent) {
    this.id = scopeId++;
    this.parent = parent;
    this.vars = {};
};
Scope.prototype.declare = function(name, resolveNode, properDeclarationConfidence, kind) {
    var result;
    var vars = this.getVars(kind);
    if (!vars['_' + name]) {
        result = vars['_' + name] = new Variable(resolveNode);
    }
    else if (resolveNode) {
        result = vars['_' + name];
        result.addDeclaration(resolveNode);
    }
    if (result) {
        result.markProperDeclaration(properDeclarationConfidence);
        result.kind = kind;
    }
    return result;
};

Scope.prototype.declareAlias = function(kind, originalName, newName) {
    var vars = this.getVars(kind);
    vars["_" + newName] = vars["_" + originalName];
};

Scope.prototype.getVars = function(kind) {
    if (kind)
        return this.vars[kind] = this.vars[kind] || {};
    else
        return this.vars;
};

Scope.prototype.isDeclared = function(name) {
    return !!this.get(name);
};
Scope.prototype.get = function(name, kind) {
    var vars = this.getVars(kind);
    if (vars['_' + name])
        return vars['_' + name];
    else if (this.parent)
        return this.parent.get(name, kind);
};

Scope.prototype.getVariableNames = function() {
    return this.getNamesByKind(KIND_DEFAULT);
};

Scope.prototype.getNamesByKind = function(kind) {
    var results = [];
    var vars = this.getVars(kind);
    for (var v in vars) {
        if (vars.hasOwnProperty(v) && v !== KIND_HIDDEN && v !== KIND_PACKAGE)
            results.push(v.slice(1));
    }
    if (this.parent) {
        var namesFromParent = this.parent.getNamesByKind(kind);
        for (var i = 0; i < namesFromParent.length; i++) {
            results.push(namesFromParent[i]);
        }
    }
    return results;
};

var SCOPE_ARRAY = Object.keys(GLOBALS).concat(KEYWORDS);

handler.getIdentifierRegex = function() {
    return (/[a-zA-Z_0-9\$\/]/);
};

handler.complete = function(doc, ast, pos, options, callback) {
    if (!options.node || options.node.cons === "Var" || options.line[pos.column] === ".")
        return callback();

    var identifier = options.identifierPrefix;
    
    var matches = completeUtil.findCompletions(identifier, SCOPE_ARRAY);
    callback(matches.map(function(m) {
        return {
          name: m,
          replaceText: m,
          icon: null,
          meta: "EcmaScript",
          priority: 0,
          isGeneric: true
        };
    }));
};
handler.analyze = function(value, ast, callback, minimalAnalysis) {
    var handler = this;
    var markers = [];
    
    if (minimalAnalysis && value === lastValue && lastAST == ast)
        return callback();
    lastValue = value;
    lastAST = ast;
    function preDeclareHoisted(scope, node) {
        node.traverseTopDown(
            'VarDecl(x)', 'ConstDecl(x)', 'LetDecl(x)', function(b, node) {
                node.setAnnotation("scope", scope);
                scope.declare(b.x.value, b.x, PROPER);
                return node;
            },
            'VarDeclInit(x, e)', 'ConstDeclInit(x, e)', 'LetDeclInit(x, e)', function(b, node) {
                node.setAnnotation("scope", scope);
                scope.declare(b.x.value, b.x, PROPER);
            },
            'Function(x, _, _)', function(b, node) {
                node.setAnnotation("scope", scope);
                if (b.x.value) {
                    scope.declare(b.x.value, b.x, PROPER);
                }
                return node;
            },
            'ImportDecl(_, x)', 'ImportBatchDecl(x)', function(b, node) {
                if (b.x.cons !== "Var")
                    return node;
                scope.declare(b.x[0].value, b.x[0], PROPER);
                return node;
            }
        );
    }
    
    function scopeAnalyzer(scope, node, parentLocalVars, inCallback) {
        preDeclareHoisted(scope, node);
        node.setAnnotation("scope", scope);
        function analyze(scope, node, inCallback) {
            node.traverseTopDown(
                'Assign(Var(x), e)', function(b, node) {		
                    if (scope.isDeclared(b.x.value)) {
                        node[0].setAnnotation("scope", scope);		
                        scope.get(b.x.value).addUse(node[0]);		
                    }		
                    analyze(scope, b.e, inCallback);		
                    return node;		
                },
                'ImportDecl(_, x)', 'ImportBatchDecl(x)', function(b, node) {
                    return node;
                },
                'Var(x)', function(b, node) {
                    node.setAnnotation("scope", scope);
                    if (scope.isDeclared(b.x.value)) {
                        scope.get(b.x.value).addUse(node);
                    }
                    else if (b.x.value === "self"
                        && !scope.isDeclared(b.x.value)
                        && handler.isFeatureEnabled("undeclaredVars")) {
                        markers.push({
                            pos: this.getPos(),
                            level: 'warning',
                            type: 'warning',
                            message: "Use 'window.self' to refer to the 'self' global."
                        });
                        return;
                    }
                    return node;
                },
                'Function(x, fargs, body)', function(b, node) {
                    var newScope = new Scope(scope);
                    node.setAnnotation("localScope", newScope);
                    newScope.declare("this");
                    b.fargs.forEach(function(farg) {
                        farg.setAnnotation("scope", newScope);
                        newScope.declare(farg[0].value, farg);
                    });
                    var inBody = inCallback === IN_CALLBACK_DEF ? IN_CALLBACK_BODY : isCallback(node);
                    scopeAnalyzer(newScope, b.body, null, inBody);
                    return node;
                },
                'Arrow(fargs, body)', function(b, node) {
                    var newScope = new Scope(scope);
                    node.setAnnotation("localScope", newScope);
                    newScope.declare("this");
                    b.fargs.forEach(function(farg) {
                        farg.setAnnotation("scope", newScope);
                        newScope.declare(farg[0].value, farg);
                    });
                    scopeAnalyzer(newScope, b.body, null, inCallback);
                    return node;
                },
                'Catch(x, body)', function(b, node) {
                    var oldVar = scope.get(b.x.value);
                    scope.vars["_" + b.x.value] = new Variable(b.x);
                    scopeAnalyzer(scope, b.body, parentLocalVars, inCallback);
                    scope.vars["_" + b.x.value] = oldVar;
                    return node;
                },
                'If(Var("err"), Call(fn, args), None())', function(b, node) {
                    if (b.args.collectTopDown('Var("err")').length > 0 &&
                        !b.fn.isMatch('PropAccess(Var("console"), _)') &&
                        !b.fn.isMatch('PropAccess(_, "log")'))
                        markers.push({
                            pos: b.fn.getPos(),
                            type: 'warning',
                            level: 'warning',
                            message: "Did you forget a 'return' here?"
                        });
                },
                'PropAccess(_, "lenght")', function(b, node) {
                    markers.push({
                        pos: node.getPos(),
                        type: 'warning',
                        level: 'warning',
                        message: "Did you mean 'length'?"
                    });
                },
                'Call(PropAccess(e1, "bind"), e2)', function(b) {
                    analyze(scope, b.e1, 0);
                    analyze(scope, b.e2, inCallback);
                    return this;
                },
                'Call(e, args)', function(b, node) {
                    analyze(scope, b.e, inCallback);
                    var newInCallback = inCallback || (isCallbackCall(node) ? IN_CALLBACK_DEF : 0);
                    analyze(scope, b.args, newInCallback);
                    return node;
                },
                'Block(_)', function(b, node) {
                    node.setAnnotation("scope", scope);
                },
                'For(e1, e2, e3, body)', function(b) {
                    analyze(scope, b.e1, inCallback);
                    analyze(scope, b.e2, inCallback);
                    analyze(scope, b.body, inCallback);
                    analyze(scope, b.e3, inCallback);
                    return node;
                },
                'ForIn(e1, e2, body)', 'ForOf(e1, e2, body)', function(b) {
                    analyze(scope, b.e2, inCallback);
                    analyze(scope, b.e1, inCallback);
                    analyze(scope, b.body, inCallback);
                    return node;
                }
            );
        }
        analyze(scope, node, inCallback);
    }
    
    if (ast) {
        var rootScope = new Scope();
        scopeAnalyzer(rootScope, ast);
        addDefineWarnings(ast, markers);
    }
    return callback(markers);
};

function addDefineWarnings(ast, markers) {
    var isArchitect;
    var outerStrictNode;
    ast.forEach(function(node) {
        node.rewrite(
            'String("use strict")', function(b, node) {
                outerStrictNode = node;
            },
            'Call(Var("define"), [Function(_, _, body)])', function(b, node) {
                b.body.forEach(function(node) {
                    if (outerStrictNode) {
                        markers.push({
                            pos: outerStrictNode.getPos(),
                            type: 'warning',
                            level: 'warning',
                            message: '"use strict" outside define()'
                        });
                    }

                    node.rewrite(
                        'Assign(PropAccess(Var("main"), "provides"),_)', function(b, node) {
                            isArchitect = true;
                        },
                        'Function("main", _, body)', function(b, node) {
                            if (!isArchitect)
                                return;
                            addCloud9PluginWarnings(b.body, markers);
                        }
                    );
                });
            }
        );
    });
}

function addCloud9PluginWarnings(body, markers) {
    var isCoreSource = /plugins\/c9\./.test(handler.path);
    var pluginVars = {};
    var unloadFunction;
    var unloadReference;
    var maybeUnloadFunction;

    body.forEach(function(node) {
        node.rewrite(
            'VarDecls(vars)', function(b, node) {
                b.vars.forEach(function(v) {
                    v.rewrite(
                        'VarDecl(x)', 'LetDecl(x)',
                        'VarDeclInit(x, _)', 'LetDeclInit(x, _)',
                        function(b, node) {
                            pluginVars[b.x.value] = node;
                        }
                    );
                });
            },
            'Call(PropAccess(Var("plugin"), "on"), [String("unload"), Function(_, _, fn)])', function(b, node) {
                unloadFunction = b.fn;
            },
            'Call(PropAccess(Var("plugin"), "on"), [String("unload"), ref])', function(b, node) {
                unloadReference = b.ref;
            },
            'Function("unload", _, fn)', function(b, node) {
                maybeUnloadFunction = b.fn;
            }
        );
    });

    if (!unloadFunction && unloadReference && maybeUnloadFunction
        && unloadReference[0] && unloadReference[0].value === "unload")
        unloadFunction = maybeUnloadFunction;

    if (!unloadFunction) {
        if (pluginVars.plugin && !unloadReference) {
            markers.push({
                pos: pluginVars.plugin.getPos(),
                type: isCoreSource ? "info" : "warning",
                message:
                    isCoreSource
                        ? "No plugin.on(\"load\", function() {}) and/or plugin.on(\"unload\", function() {}) found"
                        : "Missing plugin.on(\"load\", function() {}) or plugin.on(\"unload\", function() {})"
            });
        }
        return;
    }

    var mustUninitVars = {};
    body.traverseTopDown(
        'Assign(Var(x), _)', 'Call(Var(x), "push", _)', function(b, node) {
            if (pluginVars[b.x.value])
                mustUninitVars[b.x.value] = pluginVars[b.x.value];
        }
    );
    
    unloadFunction.traverseTopDown(
        'Var(x)', function(b, node) {
            delete mustUninitVars[b.x.value];
        }
    );

    for (var v in mustUninitVars) {
        if (v === v.toUpperCase())
            continue;
        markers.push({
            pos: mustUninitVars[v].getPos(),
            type: isCoreSource ? "info" : "warning",
            message: "Plugin state; please uninit/reset '" + v + "' in plugin unload function"
        });
    }
}
var isCallbackCall = function(node) {
    var result;
    node.rewrite(
        'Call(PropAccess(_, p), args)', function(b) {
            if (b.args.length === 1 && CALLBACK_METHODS.indexOf(b.p.value) !== -1)
                result = true;
        },
        'Call(Var(f), _)', function(b) {
            if (CALLBACK_FUNCTIONS.indexOf(b.f.value) !== -1)
                result = true;
        }
    );
    return result;
};
var isCallback = function(node) {
    var parent = node.parent;
    var parentParent = parent && parent.parent;
    if (!parentParent)
        return false;
    try {
        if (!parentParent.isMatch)
            console.log("isCallback debug:", JSON.stringify(parentParent));
    } catch (e) {
    }
    if (parent.isMatch('PropAccess(_, "call")')
        || parent.isMatch('PropAccess(_, "apply")')
        || parent.isMatch('PropAccess(_, "bind")')
        || !parentParent.isMatch('Call(_, _)')
        || (parentParent.cons === "Call" &&
            parentParent[0].cons === "PropAccess" &&
            parentParent[1].length > 1 &&
            CALLBACK_METHODS.indexOf(parentParent[0][1].value) > -1)
        )
        return false;
    var result = 0;
    node.rewrite(
        'Function(_, fargs, _)', function(b) {
            if (b.fargs.length === 0 || b.fargs[0].cons !== 'FArg')
                return result = IN_CALLBACK_BODY_MAYBE;
            var name = b.fargs[0][0].value;
            result = name === 'err' || name === 'error' || name === 'exc'
                ? IN_CALLBACK_BODY
                : IN_CALLBACK_BODY_MAYBE;
        }
    );
    return result;
};

handler.getRefactorings =
handler.highlightOccurrences = function(doc, fullAst, cursorPos, options, callback) {
    if (!options.node)
        return callback();
    
    if (!fullAst.annos.scope) {
        return handler.analyze(doc.getValue(), fullAst, function() {
            handler.highlightOccurrences(doc, fullAst, cursorPos, options, callback);
        }, true);
    }

    var markers = [];
    var enableRefactorings = [];
    
    function highlightVariable(v) {
        if (!v)
            return;
        v.declarations.forEach(function(decl) {
            if (decl.getPos())
                markers.push({
                    pos: decl.getPos(),
                    type: 'occurrence_main'
                });
        });
        v.uses.forEach(function(node) {
            markers.push({
                pos: node.getPos(),
                type: 'occurrence_other'
            });
        });
    }
    options.node.rewrite(
        'Var(x)', function(b, node) {
            var scope = node.getAnnotation("scope");
            if (!scope)
                return;
            var v = scope.get(b.x.value);
            highlightVariable(v);
            if (b.x.value !== "this" && v)
                enableRefactorings.push("rename");
        },
        'VarDeclInit(x, _)', 'ConstDeclInit(x, _)', 'LetDeclInit(x, _)', function(b) {
            highlightVariable(this.getAnnotation("scope").get(b.x.value));
            enableRefactorings.push("rename");
        },
        'VarDecl(x)', 'ConstDecl(x)', 'LetDecl(x)', function(b) {
            highlightVariable(this.getAnnotation("scope").get(b.x.value));
            enableRefactorings.push("rename");
        },
        'FArg(x)', function(b) {
            highlightVariable(this.getAnnotation("scope").get(b.x.value));
            enableRefactorings.push("rename");
        },
        'Function(x, _, _)', function(b, node) {
            if (!b.x.value || !node.getAnnotation("scope"))
                return;
            highlightVariable(node.getAnnotation("scope").get(b.x.value));
            enableRefactorings.push("rename");
        }
    );

    callback({
        markers: markers,
        refactorings: enableRefactorings
    });
};

handler.getRenamePositions = function(doc, fullAst, cursorPos, options, callback) {
    var currentNode = options.node;
    if (!fullAst || !currentNode)
        return callback();
    
    if (!fullAst.annos.scope) {
        return handler.analyze(doc.getValue(), fullAst, function() {
            handler.getRenamePositions(doc, fullAst, cursorPos, options, callback);
        }, true);
    }

    var v;
    var mainNode;
    currentNode.rewrite(
        'VarDeclInit(x, _)', 'ConstDeclInit(x, _)', 'LetDeclInit(x, _)', function(b, node) {
            v = node.getAnnotation("scope").get(b.x.value);
            mainNode = b.x;
        },
        'VarDecl(x)', 'ConstDecl(x)', 'LetDecl(x)', function(b, node) {
            v = node.getAnnotation("scope").get(b.x.value);
            mainNode = b.x;
        },
        'FArg(x)', function(b, node) {
            v = node.getAnnotation("scope").get(b.x.value);
            mainNode = node;
        },
        'Function(x, _, _)', function(b, node) {
            if (!b.x.value)
                return;
            v = node.getAnnotation("scope").get(b.x.value);
            mainNode = b.x;
        },
        'Var(x)', function(b, node) {
            v = node.getAnnotation("scope").get(b.x.value);
            mainNode = node;
        }
    );
    if (!mainNode) {
        return callback();
    }
    
    var pos = mainNode.getPos();
    var declarations = [];
    var uses = [];

    var length = pos.ec - pos.sc;
    v && v.declarations.forEach(function(node) {
         if (node !== currentNode[0]) {
            var pos = node.getPos();
            declarations.push({ column: pos.sc, row: pos.sl });
        }
    });
    
    v && v.uses.forEach(function(node) {
        if (node !== currentNode) {
            var pos = node.getPos();
            uses.push({ column: pos.sc, row: pos.sl });
        }
    });
    callback({
        length: length,
        pos: {
            row: pos.sl,
            column: pos.sc
        },
        others: declarations.concat(uses),
        declarations: declarations,
        uses: uses
    });
};

});

define("plugins/c9.ide.language/worker_util",[], function(require, exports, module) {

var worker = require("plugins/c9.ide.language.core/worker");
var completeUtil = require("./complete_util");

var MAX_MEMO_DICT_SIZE = 3000;
var msgId = 0;
var docCache = { row: null, entries: {}};

module.exports = {
    isFeatureEnabled: function(name) {
        return !disabledFeatures[name];
    },
    getIdentifierRegex: function(offset) {
        return worker.$lastWorker.getIdentifierRegex(offset);
    },
    completeUpdate: function(pos, line) {
        return worker.$lastWorker.completeUpdate(pos, line);
    },
    execFile: function(path, options, callback) {
        if (typeof options === "function")
            return this.execFile(path, {}, arguments[1]);
        
        var id = msgId++;
        worker.sender.emit("execFile", { path: path, options: options, id: id });
        worker.sender.on("execFileResult", function onExecFileResult(event) {
            if (event.data.id !== id)
                return;
            worker.sender.off("execFileResult", onExecFileResult);
            callback && callback(event.data.err, event.data.stdout, event.data.stderr);
        });
    },
    spawn: function(path, options, callback) {
        if (typeof options === "function")
            return this.execFile(path, {}, arguments[1]);
        
        var id = msgId++;
        worker.sender.emit("spawn", { path: path, options: options, id: id });
        worker.sender.on("spawnResult", function onSpawnResult(event) {
            if (event.data.id !== id)
                return;
            worker.sender.off("spawnResult", onSpawnResult);
            callback && callback(event.data.err, {
                stdout: { on: listen.bind(null, "stdout") },
                stderr: { on: listen.bind(null, "stderr") },
                on: listen.bind(null, "child"),
                kill: function(signal) {
                    worker.sender.emit("spawn_kill$" + id, { signal: signal });
                }
            });
            
            function listen(sourceName, event, listener) {
                worker.sender.on("spawnEvent$" + id + sourceName + event, function(e) {
                    listener(e.data);
                });
                worker.sender.on("spawnEvent$" + id + "childexit", function gc() {
                    setTimeout(function() {
                        worker.sender.off("spawnEvent$" + id + sourceName + event, listener);
                        worker.sender.off("spawnEvent$" + id + "childexit", gc);
                    });
                });
            }
        });
    },
    execAnalysis: function(command, options, callback) {
        if (typeof options === "function")
            return this.execAnalysis(command, {}, arguments[1]);
        
        var myWorker = worker.$lastWorker;
        options.command = command;
        options.path = options.path || (myWorker.$path && myWorker.$path[0] === "/" ? myWorker.$path.substr(1) : myWorker.$path);
        options.cwd = options.cwd || getRelativeDirname(options.path);
        options.maxBuffer = options.maxBuffer || 200 * 1024;
        var maxCallInterval = options.maxCallInterval || 50;
        if (myWorker.$overrideLine) {
            maxCallInterval = 0;
            options.overrideLineRow = myWorker.$lastCompleteRow;
            options.overrideLine = options.overrideLine || myWorker.$overrideLine;
        }
        else {
            options.overrideLineRow = myWorker.$lastCompleteRow;
            options.overrideLine = options.overrideLine || myWorker.doc.getLine(options.overrideLineRow);
        }
        if (options.path && options.path[0] === "/")
            return callback(new Error("Only workspace-relative paths are supported"));
        var id = msgId++;
        worker.sender.emit("jsonalyzerCallServer", {
            id: id,
            handlerPath: "plugins/c9.ide.language.jsonalyzer/server/invoke_helper",
            method: "invoke",
            filePath: options.path && (options.path[0] === "~" ? options.path : "/" + options.path),
            maxCallInterval: maxCallInterval,
            timeout: options.timeout || 30000,
            semaphore: "semaphore" in options
                ? options.semaphore
                : command + "|" + myWorker.$language,
            args: [options.path, null, null, options]
        });
        worker.sender.on("jsonalyzerCallServerResult", function onResult(event) {
            if (event.data.id !== id)
                return;
            worker.sender.off("jsonalyzerCallServerResult", onResult);
            var stdout = tryParseJSON(event.data.result[1]);
            var stderr = tryParseJSON(event.data.result[2]);
            callback(event.data.result[0], stdout, stderr, {
                serverTime: event.data.result[3],
            });
        });
        
        function getRelativeDirname(file) {
            return file && file.replace(/([\/\\]|^)[^\/\\]+$/, "").replace(/^\//, "");
        }
        
        function tryParseJSON(string) {
            try {
                return options.json ? JSON.parse(string) : string;
            }
            catch (e) {
                return string;
            }
        }
    },
    readFile: function(path, options, callback) {
        if (!callback) { // fix arguments
            callback = options;
            options = null;
        }
        
        if (worker.$lastWorker.$path === path) {
            callback && setTimeout(callback.bind(null, null, worker.$lastWorker.doc.getValue()), 0);
            return;
        }
        
        if (path.match(/\/$/) || path === ".") { // fail fast
            var err = new Error("File is a directory");
            err.code = "EISDIR";
            return callback(err);
        }
        
        var id = msgId++;
        worker.sender.on("readFileResult", function onReadFileResult(event) {
            if (event.data.id !== id)
                return;
            worker.sender.off("readFileResult", onReadFileResult);
            callback && callback(event.data.err && JSON.parse(event.data.err), event.data.data);
        });
        worker.sender.emit("readFile", { path: path, options: options, id: id });
    },
   stat: function(path, callback) {
        var id = msgId++;
        worker.sender.on("statResult", function onReadFileResult(event) {
            if (event.data.id !== id)
                return;
            worker.sender.off("statResult", onReadFileResult);
            callback && callback(event.data.err && JSON.parse(event.data.err), event.data.data);
        });
        worker.sender.emit("stat", { path: path, id: id });
    },
    filterDocumentation: function(doc) {
        if (docCache.entries["_" + doc])
            return docCache.entries["_" + doc];
        var lastRow = worker.$lastWorker.$lastCompleteRow;
        if (docCache.row !== lastRow)
            docCache.entries = {};
        docCache.row = lastRow;
        
        var result = escapeHtml(doc)
            .replace(/(\n|^)[ \t]*\*+[ \t]*/g, "\n")
            .trim()
            .replace(/@(param|public|private|platform|event|method|function|class|constructor|fires?|throws?|returns?|internal|ignore)/, "<br/>@$1")
            .replace(/\n\n(?!@)/g, "<br/><br/>")
            .replace(/@(param|public|private|platform|event|method|function|class|constructor|fires?|throws?|returns?|internal|ignore) ({[\w\.]+} )?(\[?[\w\.]+\]?)/g, "<br><b>@$1</b> <i>$2$3</i>&nbsp;")
            .replace(/\n@(\w+)/g, "<br/>\n<b>@$1</b>")
            .replace(/&lt;(\/?)code&gt;/g, "<$1tt>")
            .replace(/&lt;(\/?)(b|i|em|br|a) ?\/?&gt;/g, "<$1$2>")
            .replace(/&lt;(a\s+(target=('|&quot;)[^"'&]*('|&quot;)\s+)?href=('|&quot;)(https?:\/\/|#)[^"'&]*('|&quot;)\s*(target=('|&quot;)[^"'&]*('|&quot;)\s*)?)&gt;/g, '<$1 target="_docs">');
        docCache.entries["_" + doc] = result;
        return result;

        function escapeHtml(str) {
            return str
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;");
        }
    },
    showError: function(message, timeout, info) {
        if (message.stack) {
            console.error(message.stack);
            message = message.message;
        }
        var id = msgId++;
        var token;
        worker.sender.once("showErrorResult", function onResult(e) {
            token = e.token;
        });
        worker.sender.emit("showError", { message: message, timeout: timeout, id: id, info: info });
        return {
            hide: function hide() {
                if (token)
                    return worker.sender.emit("showError", { token: token });
                setTimeout(hide, 50);
            }
        };
    },
    showInfo: function(message, timeout) {
        return this.showError(message, timeout, true);
    },
    asyncForEach: function(array, fn, callback) {
        worker.asyncForEach(array, fn, callback);
    },
    getOpenFiles: function() {
        var results = [];
        var set = worker.$lastWorker.$openDocuments;
        Object.keys(set).forEach(function(e) {
            results.push(set[e]);
        });
        return results;
    },
    refreshAllMarkers: function() {
        worker.sender.emit("refreshAllMarkers");
    },
    getPrecedingIdentifier: function(line, offset, regex) {
        regex = regex || this.getIdentifierRegex(offset);
        return completeUtil.retrievePrecedingIdentifier(line, offset, regex);
    },
    getFollowingIdentifier: function(line, offset, regex) {
        regex = regex || this.getIdentifierRegex(offset);
        return completeUtil.retrieveFollowingIdentifier(line, offset, regex);
    },
    getIdentifier: function(line, offset, regex) {
        regex = regex || this.getIdentifierRegex(offset);
        return this.getPrecedingIdentifier(line, offset, regex)
            + this.getFollowingIdentifier(line, offset, regex);
    },
    getTokens: function(doc, identifiers, callback) {
        var id = msgId++;
        worker.sender.emit("getTokens", {
            path: worker.$lastWorker.$path,
            identifiers: identifiers,
            id: id,
            region: doc.region
        });
        worker.sender.on("getTokensResult", function onResult(event) {
            if (event.data.id !== id)
                return;
            worker.sender.off("getTokensResult", onResult);
            callback(event.data.err, event.data.results);
        });
    },
    
    getQuickfixKey: function() {
        return worker.$lastWorker.$keys.quickfix;
    },
    $watchDir: function(path, plugin) {
        worker.sender.emit("watchDir", { path: path });
    },
    $unwatchDir: function(path, plugin) {
        worker.sender.emit("watchDir", { path: path });
    },
    $onWatchDirChange: function(listener) {
        worker.sender.on("watchDirResult", listener);
    },
    $offWatchDirChange: function(listener) {
        worker.sender.off("watchDirResult", listener);
    }
};

});

define("plugins/c9.ide.language.jsonalyzer/worker/semantic_index",[], function(require, exports, module) {

var handler /*: require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_worker")*/;
var scopeAnalyzer = require('plugins/c9.ide.language.javascript/scope_analyzer');
var workerUtil = require("plugins/c9.ide.language/worker_util");
var KIND_PACKAGE = scopeAnalyzer.KIND_PACKAGE;
var KIND_HIDDEN = scopeAnalyzer.KIND_HIDDEN;
var GC_INTERVAL = 5 * 60 * 1000;

var index = module.exports;

var analyzedFiles = {};
var pathGuids = {};
var accessedSinceGC = {};
var summaries = {};
var imports = {};
    
index.init = function(_handler) {
    handler = _handler;
    
    var _self = this;
    setInterval(function() {
        _self.gc();
    }, GC_INTERVAL);
};
index.getAny = function(guidsOrPaths) {
    return guidsOrPaths.map(index.get.bind(index)).filter(function(i) {
        return !!i;
    });
};
index.get = function(guidOrPath) {
    accessedSinceGC["_" + guidOrPath] = true;
    var guid = pathGuids["_" + guidOrPath];
    return guid ? summaries["_" + guid] : summaries["_" + guidOrPath];
};
index.getImports = function(guidOrPath, excludeAnalyzed) {
    accessedSinceGC["_" + guidOrPath] = true;
    var guid = pathGuids["_" + guidOrPath];
    var results = guid ? imports["_" + guid] : imports["_" + guidOrPath];
    if (!results)
        return [];
    if (excludeAnalyzed)
        results = results.filter(function(r) { return !index.get(r); });
    return results;
};
index.set = function(path, guidPrefix, summary, pathImports) {
    var guid = summary && summary.guid || guidPrefix + path;
    pathGuids["_" + path] = guid;
    if (summary) {
        summary.path = path;
        summaries["_" + guid] = summary;
    }
    if (pathImports)
        imports["_" + guid] = pathImports;
};
index.setBroken = function(path, reason) {
    var guid = "broken:" + path;
    pathGuids["_" + path] = guid;
    summaries["_" + guid] = {
        broken: reason || "broken"
    };
    imports["_" + guid] = [];
};
index.flattenSummary = function(summary, result) {
    if (!summary)
        return {};
    result = result || {};
    
    var that = this;
    if (Array.isArray(summary)) {
        summary.forEach(function(e) { that.flattenSummary(e, result);});
        return result;
    }
    if (!summary || !summary.properties)
        return result;
    
    for (var p in summary.properties) {
        if (!result[p])
            result[p] = summary.properties[p];
        else
            result[p] = result[p].concat(summary.properties[p]);
        this.flattenSummary(summary.properties[p], result);
    }
    
    return result;
};
index.findEntries = function(summary, entry, matchByPrefix, dontFindAll) {
    function findUnderscoreEntries(properties, uentry) {
        if (!matchByPrefix && properties[uentry]) {
            result[uentry] = (result[uentry] || []).concat(properties[uentry]);
            if (dontFindAll)
                return;
        }
        
        for (var p in properties) {
            if (matchByPrefix && p.indexOf(uentry) === 0) {
                result[p] = (result[p] || []).concat(properties[p]);
                if (dontFindAll)
                    return;
            }
            if (!properties[p].properties)
                continue;
            findUnderscoreEntries(properties[p].properties, uentry);
        }
    }
    
    if (!summary.properties)
        return {};
    if (entry === "" && matchByPrefix)
        return this.flattenSummary(summary);
        
    var result = {};
    findUnderscoreEntries(summary.properties, "_" + entry);
    return result;
};

index.hasEntries = function(summary, entry, matchByPrefix) {
    return !!Object.keys(this.findEntries(summary, entry, matchByPrefix, true)).length;
};

index.removeByPath = function(path) {
    var guid = pathGuids["_" + path];
    if (!guid)
        return;

    delete analyzedFiles["_" + path];
    delete pathGuids["_" + guid];
    delete summaries[guid];
};

index.removeByPathPrefix = function(pathPrefixes) {
    for (var upath in pathGuids) {
        var matches = pathPrefixes.filter(function(p) {
            return upath.indexOf(p) === 1;
        });
        if (matches.length === 0)
            continue;
        
        var uguid = "_" + pathGuids[upath];
        delete summaries[uguid];
        delete imports[uguid];
        delete pathGuids[upath];
    }
};
index.gc = function() {
    var openFiles = workerUtil.getOpenFiles();
    for (var upath in pathGuids) {
        var guid = pathGuids[upath];
        
        if (accessedSinceGC[upath])
            continue;
        if (accessedSinceGC["_" + guid] || openFiles.indexOf(upath.substr(1)) > -1)
            continue;
        
        delete pathGuids[upath];
        delete summaries["_" + guid];
        delete imports["_" + guid];
    }
    accessedSinceGC = {};
};

index.clear = function() {
    pathGuids = {};
    summaries = {};
    imports = {};
    accessedSinceGC = {};
};

index.markStale = function(handler) {
    if (!handler)
        return;
    for (s in summaries) {
        if (summaries[s].handler === handler)
            summaries[s].stale = true;
    }
};

index.$clearAccessedSinceGC = function() {
    accessedSinceGC = {};
};

});

define("plugins/c9.ide.language.jsonalyzer/worker/file_indexer",[], function(require, exports, module) {

var indexer = module.exports;
var index = require("./semantic_index");
var languageWorker = require("plugins/c9.ide.language.core/worker");
var workerUtil = require("plugins/c9.ide.language/worker_util");
var assert = require("c9/assert");
var worker;

var QUEUE_DELAY = 5 * 1000;
var QUEUE_MAX_TIME = 120 * 1000;

var queueSet = {};
var queueTimer;
var queueWatcher;
var isJobActive = false;
var queueCallbacks = [];
var lastPath;
var lastDocValue;

indexer.init = function(_worker) {
    worker = _worker;
};
indexer.analyzeCurrent = function(path, docValue, ast, options, callback) {
    var entry = index.get(path);
    if (entry && !entry.stale &&
        (languageWorker.$lastWorker.updateScheduled || languageWorker.$lastWorker.updateAgain)) {
        entry.stale = true; // only do this once
        return callback(null, entry, index.getImports(path), entry.markers);
    }
    if (entry && !entry.stale && path === lastPath && docValue === lastDocValue)
        return callback(null, entry, index.getImports(path), entry.markers);
    
    lastPath = path;
    lastDocValue = docValue;
    
    var language = worker.language;
    var plugin = worker.getHandlerFor(path, language);
    options.language = language;
    
    var watcher = setTimeout(function() {
        console.log("Warning: did not receive a response for 20 seconds from " + plugin.$source);
    }, 20000);
    return plugin.analyzeCurrent(path, docValue, ast, options, function(err, indexEntry, markers) {
        clearTimeout(watcher);
        if (err) {
            index.setBroken(path, err);
            return callback(err);
        }
        assert(indexEntry || markers, "jsonalyzer handler must return a summary and/or markers");
        
        indexEntry = indexEntry || index.get(path) || {};
        markers = indexEntry.markers = indexEntry.markers || markers;
        indexEntry.handler = plugin;
        
        if (!options.service) {
            index.set(path, plugin.guidName + ":", indexEntry);
        }
        else {
            var oldEntry = index.get(path);
            if (oldEntry)
                oldEntry.stale = true;
        }
        
        plugin.findImports(path, docValue, ast, options, function(err, imports) {
            if (err) {
                console.error("[jsonalyzer] error finding imports for " + path + ": " + err);
                imports = [];
            }
            imports = (imports || []).filter(function(i) {
                return i !== path;
            });
            index.set(path, plugin.guidName + ":", null, imports);
            callback(null, indexEntry, imports, markers);
        });
    });
};
var enqueue = indexer.analyzeOthers = function(paths, now, callback) {
    if (callback)
        queueCallbacks.push(callback);
    
    for (var i = 0; i < paths.length; i++) {
        queueSet["_" + paths[i]] = paths[i];
    }
    
    if (now)
        return consumeQueue();
    
    if (!queueTimer)
        queueTimer = setTimeout(consumeQueue, QUEUE_DELAY);
};

function consumeQueue() {
    queueTimer = null;
    if (isJobActive)
        return;
    isJobActive = true;
    updateQueueWatcher();
    
    var paths = [];
    for (var item in queueSet) {
        if (index.get(queueSet[item]))
            continue;
        paths.push(queueSet[item]);
    }
    queueSet = {};
    
    var pathsPerPlugin = {};
    for (var i = 0; i < paths.length; i++) {
        var plugin = worker.getHandlerFor(paths[i]);
        if (!plugin) // path added when not fully initialized yet
            continue;
        if (!pathsPerPlugin[plugin.guidName]) {
            pathsPerPlugin[plugin.guidName] = {
                plugin: plugin,
                paths: []
            };
        }
        pathsPerPlugin[plugin.guidName].paths.push(paths[i]);
    }
    
    workerUtil.asyncForEach(
        Object.keys(pathsPerPlugin),
        function(guidName, next) {
            var task = pathsPerPlugin[guidName];
            task.paths = task.paths.filter(function(path) {
                var entry = index.get(path);
                return !entry || entry.stale;
            });
                 
            task.plugin.analyzeOthers(task.paths, {}, function(errs, results) {
                assert(!errs || Array.isArray(errs));
                updateQueueWatcher();
                
                if (!results)
                    return next();
                var pathsCopy = task.paths.slice();
                var resultsCopy = (results || []).slice();
                var errsCopy = (errs || []).slice();
                
                while (pathsCopy.length) {
                    var err = errsCopy.pop();
                    var path = pathsCopy.pop();
                    var result = resultsCopy.pop();
                    if (err) {
                        index.setBroken(path, err);
                        console.log("[jsonalyzer] Warning: failed to import " + path + ": " + err);
                        continue;
                    }
                    assert(result);
                    result.handler = task.plugin;
                    index.set(path, guidName + ":", result);
                }
                
                next();
            });
        },
        done
    );
    
    function done() {
        isJobActive = false;
        clearTimeout(queueWatcher);
        var callbacks = queueCallbacks;
        queueCallbacks = [];
        callbacks.forEach(function(callback) { callback(); });
    }
    
    function updateQueueWatcher() {
        clearTimeout(queueWatcher);
        queueWatcher = setTimeout(function() {
            isJobActive = false;
            console.error("Warning: file_indexer plugin timeout, restarting");
            consumeQueue();
        }, QUEUE_MAX_TIME);
    }
}

});

define("plugins/c9.ide.language.jsonalyzer/worker/jumptodef",[], function(require, exports, module) {

var index = require("./semantic_index");
var handler;
var worker = require("plugins/c9.ide.language.core/worker");
var fileIndexer = require("./file_indexer");
var workerUtil = require("plugins/c9.ide.language/worker_util");

module.exports.init = function(_handler) {
    handler = _handler;
};

module.exports.jumpToDefinition = function(doc, fullAst, pos, options, callback) {
    var line = doc.getLine(pos.row);
    var docValue = doc.getValue();
    var identifier = workerUtil.getIdentifier(line, pos.column);
    var indexOptions = {};
    var that = this;
    fileIndexer.analyzeCurrent(handler.path, docValue, fullAst, indexOptions, function(err, summary, imports) {
        if (err) {
            if (err.code === "ESUPERSEDED")
                return that.jumpToDefinition(doc, fullAst, pos, options, callback);
            console.error(err);
            return callback(); // can't pass error to this callback
        }
        worker.$lastWorker.getOutline(function(outline) {
            var results = [];
            if (outline && outline.items)
                results = findInOutline(outline.items, identifier);
            if (!results.length)
                results = findInSummaries([summary], identifier, results);
            var needAllImports = !results.length;
            if (needAllImports)
                fileIndexer.analyzeOthers(imports, needAllImports, done);
            else
                done();
            
            function done() {
                var summaries = index.getAny(imports);
                results = findInSummaries(summaries, identifier, results);
                if (doc.region)
                    results.forEach(function(result) {
                        result.row -= doc.region.sl;
                    });
                callback(results);
            }
        });
    });
};

function findInSummaries(summaries, identifier, results) {
    summaries.forEach(function(summary) {
        var entries = index.findEntries(summary, identifier);
        for (var uname in entries) {
            entries[uname].forEach(function(entry) {
                results.push({
                    row: entry.row,
                    column: entry.column,
                    path: summary.path,
                    icon: entry.icon
                        || entry.kind === "package" && "package"
                        || entry.kind === "event" && "event"
                        || "unknown2",
                    isGeneric: true
                });
            });
        }
    });
    return results;
}

function isNameMatch(identifier, indexName) {
    return identifier === indexName
        || indexName.replace && identifier === indexName.replace(/(.*\.)?([^.]*?)(\([^\]]*\))?$/, "$2");
}

function findInOutline(outline, identifier, results) {
    if (!results)
        results = [];
    for (var i = 0; i < outline.length; i++) {
        if (isNameMatch(identifier, outline[i].name)) {
            results.push({
                row: outline[i].pos.sl,
                column: outline[i].pos.sc,
                icon: outline[i].icon,
                isGeneric: true
            });
        }
        if (outline[i].items)
            findInOutline(outline[i].items, identifier, results);
    }
    return results;
}

function getPropertyName(node) {
    var result;
    node.rewrite(
        'PropAccess(o, p)', function(b) {
            result = b.p.value; 
        }
    );
    return result;
}

});

define("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_util",[], function(require, exports, module) {

var assert = require("c9/assert");
var workerUtil = require("plugins/c9.ide.language/worker_util");
var jsonalyzer;

var MAX_DOCHEAD_LENGTH = 80;
var EXTENSION_GROUPS;

module.exports.MAX_DOCHEAD_LENGTH = MAX_DOCHEAD_LENGTH;

module.exports.EXTENSION_GROUPS = EXTENSION_GROUPS;

module.exports.init = function(ctags, _jsonalyzer) {
    if (typeof _jsonalyzer === "function") {
        return _jsonalyzer();
    }
    
    jsonalyzer = _jsonalyzer || jsonalyzer;
    EXTENSION_GROUPS = ctags.LANGUAGES.map(function(l) { return l.extensions; });
};

module.exports.extractDocumentationAtRow = function(lines, row) {
    var prevRow = row > 0 ? row - 1 : 0;
    var line = lines[prevRow];
    if (line && line.match(/^\s*#/)) {
        line = line.match(/^\s*#\s*(.*)/)[1];
        var results = [line];
        for (var start = prevRow - 1; start >= 0; start--) {
            line = lines[start];
            if (!line.match(/^\s*#/))
                break;
            results.push(line.match(/^\s*#\s*(.*)/)[1]);
        }
        return workerUtil.filterDocumentation(results.join("\n"));
    }
    if (lines[row + 1] && lines[row + 1].match(/^\s*"""/)) {
        var result = "";
        for (var cur = row + 1; lines[cur]; cur++) {
            result += lines[cur].replace(/^\s*|\s*"""\s*/g, "") + "\n";
            if (lines[cur].match(/[^\s"]+\s*"""/))
                break;
        }
        return result;
    }
    var end = null;
    for (var cur = prevRow; cur >= 0; cur--) {
        line = lines[cur];
        for (var col = line.length - 2; col >= 0; col--) {
            if (!end) {
                if (line.substr(col, 2) === "*/") {
                    end = { sl: cur, sc: col };
                    col--;
                } else if (!line[col].match(/[\s\/]/)) {
                    return;
                }
            } else if (line.substr(col, 2) === "/*") {
                var rows = ["", line.substr(col + 3)];
                for (var r = cur + 1; r < end.sl; r++)
                    rows.push(lines[r]);
                rows.push(lines[end.sl].substr(0, end.sc));
                if (end.sl === cur)
                    rows = ["", line.substring(col + 3, end.sc)];
                return workerUtil.filterDocumentation(rows.join("\n"));
            }
        }
    }
};
module.exports.findMatchingTags = function(path, docValue, tag, guessFargs, extractDocumentation, results) {
    assert(tag.regex.global, "Regex must use /g flag: " + tag.regex);
    var _self = this;
    var lines = path === jsonalyzer.path && jsonalyzer.doc
        ? jsonalyzer.doc.getAllLines()
        : docValue.split(/\n/);
    
    docValue.replace(tag.regex, function(fullMatch, name, offset) {
        assert(typeof offset === "number", "Regex must have exactly one capture group: " + tag.regex);
        
        var addedOffset = fullMatch.indexOf(name);
        var row = getOffsetRow(docValue, offset + (addedOffset === -1 ? 0 : addedOffset));
        var line = lines[row];
        
        var doc, docHead;
        if (extractDocumentation && line) {
            docHead = line.length > MAX_DOCHEAD_LENGTH
                ? line.substr(line.length - MAX_DOCHEAD_LENGTH) + "..."
                : line;
            doc = _self.extractDocumentationAtRow(lines, row);
        }
        
        results["_" + name] = results["_" + name] || [];
        
        if (tag.docOnly) { // HACK: tag that only contributes documentation
            if (!doc)
                return;
            if (results["_" + name][0]) {
                results["_" + name][0].doc = doc;
                return;
            }
        }
        
        results["_" + name].push({
            row: row,
            docHead: docHead,
            guessFargs: guessFargs,
            doc: doc,
            kind: tag.kind,
            indent: tag.indent,
        });
        return fullMatch;
    });
    
    return results;
};
module.exports.findMatchingOpenFiles = function(path) {
    var openFiles = workerUtil.getOpenFiles();
    var extension = getExtension(path);
    var supported = getCompatibleExtensions(extension);
    var imports = openFiles.filter(function(path) {
        return supported.indexOf(getExtension(path)) > -1;
    });
    return imports;
};

module.exports.guessFargs = function(line, name) {
    if (!line)
        return "";
    var guess = /\([A-Za-z0-9$_,\s]*(\))?/;
    guess.lastIndex = line.indexOf(name) + name.length;
    var match = guess.exec(line);
    return match && match[0] + (match[1] ? "" : "...") || "";
};

function getExtension(path) {
    return path.match(/[^\.\\\/]*$/)[0];
}
function getCompatibleExtensions(extension) {
    for (var i = 0; i < EXTENSION_GROUPS.length; i++) {
        if (EXTENSION_GROUPS[i].indexOf(extension) > -1)
            return EXTENSION_GROUPS[i];
    }
    return [extension];
}

var getOffsetRow = module.exports.getOffsetRow = function(contents, offset) {
    var result = 0;
    var lastIndex = offset + 1;
    for (;;) {
        lastIndex = lastIndex === 0
            ? -1
            : contents.lastIndexOf("\n", lastIndex - 1);
        if (lastIndex < 0)
            return result;
        result++;
    }
};
module.exports.filterDocumentation = workerUtil.filterDocumentation;

module.exports.getParameterDocs = function(doc) {
    var result = {};
    doc && doc.replace(
        /@param (?:\{[^}]*\} )?([^ ]*)\s+([^@]*)/g,
        function(input, name, description) {
            result["_" + name] = workerUtil.filterDocumentation(description);
            return input;
        }
    );
    return result;
};

});

define("plugins/c9.ide.language.jsonalyzer/worker/complete",[], function(require, exports, module) {

var index = require("./semantic_index");
var fileIndexer = require("./file_indexer");
var completeUtil = require("plugins/c9.ide.language/complete_util");
var workerUtil = require("plugins/c9.ide.language/worker_util");
var ctagsUtil = require("./ctags/ctags_util");
var handler;

var PRIORITY_LOW = 1;
var PRIORITY_HIGH = 2;

module.exports.init = function(_handler) {
    handler = _handler;
};

module.exports.complete = function(doc, fullAst, pos, options, callback) {
    if (options.node && options.node.cons === "PropertyInit") // HACK for javascript
        return callback();

    var lines = doc.getAllLines();
    var line = lines[pos.row];
    var identifier = completeUtil.retrievePrecedingIdentifier(line, pos.column, workerUtil.getIdentifierRegex());
    if (line[pos.column - identifier.length - 1] === ".")
        return callback();
    
    getCurrentLazy(handler.path, doc, fullAst, function(err, result, imports) {
        if (err)
            console.log("[jsonalyzer] Warning: could not analyze " + handler.path + ": " + err);
        var currentFile = result;
        var currentResults = getCompletionResults(null, PRIORITY_HIGH, identifier, currentFile, pos, line);
        var otherResults = [];
        imports.forEach(function(path) {
            var summary = index.get(path);
            if (summary)
                otherResults = otherResults.concat(
                    getCompletionResults(path, PRIORITY_LOW, identifier, summary));
        });
        callback(currentResults.concat(otherResults));
        var unresolved = imports.filter(function(i) { return !index.get(i); });
        if (unresolved.length) {
            fileIndexer.analyzeOthers(unresolved, true, function() {
                if (index.getAny(unresolved).length)
                    workerUtil.completeUpdate(pos, line);
            });
        }
    });
};

function getCurrentLazy(path, doc, fullAst, callback) {
    var result = index.get(path);
    if (result)
        return callback(null, result, index.getImports(path));
    fileIndexer.analyzeCurrent(handler.path, doc.getValue(), fullAst, { service: "complete" }, callback);
}

function getCompletionResults(path, priority, identifier, summary, skipPos, skipLine) {
    if (!summary)
        return [];
    var entries = index.findEntries(summary, identifier, true);
    var file = path && path.match(/[^\/]*$/)[0];
    
    var results = [];
    for (var uname in entries) {
        entries[uname].forEach(function(e) {
            var name = uname.substr(1);
            if (skipPos && e.row === skipPos.row && !isDefinedInLine(skipLine, name, skipPos, identifier))
                return;
            if (e.noComplete)
                return;
            results.push(toCompletionResult(file, name, priority, e));
        });
    }
    return results;
}

function isDefinedInLine(line, name, skipPos, skipPrefix) {
    var first = line.indexOf(name);
    var last = line.lastIndexOf(name);
    if (first !== last)
        return true;
    return first !== skipPos.column - skipPrefix.length;
}

function toCompletionResult(file, name, priority, entry) {
    var fullName = entry.guessFargs
        ? name + ctagsUtil.guessFargs(entry.docHead, name)
        : name;
    var braces = fullName !== name ? "(^^)" : "";
    
    return {
        id: name,
        name: fullName,
        replaceText: name + braces,
        icon: "kind" in entry ? entry.kind : "unknown2",
        meta: file,
        doc: entry.doc,
        docHead: entry.docHead,
        priority: priority,
        isGeneric: true,
        guessTooltip: true,
    };
}

});

define("plugins/c9.ide.language.jsonalyzer/worker/outline",[], function(require, exports, module) {

var fileIndexer = require("./file_indexer");
var assert = require("c9/assert");
var ctagsUtil = require("./ctags/ctags_util");
var handler;

module.exports.init = function(_handler) {
    handler = _handler;
};

module.exports.outline = function(doc, ast, callback) {
    return fileIndexer.analyzeCurrent(handler.path, doc.getValue(), ast, { service: "outline" }, function(err, entry) {
        if (err) {
            console.error(err);
            return callback(); // can't pass error to this callback
        }
        
        var result = createOutline(null, entry, -1);
        var rootInfo = {
            displayPos: { el: doc.getLength() - 1 }
        };
        result = addDisplayPos(result, rootInfo);
        result.isGeneric = true;
        callback(result);
    });
};

function createOutline(name, entry, defaultIndent, parent) {
    var indent = entry.indent || defaultIndent;
    var fullName = entry.guessFargs
        ? name + ctagsUtil.guessFargs(entry.docHead, name)
        : name;
    var result = {
        icon: entry.icon || entry.kind,
        name: fullName,
        pos: { sl: entry.row, sc: entry.column },
        items: [],
        indent: indent,
        parent: parent,
    };
    if (!entry.properties)
        return result;
    assert(!Array.isArray(entry.properties));
    
    for (var uname in entry.properties) {
        entry.properties[uname].forEach(function(prop) {
            result.items.push(createOutline(uname.substr(1), prop, indent + 1, result));
        });
    }
    result.items = sortOutline(result.items);
    var candidateParent;
    result.items = result.items.filter(function(prop) {
        var parent = findParent(prop, candidateParent);
        if (parent !== result)
            parent.items.push(prop);
        else
            candidateParent = prop;
        return parent === result;
    });
    return result;
    
    function findParent(prop, parent) {
        if (!prop.indent || prop.indent <= indent || !parent)
            return result;
        
        if (parent.indent >= prop.indent)
            return findParent(prop, parent.parent);
            
        return parent;
    }
}

function sortOutline(items) {
    return items.sort(function(a, b) {
        return a.pos.sl - b.pos.sl;
    });
}

function addDisplayPos(outline, parent) {
    if (!outline.items)
        return outline;
    outline.displayPos = outline.displayPos || outline.pos;
    for (var i = 0; i < outline.items.length; i++) {
        var item = outline.items[i];
        var next = outline.items[i + 1];
        var nextLine = next ? next.pos.sl : parent.displayPos.el;
        item.displayPos = item.pos;
        item.pos = {
            sl: item.pos.sl,
            sc: item.pos.sc,
            el: nextLine,
            ec: nextLine > item.pos.sl ? 0 : item.pos.ec
        };
        addDisplayPos(item, outline);
    }
    return outline;
}

});

define("plugins/c9.ide.language.jsonalyzer/worker/refactor",[], function(require, exports, module) {

var index = require("./semantic_index");
var fileIndexer = require("./file_indexer");
var workerUtil = require("plugins/c9.ide.language/worker_util");
var handler;
var lastSummary;

module.exports.init = function(_handler) {
    handler = _handler;
};

module.exports.getRefactorings = function(doc, fullAst, pos, options, callback) {
    findEntries(doc, fullAst, pos, function(pos, identifier, hasEntries) {
        callback({ refactorings: hasEntries ? ["renameVariable"] : []});
    });
};

module.exports.getRenamePositions = function(doc, fullAst, pos, options, callback) {
    findEntries(doc, fullAst, pos, function(pos, identifier, hasEntries) {
        if (!hasEntries)
            return callback();
        workerUtil.getTokens(doc, [identifier, identifier + "()"], function(err, results) {
            if (err)
                callback();
            callback({
                length: identifier.length,
                pos: pos,
                others: results,
                isGeneric: true
            });
        });
    });
};

module.exports.commitRename = function(doc, oldId, newName, isGeneric, callback) {
    if (!isGeneric)
        return callback();
    if (!lastSummary)
        return callback();
    var matchingDef = !!Object.keys(index.findEntries(lastSummary, newName)).length;
    callback(matchingDef && "Name '" + newName + "' is already used.");
};

function findEntries(doc, fullAst, pos, callback) {
    if (handler.language === "javascript") // optimization
        return callback();
    
    var docValue = doc.getValue();
    var line = doc.getLine(pos.row);
    var identifier = workerUtil.getIdentifier(line, pos.column);
    var prefix = workerUtil.getPrecedingIdentifier(line, pos.column);
    var realPos = { row: pos.row, column: pos.column - prefix.length };
    
    fileIndexer.analyzeCurrent(handler.path, docValue, fullAst, { service: "refactor" }, function(err, result) {
        if (err)
            console.log("[jsonalyzer] Warning: could not analyze " + handler.path + ": " + err);
        lastSummary = result;
        callback(realPos, identifier, index.hasEntries(result, identifier));
    });
    
}

});

define("plugins/c9.ide.language.jsonalyzer/worker/highlight_occurrences",[], function(require, exports, module) {

var index = require("./semantic_index");
var handler;
var fileIndexer = require("./file_indexer");
var workerUtil = require("plugins/c9.ide.language/worker_util");

module.exports.init = function(_handler) {
    handler = _handler;
};

module.exports.highlightOccurrences = function(doc, fullAst, pos, options, callback) {
    var summary = index.get(handler.path);
    if (!summary)
        return callback(); // we're closed, come back later
        
    var line = doc.getLine(pos.row);
    var identifier = workerUtil.getIdentifier(line, pos.column);
    
    var entries = index.findEntries(summary, identifier);
    if (Object.keys(entries).length)
        return callback(getOccurrences(doc, pos, identifier, entries["_" + identifier]));
    
    var imports = index.getImports(handler.path);
    var others = index.getAny(imports);
    for (var i = 0; i < others.length; i++) {
        if (index.hasEntries(others[i], identifier))
            return callback(getOccurrences(doc, pos, identifier, []));
    }
    
    callback();
};

function getOccurrences(doc, pos, identifier, entryList) {
    var line = doc.getLine(pos.row);
    var prefix = workerUtil.getPrecedingIdentifier(line, pos.column);
    var realColumn = pos.column - prefix.length;
    
    var results = [{
        pos: {
            sl: pos.row,
            el: pos.row,
            sc: realColumn,
            ec: realColumn + identifier.length
        },
        type: "occurrence_other"
    }];
    
    var foundSelf = false;
    entryList.forEach(function(entry) {
        if (!entry.column) { // guess the column
            var entryLine = doc.getLine(entry.row);
            entry.column = entryLine.indexOf(identifier);
            if (entry.column < 0)
                return;
        }
        if (entry.row === pos.row && entry.column === realColumn)
            return foundSelf = true;
        results.push({
            pos: {
                sl: entry.row,
                el: entry.row,
                sc: entry.column,
                ec: entry.column + identifier.length
            },
            type: "occurrence_main"
        });
    });
    return { markers: foundSelf ? [] : results, isGeneric: true };
}

});

define("plugins/c9.ide.language.jsonalyzer/worker/directory_indexer",[], function(require, exports, module) {

var indexer = module.exports;
var index = require("./semantic_index");
var workerUtil = require("plugins/c9.ide.language/worker_util");
var handler;

var PARANOID_CHECK_INTERVAL = 60 * 1000;
var QUEUE_DELAY = 2000;
var PARANOID_CHECK_SET = [
    ".git/index",
    ".hg/dirstate",
    ".svn/.wc.db",
    "node_modules/*",
    "package.json"
];

var isJobActive = false;
var lastParanoidResult = "";
var queueTimer;
var queueCallbacks = [];
var queuePaths = [];

indexer.init = function(_handler) {
    handler = _handler;
    
    enqueue("/", false);
    setInterval(function() {
        if (!queuePaths.length)
            enqueue("/", true);
    }, PARANOID_CHECK_INTERVAL);
};

var enqueue = indexer.enqueue = function(path, paranoid, callback) {
    callback && queueCallbacks.push(callback);
    queuePaths.push(path);
    
    if (queuePaths.indexOf("/") > -1)
        return; // we queued the world already
    if (paranoid === undefined && path === "/")
        paranoid = true;
    
    if (paranoid) {
        return isChangedParanoid(function(err, result) {
            if (err)
                return console.error("[jsonalyzer] directory_indexer err: " + err);
            enqueue(result ? path : "$$no-path$$", false);
        });
    }
    
    if (!queueTimer)
        queueTimer = setTimeout(consumeQueue);
};

var consumeQueue = indexer.$consumeQueue = function() {
    queueTimer = null;
    var myQueue = queuePaths;
    var myCallbacks = queueCallbacks;
    queuePaths = [];
    queueCallbacks = [];

    index.removeByPathPrefix(myQueue);
    
    workerUtil.asyncForEach(
        handler.getAllHandlers(),
        function(plugin, next) {
            plugin.analyzeWorkspaceRoot(next);
        },
        done
    );
    
    function done() {
        isJobActive = false;
        var callbacks = myCallbacks;
        myCallbacks = [];
        callbacks.forEach(function(callback) { callback(); });
    }
};
function isChangedParanoid(callback) {
    workerUtil.execFile(
        "bash",
        {
            args: [
                "-c",
                "ls -l"
                + " " + PARANOID_CHECK_SET.join(" ")
                + " `find . -maxdepth 1 -type d | grep -Ev '^\\./\\.c9|^\\.$' || echo ''`"
            ]
        },
        function(err, stdout) {
            if (err)
                return callback(err);
            if (lastParanoidResult === stdout)
                return callback(null, false);
            lastParanoidResult = stdout;
            return callback(null, true);
        }
    );
}

});

define("path",[], function(require, exports, module) {
//
//
//
function normalizeArray(parts, allowAboveRoot) {
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}
var splitPathRe =
  /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;
  
  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : '/';
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }
  
    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }
  resolvedPath = normalizeArray(resolvedPath.split('/').filter(function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');
  
  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = path.substr(-1) === '/';
  path = normalizeArray(path.split('/').filter(function(p) {
    return !!p;
  }), !isAbsolute).join('/');
  
  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }
  
  return (isAbsolute ? '/' : '') + path;
};
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(paths.filter(function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);
  
  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }
  
    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }
  
    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }
  
  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));
  
  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }
  
  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }
  
  outputParts = outputParts.concat(toParts.slice(samePartsLength));
  
  return outputParts.join('/');
};

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    return '.';
  }

  if (dir) {
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};

exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

exports._makeLong = function(path) {
  return path;
};

});

"disable compress";(function() {
var ctagsInput;
var submitNewContents;
var Module;
var logged = "";

(function() {
var process;
if (typeof window !== "undefined")
    process = "process is changed to type string for compatibility, sorry";

function stringToArrayBuffer(string, callback) {
    var blob = new Blob([string]);
    var f = new FileReader();
    f.onload = function(e) {
        callback(e.target.result);
    }
    f.readAsArrayBuffer(blob);
}
var sysConsole = console;
var console = {
	log: function() {
		arguments = Array.prototype.slice.call(arguments);
		logged += arguments.map(function(a) {
			return typeof a === "object" ? JSON.stringify(a) : a;
		}).join(" ") + "\n";
		sysConsole.log.apply(sysConsole, arguments)
	},
	error: function() {
		arguments = Array.prototype.slice.call(arguments);
		logged += arguments.map(function(a) {
			return typeof a === "object" ? JSON.stringify(a) : a;
		}).join(" ") + "\n";
		sysConsole.err.apply(sysConsole, arguments)
	}
}
var print = console.log;

function aa(b){throw b}var ba=void 0,ca=!0,da=null,fa=!1,a={noInitialRun:ca,noExitRuntime:ca};try{this.Module=a}catch(ha){this.Module=a={}}var ja="object"===typeof process&&"function"===typeof require,la="object"===typeof window,ma="function"===typeof importScripts,na=!la&&!ja&&!ma;if(ja){a.print=(function(b){process.stdout.write(b+"\n")});a.printErr=(function(b){process.stderr.write(b+"\n")});var oa=require("fs"),pa=require("path");a.read=(function(b){var b=pa.normalize(b),d=oa.readFileSync(b).toString();!d&&b!=pa.resolve(b)&&(b=path.join(__dirname,"..","src",b),d=oa.readFileSync(b).toString());return d});a.load=(function(b){qa(read(b))});a.arguments||(a.arguments=process.argv.slice(2))}na&&(a.print=print,"undefined"!=typeof printErr&&(a.printErr=printErr),a.read="undefined"!=typeof read?read:(function(b){snarf(b)}),a.arguments||("undefined"!=typeof scriptArgs?a.arguments=scriptArgs:"undefined"!=typeof arguments&&(a.arguments=arguments)));la&&!ma&&(a.print||(a.print=(function(b){console.log(b)})),a.printErr||(a.printErr=(function(b){console.log(b)})));if(la||ma){a.read=(function(b){var d=new XMLHttpRequest;d.open("GET",b,fa);d.send(da);return d.responseText}),a.arguments||"undefined"!=typeof arguments&&(a.arguments=arguments)}ma&&(a.print||(a.print=(function(){})),a.load=importScripts);!ma&&!la&&!ja&&!na&&aa("Unknown runtime environment. Where are we?");function qa(b){eval.call(da,b)}"undefined"==!a.load&&a.read&&(a.load=(function(b){qa(a.read(b))}));a.print||(a.print=(function(){}));a.printErr||(a.printErr=a.print);a.arguments||(a.arguments=[]);a.print=a.print;a.h=a.printErr;a.preRun||(a.preRun=[]);a.postRun||(a.postRun=[]);function sa(b){if(1==ta){return 1}var d={"%i1":1,"%i8":1,"%i16":2,"%i32":4,"%i64":8,"%float":4,"%double":8}["%"+b];d||("*"==b.charAt(b.length-1)?d=ta:"i"==b[0]&&(b=parseInt(b.substr(1)),ua(0==b%8),d=b/8));return d}var va;function wa(){var b=[],d=0;this.C=(function(c){c&=255;d&&(b.push(c),d--);if(0==b.length){if(128>c){return String.fromCharCode(c)}b.push(c);d=191<c&&224>c?1:2;return""}if(0<d){return""}var c=b[0],e=b[1],f=b[2],c=191<c&&224>c?String.fromCharCode((c&31)<<6|e&63):String.fromCharCode((c&15)<<12|(e&63)<<6|f&63);b.length=0;return c});this.K=(function(b){for(var b=unescape(encodeURIComponent(b)),d=[],f=0;f<b.length;f++){d.push(b.charCodeAt(f))}return d})}function xa(b){var d=j;j+=b;j=j+3>>2<<2;return d}function ya(b){var d=za;za+=b;za=za+3>>2<<2;za>=Aa&&Ba("Cannot enlarge memory arrays. Either (1) compile with -s TOTAL_MEMORY=X with X higher than the current value ( "+Aa+"), (2) compile with ALLOW_MEMORY_GROWTH which adjusts the size at runtime but prevents some optimizations, or (3) set Module.TOTAL_MEMORY before the program runs.");return d}var ta=4,Ca={},Da=1,Ea={},k,Fa,Ga;function Ba(b){a.print(b+":\n"+Error().stack);aa("Assertion: "+b)}function ua(b,d){b||Ba("Assertion failed: "+d)}var Ha=this;a.ccall=(function(b,d,c,e){return Ja(Ka(b),d,c,e)});function Ka(b){try{var d=eval("_"+b)}catch(c){try{d=Ha.Module["_"+b]}catch(e){}}ua(d,"Cannot call unknown function "+b+" (perhaps LLVM optimizations or closure removed it?)");return d}function Ja(b,d,c,e){function f(b,c){if("string"==c){if(b===da||b===ba||0===b){return 0}g||(g=j);var d=xa(b.length+1);La(b,d);return d}return"array"==c?(g||(g=j),d=xa(b.length),Ma(b,d),d):b}var g=0,h=0,e=e?e.map((function(b){return f(b,c[h++])})):[];b=b.apply(da,e);"string"==d?d=Na(b):(ua("array"!=d),d=b);g&&(j=g);return d}a.cwrap=(function(b,d,c){var e=Ka(b);return(function(){return Ja(e,d,c,Array.prototype.slice.call(arguments))})});function Oa(b,d,c){c=c||"i8";"*"===c.charAt(c.length-1)&&(c="i32");switch(c){case"i1":l[b]=d;break;case"i8":l[b]=d;break;case"i16":Pa[b>>1]=d;break;case"i32":t[b>>2]=d;break;case"i64":Ga=[d>>>0,Math.min(Math.floor(d/4294967296),4294967295)];t[b>>2]=Ga[0];t[b+4>>2]=Ga[1];break;case"float":Ra[b>>2]=d;break;case"double":Ta[0]=d;t[b>>2]=Ua[0];t[b+4>>2]=Ua[1];break;default:Ba("invalid type for setValue: "+c)}}a.setValue=Oa;a.getValue=(function(b,d){d=d||"i8";"*"===d.charAt(d.length-1)&&(d="i32");switch(d){case"i1":return l[b];case"i8":return l[b];case"i16":return Pa[b>>1];case"i32":return t[b>>2];case"i64":return t[b>>2];case"float":return Ra[b>>2];case"double":return Ua[0]=t[b>>2],Ua[1]=t[b+4>>2],Ta[0];default:Ba("invalid type for setValue: "+d)}return da});var Va=1,x=2,Wa=3;a.ALLOC_NORMAL=0;a.ALLOC_STACK=Va;a.ALLOC_STATIC=x;a.ALLOC_NONE=Wa;function y(b,d,c,e){var f,g;"number"===typeof b?(f=ca,g=b):(f=fa,g=b.length);var h="string"===typeof d?d:da,c=c==Wa?e:[Xa,xa,ya][c===ba?x:c](Math.max(g,h?1:d.length));if(f){return Ya(c,g),c}for(f=0;f<g;){var i=b[f];"function"===typeof i&&(i=Ca.S(i));e=h||d[f];0===e?f++:("i64"==e&&(e="i32"),Oa(c+f,i,e),f+=sa(e))}return c}a.allocate=y;function Na(b,d){for(var c=new wa,e="undefined"==typeof d,f="",g=0,h;;){h=$a[b+g];if(e&&0==h){break}f+=c.C(h);g+=1;if(!e&&g==d){break}}return f}a.Pointer_stringify=Na;a.Array_stringify=(function(b){for(var d="",c=0;c<b.length;c++){d+=String.fromCharCode(b[c])}return d});var ab,cb=4096,l,$a,Pa,db,t,eb,Ra,fb,j,hb,za,ib=a.TOTAL_STACK||5242880,Aa=a.TOTAL_MEMORY||10485760;ua(!!Int32Array&&!!Float64Array&&!!(new Int32Array(1)).subarray&&!!(new Int32Array(1)).set,"Cannot fallback to non-typed array case: Code is too specialized");var jb=new ArrayBuffer(Aa);l=new Int8Array(jb);Pa=new Int16Array(jb);t=new Int32Array(jb);$a=new Uint8Array(jb);db=new Uint16Array(jb);eb=new Uint32Array(jb);Ra=new Float32Array(jb);fb=new Float64Array(jb);t[0]=255;ua(255===$a[0]&&0===$a[3],"Typed arrays 2 must be run on a little-endian system");a.HEAP=ba;a.HEAP8=l;a.HEAP16=Pa;a.HEAP32=t;a.HEAPU8=$a;a.HEAPU16=db;a.HEAPU32=eb;a.HEAPF32=Ra;a.HEAPF64=fb;hb=(j=4*Math.ceil(.25))+ib;var kb=8*Math.ceil(hb/8);l.subarray(kb);var Ua=t.subarray(kb>>2);Ra.subarray(kb>>2);var Ta=fb.subarray(kb>>3);hb=kb+8;za=hb+4095>>12<<12;ua(za<Aa);var mb=y(lb("(null)"),"i8",x);function nb(b){for(;0<b.length;){var d=b.shift(),c=d.t;"number"===typeof c&&(c=ab[c]);c(d.G===ba?da:d.G)}}var pb=[],qb=[],rb=[];function tb(b){for(var d=b;l[d++];){}return d-b-1}a.String_len=tb;function lb(b,d,c){b=(new wa).K(b);c&&(b.length=c);d||b.push(0);return b}a.intArrayFromString=lb;a.intArrayToString=(function(b){for(var d=[],c=0;c<b.length;c++){var e=b[c];255<e&&(e&=255);d.push(String.fromCharCode(e))}return d.join("")});function La(b,d,c){b=lb(b,c);for(c=0;c<b.length;){l[d+c]=b[c],c+=1}}a.writeStringToMemory=La;function Ma(b,d){for(var c=0;c<b.length;c++){l[d+c]=b[c]}}a.writeArrayToMemory=Ma;function ub(b,d){return 0<=b?b:32>=d?2*Math.abs(1<<d-1)+b:Math.pow(2,d)+b}function vb(b,d){if(0>=b){return b}var c=32>=d?Math.abs(1<<d-1):Math.pow(2,d-1);if(b>=c&&(32>=d||b>c)){b=-2*c+b}return b}var xb=0,zb={},Ab=fa,Bb=da;function Cb(b){xb++;a.monitorRunDependencies&&a.monitorRunDependencies(xb);b?(ua(!zb[b]),zb[b]=1,Bb===da&&"undefined"!==typeof setInterval&&(Bb=setInterval((function(){var b=fa,c;for(c in zb){b||(b=ca,a.h("still waiting on run dependencies:")),a.h("dependency: "+c)}b&&a.h("(end of list)")}),6e3))):a.h("warning: run dependency added without ID")}a.addRunDependency=Cb;function Gb(b){xb--;a.monitorRunDependencies&&a.monitorRunDependencies(xb);b?(ua(zb[b]),delete zb[b]):a.h("warning: run dependency removed without ID");0==xb&&(Bb!==da&&(clearInterval(Bb),Bb=da),Ab||Hb())}a.removeRunDependency=Gb;a.preloadedImages={};a.preloadedAudios={};var Ib,Jb,z,Kb,Lb,Mb,Nb,Ob,Wb,Xb,Yb,Zb,$b,dc,ec,fc,gc,hc,ic,jc,oc,pc,qc,rc,sc,tc,yc,zc,Ac,Bc,Cc,Dc,Ec,Fc,Gc,Hc,Ic,Jc,Kc,Lc,Tc,Uc,Vc,Wc,Xc,Yc,Zc,ld,md,nd,od,pd,qd,rd,sd,td,ud,zd,Ad,Bd,Cd,Dd,Ed,Fd,Gd,Ud,Vd,Wd,Xd,Yd,Zd,$d,ae,be,ce,re,se,te,ue,ve,we,xe,ye,ze,Ae,Be,Ce,De,Ee,Fe,Ge,Ie,Je,Ke,Le,Me,Ne,Oe,Pe,Qe,Re,Se,Te,Ue,Ve,We,Xe,Ye,Ze,$e,af,bf,cf,df,ef,ff,gf,kf,lf,mf,nf,of,pf,qf,rf,sf,tf,uf,vf,wf,xf,yf,zf,Af,Bf,Cf,Df,Ef,Ff,Gf,Hf,If,Jf,Kf,Lf,Mf,Nf,Of,Pf,Qf,Rf,Sf,Tf,Uf,Vf,Wf,Xf,Yf,Zf,$f,ag,bg,cg,dg,eg,fg,gg,hg,ig,jg,kg,lg,mg,ng,og,pg,qg,rg,sg,tg,ug,vg,wg,xg,yg,zg,Bg,Cg,Dg,Eg,Fg,Gg,Hg,Ig,Jg,Kg,Lg,Mg,Ng,Og,Pg,Qg,Rg,Sg,Tg,Ug,Vg,Wg,Xg,Yg,Zg,$g,ah,bh,ch,dh,eh,fh,gh,hh,ih,jh,kh,lh,mh,nh,oh,ph,qh,rh,sh,th,uh,vh,wh,xh,yh,zh,Ah,Bh,Ch,Dh,Eh,Fh,Gh,Hh,Ih,Jh,Kh,Lh,Mh,Nh,Oh,Ph,Qh,Rh,Sh,Th,Uh,Vh,Wh,Xh,Yh,Zh,$h,ai,bi,ci,di,ei,fi,gi,hi,ii,ji,ki,li,mi,ni,oi,pi,qi,ri,si,ti,ui,vi,wi,xi,yi,zi,Ai,Bi,Ci,Di,Ei,Fi,Gi,Hi,Ii,Ji,Ki,Li,Mi,Ni,Oi,Pi,Qi,Ri,Si,Ti,Ui,Vi,Wi,Xi,Yi,Zi,$i,aj,bj,cj,dj,ej,fj,gj,hj,ij,jj,kj,lj,mj,nj,oj,pj,qj,rj,sj,tj,uj,vj,wj,xj,yj,zj,Aj,Bj,Cj,Dj,Ej,Fj,Gj,Hj,Ij,Jj,Kj,Lj,Mj,Nj,Oj,Pj,Qj,Rj,Sj,Tj,Uj,Vj,Wj,Xj,Yj,Zj,$j,ak,bk,ck,dk,ek,fk,gk,hk,ik,jk,kk,lk,mk,nk,ok,pk,qk,rk,sk,tk,uk,vk,wk,xk,yk,zk,Ak,Bk,Ck,Dk,Ek,Fk,Gk,Hk,Ik,Jk,Kk,Lk,Mk,Nk,Ok,Pk,Qk,Rk,Sk,Tk,Uk,Vk,Wk,Xk,Yk,Zk,$k,al,bl,cl,dl,el,fl,gl,hl,il,jl,kl,ll,ml,nl,ol,pl,ql,rl,sl,tl,ul,vl,wl,xl,yl,zl,Al,Bl,Cl,Dl,El,Fl,Gl,Hl,Il,Jl,Kl,Ll,Ml,Nl,Ol,Pl,Ql,Rl,Sl,Tl,Ul,Vl,Wl,Xl,Yl,Zl,$l,am,bm,cm,dm,em,fm,gm,hm,im,jm,km,lm,mm,nm,om,pm,qm,rm,sm,tm,um,vm,wm,xm,ym,zm,Am,Bm,Cm,Dm,Em,Fm,Gm,Hm,Im,Jm,Km,Lm,Mm,Nm,Om,Pm,Qm,Rm,Sm,Tm,Um,Vm,Wm,Xm,Ym,Zm,$m,an,bn,cn,dn,en,fn,gn,hn,jn,kn,ln,mn,nn,on,pn,qn,rn,sn,tn,un,vn,wn,xn,yn,zn,An,Bn,Cn,Dn,En,Fn,Gn,Hn,In,Jn,Kn,Ln,Mn,Nn,On,Pn,Qn,Rn,Sn,Tn,Un,Vn,Wn,Xn,Yn,Zn,$n,ao,bo,co,eo,fo,go,ho,io,jo,ko,lo,mo,no,oo,po,qo,ro,so,to,uo,vo,wo,xo,yo,zo,Ao,Bo,Co,Do,Eo,Fo,Go,Ho,Io,Jo,Ko,Lo,Mo,No,Oo,Po,Qo,Ro,So,To,Uo,Vo,Wo,Xo,Yo,Zo,$o,ap,bp,cp,dp,ep,fp,gp,hp,ip,jp,kp,lp,mp,np,op,pp,qp,rp,sp,tp,up,vp,wp,xp,yp,zp,Ap,Bp,Cp,Dp,Ep,Fp,Gp,Hp,Ip,Jp,Kp,Lp,Mp,Np,Op,Pp,Qp,Rp,Sp,Tp,Up,Vp,Wp,Zp,$p,aq,bq,cq,dq,eq,fq,gq,hq,iq,jq,kq,lq,mq,nq,oq,pq,qq,rq,sq,tq,uq,vq,wq,xq,yq,zq,Aq,Bq,Cq,Dq,Eq,Fq,Gq,Hq,Iq,Jq,Kq,Lq,Mq,Nq,Oq,Pq,Qq,Rq,Sq,Tq,Uq,Vq,Wq,Xq,Yq,Zq,$q,ar,br,cr,dr,er,fr,gr,hr,ir,jr,kr,lr,mr,nr,or,pr,qr,rr,sr,tr,ur,vr,wr,xr,yr,zr,Ar,Br,Cr,Dr,Er,Fr,Gr,Hr,Ir,Jr,Kr,Lr,Mr,Nr,Or,Pr,Qr,Rr,Sr,Tr,Ur,Vr,Wr,Xr,Yr,Zr,$r,as,bs,cs,ds,es,fs,gs,hs,is,js,ks,ls,ms,ns,os,ps,qs,rs,ss,ts,us,vs,ws,xs,ys,zs,As,Bs,Cs,Ds,Es,Fs,Gs,Hs,Is,Js,Ks,Ls,Ms,Ns,Os,Ps,Qs,Rs,Ss,Ts,Us,Vs,Ws,Xs,Ys,Zs,$s,at,bt,ct,dt,et,ft,gt,ht,it,jt,kt,lt,mt,nt,ot,pt,qt,rt,st,tt,ut,vt,wt,xt,yt,zt,At,Bt,Ct,Dt,Et,Ft,Gt,Ht,It,Jt,Kt,Lt,Mt,Nt,Ot,Pt,Qt,Rt,St,Tt,Ut,Vt,Wt,Xt,Yt,Zt,$t,au,bu,cu,du,eu,fu,gu,hu,iu,ju,ku,lu,mu,nu,ou,pu,qu,ru,su,tu,uu,vu,wu,xu,yu,zu,Au,Bu,Cu,Du,Eu,Fu,Gu,Hu,Iu,Ju,Ku,Lu,Mu,Nu,Ou,Pu,Qu,Ru,Su,Tu,Uu,Vu,Wu,Xu,Yu,Zu,$u,av,bv,cv,dv,ev,fv,gv,hv,iv,jv,kv,lv,mv,nv,ov,pv,qv,rv,sv,tv,uv,vv,wv,xv,yv,zv,Av,Bv,Cv,Dv,Ev,Fv,Gv,Hv,Iv,Jv,Kv,Lv,Mv,Nv,Ov,Pv,Qv,Rv,Sv,Tv,Uv,Vv,Wv,Xv,Yv,Zv,$v,aw,bw,cw,dw,ew,fw,gw,hw,iw,jw,kw,lw,mw,nw,ow,pw,qw,rw,sw,tw,uw,vw,ww,xw,yw,zw,Aw,Bw,Cw,Dw,Ew,Fw,Gw,Hw,Iw,Jw,Kw,Lw,Mw,Nw,Ow,Pw,Qw,Rw,Sw,Tw,Uw,Vw,Ww,Xw,Yw,Zw,$w,ax,bx,cx,dx,ex,fx,gx,hx,ix,jx,kx,lx,mx,nx,ox,px,qx,rx,sx,tx,ux,vx,wx,xx,D,yx,zx,Ax,Bx,Cx,E,Dx,Ex,Fx,Gx,Hx,Ix,Jx,Kx,Lx,Mx,Nx,Ox,Px,Qx,F,Rx,Sx,Tx,Ux,Vx,Wx,Xx,Yx,Zx,$x,ay,by,cy,dy,ey,fy,gy,hy,iy,jy,ky,ly,my,ny,oy,py,qy,ry,sy,ty,uy,vy,wy,xy,yy,zy,Ay,By,Cy,Dy,Ey,Fy,Gy,Hy,Iy,Jy,Ky,Ly,My,Ny,Oy,Py,Qy,Ry,Sy,Ty,Uy,H,Vy,Wy,Xy,Yy,Zy,$y,az,bz,cz,dz,ez,fz,gz,hz,iz,J,jz,kz,lz,K,mz,nz,oz,pz,qz,rz,sz,tz,uz,vz,wz,xz,yz,zz,Az,Bz,Cz,Dz,Ez,Fz,Gz,Hz,Iz,Jz,Kz,Lz,Mz,Nz,Oz,Pz,Qz,Rz,Sz,Tz,Uz,Vz,Wz,Xz,Yz,Zz,$z,aA,bA,cA,dA,eA,fA,gA,hA,iA,jA,kA,lA;Ib=y(4,"i8",x);Jb=y(4,"i8",x);z=y(4,"i8",x);Kb=y(4,"i8",x);Lb=y(80,"i8",x);Mb=y(4,"i8",x);Nb=y(4,"i8",x);Xb=y(4,"i8",x);Yb=y(4096,"i8",x);Zb=y(4,"i8",x);$b=y([-1],["i32",0,0,0],x);dc=y([0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],["*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0],x);ec=y(4,"i8",x);fc=y(4,"i8",x);gc=y(4,"i8",x);hc=y(116,"i8",x);ic=y(4,"i8",x);jc=y(4,"i8",x);oc=y(4,"i8",x);pc=y(4,"i8",x);qc=y(4,"i8",x);rc=y(4,"i8",x);sc=y([0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,13,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,15,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,17,0,0,0,0,0,0,0,18,0,0,0,0,0,0,0,19,0,0,0,0,0,0,0,20,0,0,0],["*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0],x);tc=y(4,"i8",x);yc=y(4,"i8",x);zc=y(24,"i8",x);Ac=y(4,"i8",x);Bc=y(4,"i8",x);Cc=y(8,"i8",x);Dc=y(4,"i8",x);Ec=y(4,"i8",x);Fc=y(44,"i8",x);Gc=y(1024,"i8",x);Hc=y(4,"i8",x);Ic=y(16,"i8",x);Jc=y(4,"i8",x);Kc=y(4,"i8",x);Lc=y([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"i8",x);Tc=y([122],["void (%struct.sVString*, i32)*",0,0,0],x);Uc=y(4,"i8",x);Vc=y([1],["i32",0,0,0],x);Wc=y(4,"i8",x);Xc=y([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,1,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],["*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0],x);Yc=y(4,"i8",x);Zc=y(4,"i8",x);ld=y(32,"i8",x);md=y(4,"i8",x);nd=y(4,"i8",x);od=y(4,"i8",x);pd=y(4,"i8",x);qd=y(4,"i8",x);rd=y(4,"i8",x);sd=y([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],["*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0],x);td=y(24,"i8",x);ud=y([115,113,108,0],"i8",x);zd=y([109,97,105,110,0],"i8",x);Ad=y([115,101,116,0],"i8",x);Bd=y([99,111,110,115,116,97,110,116,32,100,101,99,108,97,114,97,116,105,111,110,115,0],"i8",x);Cd=y([109,108,116,97,98,108,101,0],"i8",x);Dd=y([115,121,110,99,104,114,111,110,105,122,101,100,0],"i8",x);Ed=y([100,101,114,105,118,101,100,32,116,121,112,101,115,32,97,110,100,32,115,116,114,117,99,116,117,114,101,115,0],"i8",x);Fd=y([99,100,101,102,32,0],"i8",x);Gd=y([115,121,110,111,110,121,109,115,0],"i8",x);Ud=y([105,44,105,110,116,101,114,102,97,99,101,44,105,110,116,101,114,102,97,99,101,115,0],"i8",x);Vd=y([120,111,114,0],"i8",x);Wd=y([118,105,101,119,115,0],"i8",x);Xd=y([115,109,108,0],"i8",x);Yd=y([112,114,111,103,114,97,109,115,0],"i8",x);Zd=y([64,101,110,99,111,100,101,0],"i8",x);$d=y([115,108,0],"i8",x);ae=y([120,110,111,114,0],"i8",x);be=y([100,111,109,97,105,110,115,0],"i8",x);ce=y([101,120,112,111,114,116,0],"i8",x);re=y([115,116,114,105,110,103,0],"i8",x);se=y([110,97,109,101,108,105,115,116,115,0],"i8",x);te=y([116,104,105,115,0],"i8",x);ue=y([102,44,102,117,110,99,116,105,111,110,44,74,97,118,97,83,99,114,105,112,116,32,102,117,110,99,116,105,111,110,115,0],"i8",x);ve=y([119,105,116,104,0],"i8",x);we=y([115,101,114,118,105,99,101,115,0],"i8",x);xe=y([115,104,0],"i8",x);ye=y([119,104,105,108,101,0],"i8",x);ze=y([112,117,98,108,105,99,97,116,105,111,110,115,0],"i8",x);Ae=y([115,116,97,116,101,0],"i8",x);Be=y([83,67,77,0],"i8",x);Ce=y([97,117,116,111,109,97,116,105,99,0],"i8",x);De=y([108,111,99,97,108,44,32,99,111,109,109,111,110,32,98,108,111,99,107,44,32,97,110,100,32,110,97,109,101,108,105,115,116,32,118,97,114,105,97,98,108,101,115,0],"i8",x);Ee=y([115,105,103,110,101,100,0],"i8",x);Fe=y([119,104,101,110,0],"i8",x);Ge=y([98,101,116,0],"i8",x);Ie=y([109,97,99,114,111,32,100,101,102,105,110,105,116,105,111,110,115,0],"i8",x);Je=y([119,97,105,116,0],"i8",x);Ke=y([105,110,100,101,120,101,115,0],"i8",x);Le=y([115,101,108,101,99,116,111,114,0],"i8",x);Me=y([115,104,111,114,116,0],"i8",x);Ne=y([102,105,108,101,0],"i8",x);Oe=y([94,91,32,9,93,42,91,70,83,82,93,68,91,32,9,93,43,40,91,65,45,90,48,45,57,93,91,65,45,90,48,45,57,45,93,42,41,92,46,0],"i8",x);Pe=y([68,72,79,66,0],"i8",x);Qe=y([112,97,114,115,101,114,32,100,101,102,105,110,105,116,105,111,110,32,109,117,115,116,32,99,111,110,116,97,105,110,32,110,97,109,101,10,0],"i8",x);Re=y([101,110,100,102,111,0],"i8",x);Se=y([97,114,99,104,105,116,101,99,116,117,114,101,0],"i8",x);Te=y([111,117,116,112,117,116,0],"i8",x);Ue=y([105,110,99,108,117,100,101,0],"i8",x);Ve=y([112,114,111,116,101,99,116,101,100,0],"i8",x);We=y([118,97,114,105,97,98,108,101,115,0],"i8",x);Xe=y([97,108,108,32,112,97,116,116,101,114,110,115,0],"i8",x);Ye=y([115,104,97,100,111,119,0],"i8",x);Ze=y([117,115,101,0],"i8",x);$e=y([116,114,105,103,103,101,114,115,0],"i8",x);af=y([97,108,105,103,110,0],"i8",x);bf=y([99,111,110,102,105,103,117,114,101,0],"i8",x);cf=y([116,121,112,101,32,97,110,100,32,115,116,114,117,99,116,117,114,101,32,99,111,109,112,111,110,101,110,116,115,0],"i8",x);df=y([117,110,116,105,108,0],"i8",x);ef=y([116,97,98,108,101,115,0],"i8",x);ff=y([117,110,108,101,115,115,0],"i8",x);gf=y([99,108,97,115,115,32,0],"i8",x);kf=y([118,97,114,105,97,98,108,101,32,100,101,102,105,110,105,116,105,111,110,115,0],"i8",x);lf=y([117,110,105,116,115,0],"i8",x);mf=y([115,117,98,116,121,112,101,115,0],"i8",x);nf=y([115,117,98,0],"i8",x);of=y([117,110,99,116,105,111,110,0],"i8",x);pf=y([105,110,116,101,114,102,97,99,101,32,99,111,110,116,101,110,116,115,44,32,103,101,110,101,114,105,99,32,110,97,109,101,115,44,32,97,110,100,32,111,112,101,114,97,116,111,114,115,0],"i8",x);qf=y([118,97,114,105,97,98,108,101,0],"i8",x);rf=y([117,110,97,102,102,101,99,116,101,100,0],"i8",x);sf=y([114,101,99,111,114,100,115,0],"i8",x);tf=y([99,109,100,0],"i8",x);uf=y([64,112,114,111,116,111,99,111,108,0],"i8",x);vf=y([109,97,112,115,0],"i8",x);wf=y([116,121,112,101,0],"i8",x);xf=y([101,110,116,114,121,32,112,111,105,110,116,115,0],"i8",x);yf=y([102,117,110,99,116,105,111,110,32,100,101,102,105,110,105,116,105,111,110,115,0],"i8",x);zf=y([116,114,97,110,115,112,111,114,116,0],"i8",x);Af=y([112,97,99,107,97,103,101,115,0],"i8",x);Bf=y([99,111,109,109,111,110,32,98,108,111,99,107,115,0],"i8",x);Cf=y([102,117,110,99,116,105,111,110,0],"i8",x);Df=y([116,111,0],"i8",x);Ef=y([98,108,111,99,107,32,108,97,98,101,108,0],"i8",x);Ff=y([97,115,115,105,103,110,109,101,110,116,0],"i8",x);Gf=y([98,108,111,99,107,32,100,97,116,97,0],"i8",x);Hf=y([117,115,101,114,45,100,101,102,105,110,101,100,32,99,111,109,109,97,110,100,115,0],"i8",x);If=y([116,104,101,110,0],"i8",x);Jf=y([112,97,99,107,101,100,0],"i8",x);Kf=y([42,67,99,33,35,36,68,100,0],"i8",x);Lf=y([99,111,109,109,97,110,100,0],"i8",x);Mf=y([115,117,98,116,121,112,101,0],"i8",x);Nf=y([108,111,99,97,108,32,118,97,114,105,97,98,108,101,115,0],"i8",x);Of=y([112,114,97,103,109,97,0],"i8",x);Pf=y([112,121,0],"i8",x);Qf=y([37,115,58,32,117,110,116,101,114,109,105,110,97,116,101,100,32,99,104,97,114,97,99,116,101,114,32,115,116,114,105,110,103,32,97,116,32,108,105,110,101,32,37,108,117,10,0],"i8",x);Rf=y([73,110,115,116,97,108,108,105,110,103,32,112,97,114,115,101,114,115,58,32,0],"i8",x);Sf=y([101,110,100,0],"i8",x);Tf=y([97,110,100,0],"i8",x);Uf=y([109,111,100,117,108,101,0],"i8",x);Vf=y([100,101,102,97,117,108,116,0],"i8",x);Wf=y([115,117,98,112,97,114,97,103,114,97,112,104,0],"i8",x);Xf=y([97,117,116,111,99,111,109,109,97,110,100,32,103,114,111,117,112,115,0],"i8",x);Yf=y([112,117,98,108,105,99,0],"i8",x);Zf=y([115,114,108,0],"i8",x);$f=y([114,101,99,111,114,100,32,102,105,101,108,100,115,0],"i8",x);ag=y([112,97,116,116,101,114,110,0],"i8",x);bg=y([42,47,43,61,60,62,0],"i8",x);cg=y([97,117,103,114,111,117,112,0],"i8",x);dg=y([115,114,97,0],"i8",x);eg=y([102,105,101,108,100,0],"i8",x);fg=y([111,118,101,114,108,111,97,100,0],"i8",x);gg=y([65,115,109,0],"i8",x);hg=y([97,98,115,116,121,112,101,0],"i8",x);ig=y([110,44,110,97,109,101,115,112,97,99,101,44,110,97,109,101,115,112,97,99,101,115,0],"i8",x);jg=y([112,104,112,0],"i8",x);kg=y([99,110,111,114,101,109,97,112,0],"i8",x);lg=y([115,108,105,0],"i8",x);mg=y([61,0],"i8",x);ng=y([100,101,102,32,0],"i8",x);og=y([99,110,111,114,101,109,97,0],"i8",x);pg=y([115,108,97,0],"i8",x);qg=y([94,91,32,9,93,42,105,110,116,101,114,102,97,99,101,91,32,9,93,43,40,91,65,45,90,97,45,122,127,45,255,95,93,91,48,45,57,65,45,90,97,45,122,127,45,255,95,93,42,41,0],"i8",x);rg=y([95,95,69,78,68,95,95,0],"i8",x);sg=y([114,111,99,101,100,117,114,101,0],"i8",x);tg=y([97,110,111,110,121,109,111,117,115,0],"i8",x);ug=y([99,110,111,114,101,109,0],"i8",x);vg=y([115,104,97,114,101,100,0],"i8",x);wg=y([110,101,119,99,111,118,0],"i8",x);xg=y([100,105,109,0],"i8",x);yg=y([100,111,110,101,0],"i8",x);zg=y([64,105,110,116,101,114,102,97,99,101,0],"i8",x);Bg=y([45,0],"i8",x);Cg=y([99,110,111,114,101,0],"i8",x);Dg=y([115,105,103,110,97,108,0],"i8",x);Eg=y([99,117,114,115,111,114,115,0],"i8",x);Fg=y([101,110,100,101,102,0],"i8",x);Gg=y([112,108,0],"i8",x);Hg=y([37,115,58,32,110,111,116,32,102,105,120,101,100,32,115,111,117,114,99,101,32,102,111,114,109,59,32,114,101,116,114,121,32,97,115,32,102,114,101,101,32,115,111,117,114,99,101,32,102,111,114,109,10,0],"i8",x);Ig=y([94,91,32,9,93,42,102,117,110,99,116,105,111,110,91,32,9,93,42,40,91,65,45,90,97,45,122,48,45,57,95,93,43,41,91,32,9,93,42,92,40,0],"i8",x);Jg=y([99,110,111,114,0],"i8",x);Kg=y([115,101,118,101,114,105,116,121,0],"i8",x);Lg=y([110,97,116,105,118,101,0],"i8",x);Mg=y([102,117,110,99,0],"i8",x);Ng=y([112,0],"i8",x);Og=y([99,110,111,0],"i8",x);Pg=y([115,101,108,101,99,116,0],"i8",x);Qg=y([103,111,0],"i8",x);Rg=y([97,108,108,111,99,97,116,97,98,108,101,0],"i8",x);Sg=y([119,104,101,114,101,0],"i8",x);Tg=y([108,110,111,114,101,109,97,112,0],"i8",x);Ug=y([114,111,114,0],"i8",x);Vg=y([99,114,101,97,116,101,0],"i8",x);Wg=y([118,111,108,97,116,105,108,101,0],"i8",x);Xg=y([97,116,116,97,99,104,101,100,0],"i8",x);Yg=y([108,110,111,114,101,109,97,0],"i8",x);Zg=y([114,111,108,0],"i8",x);$g=y([99,111,109,109,101,110,116,0],"i8",x);ah=y([109,95,116,114,97,110,115,0],"i8",x);bh=y([100,44,100,97,116,97,44,100,97,116,97,32,105,116,101,109,115,0],"i8",x);ch=y([101,110,100,105,102,0],"i8",x);dh=y([47,0],"i8",x);eh=y([42,46,91,120,88,93,91,54,56,93,91,54,56,93,0],"i8",x);fh=y([108,101,116,0],"i8",x);gh=y([105,110,116,101,103,101,114,0],"i8",x);hh=y([63,0],"i8",x);ih=y([112,97,114,97,103,114,97,112,104,0],"i8",x);jh=y([108,110,111,114,101,109,0],"i8",x);kh=y([105,116,99,108,58,58,99,108,97,115,115,0],"i8",x);lh=y([114,101,116,117,114,110,0],"i8",x);mh=y([104,97,110,100,108,101,114,0],"i8",x);nh=y([100,101,99,108,97,114,101,0],"i8",x);oh=y([102,114,97,103,109,101,110,116,32,100,101,102,105,110,105,116,105,111,110,115,0],"i8",x);ph=y([109,95,115,116,97,116,101,0],"i8",x);qh=y([108,110,111,114,101,0],"i8",x);rh=y([114,101,106,101,99,116,0],"i8",x);sh=y([115,121,110,111,110,121,109,0],"i8",x);th=y([109,95,98,97,100,95,116,114,97,110,115,0],"i8",x);uh=y([97,115,109,0],"i8",x);vh=y([102,114,97,103,109,101,110,116,0],"i8",x);wh=y([33,37,38,36,35,43,45,60,62,61,47,63,64,92,126,39,94,124,42,95,0],"i8",x);xh=y([94,91,32,9,93,42,105,109,112,108,101,109,101,110,116,115,91,32,9,93,43,92,40,91,32,9,93,42,34,40,91,94,34,93,42,41,34,91,32,9,93,42,92,41,91,32,9,93,42,59,0],"i8",x);yh=y([83,104,0],"i8",x);zh=y([83,99,104,101,109,101,0],"i8",x);Ah=y([108,110,111,114,0],"i8",x);Bh=y([114,101,103,105,115,116,101,114,0],"i8",x);Ch=y([118,105,101,119,0],"i8",x);Dh=y([109,95,98,97,100,95,115,116,97,116,101,0],"i8",x);Eh=y([115,44,115,117,98,114,111,117,116,105,110,101,44,115,117,98,114,111,117,116,105,110,101,115,0],"i8",x);Fh=y([117,110,105,111,110,0],"i8",x);Gh=y([108,110,111,0],"i8",x);Hh=y([114,101,99,111,114,100,0],"i8",x);Ih=y([100,114,111,112,0],"i8",x);Jh=y([99,44,99,108,97,115,115,44,99,108,97,115,115,101,115,0],"i8",x);Kh=y([108,111,110,103,0],"i8",x);Lh=y([95,95,68,65,84,65,95,95,0],"i8",x);Mh=y([101,115,116,114,117,99,116,111,114,0],"i8",x);Nh=y([108,111,99,97,108,32,101,110,116,105,116,105,101,115,0],"i8",x);Oh=y([105,110,111,114,101,109,97,112,0],"i8",x);Ph=y([114,97,110,103,101,0],"i8",x);Qh=y([116,101,109,112,111,114,97,114,121,0],"i8",x);Rh=y([100,105,109,32,97,115,0],"i8",x);Sh=y([109,108,0],"i8",x);Th=y([102,101,97,116,117,114,101,115,0],"i8",x);Uh=y([64,105,109,112,108,101,109,101,110,116,97,116,105,111,110,0],"i8",x);Vh=y([105,110,111,114,101,109,97,0],"i8",x);Wh=y([112,117,114,101,0],"i8",x);Xh=y([76,105,115,112,0],"i8",x);Yh=y([116,97,114,103,101,116,0],"i8",x);Zh=y([105,110,111,114,101,109,0],"i8",x);$h=y([112,114,111,99,101,115,115,0],"i8",x);ai=y([109,108,95,97,100,100,95,112,114,111,112,101,114,116,121,0],"i8",x);bi=y([105,110,111,114,101,0],"i8",x);ci=y([112,114,111,99,101,100,117,114,101,0],"i8",x);di=y([109,108,95,97,100,100,95,108,97,110,103,95,99,111,110,110,95,115,99,114,105,112,116,95,99,104,107,0],"i8",x);ei=y([70,111,114,116,114,97,110,0],"i8",x);fi=y([66,73,84,0],"i8",x);gi=y([105,110,111,114,0],"i8",x);hi=y([112,111,115,116,112,111,110,101,100,0],"i8",x);ii=y([109,108,95,97,100,100,95,106,97,118,97,95,99,111,110,110,101,99,116,105,111,110,95,115,99,114,105,112,116,0],"i8",x);ji=y([105,110,116,0],"i8",x);ki=y([115,116,100,99,97,108,108,0],"i8",x);li=y([97,115,115,105,103,110,0],"i8",x);mi=y([105,110,111,0],"i8",x);ni=y([115,101,116,91,32,9,93,43,40,91,65,45,90,97,45,122,95,48,45,57,93,43,41,91,32,9,93,42,61,0],"i8",x);oi=y([112,111,114,116,0],"i8",x);pi=y([109,108,95,97,100,100,95,100,110,101,116,95,99,111,110,110,101,99,116,105,111,110,95,115,99,114,105,112,116,0],"i8",x);qi=y([102,111,110,116,45,102,97,99,101,0],"i8",x);ri=y([98,97,115,0],"i8",x);si=y([70,97,105,108,117,114,101,32,111,110,32,97,116,116,101,109,112,116,32,116,111,32,114,101,97,100,32,102,105,108,101,0],"i8",x);ti=y([101,108,115,101,0],"i8",x);ui=y([65,110,32,101,120,99,101,112,116,105,111,110,0],"i8",x);vi=y([32,32,32,32,37,115,58,32,0],"i8",x);wi=y([115,116,97,116,105,99,0],"i8",x);xi=y([109,0],"i8",x);yi=y([97,117,103,0],"i8",x);zi=y([42,46,91,54,56,93,91,54,56,93,91,107,75,115,83,120,88,93,0],"i8",x);Ai=y([97,108,105,97,115,0],"i8",x);Bi=y([105,110,112,117,116,0],"i8",x);Ci=y([112,97,114,116,0],"i8",x);Di=y([111,110,111,114,101,109,97,112,0],"i8",x);Ei=y([99,120,120,0],"i8",x);Fi=y([99,108,97,115,115,0],"i8",x);Gi=y([112,97,99,107,97,103,101,0],"i8",x);Hi=y([109,108,95,97,100,100,95,108,97,110,103,95,99,111,110,110,101,99,116,105,111,110,95,115,99,114,105,112,116,0],"i8",x);Ii=y([99,117,114,115,111,114,0],"i8",x);Ji=y([69,120,99,101,112,116,105,111,110,0],"i8",x);Ki=y([115,101,113,117,101,110,99,101,0],"i8",x);Li=y([118,97,114,105,97,110,116,0],"i8",x);Mi=y([111,110,111,114,101,109,97,0],"i8",x);Ni=y([111,117,116,0],"i8",x);Oi=y([109,108,95,97,100,100,95,99,111,110,110,101,99,116,105,111,110,95,115,99,114,105,112,116,0],"i8",x);Pi=y([116,44,116,97,114,103,101,116,44,116,97,114,103,101,116,115,0],"i8",x);Qi=y([99,111,110,116,101,120,116,115,0],"i8",x);Ri=y([83,76,79,84,0],"i8",x);Si=y([65,32,39,115,116,114,117,99,116,117,114,101,39,32,102,105,101,108,100,0],"i8",x);Ti=y([105,0],"i8",x);Ui=y([122,115,104,0],"i8",x);Vi=y([115,109,0],"i8",x);Wi=y([91,77,109,93,97,107,101,102,105,108,101,0],"i8",x);Xi=y([46,0],"i8",x);Yi=y([111,110,111,114,101,109,0],"i8",x);Zi=y([111,116,104,101,114,115,0],"i8",x);$i=y([109,108,95,97,100,100,95,108,97,110,103,95,116,97,98,108,101,95,115,99,114,105,112,116,95,99,104,107,0],"i8",x);aj=y([100,101,115,99,114,105,98,101,115,0],"i8",x);bj=y([108,117,97,0],"i8",x);cj=y([82,101,99,111,114,100,32,102,105,101,108,100,0],"i8",x);dj=y([115,97,118,101,0],"i8",x);ej=y([80,121,116,104,111,110,0],"i8",x);fj=y([111,110,111,114,101,0],"i8",x);gj=y([111,114,0],"i8",x);hj=y([109,108,95,97,100,100,95,106,97,118,97,95,116,97,98,108,101,95,115,99,114,105,112,116,0],"i8",x);ij=y([99,108,0],"i8",x);jj=y([105,109,112,108,101,109,101,110,116,115,0],"i8",x);kj=y([92,51,0],"i8",x);lj=y([115,105,110,103,108,101,116,111,110,32,109,101,116,104,111,100,115,0],"i8",x);mj=y([65,32,99,111,110,115,116,114,117,99,116,111,114,0],"i8",x);nj=y([61,99,117,116,0],"i8",x);oj=y([111,110,115,116,114,117,99,116,111,114,0],"i8",x);pj=y([114,101,99,117,114,115,105,118,101,0],"i8",x);qj=y([117,110,100,101,102,105,110,101,0],"i8",x);rj=y([111,110,111,114,0],"i8",x);sj=y([111,112,101,110,0],"i8",x);tj=y([109,108,95,97,100,100,95,100,110,101,116,95,116,97,98,108,101,95,115,99,114,105,112,116,0],"i8",x);uj=y([115,105,110,103,108,101,116,111,110,32,109,101,116,104,111,100,0],"i8",x);vj=y([67,111,110,115,116,114,117,99,116,111,114,0],"i8",x);wj=y([101,110,117,109,0],"i8",x);xj=y([103,111,116,111,0],"i8",x);yj=y([111,110,111,0],"i8",x);zj=y([109,108,95,97,100,100,95,108,97,110,103,95,116,97,98,108,101,95,115,99,114,105,112,116,0],"i8",x);Aj=y([97,119,107,0],"i8",x);Bj=y([108,115,112,0],"i8",x);Cj=y([65,32,102,117,110,99,116,105,111,110,0],"i8",x);Dj=y([79,98,106,101,99,116,0],"i8",x);Ej=y([97,44,97,110,99,104,111,114,44,110,97,109,101,100,32,97,110,99,104,111,114,115,0],"i8",x);Fj=y([118,110,111,114,101,109,97,112,0],"i8",x);Gj=y([111,102,0],"i8",x);Hj=y([109,108,95,97,100,100,95,116,97,98,108,101,95,115,99,114,105,112,116,0],"i8",x);Ij=y([84,121,112,101,32,110,97,109,101,0],"i8",x);Jj=y([115,116,114,105,112,0],"i8",x);Kj=y([118,110,111,114,101,109,97,0],"i8",x);Lj=y([110,117,108,108,0],"i8",x);Mj=y([102,111,114,101,105,103,110,0],"i8",x);Nj=y([102,114,105,101,110,100,0],"i8",x);Oj=y([102,57,53,0],"i8",x);Pj=y([71,108,111,98,97,108,32,118,97,114,105,97,98,108,101,0],"i8",x);Qj=y([115,101,112,97,114,97,116,101,0],"i8",x);Rj=y([118,110,111,114,101,109,0],"i8",x);Sj=y([110,111,116,0],"i8",x);Tj=y([99,111,110,115,116,114,97,105,110,116,0],"i8",x);Uj=y([108,111,97,100,0],"i8",x);Vj=y([102,111,114,101,97,99,104,0],"i8",x);Wj=y([118,97,114,0],"i8",x);Xj=y([112,114,111,103,114,97,109,0],"i8",x);Yj=y([106,115,0],"i8",x);Zj=y([118,110,111,114,101,0],"i8",x);$j=y([99,104,101,99,107,0],"i8",x);ak=y([112,97,103,101,0],"i8",x);bk=y([96,0],"i8",x);ck=y([78,85,76,76,32,102,105,108,101,32,112,111,105,110,116,101,114,0],"i8",x);dk=y([101,108,105,102,0],"i8",x);ek=y([94,91,32,9,93,42,91,48,45,57,93,43,91,32,9,93,43,40,91,65,45,90,48,45,57,93,91,65,45,90,48,45,57,45,93,42,41,91,32,9,93,43,40,66,76,65,78,75,124,79,67,67,85,82,83,124,73,83,124,74,85,83,84,124,80,73,67,124,82,69,68,69,70,73,78,69,83,124,82,69,78,65,77,69,83,124,83,73,71,78,124,83,89,78,67,124,85,83,65,71,69,124,86,65,76,85,69,41,0],"i8",x);fk=y([77,111,100,117,108,101,32,111,114,32,102,117,110,99,116,111,114,0],"i8",x);gk=y([111,117,116,32,111,102,32,109,101,109,111,114,121,0],"i8",x);hk=y([102,117,0],"i8",x);ik=y([104,116,109,0],"i8",x);jk=y([114,101,116,114,121,0],"i8",x);kk=y([97,102,116,101,114,0],"i8",x);lk=y([42,46,50,57,91,107,75,93,0],"i8",x);mk=y([115,117,98,115,117,98,115,101,99,116,105,111,110,0],"i8",x);nk=y([118,110,111,114,0],"i8",x);ok=y([112,114,111,99,0],"i8",x);pk=y([110,101,120,116,0],"i8",x);qk=y([99,112,112,0],"i8",x);rk=y([117,110,105,113,117,101,0],"i8",x);sk=y([102,108,111,97,116,0],"i8",x);tk=y([33,126,0],"i8",x);uk=y([79,98,106,101,99,116,39,115,32,109,101,116,104,111,100,0],"i8",x);vk=y([112,114,101,99,105,115,105,111,110,0],"i8",x);wk=y([100,101,102,0],"i8",x);xk=y([118,110,111,0],"i8",x);yk=y([110,101,119,0],"i8",x);zk=y([114,101,102,101,114,101,110,99,101,115,0],"i8",x);Ak=y([102,105,110,97,108,0],"i8",x);Bk=y([94,91,32,9,93,42,60,91,32,9,93,42,116,97,114,103,101,116,91,94,62,93,43,110,97,109,101,61,34,40,91,94,34,93,43,41,34,46,42,0],"i8",x);Ck=y([61,126,0],"i8",x);Dk=y([40,42,0],"i8",x);Ek=y([102,44,102,117,110,99,116,105,111,110,44,102,117,110,99,116,105,111,110,115,0],"i8",x);Fk=y([107,115,104,0],"i8",x);Gk=y([115,99,109,0],"i8",x);Hk=y([112,111,105,110,116,101,114,0],"i8",x);Ik=y([114,101,115,99,117,101,0],"i8",x);Jk=y([105,110,99,0],"i8",x);Kk=y([110,110,111,114,101,109,97,112,0],"i8",x);Lk=y([110,97,110,100,0],"i8",x);Mk=y([112,114,105,109,97,114,121,0],"i8",x);Nk=y([33,61,0],"i8",x);Ok=y([61,101,110,100,0],"i8",x);Pk=y([94,40,91,65,45,90,97,45,122,48,45,57,64,35,36,92,46,33,63,95,93,43,41,91,32,9,93,42,58,0],"i8",x);Qk=y([79,67,97,109,108,32,77,97,120,105,109,117,109,32,100,101,112,116,104,32,114,101,97,99,104,101,100,0],"i8",x);Rk=y([65,32,112,114,101,112,114,111,99,101,115,115,111,114,32,109,97,99,114,111,0],"i8",x);Sk=y([112,103,108,111,98,97,108,0],"i8",x);Tk=y([114,101,113,117,105,114,101,0],"i8",x);Uk=y([115,99,111,110,115,0],"i8",x);Vk=y([104,43,43,0],"i8",x);Wk=y([110,110,111,114,101,109,97,0],"i8",x);Xk=y([109,111,100,0],"i8",x);Yk=y([101,120,116,101,110,100,115,0],"i8",x);Zk=y([94,91,32,9,93,42,40,40,102,105,110,97,108,124,97,98,115,116,114,97,99,116,41,91,32,9,93,43,41,42,99,108,97,115,115,91,32,9,93,43,40,91,65,45,90,97,45,122,127,45,255,95,93,91,48,45,57,65,45,90,97,45,122,127,45,255,95,93,42,41,0],"i8",x);$k=y([61,61,61,0],"i8",x);al=y([98,101,103,105,110,47,101,110,100,0],"i8",x);bl=y([80,101,114,108,0],"i8",x);cl=y([102,111,114,119,97,114,100,0],"i8",x);dl=y([112,101,120,116,101,114,110,97,108,0],"i8",x);el=y([114,101,110,97,109,101,0],"i8",x);fl=y([104,120,120,0],"i8",x);gl=y([110,110,111,114,101,109,0],"i8",x);hl=y([97,116,0],"i8",x);il=y([101,120,112,108,105,99,105,116,0],"i8",x);jl=y([61,61,0],"i8",x);kl=y([105,109,112,111,114,116,115,0],"i8",x);ll=y([77,111,100,117,108,101,0],"i8",x);ml=y([65,110,32,101,110,117,109,101,114,97,116,105,111,110,0],"i8",x);nl=y([66,97,115,105,99,0],"i8",x);ol=y([112,97,115,99,97,108,0],"i8",x);pl=y([114,101,100,101,102,105,110,101,0],"i8",x);ql=y([104,112,112,0],"i8",x);rl=y([110,110,111,114,101,0],"i8",x);sl=y([108,111,111,112,0],"i8",x);tl=y([101,120,99,101,112,116,105,111,110,0],"i8",x);ul=y([77,97,107,101,0],"i8",x);vl=y([60,61,62,0],"i8",x);wl=y([110,97,109,101,115,112,97,99,101,0],"i8",x);xl=y([108,105,115,112,0],"i8",x);yl=y([65,32,116,121,112,101,32,115,116,114,117,99,116,117,114,101,0],"i8",x);zl=y([112,114,101,102,105,120,0],"i8",x);Al=y([104,104,0],"i8",x);Bl=y([110,110,111,114,0],"i8",x);Cl=y([108,105,116,101,114,97,108,0],"i8",x);Dl=y([62,61,0],"i8",x);El=y([99,111,110,115,116,0],"i8",x);Fl=y([102,97,108,115,101,0],"i8",x);Gl=y([65,32,116,121,112,101,32,97,108,105,97,115,0],"i8",x);Hl=y([111,112,116,105,111,110,97,108,0],"i8",x);Il=y([72,0],"i8",x);Jl=y([110,110,111,0],"i8",x);Kl=y([108,105,110,107,97,103,101,0],"i8",x);Ll=y([62,0],"i8",x);Ml=y([99,108,97,115,115,32,109,101,109,98,101,114,115,0],"i8",x);Nl=y([102,57,48,0],"i8",x);Ol=y([116,114,117,101,0],"i8",x);Pl=y([65,32,112,114,111,112,101,114,116,121,0],"i8",x);Ql=y([111,112,101,114,97,116,111,114,0],"i8",x);Rl=y([111,110,99,101,0],"i8",x);Sl=y([104,0],"i8",x);Tl=y([110,111,114,101,109,97,112,0],"i8",x);Ul=y([108,105,98,114,97,114,121,0],"i8",x);Vl=y([69,114,108,97,110,103,0],"i8",x);Wl=y([60,0],"i8",x);Xl=y([45,62,0],"i8",x);Yl=y([112,114,111,112,101,114,116,121,0],"i8",x);Zl=y([110,97,109,101,108,105,115,116,0],"i8",x);$l=y([111,108,100,0],"i8",x);am=y([32,32,32,32,83,101,116,116,105,110,103,32,100,101,102,97,117,108,116,32,104,101,97,100,101,114,32,101,120,116,101,110,115,105,111,110,115,58,32,0],"i8",x);bm=y([110,111,114,101,109,97,0],"i8",x);cm=y([108,97,98,101,108,0],"i8",x);dm=y([116,97,115,107,115,0],"i8",x);em=y([101,120,116,101,114,110,97,108,0],"i8",x);fm=y([100,101,108,101,116,101,0],"i8",x);gm=y([60,61,0],"i8",x);hm=y(1,"i8",x);im=y([105,102,0],"i8",x);jm=y([67,111,98,111,108,0],"i8",x);km=y([97,115,114,0],"i8",x);lm=y([37,115,46,37,115,0],"i8",x);mm=y([108,44,108,97,98,101,108,44,108,97,98,101,108,115,0],"i8",x);nm=y([109,120,116,97,103,115,0],"i8",x);om=y([99,111,109,0],"i8",x);pm=y([111,98,115,111,108,101,116,101,0],"i8",x);qm=y([97,99,99,101,115,115,0],"i8",x);rm=y([32,32,32,32,97,100,100,105,110,103,32,101,120,99,108,117,100,101,32,112,97,116,116,101,114,110,58,32,37,115,10,0],"i8",x);sm=y([115,117,98,115,101,99,116,105,111,110,0],"i8",x);tm=y([110,111,114,101,109,0],"i8",x);um=y([84,99,108,0],"i8",x);vm=y([105,115,0],"i8",x);wm=y([114,101,103,105,115,116,101,114,32,100,97,116,97,32,116,121,112,101,115,0],"i8",x);xm=y([99,112,0],"i8",x);ym=y([105,110,116,101,114,110,97,108,0],"i8",x);zm=y([42,46,65,53,49,0],"i8",x);Am=y([100,101,108,101,103,97,116,101,0],"i8",x);Bm=y([124,0],"i8",x);Cm=y([34,34,34,0],"i8",x);Dm=y([108,115,114,32,0],"i8",x);Em=y([109,120,116,97,103,0],"i8",x);Fm=y([32,32,32,32,97,100,100,105,110,103,32,101,120,99,108,117,100,101,32,112,97,116,116,101,114,110,115,32,102,114,111,109,32,37,115,10,0],"i8",x);Gm=y([110,111,114,101,0],"i8",x);Hm=y([105,110,111,117,116,0],"i8",x);Im=y([117,114,108,0],"i8",x);Jm=y([112,44,112,114,111,106,101,99,116,44,112,114,111,106,101,99,116,115,0],"i8",x);Km=y([94,0],"i8",x);Lm=y([39,39,39,0],"i8",x);Mm=y([42,41,0],"i8",x);Nm=y([108,115,108,32,0],"i8",x);Om=y([79,98,106,101,99,116,32,102,105,101,108,100,0],"i8",x);Pm=y([80,82,79,71,82,65,77,0],"i8",x);Qm=y([98,97,115,104,0],"i8",x);Rm=y([115,99,104,101,109,101,0],"i8",x);Sm=y([108,111,103,105,99,97,108,0],"i8",x);Tm=y([110,111,114,0],"i8",x);Um=y([105,110,101,114,116,105,97,108,0],"i8",x);Vm=y([112,111,114,116,115,0],"i8",x);Wm=y([114,101,115,117,108,116,0],"i8",x);Xm=y([38,0],"i8",x);Ym=y([99,112,100,101,102,0],"i8",x);Zm=y([61,98,101,103,105,110,0],"i8",x);$m=y([82,69,88,88,0],"i8",x);an=y([108,120,111,114,32,0],"i8",x);bn=y([105,110,116,114,105,110,115,105,99,0],"i8",x);cn=y([112,120,105,0],"i8",x);dn=y([46,115,118,110,0],"i8",x);en=y([105,110,0],"i8",x);fn=y([100,97,116,97,116,121,112,101,0],"i8",x);gn=y([99,111,118,101,114,97,103,101,95,100,101,102,0],"i8",x);hn=y([80,72,80,0],"i8",x);jn=y([60,60,0],"i8",x);kn=y([99,100,101,102,0],"i8",x);ln=y([108,111,114,32,0],"i8",x);mn=y([112,101,114,108,0],"i8",x);nn=y([108,105,107,101,0],"i8",x);on=y([83,67,67,83,0],"i8",x);pn=y([99,109,97,112,0],"i8",x);qn=y([105,109,112,117,114,101,0],"i8",x);rn=y([110,101,116,32,100,97,116,97,32,116,121,112,101,115,0],"i8",x);sn=y([100,111,109,97,105,110,0],"i8",x);tn=y([99,111,118,101,114,97,103,101,95,98,108,111,99,107,0],"i8",x);un=y([62,62,0],"i8",x);vn=y([108,97,110,100,32,0],"i8",x);wn=y([112,98,0],"i8",x);xn=y([105,110,116,101,110,116,0],"i8",x);yn=y([116,121,112,101,100,101,102,0],"i8",x);zn=y([82,69,83,89,78,67,0],"i8",x);An=y([99,109,97,0],"i8",x);Bn=y([110,101,116,0],"i8",x);Cn=y([115,101,114,118,105,99,101,0],"i8",x);Dn=y([97,115,112,0],"i8",x);En=y([109,107,0],"i8",x);Fn=y([65,119,107,0],"i8",x);Gn=y([102,114,111,109,0],"i8",x);Hn=y([108,0],"i8",x);In=y([115,117,98,114,111,117,116,105,110,101,32,100,101,99,108,97,114,97,116,105,111,110,115,0],"i8",x);Jn=y([109,111,100,32,0],"i8",x);Kn=y([67,108,97,115,115,39,32,109,101,116,104,111,100,0],"i8",x);Ln=y([70,117,110,99,116,105,111,110,0],"i8",x);Mn=y([105,110,118,97,114,105,97,110,116,0],"i8",x);Nn=y([60,97,40,91,32,9,93,43,91,97,45,122,93,43,61,34,63,91,94,62,34,93,42,34,63,41,42,91,32,9,93,43,110,97,109,101,61,34,63,40,91,94,62,34,93,43,41,34,63,40,91,32,9,93,43,91,97,45,122,93,43,61,34,63,91,94,62,34,93,42,34,63,41,42,91,32,9,93,42,62,0],"i8",x);On=y([82,67,83,0],"i8",x);Pn=y([99,109,0],"i8",x);Qn=y([103,117,97,114,100,101,100,0],"i8",x);Rn=y([109,111,100,117,108,101,115,0],"i8",x);Sn=y([112,117,98,108,105,99,97,116,105,111,110,0],"i8",x);Tn=y([116,121,112,101,115,32,40,115,116,114,117,99,116,115,32,97,110,100,32,114,101,99,111,114,100,115,41,0],"i8",x);Un=y([43,0],"i8",x);Vn=y([101,120,116,101,114,110,0],"i8",x);Wn=y([115,117,98,114,111,117,116,105,110,101,32,100,101,99,108,97,114,97,116,105,111,110,0],"i8",x);Xn=y([105,110,108,105,110,101,0],"i8",x);Yn=y([105,110,115,112,101,99,116,0],"i8",x);Zn=y([80,69,78,68,73,78,71,0],"i8",x);$n=y([108,109,97,112,0],"i8",x);ao=y([103,114,111,117,112,0],"i8",x);bo=y([102,117,110,99,116,105,111,110,115,0],"i8",x);co=y([37,0],"i8",x);eo=y([115,117,98,114,111,117,116,105,110,101,115,0],"i8",x);fo=y([102,55,55,0],"i8",x);go=y([105,110,104,101,114,105,116,0],"i8",x);ho=y([46,104,103,0],"i8",x);io=y([99,104,97,114,0],"i8",x);jo=y([108,109,97,0],"i8",x);ko=y([103,101,110,101,114,105,99,0],"i8",x);lo=y([101,118,101,110,116,115,0],"i8",x);mo=y([105,110,100,101,120,0],"i8",x);no=y([72,82,76,0],"i8",x);oo=y([115,117,98,114,111,117,116,105,110,101,0],"i8",x);po=y([105,109,112,108,105,99,105,116,0],"i8",x);qo=y([105,110,102,105,120,0],"i8",x);ro=y([46,103,105,116,0],"i8",x);so=y([108,109,0],"i8",x);to=y([103,101,110,101,114,97,116,101,0],"i8",x);uo=y([99,111,110,115,116,97,110,116,115,32,40,100,101,102,105,110,101,44,32,112,97,114,97,109,101,116,101,114,44,32,115,112,101,99,112,97,114,97,109,41,0],"i8",x);vo=y([94,58,40,91,65,45,90,97,45,122,95,48,45,57,93,43,41,0],"i8",x);wo=y([42,0],"i8",x);xo=y([108,97,109,98,100,97,0],"i8",x);yo=y([105,110,99,108,117,100,101,32,0],"i8",x);zo=y([117,110,100,101,102,0],"i8",x);Ao=y([67,79,66,0],"i8",x);Bo=y([118,105,114,116,117,97,108,0],"i8",x);Co=y([32,58,32,37,115,0],"i8",x);Do=y([80,114,111,116,111,99,111,108,0],"i8",x);Eo=y([32,0],"i8",x);Fo=y([92,49,0],"i8",x);Go=y([99,111,109,99,0],"i8",x);Ho=y([105,110,100,101,120,105,110,103,0],"i8",x);Io=y([97,98,115,0],"i8",x);Jo=y([101,118,101,110,116,0],"i8",x);Ko=y([69,73,70,71,69,78,0],"i8",x);Lo=y([101,110,118,0],"i8",x);Mo=y([115,101,99,116,105,111,110,0],"i8",x);No=y([105,109,97,112,0],"i8",x);Oo=y([105,116,99,108,0],"i8",x);Po=y([116,114,105,103,103,101,114,0],"i8",x);Qo=y([99,99,0],"i8",x);Ro=y([83,0],"i8",x);So=y([100,101,102,105,110,101,115,0],"i8",x);To=y([101,110,117,109,101,114,97,116,105,111,110,115,0],"i8",x);Uo=y([45,64,0],"i8",x);Vo=y([108,97,98,101,108,115,0],"i8",x);Wo=y([112,114,111,116,111,99,111,108,0],"i8",x);Xo=y([102,97,108,0],"i8",x);Yo=y([111,118,101,114,114,105,100,101,0],"i8",x);Zo=y([105,109,112,108,105,101,115,0],"i8",x);$o=y([46,100,101,112,115,0],"i8",x);ap=y([105,109,97,0],"i8",x);bp=y([102,111,114,0],"i8",x);cp=y([116,97,98,108,101,0],"i8",x);dp=y([43,64,0],"i8",x);ep=y([83,77,76,0],"i8",x);fp=y([99,108,97,115,115,32,105,109,112,108,101,109,101,110,116,97,116,105,111,110,0],"i8",x);gp=y([94,46,42,100,101,102,105,110,101,91,32,9,93,43,40,91,65,45,90,95,93,91,65,45,90,48,45,57,95,93,42,41,91,94,59,93,42,36,0],"i8",x);hp=y([98,115,104,0],"i8",x);ip=y([76,73,66,0],"i8",x);jp=y([115,99,104,0],"i8",x);kp=y([102,120,0],"i8",x);lp=y([95,36,0],"i8",x);mp=y([95,100,97,114,99,115,0],"i8",x);np=y([105,109,0],"i8",x);op=y([98,111,111,108,101,97,110,0],"i8",x);pp=y([101,114,108,0],"i8",x);qp=y([115,0],"i8",x);rp=y([126,0],"i8",x);sp=y([95,95,105,110,105,116,95,95,0],"i8",x);tp=y([82,117,98,121,0],"i8",x);up=y([102,111,114,109,97,116,115,0],"i8",x);vp=y([114,120,0],"i8",x);wp=y([105,109,112,108,101,109,101,110,116,97,116,105,111,110,0],"i8",x);xp=y([103,108,111,98,97,108,32,118,97,114,105,97,98,108,101,115,0],"i8",x);yp=y([109,120,0],"i8",x);zp=y([102,114,111,122,101,110,0],"i8",x);Ap=y([112,120,100,0],"i8",x);Bp=y([46,99,118,115,105,103,110,111,114,101,0],"i8",x);Cp=y([111,109,97,112,0],"i8",x);Dp=y([98,105,116,0],"i8",x);Ep=y([101,120,105,116,0],"i8",x);Fp=y([114,101,116,117,114,110,115,0],"i8",x);Gp=y([95,36,63,0],"i8",x);Hp=y([112,104,116,109,108,0],"i8",x);Ip=y([33,0],"i8",x);Jp=y([95,95,0],"i8",x);Kp=y([99,111,110,115,116,97,110,116,115,0],"i8",x);Lp=y([116,114,121,0],"i8",x);Mp=y([99,108,97,115,115,32,105,110,116,101,114,102,97,99,101,0],"i8",x);Np=y([112,108,120,0],"i8",x);Op=y([80,97,115,99,97,108,0],"i8",x);Pp=y([101,113,117,105,118,97,108,101,110,99,101,0],"i8",x);Qp=y([99,100,97,116,97,0],"i8",x);Rp=y([67,86,83,0],"i8",x);Sp=y([111,109,97,0],"i8",x);Tp=y([98,105,110,100,95,118,97,114,0],"i8",x);Up=y([101,110,116,105,116,121,0],"i8",x);Vp=y([119,111,114,0],"i8",x);Wp=y([42,47,0],"i8",x);Zp=y([42,42,0],"i8",x);$p=y([109,101,109,98,101,114,0],"i8",x);aq=y([32,9,0],"i8",x);bq=y([79,67,97,109,108,0],"i8",x);cq=y([105,110,116,101,114,102,97,99,101,0],"i8",x);dq=y([112,114,111,112,101,114,116,105,101,115,0],"i8",x);eq=y([98,98,0],"i8",x);fq=y([101,110,116,114,121,0],"i8",x);gq=y([115,99,114,105,112,116,0],"i8",x);hq=y([102,101,97,116,117,114,101,0],"i8",x);iq=y([79,98,106,101,99,116,105,118,101,67,0],"i8",x);jq=y([46,98,122,114,105,103,110,111,114,101,0],"i8",x);kq=y([111,109,0],"i8",x);lq=y([98,105,110,100,0],"i8",x);mq=y([119,105,114,101,0],"i8",x);nq=y([114,101,109,0],"i8",x);oq=y([47,42,0],"i8",x);pq=y([118,97,108,117,101,32,98,105,110,100,105,110,103,115,0],"i8",x);qq=y([109,97,107,0],"i8",x);rq=y([91,93,61,0],"i8",x);sq=y([101,108,0],"i8",x);tq=y([109,97,119,107,0],"i8",x);uq=y([115,116,114,117,99,116,0],"i8",x);vq=y([110,97,109,101,0],"i8",x);wq=y([46,98,122,114,0],"i8",x);xq=y([72,84,77,76,0],"i8",x);yq=y([118,109,97,112,0],"i8",x);zq=y([98,97,100,95,116,114,97,110,115,0],"i8",x);Aq=y([101,108,115,105,102,0],"i8",x);Bq=y([119,97,110,100,0],"i8",x);Cq=y([114,101,102,0],"i8",x);Dq=y([59,42,64,0],"i8",x);Eq=y([118,97,108,117,101,0],"i8",x);Fq=y([91,93,0],"i8",x);Gq=y([58,0],"i8",x);Hq=y([101,108,101,109,101,110,116,97,108,0],"i8",x);Iq=y([105,100,0],"i8",x);Jq=y([10,0],"i8",x);Kq=y([66,105,116,75,101,101,112,101,114,0],"i8",x);Lq=y([118,109,97,0],"i8",x);Mq=y([98,97,100,95,115,116,97,116,101,0],"i8",x);Nq=y([116,114,105,114,101,103,0],"i8",x);Oq=y([111,98,106,101,99,116,0],"i8",x);Pq=y([63,33,61,0],"i8",x);Qq=y([65,115,112,0],"i8",x);Rq=y([102,116,110,0],"i8",x);Sq=y([114,101,99,0],"i8",x);Tq=y([64,114,101,113,117,105,114,101,100,0],"i8",x);Uq=y([97,108,108,0],"i8",x);Vq=y([100,111,117,98,108,101,0],"i8",x);Wq=y([70,108,101,120,0],"i8",x);Xq=y([97,117,116,111,109,52,116,101,46,99,97,99,104,101,0],"i8",x);Yq=y([118,109,0],"i8",x);Zq=y([97,98,115,116,114,97,99,116,0],"i8",x);$q=y([100,111,119,110,116,111,0],"i8",x);ar=y([116,114,105,111,114,0],"i8",x);br=y([110,111,0],"i8",x);cr=y([70,97,108,99,111,110,0],"i8",x);dr=y([115,116,114,117,99,116,117,114,101,32,100,101,99,108,97,114,97,116,105,111,110,115,0],"i8",x);er=y([104,114,108,0],"i8",x);fr=y([95,0],"i8",x);gr=y([98,114,34,0],"i8",x);hr=y([111,110,0],"i8",x);ir=y([112,111,100,0],"i8",x);jr=y([64,111,112,116,105,111,110,97,108,0],"i8",x);kr=y([121,0],"i8",x);lr=y([101,120,112,97,110,100,101,100,0],"i8",x);mr=y([46,97,114,99,104,45,105,110,118,101,110,116,111,114,121,0],"i8",x);nr=y([110,109,97,112,0],"i8",x);or=y([95,95,97,116,116,114,105,98,117,116,101,95,95,0],"i8",x);pr=y([100,105,115,99,111,110,110,101,99,116,0],"i8",x);qr=y([116,114,105,0],"i8",x);rr=y([68,111,115,66,97,116,99,104,0],"i8",x);sr=y([102,0],"i8",x);tr=y([115,105,103,110,97,116,117,114,101,32,100,101,99,108,97,114,97,116,105,111,110,115,0],"i8",x);ur=y([109,101,100,105,97,0],"i8",x);vr=y([32,44,34,46,35,95,63,33,61,39,47,45,0],"i8",x);wr=y([79,80,69,78,73,78,71,32,37,115,32,97,115,32,37,115,32,108,97,110,103,117,97,103,101,32,37,115,102,105,108,101,10,0],"i8",x);xr=y([98,114,39,0],"i8",x);yr=y([92,50,46,92,51,0],"i8",x);zr=y([100,101,102,105,110,101,0],"i8",x);Ar=y([67,66,76,0],"i8",x);Br=y([98,97,99,107,0],"i8",x);Cr=y([44,32,0],"i8",x);Dr=y([64,100,121,110,97,109,105,99,0],"i8",x);Er=y([101,0],"i8",x);Fr=y([94,40,91,65,45,90,97,45,122,93,91,65,45,90,97,45,122,95,48,45,57,93,43,41,91,32,9,93,42,58,0],"i8",x);Gr=y([100,108,108,95,105,109,112,111,114,116,0],"i8",x);Hr=y([99,111,109,112,0],"i8",x);Ir=y([101,110,115,117,114,101,0],"i8",x);Jr=y([86,72,68,76,0],"i8",x);Kr=y([96,100,101,102,105,110,101,0],"i8",x);Lr=y([46,97,114,99,104,45,105,100,115,0],"i8",x);Mr=y([105,103,110,111,114,105,110,103,32,37,115,32,40,108,97,110,103,117,97,103,101,32,100,105,115,97,98,108,101,100,41,10,0],"i8",x);Nr=y([99,104,97,112,116,101,114,0],"i8",x);Or=y([110,109,97,0],"i8",x);Pr=y([86,101,114,97,0],"i8",x);Qr=y([119,105,115,104,0],"i8",x);Rr=y([99,111,110,115,116,97,110,116,0],"i8",x);Sr=y([116,114,105,97,110,100,0],"i8",x);Tr=y([99,43,43,0],"i8",x);Ur=y([97,115,0],"i8",x);Vr=y([102,117,110,99,116,111,114,32,100,101,102,105,110,105,116,105,111,110,115,0],"i8",x);Wr=y([95,46,63,33,61,0],"i8",x);Xr=y([117,114,34,0],"i8",x);Yr=y([40,94,124,91,32,9,93,41,40,91,65,45,90,97,45,122,48,45,57,95,46,93,43,41,92,46,40,91,65,45,90,97,45,122,48,45,57,95,93,43,41,91,32,9,93,42,61,91,32,9,93,42,102,117,110,99,116,105,111,110,91,32,9,93,42,92,40,0],"i8",x);Zr=y([98,97,116,0],"i8",x);$r=y([105,116,101,109,0],"i8",x);as=y([102,111,114,109,97,116,0],"i8",x);bs=y([109,117,116,97,98,108,101,0],"i8",x);cs=y([64,115,121,110,116,104,101,115,105,122,101,0],"i8",x);ds=y([102,105,101,108,100,115,0],"i8",x);es=y([100,108,108,95,101,120,112,111,114,116,0],"i8",x);fs=y([123,97,114,99,104,125,0],"i8",x);gs=y([105,103,110,111,114,105,110,103,32,37,115,32,40,117,110,107,110,111,119,110,32,108,97,110,103,117,97,103,101,41,10,0],"i8",x);hs=y([110,109,0],"i8",x);is=y([118,114,104,0],"i8",x);js=y([99,111,110,102,105,103,117,114,97,116,105,111,110,0],"i8",x);ks=y([116,114,105,49,0],"i8",x);ls=y([94,91,32,9,93,42,60,91,32,9,93,42,112,114,111,106,101,99,116,91,94,62,93,43,110,97,109,101,61,34,40,91,94,34,93,43,41,34,46,42,0],"i8",x);ms=y([117,114,39,0],"i8",x);ns=y([106,44,106,115,102,117,110,99,116,105,111,110,44,106,97,118,97,115,99,114,105,112,116,32,102,117,110,99,116,105,111,110,115,0],"i8",x);os=y([111,118,101,114,0],"i8",x);ps=y([115,105,103,0],"i8",x);qs=y([64,112,114,111,116,101,99,116,101,100,0],"i8",x);rs=y([83,76,97,110,103,0],"i8",x);ss=y([83,72,0],"i8",x);ts=y([99,115,115,0],"i8",x);us=y([83,77,0],"i8",x);vs=y([66,69,84,65,0],"i8",x);ws=y([100,105,109,101,110,115,105,111,110,0],"i8",x);xs=y([32,32,73,110,115,116,97,108,108,105,110,103,32,100,101,102,97,117,108,116,32,101,120,99,108,117,100,101,32,112,97,116,116,101,114,110,115,58,10,0],"i8",x);ys=y([109,97,112,0],"i8",x);zs=y([118,114,105,0],"i8",x);As=y([99,111,109,112,111,110,101,110,116,0],"i8",x);Bs=y([116,114,105,48,0],"i8",x);Cs=y([105,110,99,108,117,100,101,115,0],"i8",x);Ds=y([99,97,108,108,0],"i8",x);Es=y([98,34,0],"i8",x);Fs=y([40,94,124,91,32,9,93,41,40,91,65,45,90,97,45,122,48,45,57,95,93,43,41,91,32,9,93,42,91,61,58,93,91,32,9,93,42,102,117,110,99,116,105,111,110,91,32,9,93,42,92,40,0],"i8",x);Gs=y([103,108,111,98,97,108,0],"i8",x);Hs=y([114,117,98,121,0],"i8",x);Is=y([104,101,97,100,52,0],"i8",x);Js=y([114,101,120,120,0],"i8",x);Ks=y([85,110,107,110,111,119,110,32,102,105,108,101,32,101,120,116,101,110,115,105,111,110,58,32,37,115,10,0],"i8",x);Ls=y([64,112,117,98,108,105,99,0],"i8",x);Ms=y([102,105,110,97,108,108,121,0],"i8",x);Ns=y([114,98,0],"i8",x);Os=y([100,97,116,97,0],"i8",x);Ps=y([115,44,115,101,99,116,105,111,110,44,115,101,99,116,105,111,110,115,0],"i8",x);Qs=y([112,121,120,0],"i8",x);Rs=y([58,61,0],"i8",x);Ss=y([32,32,73,110,115,116,97,108,108,105,110,103,32,100,101,102,97,117,108,116,32,108,97,110,103,117,97,103,101,32,109,97,112,112,105,110,103,115,58,10,0],"i8",x);Ts=y([60,115,112,101,99,105,97,108,62,0],"i8",x);Us=y([118,114,0],"i8",x);Vs=y([99,97,115,101,0],"i8",x);Ws=y([116,105,109,101,0],"i8",x);Xs=y([115,117,98,112,97,114,97,103,114,97,112,104,115,0],"i8",x);Ys=y([119,101,97,107,0],"i8",x);Zs=y([100,111,0],"i8",x);$s=y([65,83,77,0],"i8",x);at=y([101,120,99,101,112,116,105,111,110,32,100,101,99,108,97,114,97,116,105,111,110,115,0],"i8",x);bt=y([112,104,112,51,0],"i8",x);ct=y([98,39,0],"i8",x);dt=y([94,91,32,9,93,42,40,40,118,97,114,124,112,117,98,108,105,99,124,112,114,111,116,101,99,116,101,100,124,112,114,105,118,97,116,101,124,115,116,97,116,105,99,41,91,32,9,93,43,41,43,92,36,40,91,65,45,90,97,45,122,127,45,255,95,93,91,48,45,57,65,45,90,97,45,122,127,45,255,95,93,42,41,91,32,9,93,42,91,61,59,93,0],"i8",x);et=y([110,101,119,108,105,115,116,0],"i8",x);ft=y([104,101,97,100,51,0],"i8",x);gt=y([109,97,116,99,104,0],"i8",x);ht=y([64,112,97,99,107,97,103,101,0],"i8",x);it=y([99,98,108,0],"i8",x);jt=y([112,109,0],"i8",x);kt=y([99,97,116,99,104,0],"i8",x);lt=y([101,120,116,101,114,110,97,108,32,97,110,100,32,102,111,114,119,97,114,100,32,118,97,114,105,97,98,108,101,32,100,101,99,108,97,114,97,116,105,111,110,115,0],"i8",x);mt=y([112,97,115,0],"i8",x);nt=y([117,110,105,111,110,32,110,97,109,101,115,0],"i8",x);ot=y([99,111,110,116,97,105,110,115,0],"i8",x);pt=y([46,46,46,0],"i8",x);qt=y([37,115,58,32,99,111,110,102,117,115,105,110,103,32,97,114,103,117,109,101,110,116,32,100,101,99,108,97,114,97,116,105,111,110,115,32,98,101,103,105,110,110,105,110,103,32,97,116,32,108,105,110,101,32,37,108,117,10,0],"i8",x);rt=y([94,91,32,9,93,42,40,91,65,45,90,48,45,57,93,91,65,45,90,48,45,57,45,93,42,41,91,32,9,93,43,83,69,67,84,73,79,78,92,46,0],"i8",x);st=y([83,101,116,116,105,110,103,32,111,112,116,105,111,110,32,100,101,102,97,117,108,116,115,10,0],"i8",x);tt=y([60,101,120,112,114,62,0],"i8",x);ut=y([74,97,118,97,0],"i8",x);vt=y([98,117,115,0],"i8",x);wt=y([116,97,115,107,0],"i8",x);xt=y([112,97,114,97,103,114,97,112,104,115,0],"i8",x);yt=y([114,101,103,101,120,0],"i8",x);zt=y([123,59,44,61,0],"i8",x);At=y([44,59,0],"i8",x);Bt=y([118,97,108,0],"i8",x);Ct=y([60,62,0],"i8",x);Dt=y([114,34,0],"i8",x);Et=y([118,44,118,97,114,105,97,98,108,101,44,118,97,114,105,97,98,108,101,115,0],"i8",x);Ft=y([59,0],"i8",x);Gt=y([104,101,97,100,50,0],"i8",x);Ht=y([37,115,58,32,37,115,0],"i8",x);It=y([40,59,0],"i8",x);Jt=y([109,108,105,0],"i8",x);Kt=y([64,112,114,105,118,97,116,101,0],"i8",x);Lt=y([43,45,42,47,37,94,38,124,126,33,61,60,62,44,91,93,0],"i8",x);Mt=y([40,41,0],"i8",x);Nt=y([99,111,109,112,108,101,120,0],"i8",x);Ot=y([112,117,114,101,32,118,105,114,116,117,97,108,0],"i8",x);Pt=y([98,105,0],"i8",x);Qt=y([100,101,116,97,99,104,97,98,108,101,0],"i8",x);Rt=y([80,44,112,114,111,103,114,97,109,44,112,114,111,103,114,97,109,32,105,100,115,0],"i8",x);St=y([37,115,58,37,108,100,58,32,110,117,108,108,32,101,120,112,97,110,115,105,111,110,32,111,102,32,110,97,109,101,32,112,97,116,116,101,114,110,32,34,37,115,34,0],"i8",x);Tt=y([116,121,112,101,115,0],"i8",x);Ut=y([60,117,110,105,113,117,101,62,0],"i8",x);Vt=y([98,117,102,102,101,114,0],"i8",x);Wt=y([106,97,118,97,0],"i8",x);Xt=y([115,117,112,112,108,121,49,0],"i8",x);Yt=y([112,97,114,116,115,0],"i8",x);Zt=y([71,78,85,109,97,107,101,102,105,108,101,0],"i8",x);$t=y([76,117,97,0],"i8",x);au=y([95,95,97,110,111,110,37,100,0],"i8",x);bu=y([114,39,0],"i8",x);cu=y([99,108,105,115,112,0],"i8",x);du=y([92,50,0],"i8",x);eu=y([104,101,97,100,49,0],"i8",x);fu=y([123,125,0],"i8",x);gu=y([103,97,119,107,0],"i8",x);hu=y([64,99,108,97,115,115,0],"i8",x);iu=y([37,115,58,32,117,110,101,120,112,101,99,116,101,100,32,99,108,111,115,105,110,103,32,98,114,97,99,101,32,97,116,32,108,105,110,101,32,37,108,117,10,0],"i8",x);ju=y([115,119,105,116,99,104,0],"i8",x);ku=y([37,115,58,32,114,101,116,114,121,105,110,103,32,102,105,108,101,32,119,105,116,104,32,102,97,108,108,98,97,99,107,32,98,114,97,99,101,32,109,97,116,99,104,105,110,103,32,97,108,103,111,114,105,116,104,109,10,0],"i8",x);lu=y([115,116,114,117,99,116,117,114,101,32,110,97,109,101,115,0],"i8",x);mu=y([99,111,109,109,111,110,0],"i8",x);nu=y([74,97,118,97,83,99,114,105,112,116,0],"i8",x);ou=y([100,101,102,101,114,114,101,100,0],"i8",x);pu=y([94,91,32,9,93,42,80,82,79,71,82,65,77,45,73,68,92,46,91,32,9,93,43,40,91,65,45,90,48,45,57,93,91,65,45,90,48,45,57,45,93,42,41,92,46,0],"i8",x);y([114,101,103,99,111,109,112,32,37,115,58,32,37,115,0],"i8",x);qu=y([78,79,78,69,0],"i8",x);ru=y([104,116,109,108,0],"i8",x);su=y([60,115,99,114,105,112,116,62,0],"i8",x);tu=y([98,111,100,121,0],"i8",x);uu=y([67,35,0],"i8",x);vu=y([115,117,112,112,108,121,48,0],"i8",x);wu=y([115,117,98,115,117,98,115,101,99,116,105,111,110,115,0],"i8",x);xu=y([112,114,111,99,101,100,117,114,101,115,0],"i8",x);yu=y([110,97,109,101,115,112,97,99,101,115,0],"i8",x);zu=y([101,113,117,0],"i8",x);Au=y([115,116,114,117,99,116,117,114,101,0],"i8",x);Bu=y([99,111,110,116,101,120,116,0],"i8",x);Cu=y([71,111,0],"i8",x);Du=y([117,34,0],"i8",x);Eu=y([94,91,32,9,93,42,40,92,36,124,58,58,92,36,124,92,36,116,104,105,115,45,62,41,40,91,65,45,90,97,45,122,127,45,255,95,93,91,48,45,57,65,45,90,97,45,122,127,45,255,95,93,42,41,91,32,9,93,42,61,0],"i8",x);Fu=y([83,84,68,79,85,84,0],"i8",x);Gu=y([112,117,98,108,105,99,32,102,117,110,99,116,105,111,110,0],"i8",x);Hu=y([64,100,101,102,115,0],"i8",x);Iu=y([109,97,99,114,111,115,0],"i8",x);Ju=y([105,110,116,101,114,102,97,99,101,115,0],"i8",x);Ku=y([101,110,117,109,32,116,121,112,101,115,0],"i8",x);Lu=y([117,110,107,110,111,119,110,0],"i8",x);Mu=y([99,104,97,114,97,99,116,101,114,0],"i8",x);Nu=y([100,101,98,117,103,0],"i8",x);Ou=y([101,110,117,109,32,99,111,110,115,116,97,110,116,115,0],"i8",x);Pu=y([112,44,112,97,114,97,103,114,97,112,104,44,112,97,114,97,103,114,97,112,104,115,0],"i8",x);Qu=y([117,110,107,110,111,119,110,32,114,101,103,101,120,32,102,108,97,103,58,32,39,37,99,39,0],"i8",x);Ru=y([60,115,105,108,101,110,116,62,0],"i8",x);Su=y([98,108,111,99,107,0],"i8",x);Tu=y([99,115,0],"i8",x);Uu=y([115,112,101,99,112,97,114,97,109,0],"i8",x);Vu=y([115,117,98,115,101,99,116,105,111,110,115,0],"i8",x);Wu=y([101,110,117,109,32,99,111,110,115,116,97,110,116,0],"i8",x);Xu=y([101,120,116,101,114,110,97,108,32,118,97,114,105,97,98,108,101,32,100,101,99,108,97,114,97,116,105,111,110,115,0],"i8",x);Yu=y([101,110,100,115,0],"i8",x);Zu=y([115,105,103,110,97,116,117,114,101,0],"i8",x);$u=y([101,120,116,101,114,110,118,97,114,0],"i8",x);av=y([100,101,115,99,114,105,98,101,0],"i8",x);bv=y([117,39,0],"i8",x);cv=y([112,114,105,118,97,116,101,32,102,117,110,99,116,105,111,110,0],"i8",x);dv=y([97,115,97,0],"i8",x);ev=y([64,101,110,100,0],"i8",x);fv=y([116,121,112,101,100,101,102,115,0],"i8",x);gv=y([118,105,109,0],"i8",x);hv=y([102,117,110,99,116,105,111,110,32,112,114,111,116,111,116,121,112,101,115,0],"i8",x);iv=y([99,103,108,111,98,97,108,0],"i8",x);jv=y([114,101,99,111,114,100,32,100,101,102,105,110,105,116,105,111,110,115,0],"i8",x);kv=y([99,117,114,114,101,110,116,0],"i8",x);lv=y([109,120,109,108,0],"i8",x);mv=y([94,91,32,9,93,42,40,91,65,45,90,48,45,57,93,91,65,45,90,48,45,57,45,93,42,41,92,46,0],"i8",x);nv=y([60,98,117,102,102,101,114,62,0],"i8",x);ov=y([98,101,103,105,110,0],"i8",x);pv=y([67,43,43,0],"i8",x);qv=y([114,101,103,0],"i8",x);rv=y([115,101,99,116,105,111,110,115,0],"i8",x);sv=y([109,101,116,104,111,100,115,0],"i8",x);tv=y([112,97,116,116,101,114,110,115,32,40,118,105,114,116,117,97,108,32,111,114,32,114,101,98,111,117,110,100,41,0],"i8",x);uv=y([99,108,97,115,115,44,32,115,116,114,117,99,116,44,32,97,110,100,32,117,110,105,111,110,32,109,101,109,98,101,114,115,0],"i8",x);vv=y([102,116,100,0],"i8",x);wv=y([101,110,100,112,0],"i8",x);xv=y([102,117,110,0],"i8",x);yv=y([69,82,76,0],"i8",x);zv=y([94,91,32,9,93,42,40,40,115,116,97,116,105,99,124,112,117,98,108,105,99,124,112,114,111,116,101,99,116,101,100,124,112,114,105,118,97,116,101,41,91,32,9,93,43,41,42,102,117,110,99,116,105,111,110,91,32,9,93,43,38,63,91,32,9,93,42,40,91,65,45,90,97,45,122,127,45,255,95,93,91,48,45,57,65,45,90,97,45,122,127,45,255,95,93,42,41,0],"i8",x);Av=y([101,110,117,109,101,114,97,116,105,111,110,32,110,97,109,101,115,0],"i8",x);Bv=y([58,58,0],"i8",x);Cv=y([112,117,98,108,105,99,32,115,117,98,0],"i8",x);Dv=y([64,115,101,108,101,99,116,111,114,0],"i8",x);Ev=y([37,115,58,32,102,97,105,108,101,100,32,116,111,32,102,105,110,100,32,109,97,116,99,104,32,102,111,114,32,39,37,99,39,32,97,116,32,108,105,110,101,32,37,108,117,10,0],"i8",x);Fv=y([101,110,117,109,101,114,97,116,111,114,115,32,40,118,97,108,117,101,115,32,105,110,115,105,100,101,32,97,110,32,101,110,117,109,101,114,97,116,105,111,110,41,0],"i8",x);Gv=y([101,110,117,109,101,114,97,116,111,114,0],"i8",x);Hv=y([99,101,120,116,101,114,110,97,108,0],"i8",x);Iv=y([99,114,101,97,116,105,111,110,0],"i8",x);Jv=y([105,100,101,110,116,105,116,105,101,115,0],"i8",x);Kv=y([103,44,103,114,111,117,112,44,103,114,111,117,112,32,105,116,101,109,115,0],"i8",x);Lv=y([118,104,100,108,0],"i8",x);Mv=y([69,105,102,102,101,108,0],"i8",x);Nv=y([60,76,101,97,100,101,114,62,0],"i8",x);Ov=y([97,116,116,114,105,98,117,116,101,0],"i8",x);Pv=y([114,101,97,108,116,105,109,101,0],"i8",x);Qv=y([99,104,97,112,116,101,114,115,0],"i8",x);Rv=y([99,108,97,115,115,101,115,0],"i8",x);Sv=y([101,108,115,101,105,102,0],"i8",x);Tv=y([119,99,104,97,114,95,116,0],"i8",x);Uv=y([102,117,110,99,116,111,114,0],"i8",x);Vv=y([67,83,83,0],"i8",x);Wv=y([114,0],"i8",x);Xv=y([99,97,110,110,111,116,32,111,112,101,110,32,34,37,115,34,0],"i8",x);Yv=y([105,109,112,111,114,116,0],"i8",x);Zv=y([109,97,99,114,111,0],"i8",x);$v=y([100,44,100,101,102,105,110,101,44,99,111,110,115,116,97,110,116,32,100,101,102,105,110,105,116,105,111,110,115,0],"i8",x);aw=y([118,111,105,100,0],"i8",x);bw=y([99,111,98,0],"i8",x);cw=y([37,115,37,115,0],"i8",x);dw=y([112,114,105,118,97,116,101,32,115,117,98,0],"i8",x);ew=y([118,0],"i8",x);fw=y([87,97,114,110,105,110,103,58,32,0],"i8",x);gw=y([64,115,121,110,99,104,114,111,110,105,122,101,100,0],"i8",x);hw=y([46,45,95,0],"i8",x);iw=y([117,115,105,110,103,0],"i8",x);jw=y([117,115,104,111,114,116,0],"i8",x);kw=y([99,104,97,110,0],"i8",x);lw=y([37,115,40,37,115,41,0],"i8",x);mw=y([89,65,67,67,0],"i8",x);nw=y([117,110,115,105,103,110,101,100,0],"i8",x);ow=y([116,101,120,0],"i8",x);pw=y([98,121,116,101,0],"i8",x);qw=y([86,105,109,0],"i8",x);rw=y([116,99,108,0],"i8",x);sw=y([118,104,100,0],"i8",x);tw=y([117,108,111,110,103,0],"i8",x);uw=y([94,91,32,9,93,42,91,48,45,57,93,43,91,32,9,93,43,40,91,65,45,90,48,45,57,93,91,65,45,90,48,45,57,45,93,42,41,92,46,0],"i8",x);vw=y([86,101,114,105,108,111,103,0],"i8",x);ww=y([84,101,120,0],"i8",x);xw=y([60,83,73,68,62,0],"i8",x);yw=y([116,107,0],"i8",x);zw=y([97,115,115,101,114,116,0],"i8",x);Aw=y([114,101,97,108,0],"i8",x);Bw=y([109,101,116,104,111,100,0],"i8",x);Cw=y([108,111,99,97,108,32,100,101,102,105,110,105,116,105,111,110,115,0],"i8",x);Dw=y([115,108,111,116,115,32,40,102,114,97,103,109,101,110,116,32,117,115,101,115,41,0],"i8",x);Ew=y([117,105,110,116,0],"i8",x);Fw=y([67,0],"i8",x);Gw=y([108,111,99,97,108,0],"i8",x);Hw=y([83,81,76,0],"i8",x);Iw=y([116,121,112,101,110,97,109,101,0],"i8",x);Jw=y([101,110,100,109,0],"i8",x);Kw=y([115,101,116,115,0],"i8",x);Lw=y([112,97,99,107,97,103,101,32,100,101,102,105,110,105,116,105,111,110,115,0],"i8",x);Mw=y([99,112,100,101,102,32,0],"i8",x);Nw=y([112,114,111,99,101,100,117,114,101,32,112,114,111,116,111,116,121,112,101,115,32,97,110,100,32,100,101,99,108,97,114,97,116,105,111,110,115,0],"i8",x);Ow=y([94,91,32,9,93,42,100,101,102,105,110,101,91,32,9,93,42,92,40,91,32,9,93,42,91,39,34,93,63,40,91,65,45,90,97,45,122,127,45,255,95,93,91,48,45,57,65,45,90,97,45,122,127,45,255,95,93,42,41,0],"i8",x);Pw=y([116,114,97,110,115,105,101,110,116,0],"i8",x);Qw=y([102,117,110,99,116,105,111,110,32,112,114,111,116,111,116,121,112,101,115,32,97,110,100,32,100,101,99,108,97,114,97,116,105,111,110,115,0],"i8",x);Rw=y([99,0],"i8",x);Sw=y([64,112,114,111,112,101,114,116,121,0],"i8",x);Tw=y([112,114,111,116,111,116,121,112,101,115,0],"i8",x);Uw=y([58,63,43,0],"i8",x);Vw=y([116,114,97,110,115,105,116,105,111,110,0],"i8",x);Ww=y([112,114,111,116,111,116,121,112,101,0],"i8",x);Xw=y([116,114,97,110,115,0],"i8",x);Yw=y([99,111,109,112,111,110,101,110,116,32,100,101,99,108,97,114,97,116,105,111,110,115,0],"i8",x);Zw=y([77,111,98,105,76,105,110,107,32,80,114,111,112,101,114,116,105,101,115,32,0],"i8",x);$w=y([116,104,114,111,119,115,0],"i8",x);ax=y([101,110,116,105,116,121,32,100,101,99,108,97,114,97,116,105,111,110,115,0],"i8",x);bx=y([109,108,112,114,111,112,0],"i8",x);cx=y([116,104,114,111,119,0],"i8",x);dx=y([99,111,110,118,101,114,116,0],"i8",x);ex=y([114,101,99,111,114,100,32,110,97,109,101,115,0],"i8",x);fx=y([77,111,98,105,76,105,110,107,32,67,111,110,110,32,83,99,114,105,112,116,115,0],"i8",x);gx=y([115,101,108,101,99,116,111,114,115,0],"i8",x);hx=y([102,44,102,105,108,101,44,102,105,108,101,32,100,101,115,99,114,105,112,116,105,111,110,115,32,40,70,68,44,32,83,68,44,32,82,68,41,0],"i8",x);ix=y([37,115,32,112,97,114,115,101,114,32,100,101,102,105,110,105,116,105,111,110,32,109,117,115,116,32,100,101,102,105,110,101,32,111,110,101,32,97,110,100,32,111,110,108,121,32,111,110,101,32,112,97,114,115,105,110,103,32,114,111,117,116,105,110,101,10,0],"i8",x);jx=y([101,110,100,102,0],"i8",x);kx=y([97,114,114,97,121,0],"i8",x);lx=y([112,97,114,97,109,101,116,101,114,0],"i8",x);mx=y([104,112,0],"i8",x);nx=y([112,114,105,118,97,116,101,0],"i8",x);ox=y([115,117,98,116,121,112,101,32,100,101,102,105,110,105,116,105,111,110,115,0],"i8",x);px=y([109,108,99,111,110,110,0],"i8",x);qx=y([115,108,111,116,0],"i8",x);rx=y([116,101,109,112,108,97,116,101,0],"i8",x);sx=y([112,114,111,103,114,97,109,32,40,103,108,111,98,97,108,41,32,97,110,100,32,109,111,100,117,108,101,32,118,97,114,105,97,98,108,101,115,0],"i8",x);tx=y([116,121,112,101,32,100,101,102,105,110,105,116,105,111,110,115,0],"i8",x);ux=y([77,111,98,105,76,105,110,107,32,84,97,98,108,101,32,83,99,114,105,112,116,115,0],"i8",x);vx=y([101,110,100,109,97,99,114,111,0],"i8",x);wx=y([65,110,116,0],"i8",x);xx=y([98,117,105,108,100,46,120,109,108,0],"i8",x);D=y(468,"i8",x);yx=y(8,"i8",x);zx=y(8,"i8",x);Ax=y([1,0,0,0,97,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Bx=y(12,"i8",x);Cx=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,84,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,114,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,101,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,67,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,100,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,80,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,108,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);E=y([0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,13,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,15,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,17,0,0,0,0,0,0,0,18,0,0,0,0,0,0,0,19,0,0,0,0,0,0,0,20,0,0,0,0,0,0,0,21,0,0,0,0,0,0,0,22,0,0,0,0,0,0,0,23,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,25,0,0,0,0,0,0,0,26,0,0,0,0,0,0,0,27,0,0,0,0,0,0,0,28,0,0,0,0,0,0,0,29,0,0,0,0,0,0,0,30,0,0,0,0,0,0,0,31,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,33,0,0,0,0,0,0,0,34,0,0,0,0,0,0,0,35,0,0,0,0,0,0,0,36,0,0,0,0,0,0,0,37,0,0,0,0,0,0,0,38,0,0,0,0,0,0,0,39,0,0,0,0,0,0,0,40,0,0,0,0,0,0,0,41,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,43,0,0,0,0,0,0,0,44,0,0,0,0,0,0,0,45,0,0,0,0,0,0,0,46,0,0,0,0,0,0,0,47,0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,49,0,0,0,0,0,0,0,50,0,0,0,0,0,0,0,51,0,0,0,0,0,0,0,52,0,0,0,0,0,0,0,53,0,0,0,0,0,0,0,54,0,0,0,0,0,0,0,55,0,0,0,0,0,0,0,56,0,0,0,0,0,0,0,57,0,0,0,0,0,0,0,58,0,0,0,0,0,0,0,59,0,0,0,0,0,0,0,60,0,0,0,0,0,0,0,61,0,0,0,0,0,0,0,62,0,0,0,0,0,0,0,63,0,0,0,0,0,0,0,64,0,0,0,0,0,0,0,65,0,0,0,0,0,0,0,66,0,0,0,0,0,0,0,67,0,0,0,0,0,0,0,68,0,0,0,0,0,0,0,69,0,0,0,0,0,0,0,70,0,0,0,0,0,0,0,71,0,0,0,0,0,0,0,72,0,0,0,0,0,0,0,73,0,0,0,0,0,0,0,74,0,0,0,0,0,0,0,75,0,0,0,0,0,0,0,76,0,0,0,0,0,0,0,77,0,0,0,0,0,0,0,78,0,0,0,0,0,0,0,79,0,0,0,0,0,0,0,80,0,0,0,0,0,0,0,81,0,0,0,0,0,0,0,82,0,0,0,0,0,0,0,83,0,0,0,0,0,0,0,84,0,0,0,0,0,0,0,85,0,0,0,0,0,0,0,86,0,0,0,0,0,0,0,87,0,0,0,0,0,0,0,88,0,0,0,0,0,0,0,89,0,0,0,0,0,0,0,90,0,0,0,0,0,0,0,91,0,0,0,0,0,0,0,92,0,0,0,0,0,0,0,93,0,0,0,0,0,0,0,94,0,0,0],["*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0],x);Dx=y(8,"i8",x);Ex=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,101,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,110,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,114,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Fx=y([0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,4,0,0,0],["*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0],x);Gx=y(16,"i8",x);Hx=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,100,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,101,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,103,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,108,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,80,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,84,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,120,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Ix=y(4,"i8",x);Jx=y(4,"i8",x);Kx=y(8,"i8",x);Lx=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,115,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,117,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,98,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,80,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,71,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,105,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Mx=y(20,"i8",x);Nx=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Ox=y(4,"i8",x);Px=y(8,"i8",x);Qx=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,100,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,70,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,108,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,76,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,80,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,114,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,115,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,84,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,105,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,101,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,85,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,82,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,68,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,86,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,110,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,120,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,121,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,122,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);F=y([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,13,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,15,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,17,0,0,0,0,0,0,0,18,0,0,0,0,0,0,0,19,0,0,0,0,0,0,0,20,0,0,0,0,0,0,0,21,0,0,0,0,0,0,0,22,0,0,0,0,0,0,0,23,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,25,0,0,0,0,0,0,0,26,0,0,0,0,0,0,0,27,0,0,0,0,0,0,0,28,0,0,0,0,0,0,0,29,0,0,0,0,0,0,0,30,0,0,0,0,0,0,0,31,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,33,0,0,0,0,0,0,0,34,0,0,0,0,0,0,0,35,0,0,0,0,0,0,0,36,0,0,0,0,0,0,0,37,0,0,0,0,0,0,0,38,0,0,0,0,0,0,0,39,0,0,0,0,0,0,0,40,0,0,0,0,0,0,0,41,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,43,0,0,0,0,0,0,0,44,0,0,0,0,0,0,0,45,0,0,0,0,0,0,0,46,0,0,0,0,0,0,0,47,0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,49,0,0,0,0,0,0,0,50,0,0,0,0,0,0,0,51,0,0,0,0,0,0,0,52,0,0,0,0,0,0,0,53,0,0,0,0,0,0,0,54,0,0,0,0,0,0,0,55,0,0,0,0,0,0,0,56,0,0,0,0,0,0,0,57,0,0,0,0,0,0,0,58,0,0,0,0,0,0,0,59,0,0,0,0,0,0,0,60,0,0,0,0,0,0,0,61,0,0,0,0,0,0,0,62,0,0,0,0,0,0,0,63,0,0,0,0,0,0,0,64,0,0,0,0,0,0,0,65,0,0,0,0,0,0,0,66,0,0,0,0,0,0,0,67,0,0,0,0,0,0,0,68,0,0,0,0,0,0,0,69,0,0,0,0,0,0,0,70,0,0,0,0,0,0,0,71,0,0,0],["*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0],x);Rx=y(12,"i8",x);Sx=y([1,0,0,0,101,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,115,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,114,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Tx=y([0,0,0,0,5,0,0,0,0,0,0,0,-2,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,6,0,0,0],["*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0],x);Ux=y(8,"i8",x);Vx=y(4,"i8",x);Wx=y(28,"i8",x);Xx=y([1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Yx=y(4,"i8",x);Zx=y([-1],["i32",0,0,0],x);$x=y(28,"i8",x);ay=y([1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,115,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);by=y(12,"i8",x);cy=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,70,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,100,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,67,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);dy=y(16,"i8",x);ey=y(24,"i8",x);fy=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,105,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);gy=y(16,"i8",x);hy=y(20,"i8",x);iy=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,108,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,115,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,100,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);jy=y(12,"i8",x);ky=y([1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);ly=y(4,"i8",x);my=y(4,"i8",x);ny=y(4,"i8",x);oy=y([0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0],x);py=y([0,0,0,0,-1,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,-1,0,0,0,3,0,0,0,-1,0,0,0,4,0,0,0,-1,0,0,0,5,0,0,0,-1,0,0,0,6,0,0,0,-1,0,0,0,7,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,9,0,0,0,1,0,0,0,10,0,0,0,2,0,0,0,11,0,0,0,1,0,0,0,12,0,0,0,3,0,0,0,13,0,0,0,-1,0,0,0,14,0,0,0,0,0,0,0,15,0,0,0,3,0,0,0],["i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0,"i32",0,0,0],x);qy=y(12,"i8",x);ry=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,77,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,67,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,114,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,101,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);sy=y([0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,13,0,0,0,0,0,0,0,15,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,17,0,0,0,0,0,0,0,18,0,0,0,0,0,0,0,19,0,0,0,0,0,0,0,20,0,0,0,0,0,0,0,21,0,0,0,0,0,0,0,22,0,0,0,0,0,0,0,23,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,25,0,0,0,0,0,0,0,26,0,0,0,0,0,0,0,27,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,28,0,0,0,0,0,0,0,29,0,0,0,0,0,0,0,30,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,45,0,0,0,0,0,0,0,41,0,0,0,0,0,0,0,41,0,0,0],["*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0],x);ty=y(12,"i8",x);uy=y([1,0,0,0,105,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,73,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,70,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,115,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,101,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,77,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);vy=y(12,"i8",x);wy=y(12,"i8",x);xy=y([1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);yy=y(8,"i8",x);zy=y([1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Ay=y(28,"i8",x);By=y([1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Cy=y(4,"i8",x);Dy=y(4,"i8",x);Ey=y(4,"i8",x);Fy=y(4,"i8",x);Gy=y(4,"i8",x);Hy=y(4,"i8",x);Iy=y(4,"i8",x);Jy=y(4,"i8",x);Ky=y(4,"i8",x);Ly=y(4,"i8",x);My=y(4,"i8",x);Ny=y(4,"i8",x);Oy=y(4,"i8",x);Py=y(4,"i8",x);Qy=y(4,"i8",x);Ry=y(4,"i8",x);Sy=y(4,"i8",x);Ty=y(4,"i8",x);Uy=y(4,"i8",x);H=y([0,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,9,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,10,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,11,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,13,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,15,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,20,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,17,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,18,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,19,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,21,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,22,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,23,0,0,0,1,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,27,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,24,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,26,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,25,0,0,0,1,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,28,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,29,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,30,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,31,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,33,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,34,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,35,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,36,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,37,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,38,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,40,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,41,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,39,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,43,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,44,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,45,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,46,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,47,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,49,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,50,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,51,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,52,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,55,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,53,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,54,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,56,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,57,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,58,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,59,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,62,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,60,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,61,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,63,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,64,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,65,0,0,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,66,0,0,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,67,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,68,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,69,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,71,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,72,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,70,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,73,0,0,0,1,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,74,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,75,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,76,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,77,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,78,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,79,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,80,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,81,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,82,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,84,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,85,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,83,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,86,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,87,0,0,0,1,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,88,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,89,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,90,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,91,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,92,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,93,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,94,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,95,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,96,0,0,0,1,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,97,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,98,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,99,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0],["*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8","*",0,0,0,"i32",0,0,0,"i16",0,"i16",0,"i16",0,"i16",0,"i16",0,"i8","i8"],x);Vy=y([1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Wy=y([0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,13,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,15,0,0,0,0,0,0,0,16,0,0,0],["*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0],x);Xy=y(8,"i8",x);Yy=y(8,"i8",x);Zy=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,101,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,103,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,105,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,108,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);$y=y(12,"i8",x);az=y(36,"i8",x);bz=y(4,"i8",x);cz=y(8,"i8",x);dz=y([1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);ez=y(4,"i8",x);fz=y(4,"i8",x);gz=y(4,"i8",x);hz=y(28,"i8",x);iz=y([1,0,0,0,98,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,101,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,105,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,107,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,108,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,76,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,110,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,115,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);J=y([0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,13,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,15,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,17,0,0,0,0,0,0,0,18,0,0,0,0,0,0,0,19,0,0,0,0,0,0,0,20,0,0,0,0,0,0,0,21,0,0,0,0,0,0,0,22,0,0,0,0,0,0,0,23,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,25,0,0,0,0,0,0,0,26,0,0,0,0,0,0,0,27,0,0,0,0,0,0,0,28,0,0,0,0,0,0,0,29,0,0,0,0,0,0,0,30,0,0,0,0,0,0,0,31,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,33,0,0,0,0,0,0,0,34,0,0,0,0,0,0,0,35,0,0,0,0,0,0,0,36,0,0,0,0,0,0,0,37,0,0,0,0,0,0,0,38,0,0,0,0,0,0,0,39,0,0,0,0,0,0,0,40,0,0,0,0,0,0,0,41,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,43,0,0,0,0,0,0,0,44,0,0,0,0,0,0,0,45,0,0,0,0,0,0,0,46,0,0,0,0,0,0,0,47,0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,49,0,0,0,0,0,0,0,50,0,0,0,0,0,0,0,51,0,0,0,0,0,0,0,52,0,0,0,0,0,0,0,53,0,0,0,0,0,0,0,54,0,0,0,0,0,0,0,55,0,0,0,0,0,0,0,56,0,0,0,0,0,0,0,57,0,0,0,0,0,0,0,58,0,0,0,0,0,0,0,59,0,0,0,0,0,0,0,60,0,0,0,0,0,0,0,61,0,0,0,0,0,0,0,62,0,0,0,0,0,0,0,63,0,0,0,0,0,0,0,64,0,0,0,0,0,0,0,65,0,0,0,0,0,0,0,66,0,0,0,0,0,0,0,67,0,0,0],["*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0],x);jz=y(12,"i8",x);kz=y([1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,120,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);lz=y([0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,13,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,15,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,17,0,0,0,0,0,0,0,18,0,0,0,0,0,0,0,19,0,0,0,0,0,0,0,20,0,0,0,0,0,0,0,21,0,0,0,0,0,0,0,22,0,0,0,0,0,0,0,23,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,25,0,0,0,0,0,0,0,26,0,0,0,0,0,0,0,27,0,0,0],["*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0],x);K=y(60,"i8",x);mz=y(12,"i8",x);nz=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,105,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);oz=y(4,"i8",x);pz=y(40,"i8",x);qz=y(40,"i8",x);rz=y(40,"i8",x);sz=y(40,"i8",x);tz=y(40,"i8",x);uz=y(40,"i8",x);vz=y(40,"i8",x);wz=y(40,"i8",x);xz=y(40,"i8",x);yz=y(40,"i8",x);zz=y(20,"i8",x);Az=y([1,0,0,0,100,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,114,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Bz=y(8,"i8",x);Cz=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,108,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Dz=y([0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,13,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,15,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,17,0,0,0,0,0,0,0,18,0,0,0,0,0,0,0,19,0,0,0,0,0,0,0,20,0,0,0,0,0,0,0,21,0,0,0,0,0,0,0,22,0,0,0,0,0,0,0,23,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,25,0,0,0,0,0,0,0,26,0,0,0,0,0,0,0,27,0,0,0,0,0,0,0,28,0,0,0,0,0,0,0,29,0,0,0,0,0,0,0,30,0,0,0,0,0,0,0,31,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,33,0,0,0,0,0,0,0,34,0,0,0,0,0,0,0,35,0,0,0,0,0,0,0,36,0,0,0,0,0,0,0,37,0,0,0,0,0,0,0,38,0,0,0,0,0,0,0,39,0,0,0,0,0,0,0,40,0,0,0,0,0,0,0,41,0,0,0,0,0,0,0,42,0,0,0,0,0,0,0,43,0,0,0,0,0,0,0,44,0,0,0,0,0,0,0,45,0,0,0,0,0,0,0,46,0,0,0,0,0,0,0,47,0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,49,0,0,0,0,0,0,0,50,0,0,0,0,0,0,0,51,0,0,0,0,0,0,0,52,0,0,0,0,0,0,0,53,0,0,0,0,0,0,0,54,0,0,0,0,0,0,0,55,0,0,0,0,0,0,0,56,0,0,0,0,0,0,0,57,0,0,0,0,0,0,0,58,0,0,0,0,0,0,0,59,0,0,0,0,0,0,0,60,0,0,0],["*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0],x);Ez=y(12,"i8",x);Fz=y(4,"i8",x);Gz=y(8,"i8",x);Hz=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,115,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,105,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Iz=y(8,"i8",x);Jz=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,100,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,101,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,69,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,103,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,105,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,108,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,110,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,115,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Kz=y(48,"i8",x);Lz=y(352,"i8",x);Mz=y(4,"i8",x);Nz=y(4,"i8",x);Oz=y(4,"i8",x);Pz=y(20,"i8",x);Qz=y(4,"i8",x);Rz=y(4,"i8",x);Sz=y(8,"i8",x);Tz=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,100,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,101,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,103,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,108,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,110,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,115,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,117,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,120,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Uz=y([240,0,0,0,242,0,0,0,258,0,0,0,178,0,0,0,302,0,0,0,98,0,0,0,196,0,0,0,184,0,0,0,290,0,0,0,42,0,0,0,76,0,0,0,214,0,0,0,112,0,0,0,28,0,0,0,72,0,0,0,264,0,0,0,40,0,0,0,136,0,0,0,32,0,0,0,80,0,0,0,34,0,0,0,106,0,0,0,90,0,0,0,200,0,0,0,138,0,0,0,292,0,0,0,58,0,0,0,56,0,0,0,6,0,0,0,146,0,0,0,218,0,0,0,252,0,0,0,52,0,0,0,30,0,0,0,222,0,0,0,96,0,0,0,262,0,0,0,54,0,0,0,182,0,0,0,152,0,0,0,220,0,0,0,226,0,0,0,206,0,0,0,244,0,0,0],["*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0,"*",0,0,0],x);Vz=y(4,"i8",x);Wz=y(8,"i8",x);Xz=y([1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,112,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,115,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);Yz=y(20,"i8",x);Zz=y([1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,108,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,103,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);$z=y(16,"i8",x);aA=y([1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);bA=y(12,"i8",x);cA=y([1,0,0,0,100,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,102,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,115,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,118,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);dA=y(20,"i8",x);eA=y(20,"i8",x);fA=y([1,0,0,0,100,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,108,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,109,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0],["i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0,"i32",0,0,0,"i32",0,0,0,"*",0,0,0,"*",0,0,0],x);gA=y([0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,6,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,13,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,15,0,0,0],["*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0,"*",0,0,0,"i32",0,0,0],x);hA=y(8,"i8",x);iA=y(4,"i8",x);jA=y(4,"i8",x);kA=y(4,"i8",x);lA=y(4,"i8",x);t[dc>>2]=et|0;t[dc+12>>2]=Gs|0;t[dc+24>>2]=xg|0;t[dc+36>>2]=ci|0;t[dc+48>>2]=cq|0;t[dc+60>>2]=Au|0;t[hc>>2]=Fq|0;t[hc+4>>2]=rq|0;t[hc+8>>2]=Zp|0;t[hc+12>>2]=Ip|0;t[hc+16>>2]=rp|0;t[hc+20>>2]=dp|0;t[hc+24>>2]=Uo|0;t[hc+28>>2]=wo|0;t[hc+32>>2]=dh|0;t[hc+36>>2]=co|0;t[hc+40>>2]=Un|0;t[hc+44>>2]=Bg|0;t[hc+48>>2]=un|0;t[hc+52>>2]=jn|0;t[hc+56>>2]=Xm|0;t[hc+60>>2]=Km|0;t[hc+64>>2]=Bm|0;t[hc+68>>2]=gm|0;t[hc+72>>2]=Wl|0;t[hc+76>>2]=Ll|0;t[hc+80>>2]=Dl|0;t[hc+84>>2]=vl|0;t[hc+88>>2]=jl|0;t[hc+92>>2]=$k|0;t[hc+96>>2]=Nk|0;t[hc+100>>2]=Ck|0;t[hc+104>>2]=tk|0;t[hc+108>>2]=bk|0;t[sc>>2]=yn|0;t[sc+8>>2]=uq|0;t[sc+16>>2]=wj|0;t[sc+24>>2]=Uh|0;t[sc+32>>2]=zg|0;t[sc+40>>2]=uf|0;t[sc+48>>2]=Zd|0;t[sc+56>>2]=Sw|0;t[sc+64>>2]=gw|0;t[sc+72>>2]=Dv|0;t[sc+80>>2]=ev|0;t[sc+88>>2]=Hu|0;t[sc+96>>2]=hu|0;t[sc+104>>2]=Kt|0;t[sc+112>>2]=ht|0;t[sc+120>>2]=Ls|0;t[sc+128>>2]=qs|0;t[sc+136>>2]=cs|0;t[sc+144>>2]=Dr|0;t[sc+152>>2]=jr|0;t[sc+160>>2]=Tq|0;t[Cc>>2]=134;t[Cc+4>>2]=204;t[Fc>>2]=eu|0;t[Fc+4>>2]=Gt|0;t[Fc+8>>2]=ft|0;t[Fc+12>>2]=Is|0;t[Fc+16>>2]=os|0;t[Fc+20>>2]=$r|0;t[Fc+24>>2]=Br|0;t[Fc+28>>2]=ir|0;t[Fc+32>>2]=ov|0;t[Fc+36>>2]=Sf|0;t[Fc+40>>2]=bp|0;t[Ic>>2]=hh|0;t[Ic+4>>2]=Zq|0;t[Ic+8>>2]=Bo|0;t[Ic+12>>2]=Ot|0;t[Xc>>2]=El|0;t[Xc+12>>2]=Rh|0;t[Xc+24>>2]=xg|0;t[Xc+36>>2]=mu|0;t[Xc+48>>2]=Cf|0;t[Xc+60>>2]=nf|0;t[Xc+72>>2]=dw|0;t[Xc+84>>2]=Cv|0;t[Xc+96>>2]=cv|0;t[Xc+108>>2]=Gu|0;t[Xc+120>>2]=wf|0;t[Xc+132>>2]=wj|0;t[sd>>2]=El|0;t[sd+12>>2]=Gs|0;t[sd+24>>2]=xg|0;t[sd+36>>2]=Cf|0;t[sd+48>>2]=wf|0;t[td>>2]=hh|0;t[td+4>>2]=Gw|0;t[td+8>>2]=nx|0;t[td+12>>2]=Ve|0;t[td+16>>2]=Yf|0;t[td+20>>2]=Vf|0;t[yx>>2]=kr|0;t[zx>>2]=gv|0;t[Ax+8>>2]=cg|0;t[Ax+12>>2]=Xf|0;t[Ax+24>>2]=Lf|0;t[Ax+28>>2]=Hf|0;t[Ax+40>>2]=Cf|0;t[Ax+44>>2]=yf|0;t[Ax+56>>2]=ys|0;t[Ax+60>>2]=vf|0;t[Ax+72>>2]=qf|0;t[Ax+76>>2]=kf|0;t[Bx>>2]=Lv|0;t[Bx+4>>2]=sw|0;t[Cx+8>>2]=Rr|0;t[Cx+12>>2]=Bd|0;t[Cx+24>>2]=wf|0;t[Cx+28>>2]=tx|0;t[Cx+40>>2]=Mf|0;t[Cx+44>>2]=ox|0;t[Cx+56>>2]=Hh|0;t[Cx+60>>2]=ex|0;t[Cx+72>>2]=Up|0;t[Cx+76>>2]=ax|0;t[Cx+88>>2]=As|0;t[Cx+92>>2]=Yw|0;t[Cx+104>>2]=Ww|0;t[Cx+108>>2]=Tw|0;t[Cx+120>>2]=Cf|0;t[Cx+124>>2]=Qw|0;t[Cx+136>>2]=ci|0;t[Cx+140>>2]=Nw|0;t[Cx+152>>2]=Gi|0;t[Cx+156>>2]=Lw|0;t[Cx+168>>2]=Gw|0;t[Cx+172>>2]=Cw|0;t[E>>2]=Io|0;t[E+8>>2]=qm|0;t[E+16>>2]=kk|0;t[E+24>>2]=Ai|0;t[E+32>>2]=Uq|0;t[E+40>>2]=Tf|0;t[E+48>>2]=Se|0;t[E+56>>2]=kx|0;t[E+64>>2]=zw|0;t[E+72>>2]=Ov|0;t[E+80>>2]=ov|0;t[E+88>>2]=Su|0;t[E+96>>2]=tu|0;t[E+104>>2]=Vt|0;t[E+112>>2]=vt|0;t[E+120>>2]=Vs|0;t[E+128>>2]=As|0;t[E+136>>2]=js|0;t[E+144>>2]=Rr|0;t[E+152>>2]=pr|0;t[E+160>>2]=$q|0;t[E+168>>2]=ti|0;t[E+176>>2]=Aq|0;t[E+184>>2]=Sf|0;t[E+192>>2]=Up|0;t[E+200>>2]=Ep|0;t[E+208>>2]=Ne|0;t[E+216>>2]=bp|0;t[E+224>>2]=Cf|0;t[E+232>>2]=to|0;t[E+240>>2]=ko|0;t[E+248>>2]=ao|0;t[E+256>>2]=Qn|0;t[E+264>>2]=im|0;t[E+272>>2]=qn|0;t[E+280>>2]=en|0;t[E+288>>2]=Um|0;t[E+296>>2]=Hm|0;t[E+304>>2]=vm|0;t[E+312>>2]=cm|0;t[E+320>>2]=Ul|0;t[E+328>>2]=Kl|0;t[E+336>>2]=Cl|0;t[E+344>>2]=sl|0;t[E+352>>2]=ys|0;t[E+360>>2]=Xk|0;t[E+368>>2]=Lk|0;t[E+376>>2]=yk|0;t[E+384>>2]=pk|0;t[E+392>>2]=Tm|0;t[E+400>>2]=Sj|0;t[E+408>>2]=Lj|0;t[E+416>>2]=Gj|0;t[E+424>>2]=hr|0;t[E+432>>2]=sj|0;t[E+440>>2]=gj|0;t[E+448>>2]=Zi|0;t[E+456>>2]=Ni|0;t[E+464>>2]=Gi|0;t[E+472>>2]=oi|0;t[E+480>>2]=hi|0;t[E+488>>2]=ci|0;t[E+496>>2]=$h|0;t[E+504>>2]=Wh|0;t[E+512>>2]=Ph|0;t[E+520>>2]=Hh|0;t[E+528>>2]=Bh|0;t[E+536>>2]=rh|0;t[E+544>>2]=lh|0;t[E+552>>2]=Zg|0;t[E+560>>2]=Ug|0;t[E+568>>2]=Pg|0;t[E+576>>2]=Kg|0;t[E+584>>2]=Dg|0;t[E+592>>2]=vg|0;t[E+600>>2]=pg|0;t[E+608>>2]=lg|0;t[E+616>>2]=dg|0;t[E+624>>2]=Zf|0;t[E+632>>2]=Mf|0;t[E+640>>2]=If|0;t[E+648>>2]=Df|0;t[E+656>>2]=zf|0;t[E+664>>2]=wf|0;t[E+672>>2]=rf|0;t[E+680>>2]=lf|0;t[E+688>>2]=df|0;t[E+696>>2]=Ze|0;t[E+704>>2]=qf|0;t[E+712>>2]=Je|0;t[E+720>>2]=Fe|0;t[E+728>>2]=ye|0;t[E+736>>2]=ve|0;t[E+744>>2]=ae|0;t[E+752>>2]=Vd|0;t[Dx>>2]=ew|0;t[Ex+8>>2]=Rr|0;t[Ex+12>>2]=uo|0;t[Ex+24>>2]=Jo|0;t[Ex+28>>2]=lo|0;t[Ex+40>>2]=Cf|0;t[Ex+44>>2]=bo|0;t[Ex+56>>2]=Uf|0;t[Ex+60>>2]=Rn|0;t[Ex+72>>2]=Bn|0;t[Ex+76>>2]=rn|0;t[Ex+88>>2]=oi|0;t[Ex+92>>2]=Vm|0;t[Ex+104>>2]=Bh|0;t[Ex+108>>2]=wm|0;t[Ex+120>>2]=wt|0;t[Ex+124>>2]=dm|0;t[Fx>>2]=Kr|0;t[Fx+8>>2]=Jo|0;t[Fx+16>>2]=Cf|0;t[Fx+24>>2]=Hm|0;t[Fx+32>>2]=Bi|0;t[Fx+40>>2]=gh|0;t[Fx+48>>2]=Uf|0;t[Fx+56>>2]=Te|0;t[Fx+64>>2]=lx|0;t[Fx+72>>2]=Aw|0;t[Fx+80>>2]=Pv|0;t[Fx+88>>2]=qv|0;t[Fx+96>>2]=Uu|0;t[Fx+104>>2]=vu|0;t[Fx+112>>2]=Xt|0;t[Fx+120>>2]=wt|0;t[Fx+128>>2]=Ws|0;t[Fx+136>>2]=Bs|0;t[Fx+144>>2]=ks|0;t[Fx+152>>2]=Sr|0;t[Fx+160>>2]=qr|0;t[Fx+168>>2]=ar|0;t[Fx+176>>2]=Nq|0;t[Fx+184>>2]=Bq|0;t[Fx+192>>2]=mq|0;t[Fx+200>>2]=Vp|0;t[Gx>>2]=Us|0;t[Gx+4>>2]=zs|0;t[Gx+8>>2]=is|0;t[Hx+8>>2]=Fi|0;t[Hx+12>>2]=Rv|0;t[Hx+24>>2]=Zv|0;t[Hx+28>>2]=Ie|0;t[Hx+40>>2]=Gv|0;t[Hx+44>>2]=Fv|0;t[Hx+56>>2]=Cf|0;t[Hx+60>>2]=yf|0;t[Hx+72>>2]=wj|0;t[Hx+76>>2]=Av|0;t[Hx+88>>2]=Gw|0;t[Hx+92>>2]=Nf|0;t[Hx+104>>2]=$p|0;t[Hx+108>>2]=uv|0;t[Hx+120>>2]=Xj|0;t[Hx+124>>2]=Yd|0;t[Hx+136>>2]=Ww|0;t[Hx+140>>2]=hv|0;t[Hx+152>>2]=wt|0;t[Hx+156>>2]=dm|0;t[Hx+168>>2]=yn|0;t[Hx+172>>2]=fv|0;t[Hx+184>>2]=qf|0;t[Hx+188>>2]=kf|0;t[Hx+200>>2]=$u|0;t[Hx+204>>2]=Xu|0;t[Kx>>2]=ow|0;t[Lx+8>>2]=Nr|0;t[Lx+12>>2]=Qv|0;t[Lx+24>>2]=Mo|0;t[Lx+28>>2]=rv|0;t[Lx+40>>2]=sm|0;t[Lx+44>>2]=Vu|0;t[Lx+56>>2]=mk|0;t[Lx+60>>2]=wu|0;t[Lx+72>>2]=Ci|0;t[Lx+76>>2]=Yt|0;t[Lx+88>>2]=ih|0;t[Lx+92>>2]=xt|0;t[Lx+104>>2]=Wf|0;t[Lx+108>>2]=Xs|0;t[Lx+120>>2]=Ue|0;t[Lx+124>>2]=Cs|0;t[Mx>>2]=rw|0;t[Mx+4>>2]=yw|0;t[Mx+8>>2]=Qr|0;t[Mx+12>>2]=Oo|0;t[Nx+8>>2]=Fi|0;t[Nx+12>>2]=Rv|0;t[Nx+24>>2]=Bw|0;t[Nx+28>>2]=sv|0;t[Nx+40>>2]=ci|0;t[Nx+44>>2]=xu|0;t[Px>>2]=ud|0;t[Qx+8>>2]=Ii|0;t[Qx+12>>2]=Eg|0;t[Qx+24>>2]=Ww|0;t[Qx+28>>2]=Tw|0;t[Qx+40>>2]=Cf|0;t[Qx+44>>2]=bo|0;t[Qx+56>>2]=eg|0;t[Qx+60>>2]=$f|0;t[Qx+72>>2]=Gw|0;t[Qx+76>>2]=Nf|0;t[Qx+88>>2]=cm|0;t[Qx+92>>2]=Ef|0;t[Qx+104>>2]=Gi|0;t[Qx+108>>2]=Af|0;t[Qx+120>>2]=ci|0;t[Qx+124>>2]=xu|0;t[Qx+136>>2]=Hh|0;t[Qx+140>>2]=sf|0;t[Qx+152>>2]=Mf|0;t[Qx+156>>2]=mf|0;t[Qx+168>>2]=cp|0;t[Qx+172>>2]=ef|0;t[Qx+184>>2]=Po|0;t[Qx+188>>2]=$e|0;t[Qx+200>>2]=qf|0;t[Qx+204>>2]=We|0;t[Qx+216>>2]=mo|0;t[Qx+220>>2]=Ke|0;t[Qx+232>>2]=Jo|0;t[Qx+236>>2]=lo|0;t[Qx+248>>2]=Sn|0;t[Qx+252>>2]=ze|0;t[Qx+264>>2]=Cn|0;t[Qx+268>>2]=we|0;t[Qx+280>>2]=sn|0;t[Qx+284>>2]=be|0;t[Qx+296>>2]=Ch|0;t[Qx+300>>2]=Wd|0;t[Qx+312>>2]=sh|0;t[Qx+316>>2]=Gd|0;t[Qx+328>>2]=Cd|0;t[Qx+332>>2]=ux|0;t[Qx+344>>2]=px|0;t[Qx+348>>2]=fx|0;t[Qx+360>>2]=bx|0;t[Qx+364>>2]=Zw|0;t[F>>2]=Ur|0;t[F+8>>2]=vm|0;t[F+16>>2]=ov|0;t[F+24>>2]=tu|0;t[F+32>>2]=Ii|0;t[F+40>>2]=nh|0;t[F+48>>2]=Sf|0;t[F+56>>2]=Cf|0;t[F+64>>2]=im|0;t[F+72>>2]=ti|0;t[F+80>>2]=Sv|0;t[F+88>>2]=ch|0;t[F+96>>2]=sl|0;t[F+104>>2]=ye|0;t[F+112>>2]=Vs|0;t[F+120>>2]=bp|0;t[F+128>>2]=Zs|0;t[F+136>>2]=Ds|0;t[F+144>>2]=Gi|0;t[F+152>>2]=Of|0;t[F+160>>2]=ci|0;t[F+168>>2]=Hh|0;t[F+176>>2]=Oq|0;t[F+184>>2]=Cq|0;t[F+192>>2]=nq|0;t[F+200>>2]=lh|0;t[F+208>>2]=Fp|0;t[F+216>>2]=Mf|0;t[F+224>>2]=cp|0;t[F+232>>2]=Po|0;t[F+240>>2]=wf|0;t[F+248>>2]=mo|0;t[F+256>>2]=Jo|0;t[F+264>>2]=Sn|0;t[F+272>>2]=Cn|0;t[F+280>>2]=sn|0;t[F+288>>2]=fn|0;t[F+296>>2]=Wm|0;t[F+304>>2]=Im|0;t[F+312>>2]=ym|0;t[F+320>>2]=em|0;t[F+328>>2]=Fe|0;t[F+336>>2]=If|0;t[F+344>>2]=qf|0;t[F+352>>2]=tl|0;t[F+360>>2]=hl|0;t[F+368>>2]=hr|0;t[F+376>>2]=Mk|0;t[F+384>>2]=zk|0;t[F+392>>2]=rk|0;t[F+400>>2]=$j|0;t[F+408>>2]=Tj|0;t[F+416>>2]=Mj|0;t[F+424>>2]=Hj|0;t[F+432>>2]=zj|0;t[F+440>>2]=tj|0;t[F+448>>2]=hj|0;t[F+456>>2]=$i|0;t[F+464>>2]=Oi|0;t[F+472>>2]=Hi|0;t[F+480>>2]=pi|0;t[F+488>>2]=ii|0;t[F+496>>2]=di|0;t[F+504>>2]=ai|0;t[F+512>>2]=Gw|0;t[F+520>>2]=Qh|0;t[F+528>>2]=Ih|0;t[F+536>>2]=Ch|0;t[F+544>>2]=sh|0;t[F+552>>2]=mh|0;t[F+560>>2]=$g|0;t[F+568>>2]=Vg|0;t[F+576>>2]=Qg|0;t[Rx>>2]=Xd|0;t[Rx+4>>2]=ps|0;t[Sx+8>>2]=tl|0;t[Sx+12>>2]=at|0;t[Sx+24>>2]=Cf|0;t[Sx+28>>2]=yf|0;t[Sx+40>>2]=Uv|0;t[Sx+44>>2]=Vr|0;t[Sx+56>>2]=Zu|0;t[Sx+60>>2]=tr|0;t[Sx+72>>2]=Au|0;t[Sx+76>>2]=dr|0;t[Sx+88>>2]=wf|0;t[Sx+92>>2]=tx|0;t[Sx+104>>2]=Eq|0;t[Sx+108>>2]=pq|0;t[Tx>>2]=hg|0;t[Tx+8>>2]=Tf|0;t[Tx+16>>2]=fn|0;t[Tx+24>>2]=tl|0;t[Tx+32>>2]=Uv|0;t[Tx+40>>2]=xv|0;t[Tx+48>>2]=Zu|0;t[Tx+56>>2]=Au|0;t[Tx+64>>2]=wf|0;t[Tx+72>>2]=Bt|0;t[Ux>>2]=$d|0;t[Wx>>2]=xe|0;t[Wx+4>>2]=ss|0;t[Wx+8>>2]=hp|0;t[Wx+12>>2]=Qm|0;t[Wx+16>>2]=Fk|0;t[Wx+20>>2]=Ui|0;t[Xx+8>>2]=Cf|0;t[Xx+12>>2]=bo|0;t[$x>>2]=Be|0;t[$x+4>>2]=us|0;t[$x+8>>2]=jp|0;t[$x+12>>2]=Rm|0;t[$x+16>>2]=Gk|0;t[$x+20>>2]=Vi|0;t[ay+8>>2]=Cf|0;t[ay+12>>2]=bo|0;t[ay+24>>2]=Ad|0;t[ay+28>>2]=Kw|0;t[by>>2]=Ns|0;t[by+4>>2]=Hs|0;t[cy+8>>2]=Fi|0;t[cy+12>>2]=Rv|0;t[cy+24>>2]=Bw|0;t[cy+28>>2]=sv|0;t[cy+40>>2]=Uf|0;t[cy+44>>2]=Rn|0;t[cy+56>>2]=uj|0;t[cy+60>>2]=lj|0;t[cy+72>>2]=av|0;t[cy+76>>2]=aj|0;t[cy+88>>2]=Bu|0;t[cy+92>>2]=Qi|0;t[dy>>2]=tf|0;t[dy+4>>2]=Js|0;t[dy+8>>2]=vp|0;t[ey>>2]=Pf|0;t[ey+4>>2]=Qs|0;t[ey+8>>2]=Ap|0;t[ey+12>>2]=cn|0;t[ey+16>>2]=Uk|0;t[fy+8>>2]=Fi|0;t[fy+12>>2]=Rv|0;t[fy+24>>2]=Cf|0;t[fy+28>>2]=bo|0;t[fy+40>>2]=$p|0;t[fy+44>>2]=Ml|0;t[fy+56>>2]=qf|0;t[fy+60>>2]=We|0;t[fy+72>>2]=wl|0;t[fy+76>>2]=kl|0;t[gy>>2]=jg|0;t[gy+4>>2]=bt|0;t[gy+8>>2]=Hp|0;t[hy>>2]=Gg|0;t[hy+4>>2]=jt|0;t[hy+8>>2]=Np|0;t[hy+12>>2]=mn|0;t[iy+8>>2]=Rr|0;t[iy+12>>2]=Kp|0;t[iy+24>>2]=as|0;t[iy+28>>2]=up|0;t[iy+40>>2]=cm|0;t[iy+44>>2]=Vo|0;t[iy+56>>2]=Gi|0;t[iy+60>>2]=Af|0;t[iy+72>>2]=oo|0;t[iy+76>>2]=eo|0;t[iy+88>>2]=Wn|0;t[iy+92>>2]=In|0;t[jy>>2]=Ng|0;t[jy+4>>2]=mt|0;t[ky+8>>2]=Cf|0;t[ky+12>>2]=bo|0;t[ky+24>>2]=ci|0;t[ky+28>>2]=xu|0;t[qy>>2]=Sh|0;t[qy+4>>2]=Jt|0;t[ry+8>>2]=Fi|0;t[ry+12>>2]=Rv|0;t[ry+24>>2]=Bw|0;t[ry+28>>2]=uk|0;t[ry+40>>2]=Uf|0;t[ry+44>>2]=fk|0;t[ry+56>>2]=Wj|0;t[ry+60>>2]=Pj|0;t[ry+72>>2]=wf|0;t[ry+76>>2]=Ij|0;t[ry+88>>2]=Cf|0;t[ry+92>>2]=Cj|0;t[ry+104>>2]=vj|0;t[ry+108>>2]=mj|0;t[ry+120>>2]=cj|0;t[ry+124>>2]=Si|0;t[ry+136>>2]=Ji|0;t[ry+140>>2]=ui|0;t[sy>>2]=Tf|0;t[sy+8>>2]=ov|0;t[sy+16>>2]=Fi|0;t[sy+24>>2]=Zs|0;t[sy+32>>2]=yg|0;t[sy+40>>2]=ti|0;t[sy+48>>2]=Sf|0;t[sy+56>>2]=tl|0;t[sy+64>>2]=bp|0;t[sy+72>>2]=xv|0;t[sy+80>>2]=Cf|0;t[sy+88>>2]=Uv|0;t[sy+96>>2]=en|0;t[sy+104>>2]=fh|0;t[sy+112>>2]=gt|0;t[sy+120>>2]=Bw|0;t[sy+128>>2]=Uf|0;t[sy+136>>2]=bs|0;t[sy+144>>2]=Oq|0;t[sy+152>>2]=Gj|0;t[sy+160>>2]=Sq|0;t[sy+168>>2]=ps|0;t[sy+176>>2]=uq|0;t[sy+184>>2]=If|0;t[sy+192>>2]=Lp|0;t[sy+200>>2]=wf|0;t[sy+208>>2]=Bt|0;t[sy+216>>2]=Eq|0;t[sy+224>>2]=Bo|0;t[sy+232>>2]=ye|0;t[sy+240>>2]=ve|0;t[sy+248>>2]=gj|0;t[sy+256>>2]=Jn|0;t[sy+264>>2]=vn|0;t[sy+272>>2]=ln|0;t[sy+280>>2]=an|0;t[sy+288>>2]=Nm|0;t[sy+296>>2]=Dm|0;t[sy+304>>2]=km|0;t[sy+312>>2]=Xl|0;t[sy+320>>2]=Ol|0;t[sy+328>>2]=Fl|0;t[ty>>2]=xi|0;t[ty+4>>2]=Sl|0;t[uy+8>>2]=cq|0;t[uy+12>>2]=Mp|0;t[uy+24>>2]=wp|0;t[uy+28>>2]=fp|0;t[uy+40>>2]=Wo|0;t[uy+44>>2]=Do|0;t[uy+56>>2]=Bw|0;t[uy+60>>2]=uk|0;t[uy+72>>2]=Fi|0;t[uy+76>>2]=Kn|0;t[uy+88>>2]=Wj|0;t[uy+92>>2]=Pj|0;t[uy+104>>2]=eg|0;t[uy+108>>2]=Om|0;t[uy+120>>2]=Cf|0;t[uy+124>>2]=Cj|0;t[uy+136>>2]=Yl|0;t[uy+140>>2]=Pl|0;t[uy+152>>2]=yn|0;t[uy+156>>2]=Gl|0;t[uy+168>>2]=uq|0;t[uy+172>>2]=yl|0;t[uy+184>>2]=wj|0;t[uy+188>>2]=ml|0;t[uy+200>>2]=Zv|0;t[uy+204>>2]=Rk|0;t[vy>>2]=Wi|0;t[vy+4>>2]=Zt|0;t[wy>>2]=qq|0;t[wy+4>>2]=En|0;t[xy+8>>2]=Zv|0;t[xy+12>>2]=Iu|0;t[yy>>2]=bj|0;t[zy+8>>2]=Cf|0;t[zy+12>>2]=bo|0;t[Ay>>2]=ij|0;t[Ay+4>>2]=cu|0;t[Ay+8>>2]=sq|0;t[Ay+12>>2]=Hn|0;t[Ay+16>>2]=xl|0;t[Ay+20>>2]=Bj|0;t[By+8>>2]=Cf|0;t[By+12>>2]=bo|0;t[H>>2]=or|0;t[H+20>>2]=Zq|0;t[H+40>>2]=Mq|0;t[H+60>>2]=zq|0;t[H+80>>2]=lq|0;t[H+100>>2]=Tp|0;t[H+120>>2]=Dp|0;t[H+140>>2]=op|0;t[H+160>>2]=pw|0;t[H+180>>2]=Vs|0;t[H+200>>2]=kt|0;t[H+220>>2]=io|0;t[H+240>>2]=Fi|0;t[H+260>>2]=El|0;t[H+280>>2]=Tj|0;t[H+300>>2]=tn|0;t[H+320>>2]=gn|0;t[H+340>>2]=Zs|0;t[H+360>>2]=Vf|0;t[H+380>>2]=Am|0;t[H+400>>2]=fm|0;t[H+420>>2]=Vq|0;t[H+440>>2]=ti|0;t[H+460>>2]=wj|0;t[H+480>>2]=Jo|0;t[H+500>>2]=il|0;t[H+520>>2]=Yk|0;t[H+540>>2]=Vn|0;t[H+560>>2]=Ak|0;t[H+580>>2]=sk|0;t[H+600>>2]=bp|0;t[H+620>>2]=Vj|0;t[H+640>>2]=Nj|0;t[H+660>>2]=Cf|0;t[H+680>>2]=xj|0;t[H+700>>2]=im|0;t[H+720>>2]=jj|0;t[H+740>>2]=Yv|0;t[H+760>>2]=Xn|0;t[H+780>>2]=Hm|0;t[H+800>>2]=Bi|0;t[H+820>>2]=ji|0;t[H+840>>2]=gh|0;t[H+860>>2]=cq|0;t[H+880>>2]=ym|0;t[H+900>>2]=Gw|0;t[H+920>>2]=Kh|0;t[H+940>>2]=Dh|0;t[H+960>>2]=th|0;t[H+980>>2]=ph|0;t[H+1e3>>2]=ah|0;t[H+1020>>2]=bs|0;t[H+1040>>2]=wl|0;t[H+1060>>2]=Lg|0;t[H+1080>>2]=yk|0;t[H+1100>>2]=wg|0;t[H+1120>>2]=Ql|0;t[H+1140>>2]=Te|0;t[H+1160>>2]=fg|0;t[H+1180>>2]=Yo|0;t[H+1200>>2]=Gi|0;t[H+1220>>2]=Jf|0;t[H+1240>>2]=oi|0;t[H+1260>>2]=nx|0;t[H+1280>>2]=Xj|0;t[H+1300>>2]=Ve|0;t[H+1320>>2]=Yf|0;t[H+1340>>2]=Bh|0;t[H+1360>>2]=lh|0;t[H+1380>>2]=Ye|0;t[H+1400>>2]=Me|0;t[H+1420>>2]=Ee|0;t[H+1440>>2]=Ae|0;t[H+1460>>2]=wi|0;t[H+1480>>2]=re|0;t[H+1500>>2]=uq|0;t[H+1520>>2]=ju|0;t[H+1540>>2]=Dd|0;t[H+1560>>2]=wt|0;t[H+1580>>2]=rx|0;t[H+1600>>2]=te|0;t[H+1620>>2]=cx|0;t[H+1640>>2]=$w|0;t[H+1660>>2]=Xw|0;t[H+1680>>2]=Vw|0;t[H+1700>>2]=Pw|0;t[H+1720>>2]=Lp|0;t[H+1740>>2]=yn|0;t[H+1760>>2]=Iw|0;t[H+1780>>2]=Ew|0;t[H+1800>>2]=tw|0;t[H+1820>>2]=Fh|0;t[H+1840>>2]=nw|0;t[H+1860>>2]=jw|0;t[H+1880>>2]=iw|0;t[H+1900>>2]=Bo|0;t[H+1920>>2]=aw|0;t[H+1940>>2]=Wg|0;t[H+1960>>2]=Tv|0;t[H+1980>>2]=ye|0;t[Vy+8>>2]=Cf|0;t[Vy+12>>2]=bo|0;t[Vy+24>>2]=Fi|0;t[Vy+28>>2]=Rv|0;t[Vy+40>>2]=Bw|0;t[Vy+44>>2]=sv|0;t[Vy+56>>2]=Yl|0;t[Vy+60>>2]=dq|0;t[Vy+72>>2]=qf|0;t[Vy+76>>2]=xp|0;t[Wy>>2]=Cf|0;t[Wy+8>>2]=Ln|0;t[Wy+16>>2]=Oq|0;t[Wy+24>>2]=Dj|0;t[Wy+32>>2]=Ww|0;t[Wy+40>>2]=Wj|0;t[Wy+48>>2]=yk|0;t[Wy+56>>2]=te|0;t[Wy+64>>2]=bp|0;t[Wy+72>>2]=ye|0;t[Wy+80>>2]=Zs|0;t[Wy+88>>2]=im|0;t[Wy+96>>2]=ti|0;t[Wy+104>>2]=ju|0;t[Wy+112>>2]=Lp|0;t[Wy+120>>2]=kt|0;t[Wy+128>>2]=Ms|0;t[Xy>>2]=Yj|0;t[Yy>>2]=Wt|0;t[Zy+8>>2]=Fi|0;t[Zy+12>>2]=Rv|0;t[Zy+24>>2]=Wu|0;t[Zy+28>>2]=Ou|0;t[Zy+40>>2]=eg|0;t[Zy+44>>2]=ds|0;t[Zy+56>>2]=wj|0;t[Zy+60>>2]=Ku|0;t[Zy+72>>2]=cq|0;t[Zy+76>>2]=Ju|0;t[Zy+88>>2]=Gw|0;t[Zy+92>>2]=Nf|0;t[Zy+104>>2]=Bw|0;t[Zy+108>>2]=sv|0;t[Zy+120>>2]=Gi|0;t[Zy+124>>2]=Af|0;t[$y>>2]=ik|0;t[$y+4>>2]=ru|0;t[az>>2]=Sl|0;t[az+4>>2]=Il|0;t[az+8>>2]=Al|0;t[az+12>>2]=ql|0;t[az+16>>2]=fl|0;t[az+20>>2]=Vk|0;t[az+24>>2]=Jk|0;t[az+28>>2]=wk|0;t[cz>>2]=Qg|0;t[dz+8>>2]=Gi|0;t[dz+12>>2]=Af|0;t[dz+24>>2]=Mg|0;t[dz+28>>2]=bo|0;t[dz+40>>2]=El|0;t[dz+44>>2]=Kp|0;t[dz+56>>2]=wf|0;t[dz+60>>2]=Tt|0;t[dz+72>>2]=Wj|0;t[dz+76>>2]=We|0;t[hz>>2]=sr|0;t[hz+4>>2]=bp|0;t[hz+8>>2]=Rq|0;t[hz+12>>2]=fo|0;t[hz+16>>2]=Nl|0;t[hz+20>>2]=Oj|0;t[iz+8>>2]=Gf|0;t[iz+12>>2]=Gf|0;t[iz+24>>2]=mu|0;t[iz+28>>2]=Bf|0;t[iz+40>>2]=fq|0;t[iz+44>>2]=xf|0;t[iz+56>>2]=Cf|0;t[iz+60>>2]=bo|0;t[iz+72>>2]=cq|0;t[iz+76>>2]=pf|0;t[iz+88>>2]=As|0;t[iz+92>>2]=cf|0;t[iz+104>>2]=cm|0;t[iz+108>>2]=Vo|0;t[iz+120>>2]=Gw|0;t[iz+124>>2]=De|0;t[iz+136>>2]=Uf|0;t[iz+140>>2]=Rn|0;t[iz+152>>2]=Zl|0;t[iz+156>>2]=se|0;t[iz+168>>2]=Xj|0;t[iz+172>>2]=Yd|0;t[iz+184>>2]=oo|0;t[iz+188>>2]=eo|0;t[iz+200>>2]=wf|0;t[iz+204>>2]=Ed|0;t[iz+216>>2]=qf|0;t[iz+220>>2]=sx|0;t[J>>2]=Rg|0;t[J+8>>2]=Ff|0;t[J+16>>2]=Ce|0;t[J+24>>2]=Su|0;t[J+32>>2]=pw|0;t[J+40>>2]=Hv|0;t[J+48>>2]=iv|0;t[J+56>>2]=Mu|0;t[J+64>>2]=mu|0;t[J+72>>2]=Nt|0;t[J+80>>2]=ot|0;t[J+88>>2]=Os|0;t[J+96>>2]=ws|0;t[J+104>>2]=es|0;t[J+112>>2]=Gr|0;t[J+120>>2]=Zs|0;t[J+128>>2]=Vq|0;t[J+136>>2]=Hq|0;t[J+144>>2]=Sf|0;t[J+152>>2]=fq|0;t[J+160>>2]=Pp|0;t[J+168>>2]=em|0;t[J+176>>2]=as|0;t[J+184>>2]=Cf|0;t[J+192>>2]=im|0;t[J+200>>2]=po|0;t[J+208>>2]=Ue|0;t[J+216>>2]=Xn|0;t[J+224>>2]=gh|0;t[J+232>>2]=xn|0;t[J+240>>2]=cq|0;t[J+248>>2]=bn|0;t[J+256>>2]=Sm|0;t[J+264>>2]=ys|0;t[J+272>>2]=Uf|0;t[J+280>>2]=Zl|0;t[J+288>>2]=Ql|0;t[J+296>>2]=Hl|0;t[J+304>>2]=lx|0;t[J+312>>2]=ol|0;t[J+320>>2]=dl|0;t[J+328>>2]=Sk|0;t[J+336>>2]=Hk|0;t[J+344>>2]=vk|0;t[J+352>>2]=nx|0;t[J+360>>2]=Xj|0;t[J+368>>2]=Yf|0;t[J+376>>2]=Wh|0;t[J+384>>2]=Aw|0;t[J+392>>2]=Hh|0;t[J+400>>2]=pj|0;t[J+408>>2]=dj|0;t[J+416>>2]=Pg|0;t[J+424>>2]=Ki|0;t[J+432>>2]=wi|0;t[J+440>>2]=ki|0;t[J+448>>2]=Au|0;t[J+456>>2]=oo|0;t[J+464>>2]=Yh|0;t[J+472>>2]=If|0;t[J+480>>2]=wf|0;t[J+488>>2]=Fh|0;t[J+496>>2]=Ze|0;t[J+504>>2]=Eq|0;t[J+512>>2]=Bo|0;t[J+520>>2]=Wg|0;t[J+528>>2]=Sg|0;t[J+536>>2]=ye|0;t[jz>>2]=Ur|0;t[jz+4>>2]=lv|0;t[kz+8>>2]=Cf|0;t[kz+12>>2]=bo|0;t[kz+24>>2]=Fi|0;t[kz+28>>2]=Rv|0;t[kz+40>>2]=Bw|0;t[kz+44>>2]=sv|0;t[kz+56>>2]=Yl|0;t[kz+60>>2]=dq|0;t[kz+72>>2]=qf|0;t[kz+76>>2]=xp|0;t[kz+88>>2]=Em|0;t[kz+92>>2]=nm|0;t[lz>>2]=Cf|0;t[lz+8>>2]=Ln|0;t[lz+16>>2]=Oq|0;t[lz+24>>2]=Dj|0;t[lz+32>>2]=Ww|0;t[lz+40>>2]=Wj|0;t[lz+48>>2]=yk|0;t[lz+56>>2]=te|0;t[lz+64>>2]=bp|0;t[lz+72>>2]=ye|0;t[lz+80>>2]=Zs|0;t[lz+88>>2]=im|0;t[lz+96>>2]=ti|0;t[lz+104>>2]=ju|0;t[lz+112>>2]=Lp|0;t[lz+120>>2]=kt|0;t[lz+128>>2]=Ms|0;t[lz+136>>2]=Yf|0;t[lz+144>>2]=nx|0;t[lz+152>>2]=wi|0;t[lz+160>>2]=Fi|0;t[lz+168>>2]=Iq|0;t[lz+176>>2]=vq|0;t[lz+184>>2]=gq|0;t[lz+192>>2]=Qp|0;t[lz+200>>2]=yp|0;t[lz+208>>2]=kp|0;t[lz+216>>2]=Yo|0;t[mz>>2]=Xo|0;t[mz+4>>2]=vv|0;t[nz+8>>2]=Fi|0;t[nz+12>>2]=Rv|0;t[nz+24>>2]=Cf|0;t[nz+28>>2]=bo|0;t[nz+40>>2]=$p|0;t[nz+44>>2]=Ml|0;t[nz+56>>2]=qf|0;t[nz+60>>2]=We|0;t[nz+72>>2]=wl|0;t[nz+76>>2]=kl|0;t[zz>>2]=pp|0;t[zz+4>>2]=yv|0;t[zz+8>>2]=er|0;t[zz+12>>2]=no|0;t[Az+8>>2]=Zv|0;t[Az+12>>2]=Ie|0;t[Az+24>>2]=Cf|0;t[Az+28>>2]=bo|0;t[Az+40>>2]=Uf|0;t[Az+44>>2]=Rn|0;t[Az+56>>2]=Hh|0;t[Az+60>>2]=jv|0;t[Bz>>2]=Er|0;t[Cz+8>>2]=Fi|0;t[Cz+12>>2]=Rv|0;t[Cz+24>>2]=hq|0;t[Cz+28>>2]=Th|0;t[Cz+40>>2]=Gw|0;t[Cz+44>>2]=Nh|0;t[Dz>>2]=Ai|0;t[Dz+8>>2]=Uq|0;t[Dz+16>>2]=Tf|0;t[Dz+24>>2]=Ur|0;t[Dz+32>>2]=li|0;t[Dz+40>>2]=Xg|0;t[Dz+48>>2]=$j|0;t[Dz+56>>2]=Fi|0;t[Dz+64>>2]=dx|0;t[Dz+72>>2]=Vg|0;t[Dz+80>>2]=Iv|0;t[Dz+88>>2]=kv|0;t[Dz+96>>2]=Nu|0;t[Dz+104>>2]=ou|0;t[Dz+112>>2]=Qt|0;t[Dz+120>>2]=Zs|0;t[Dz+128>>2]=ti|0;t[Dz+136>>2]=Sv|0;t[Dz+144>>2]=Sf|0;t[Dz+152>>2]=Ir|0;t[Dz+160>>2]=lr|0;t[Dz+168>>2]=ce|0;t[Dz+176>>2]=em|0;t[Dz+184>>2]=Fl|0;t[Dz+192>>2]=hq|0;t[Dz+200>>2]=Gn|0;t[Dz+208>>2]=zp|0;t[Dz+216>>2]=im|0;t[Dz+224>>2]=Zo|0;t[Dz+232>>2]=Ho|0;t[Dz+240>>2]=qo|0;t[Dz+248>>2]=go|0;t[Dz+256>>2]=Yn|0;t[Dz+264>>2]=Mn|0;t[Dz+272>>2]=vm|0;t[Dz+280>>2]=nn|0;t[Dz+288>>2]=Gw|0;t[Dz+296>>2]=sl|0;t[Dz+304>>2]=Sj|0;t[Dz+312>>2]=pm|0;t[Dz+320>>2]=$l|0;t[Dz+328>>2]=Rl|0;t[Dz+336>>2]=gj|0;t[Dz+344>>2]=zl|0;t[Dz+352>>2]=pl|0;t[Dz+360>>2]=el|0;t[Dz+368>>2]=Tk|0;t[Dz+376>>2]=Ik|0;t[Dz+384>>2]=Wm|0;t[Dz+392>>2]=jk|0;t[Dz+400>>2]=Pg|0;t[Dz+408>>2]=Qj|0;t[Dz+416>>2]=Jj|0;t[Dz+424>>2]=If|0;t[Dz+432>>2]=Ol|0;t[Dz+440>>2]=qj|0;t[Dz+448>>2]=rk|0;t[Dz+456>>2]=df|0;t[Dz+464>>2]=Li|0;t[Dz+472>>2]=Fe|0;t[Dz+480>>2]=Vd|0;t[Ez>>2]=Zr|0;t[Ez+4>>2]=tf|0;t[Gz>>2]=ts|0;t[Hz+8>>2]=Fi|0;t[Hz+12>>2]=Rv|0;t[Hz+24>>2]=Le|0;t[Hz+28>>2]=gx|0;t[Hz+40>>2]=Iq|0;t[Hz+44>>2]=Jv|0;t[Iz>>2]=Tu|0;t[Jz+8>>2]=Fi|0;t[Jz+12>>2]=Rv|0;t[Jz+24>>2]=Zv|0;t[Jz+28>>2]=Ie|0;t[Jz+40>>2]=Gv|0;t[Jz+44>>2]=Fv|0;t[Jz+56>>2]=Jo|0;t[Jz+60>>2]=lo|0;t[Jz+72>>2]=eg|0;t[Jz+76>>2]=ds|0;t[Jz+88>>2]=wj|0;t[Jz+92>>2]=Av|0;t[Jz+104>>2]=cq|0;t[Jz+108>>2]=Ju|0;t[Jz+120>>2]=Gw|0;t[Jz+124>>2]=Nf|0;t[Jz+136>>2]=Bw|0;t[Jz+140>>2]=sv|0;t[Jz+152>>2]=wl|0;t[Jz+156>>2]=yu|0;t[Jz+168>>2]=Yl|0;t[Jz+172>>2]=dq|0;t[Jz+184>>2]=uq|0;t[Jz+188>>2]=lu|0;t[Jz+200>>2]=yn|0;t[Jz+204>>2]=fv|0;t[Kz>>2]=Tr|0;t[Kz+4>>2]=Qo|0;t[Kz+8>>2]=xm|0;t[Kz+12>>2]=qk|0;t[Kz+16>>2]=Ei|0;t[Kz+20>>2]=Sl|0;t[Kz+24>>2]=Vk|0;t[Kz+28>>2]=Al|0;t[Kz+32>>2]=mx|0;t[Kz+36>>2]=ql|0;t[Kz+40>>2]=fl|0;t[Pz>>2]=it|0;t[Pz+4>>2]=bw|0;t[Pz+8>>2]=Ar|0;t[Pz+12>>2]=Ao|0;t[Sz>>2]=Rw|0;t[Tz+8>>2]=Fi|0;t[Tz+12>>2]=Rv|0;t[Tz+24>>2]=Zv|0;t[Tz+28>>2]=Ie|0;t[Tz+40>>2]=Gv|0;t[Tz+44>>2]=Fv|0;t[Tz+56>>2]=Cf|0;t[Tz+60>>2]=yf|0;t[Tz+72>>2]=wj|0;t[Tz+76>>2]=Av|0;t[Tz+88>>2]=Gw|0;t[Tz+92>>2]=Nf|0;t[Tz+104>>2]=$p|0;t[Tz+108>>2]=uv|0;t[Tz+120>>2]=wl|0;t[Tz+124>>2]=yu|0;t[Tz+136>>2]=Ww|0;t[Tz+140>>2]=hv|0;t[Tz+152>>2]=uq|0;t[Tz+156>>2]=lu|0;t[Tz+168>>2]=yn|0;t[Tz+172>>2]=fv|0;t[Tz+184>>2]=Fh|0;t[Tz+188>>2]=nt|0;t[Tz+200>>2]=qf|0;t[Tz+204>>2]=kf|0;t[Tz+216>>2]=$u|0;t[Tz+220>>2]=lt|0;t[Wz>>2]=Ge|0;t[Xz+8>>2]=vh|0;t[Xz+12>>2]=oh|0;t[Xz+24>>2]=ag|0;t[Xz+28>>2]=Xe|0;t[Xz+40>>2]=qx|0;t[Xz+44>>2]=Dw|0;t[Xz+56>>2]=Bo|0;t[Xz+60>>2]=tv|0;t[Yz>>2]=ri|0;t[Yz+4>>2]=Pt|0;t[Yz+8>>2]=eq|0;t[Yz+12>>2]=wn|0;t[Zz+8>>2]=Rr|0;t[Zz+12>>2]=Kp|0;t[Zz+24>>2]=Cf|0;t[Zz+28>>2]=bo|0;t[Zz+40>>2]=cm|0;t[Zz+44>>2]=Vo|0;t[Zz+56>>2]=wf|0;t[Zz+60>>2]=Tt|0;t[Zz+72>>2]=qf|0;t[Zz+76>>2]=We|0;t[Zz+88>>2]=wj|0;t[Zz+92>>2]=To|0;t[$z>>2]=Aj|0;t[$z+4>>2]=gu|0;t[$z+8>>2]=tq|0;t[aA+8>>2]=Cf|0;t[aA+12>>2]=bo|0;t[bA>>2]=Dn|0;t[bA+4>>2]=dv|0;t[cA+8>>2]=Rr|0;t[cA+12>>2]=Kp|0;t[cA+24>>2]=Fi|0;t[cA+28>>2]=Rv|0;t[cA+40>>2]=Cf|0;t[cA+44>>2]=bo|0;t[cA+56>>2]=oo|0;t[cA+60>>2]=eo|0;t[cA+72>>2]=qf|0;t[cA+76>>2]=We|0;t[dA>>2]=zm|0;t[dA+4>>2]=lk|0;t[dA+8>>2]=zi|0;t[dA+12>>2]=eh|0;t[eA>>2]=uh|0;t[eA+4>>2]=$s|0;t[eA+8>>2]=qp|0;t[eA+12>>2]=Ro|0;t[fA+8>>2]=zr|0;t[fA+12>>2]=So|0;t[fA+24>>2]=cm|0;t[fA+28>>2]=Vo|0;t[fA+40>>2]=Zv|0;t[fA+44>>2]=Iu|0;t[fA+56>>2]=wf|0;t[fA+60>>2]=Tn|0;t[gA>>2]=af|0;t[gA+8>>2]=vx|0;t[gA+16>>2]=Jw|0;t[gA+24>>2]=Sf|0;t[gA+32>>2]=wv|0;t[gA+40>>2]=Yu|0;t[gA+48>>2]=zu|0;t[gA+56>>2]=cm|0;t[gA+64>>2]=Zv|0;t[gA+72>>2]=Rs|0;t[gA+80>>2]=mg|0;t[gA+88>>2]=ok|0;t[gA+96>>2]=Hh|0;t[gA+104>>2]=rv|0;t[gA+112>>2]=Ad|0;t[gA+120>>2]=uq|0;t[hA>>2]=xx|0;function L(b){return b in{32:0,9:0,10:0,11:0,12:0,13:0}}function mA(b,d){b--;do{b++;var c=l[b];if(c==d){return b}}while(c);return 0}function N(b,d,c){for(var e=0;e<c;){var f=$a[b+e],g=$a[d+e];if(f==g&&0==f){break}if(0==f){return-1}if(0==g){return 1}if(f==g){e++}else{return f>g?1:-1}}return 0}function nA(b){return 97<=b&&122>=b?b-97+65:b}function oA(b){return 48<=b&&57>=b||97<=b&&122>=b||65<=b&&90>=b}function pA(b){return 97<=b&&122>=b||65<=b&&90>=b}function qA(b,d){return N(b,d,Aa)}function rA(b){return 65<=b&&90>=b?b-65+97:b}function sA(b,d,c){for(var e=0;e<c;){var f=rA($a[b+e]),g=rA($a[d+e]);if(f==g&&0==f){break}if(0==f){return-1}if(0==g){return 1}if(f==g){e++}else{return f>g?1:-1}}return 0}function tA(b,d){var c=0,e;do{c||(e=b,c=d);var f=l[b++],g=l[c++];if(0==g){return e}g!=f&&(b=e+1,c=0)}while(f);return 0}var uA=13,vA=9,wA=17,xA=22,yA=5,zA=21,AA=2,BA=6,CA=32,DA=34,EA=29;function FA(b){GA||(GA=y([0],"i32",x));t[GA>>2]=b}var GA,HA=0;Wb=Ob=0;var IA=2,JA=[da],KA=ca;function LA(b,d){if("string"!==typeof b){return da}d===ba&&(d="/");b&&"/"==b[0]&&(d="");for(var c=(d+"/"+b).split("/").reverse(),e=[""];c.length;){var f=c.pop();""==f||"."==f||(".."==f?1<e.length&&e.pop():e.push(f))}return 1==e.length?"/":e.join("/")}function MA(b,d,c){var e={J:fa,s:fa,error:0,name:da,path:da,object:da,v:fa,w:da,o:da},b=LA(b);if("/"==b){e.J=ca,e.s=e.v=ca,e.name="/",e.path=e.w="/",e.object=e.o=NA}else{if(b!==da){for(var c=c||0,b=b.slice(1).split("/"),f=NA,g=[""];b.length;){1==b.length&&f.d&&(e.v=ca,e.w=1==g.length?"/":g.join("/"),e.o=f,e.name=b[0]);var h=b.shift();if(f.d){if(f.q){if(!f.a.hasOwnProperty(h)){e.error=AA;break}}else{e.error=uA;break}}else{e.error=20;break}f=f.a[h];if(f.link&&!(d&&0==b.length)){if(40<c){e.error=40;break}e=LA(f.link,g.join("/"));e=MA([e].concat(b).join("/"),d,c+1);break}g.push(h);0==b.length&&(e.s=ca,e.path=g.join("/"),e.object=f)}}}return e}function OA(b,d){PA();var c=MA(b,d);if(c.s){return c.object}FA(c.error);return da}function QA(b,d,c,e,f){b||(b="/");"string"===typeof b&&(b=OA(b));b||(FA(uA),aa(Error("Parent path must exist.")));b.d||(FA(20),aa(Error("Parent must be a folder.")));!b.write&&!KA&&(FA(uA),aa(Error("Parent folder must be writeable.")));if(!d||"."==d||".."==d){FA(AA),aa(Error("Name must not be empty."))}
b.a[d]={q:e===ba?ca:e,write:f===ba?fa:f,timestamp:Date.now(),u:IA++};for(var g in c){c.hasOwnProperty(g)&&(b.a[d][g]=c[g])}return b.a[d]}function RA(b,d,c,e){return QA(b,d,{d:ca,b:fa,a:{}},c,e)}function SA(b,d,c,e){b=OA(b);b===da&&aa(Error("Invalid parent."));for(d=d.split("/").reverse();d.length;){var f=d.pop();f&&(b.a.hasOwnProperty(f)||RA(b,f,c,e),b=b.a[f])}return b}function TA(b,d,c,e,f){c.d=fa;return QA(b,d,c,e,f)}function UA(b,d,c,e,f){if("string"===typeof c){for(var g=Array(c.length),h=0,i=c.length;h<i;++h){g[h]=c.charCodeAt(h)}c=g}c={b:fa,a:c.subarray?c.subarray(0):c};return TA(b,d,c,e,f)}function VA(b,d,c,e,f,g,h,i){function m(b){return{jpg:"image/jpeg",png:"image/png",bmp:"image/bmp",ogg:"audio/ogg",wav:"audio/wav",mp3:"audio/mpeg"}[b.substr(-3)]}function n(c){function m(c){i||UA(b,d,c,e,f);g&&g();Gb("cp "+p)}var n=fa;a.preloadPlugins.forEach((function(b){!n&&b.canHandle(p)&&(b.handle(c,p,m,(function(){h&&h();Gb("cp "+p)})),n=ca)}));n||m(c)}if(!WA){WA=ca;try{new Blob,XA=ca}catch(q){XA=fa,console.log("warning: no blob constructor, cannot create blobs with mimetypes")}YA="undefined"!=typeof MozBlobBuilder?MozBlobBuilder:"undefined"!=typeof WebKitBlobBuilder?WebKitBlobBuilder:!XA?console.log("warning: no BlobBuilder"):da;ZA="undefined"!=typeof window?window.URL?window.URL:window.webkitURL:console.log("warning: cannot create object URLs");a.preloadPlugins||(a.preloadPlugins=[]);a.preloadPlugins.push({canHandle:(function(b){return b.substr(-4)in{".jpg":1,".png":1,".bmp":1}}),handle:(function(b,c,d,e){var f=da;if(XA){try{f=new Blob([b],{type:m(c)})}catch(g){var h="Blob constructor present but fails: "+g+"; falling back to blob builder";va||(va={});va[h]||(va[h]=1,a.h(h))}}f||(f=new YA,f.append((new Uint8Array(b)).buffer),f=f.getBlob());var i=ZA.createObjectURL(f);ua("string"==typeof i,"createObjectURL must return a url as a string");var n=new Image;n.onload=(function(){ua(n.complete,"Image "+c+" could not be decoded");var e=document.createElement("canvas");e.width=n.width;e.height=n.height;e.getContext("2d").drawImage(n,0,0);a.preloadedImages[c]=e;ZA.revokeObjectURL(i);d&&d(b)});n.onerror=(function(){console.log("Image "+i+" could not be decoded");e&&e()});n.src=i})});a.preloadPlugins.push({canHandle:(function(b){return b.substr(-4)in{".ogg":1,".wav":1,".mp3":1}}),handle:(function(b,c,d,e){function f(e){h||(h=ca,a.preloadedAudios[c]=e,d&&d(b))}function g(){h||(h=ca,a.preloadedAudios[c]=new Audio,e&&e())}var h=fa;if(XA){try{var i=new Blob([b],{type:m(c)})}catch(n){return g()}i=ZA.createObjectURL(i);ua("string"==typeof i,"createObjectURL must return a url as a string");var p=new Audio;p.addEventListener("canplaythrough",(function(){f(p)}),fa);p.onerror=(function(){if(!h){console.log("warning: browser could not fully decode audio "+c+", trying slower base64 approach");for(var d="",e=0,g=0,i=0;i<b.length;i++){e=e<<8|b[i];for(g+=8;6<=g;){var m=e>>g-6&63,g=g-6,d=d+"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[m]}}2==g?(d+="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(e&3)<<4],d+="=="):4==g&&(d+="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(e&15)<<2],d+="=");p.src="data:audio/x-"+c.substr(-3)+";base64,"+d;f(p)}});p.src=i;setTimeout((function(){f(p)}),1e4)}else{return g()}})})}for(var p,s=[b,d],r=s[0],u=1;u<s.length;u++){"/"!=r[r.length-1]&&(r+="/"),r+=s[u]}"/"==r[0]&&(r=r.substr(1));p=r;Cb("cp "+p);if("string"==typeof c){var v=h,w=(function(){v?v():aa('Loading data file "'+c+'" failed.')}),C=new XMLHttpRequest;C.open("GET",c,ca);C.responseType="arraybuffer";C.onload=(function(){if(200==C.status){var b=C.response;ua(b,'Loading data file "'+c+'" failed (no arrayBuffer).');b=new Uint8Array(b);n(b);Gb("al "+c)}else{w()}});C.onerror=w;C.send(da);Cb("al "+c)}else{n(c)}}function $A(b,d,c,e){!c&&!e&&aa(Error("A device must have at least one callback defined."));return TA(b,d,{b:ca,input:c,k:e},Boolean(c),Boolean(e))}function aB(b){if(b.b||b.d||b.link||b.a){return ca}var d=ca;"undefined"!==typeof XMLHttpRequest&&aa(Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread."));if(a.read){try{b.a=lb(a.read(b.url),ca)}catch(c){d=fa}}else{aa(Error("Cannot load without read() or XMLHttpRequest."))}d||FA(yA);return d}function PA(){NA||(NA={q:ca,write:ca,d:ca,b:fa,timestamp:Date.now(),u:1,a:{}})}var bB,NA;function cB(b){return Number(JA[b]&&JA[b].c)}function dB(b,d){aa({f:ca,id:t[b>>2],value:d||1})}function eB(b,d){function c(b){var c;"double"===b?c=(Ua[0]=t[d+f>>2],Ua[1]=t[d+(f+4)>>2],Ta[0]):"i64"==b?c=[t[d+f>>2],t[d+(f+4)>>2]]:(b="i32",c=t[d+f>>2]);f+=Math.max(sa(b),ta);return c}for(var e=b,f=0,g=[],h,i;;){var m=e;h=l[e];if(0===h){break}i=l[e+1];if(37==h){var n=fa,q=fa,p=fa,s=fa;a:for(;;){switch(i){case 43:n=ca;break;case 45:q=ca;break;case 35:p=ca;break;case 48:if(s){break a}else{s=ca;break};default:break a}e++;i=l[e+1]}var r=0;if(42==i){r=c("i32"),e++,i=l[e+1]}else{for(;48<=i&&57>=i;){r=10*r+(i-48),e++,i=l[e+1]}}var u=fa;if(46==i){var v=0,u=ca;e++;i=l[e+1];if(42==i){v=c("i32"),e++}else{for(;;){i=l[e+1];if(48>i||57<i){break}v=10*v+(i-48);e++}}i=l[e+1]}else{v=6}var w;switch(String.fromCharCode(i)){case"h":i=l[e+2];104==i?(e++,w=1):w=2;break;case"l":i=l[e+2];108==i?(e++,w=8):w=4;break;case"L":;case"q":;case"j":w=8;break;case"z":;case"t":;case"I":w=4;break;default:w=da}w&&e++;i=l[e+1];if(-1!="diuoxXp".split("").indexOf(String.fromCharCode(i))){m=100==i||105==i;w=w||4;var C=h=c("i"+8*w),A;8==w&&(h=117==i?(h[0]>>>0)+4294967296*(h[1]>>>0):(h[0]>>>0)+4294967296*(h[1]|0));4>=w&&(h=(m?vb:ub)(h&Math.pow(256,w)-1,8*w));var I=Math.abs(h),m="";if(100==i||105==i){A=8==w&&fB?fB.stringify(C[0],C[1],da):vb(h,8*w).toString(10)}else{if(117==i){A=8==w&&fB?fB.stringify(C[0],C[1],ca):ub(h,8*w).toString(10),h=Math.abs(h)}else{if(111==i){A=(p?"0":"")+I.toString(8)}else{if(120==i||88==i){m=p?"0x":"";if(8==w&&fB){A=(C[1]>>>0).toString(16)+(C[0]>>>0).toString(16)}else{if(0>h){h=-h;A=(I-1).toString(16);C=[];for(p=0;p<A.length;p++){C.push((15-parseInt(A[p],16)).toString(16))}for(A=C.join("");A.length<2*w;){A="f"+A}}else{A=I.toString(16)}}88==i&&(m=m.toUpperCase(),A=A.toUpperCase())}else{112==i&&(0===I?A="(nil)":(m="0x",A=I.toString(16)))}}}}if(u){for(;A.length<v;){A="0"+A}}for(n&&(m=0>h?"-"+m:"+"+m);m.length+A.length<r;){q?A+=" ":s?A="0"+A:m=" "+m}A=m+A;A.split("").forEach((function(b){g.push(b.charCodeAt(0))}))}else{if(-1!="fFeEgG".split("").indexOf(String.fromCharCode(i))){h=c("double");if(isNaN(h)){A="nan",s=fa}else{if(isFinite(h)){u=fa;w=Math.min(v,20);if(103==i||71==i){u=ca,v=v||1,w=parseInt(h.toExponential(w).split("e")[1],10),v>w&&-4<=w?(i=(103==i?"f":"F").charCodeAt(0),v-=w+1):(i=(103==i?"e":"E").charCodeAt(0),v--),w=Math.min(v,20)}if(101==i||69==i){A=h.toExponential(w),/[eE][-+]\d$/.test(A)&&(A=A.slice(0,-1)+"0"+A.slice(-1))}else{if(102==i||70==i){A=h.toFixed(w)}}m=A.split("e");if(u&&!p){for(;1<m[0].length&&-1!=m[0].indexOf(".")&&("0"==m[0].slice(-1)||"."==m[0].slice(-1));){m[0]=m[0].slice(0,-1)}}else{for(p&&-1==A.indexOf(".")&&(m[0]+=".");v>w++;){m[0]+="0"}}A=m[0]+(1<m.length?"e"+m[1]:"");69==i&&(A=A.toUpperCase());n&&0<=h&&(A="+"+A)}else{A=(0>h?"-":"")+"inf",s=fa}}for(;A.length<r;){A=q?A+" ":s&&("-"==A[0]||"+"==A[0])?A[0]+"0"+A.slice(1):(s?"0":" ")+A}97>i&&(A=A.toUpperCase());A.split("").forEach((function(b){g.push(b.charCodeAt(0))}))}else{if(115==i){n=c("i8*")||mb;s=tb(n);u&&(s=Math.min(s,v));if(!q){for(;s<r--;){g.push(32)}}for(p=0;p<s;p++){g.push($a[n++])}if(q){for(;s<r--;){g.push(32)}}}else{if(99==i){for(q&&g.push(c("i8"));0<--r;){g.push(32)}q||g.push(c("i8"))}else{if(110==i){q=c("i32*"),t[q>>2]=g.length}else{if(37==i){g.push(h)}else{for(p=m;p<e+2;p++){g.push(l[p])}}}}}}}e+=2}else{g.push(h),e+=1}}return g}function gB(b,d){var c=b+tb(b);do{if(l[c]==d){return c}c--}while(c>=b);return 0}function hB(b,d,c){if(20<=c&&d%2==b%2){if(d%4==b%4){for(c=d+c;d%4;){l[b++]=l[d++]}for(var d=d>>2,b=b>>2,e=c>>2;d<e;){t[b++]=t[d++]}d<<=2;for(b<<=2;d<c;){l[b++]=l[d++]}}else{c=d+c;d%2&&(l[b++]=l[d++]);d>>=1;b>>=1;for(e=c>>1;d<e;){Pa[b++]=Pa[d++]}d<<=1;b<<=1;d<c&&(l[b++]=l[d++])}}else{for(;c--;){l[b++]=l[d++]}}}function iB(b,d,c){for(var e=fa,f,g=0;g<c;g++){f=e?0:l[d+g],l[b+g]=f,e=e||0==l[d+g]}}function jB(b){var d=tb(b),c=Xa(d+1);hB(c,b,d);l[c+d]=0;return c}function kB(b,d,c){var e=JA[b];if(e){if(e.j){if(0>c){return FA(xA),-1}if(e.object.b){if(e.object.k){for(var f=0;f<c;f++){try{e.object.k(l[d+f])}catch(g){return FA(yA),-1}}e.object.timestamp=Date.now();return f}FA(BA);return-1}f=e.position;b=JA[b];if(!b||b.object.b){FA(vA),d=-1}else{if(b.j){if(b.object.d){FA(zA),d=-1}else{if(0>c||0>f){FA(xA),d=-1}else{for(var h=b.object.a;h.length<f;){h.push(0)}for(var i=0;i<c;i++){h[f+i]=$a[d+i]}b.object.timestamp=Date.now();d=i}}}else{FA(uA),d=-1}}-1!=d&&(e.position+=d);return d}FA(uA);return-1}FA(vA);return-1}function lB(b,d,c){var e=eB(d,c),d=j;c=y(e,"i8",Va);e=1*e.length;0==e?b=0:(c=kB(b,c,e),-1==c?(JA[b]&&(JA[b].error=ca),b=0):b=Math.floor(c/1));j=d;return b}function mB(b,d){return lB(t[Ob>>2],b,d)}function nB(b,d){JA[b]?(b=JA[b],b.object.b?FA(EA):(t[d>>2]=b.position,t[d+4>>2]=(b.c?1:0)+(b.error?2:0))):FA(vA)}function oB(b,d){if(JA[b]){if(JA[b].object.b){FA(CA)}else{JA[b].position=t[d>>2];var c=t[d+4>>2];JA[b].c=Boolean(c&1);JA[b].error=Boolean(c&2)}}else{FA(vA)}}function pB(b,d){var c=ub(b&255);l[pB.l]=c;return-1==kB(d,pB.l,1)?(JA[d]&&(JA[d].error=ca),-1):c}var qB=pB,rB=da;function sB(b,d){var c=y([511,0,0,0],"i32",Va),e=t[c>>2],c=d&3,f=0!=c,g=1!=c,h=Boolean(d&512),i=Boolean(d&2048),m=Boolean(d&1024),n=Boolean(d&8),b=MA(Na(b));if(!b.v){return FA(b.error),-1}if(c=b.object||da){if(h&&i){return FA(wA),-1}if((f||h||m)&&c.d){return FA(zA),-1}if(g&&!c.q||f&&!c.write){return FA(uA),-1}if(m&&!c.b){c.a=[]}else{if(!aB(c)){return FA(yA),-1}}e=b.path}else{if(!h){return FA(AA),-1}if(!b.o.write){return FA(uA),-1}c=UA(b.o,b.name,[],e&256,e&128);e=b.w+"/"+b.name}h=JA.length;if(c.d){f=0;rB&&(f=Xa(rB.R));var g=[],q;for(q in c.a){g.push(q)}JA[h]={path:e,object:c,position:-2,i:ca,j:fa,n:fa,error:fa,c:fa,e:[],a:g,A:f}}else{JA[h]={path:e,object:c,position:0,i:g,j:f,n:n,error:fa,c:fa,e:[]}}return h}function tB(b,d){var c,d=Na(d);if("r"==d[0]){c=-1!=d.indexOf("+")?2:0}else{if("w"==d[0]){c=-1!=d.indexOf("+")?2:1,c|=1536}else{if("a"==d[0]){c=-1!=d.indexOf("+")?2:1,c|=512,c|=8}else{return FA(xA),0}}}c=sB(b,c);return-1==c?0:c}function uB(b){JA[b]||FA(vA);JA[b]?(JA[b].A&&vB(JA[b].A),JA[b]=da):FA(vA)}var wB=mB;function Ya(b,d){var c=0;if(20<=d){for(var e=b+d;b%4;){l[b++]=c}0>c&&(c+=256);for(var f=b>>2,g=e>>2,h=c|c<<8|c<<16|c<<24;f<g;){t[f++]=h}for(b=f<<2;b<e;){l[b++]=c}}else{for(;d--;){l[b++]=c}}}var xB=lB,yB={1:"Operation not permitted",2:"No such file or directory",3:"No such process",4:"Interrupted system call",5:"Input/output error",6:"No such device or address",8:"Exec format error",9:"Bad file descriptor",10:"No child processes",11:"Resource temporarily unavailable",12:"Cannot allocate memory",13:"Permission denied",14:"Bad address",16:"Device or resource busy",17:"File exists",18:"Invalid cross-device link",19:"No such device",20:"Not a directory",21:"Is a directory",22:"Invalid argument",23:"Too many open files in system",24:"Too many open files",25:"Inappropriate ioctl for device",26:"Text file busy",27:"File too large",28:"No space left on device",29:"Illegal seek",30:"Read-only file system",31:"Too many links",32:"Broken pipe",33:"Numerical argument out of domain",34:"Numerical result out of range",35:"Resource deadlock avoided",36:"File name too long",37:"No locks available",38:"Function not implemented",39:"Directory not empty",40:"Too many levels of symbolic links",42:"No message of desired type",43:"Identifier removed",60:"Device not a stream",61:"No data available",62:"Timer expired",63:"Out of streams resources",67:"Link has been severed",71:"Protocol error",72:"Multihop attempted",74:"Bad message",75:"Value too large for defined data type",84:"Invalid or incomplete multibyte or wide character",88:"Socket operation on non-socket",89:"Destination address required",90:"Message too long",91:"Protocol wrong type for socket",92:"Protocol not available",93:"Protocol not supported",95:"Operation not supported",97:"Address family not supported by protocol",98:"Address already in use",99:"Cannot assign requested address",100:"Network is down",101:"Network is unreachable",102:"Network dropped connection on reset",103:"Software caused connection abort",104:"Connection reset by peer",105:"No buffer space available",106:"Transport endpoint is already connected",107:"Transport endpoint is not connected",110:"Connection timed out",111:"Connection refused",113:"No route to host",114:"Operation already in progress",115:"Operation now in progress",116:"Stale NFS file handle",122:"Disk quota exceeded",125:"Operation canceled",130:"Owner died",131:"State not recoverable"},zB;function AB(b,d){var c=0;do{l[b+c]=l[d+c],c++}while(0!=l[d+(c-1)])}var BB=0,CB=4,DB=8,EB=12,FB=16,GB=20,HB=24,IB=28,JB=32,KB=40,LB=48,MB=56,NB=60,OB={};function PB(b,d,c){b=OA(Na(b),c);if(b===da||!aB(b)){return-1}t[d+EB>>2]=1;t[d+FB>>2]=0;t[d+GB>>2]=0;t[d+MB>>2]=4096;t[d+CB>>2]=b.u;c=Math.floor(b.timestamp/1e3);if(JB===ba){JB=OB.O.F;KB=OB.Q.F;LB=OB.P.F;var e=1e3*(b.timestamp%1e3);t[d+OB.O.D>>2]=e;t[d+OB.Q.D>>2]=e;t[d+OB.P.D>>2]=e}t[d+JB>>2]=c;t[d+KB>>2]=c;t[d+LB>>2]=c;var f=0,g=c=0,h=e=0;b.b?(e=h=b.u,c=g=0,f=8192):(e=1,h=0,b.d?(c=4096,g=1,f=16384):(f=b.a||b.link,c=f.length,g=Math.ceil(f.length/4096),f=b.link===ba?32768:40960));t[d+BB>>2]=e;t[d+HB>>2]=h;t[d+IB>>2]=c;t[d+NB>>2]=g;b.q&&(f|=365);b.write&&(f|=146);t[d+DB>>2]=f;return 0}var QB=da,RB=da,SB={};function TB(b){for(var d="",c=0,e;e=$a[b+c];){d+=String.fromCharCode(e),c++}return d}function UB(b,d,c,e){var f=JA[b];if(!f||f.object.b){return FA(vA),-1}if(f.i){if(f.object.d){return FA(zA),-1}if(0>c||0>e){return FA(xA),-1}for(b=0;f.e.length&&0<c;){l[d++]=f.e.pop(),c--,b++}f=f.object.a;c=Math.min(f.length-e,c);if(f.subarray||f.slice){for(var g=0;g<c;g++){l[d+g]=f[e+g]}}else{for(g=0;g<c;g++){l[d+g]=f.get(e+g)}}return b+c}FA(uA);return-1}function VB(b){var d=WB.l,c=1,e=JA[b];if(e){if(e.i){if(0>c){return FA(xA),-1}if(e.object.b){if(e.object.input){for(b=0;e.e.length&&0<c;){l[d++]=e.e.pop(),c--,b++}for(var f=0;f<c;f++){try{var g=e.object.input()}catch(h){return FA(yA),-1}if(g===da||g===ba){break}b++;l[d+f]=g}return b}FA(BA);return-1}g=e.e.length;b=UB(b,d,c,e.position);-1!=b&&(e.position+=e.e.length-g+b);return b}FA(uA);return-1}FA(vA);return-1}function WB(b){if(!JA[b]){return-1}var d=JA[b];if(d.c||d.error){return-1}b=VB(b);return 0==b?(d.c=ca,-1):-1==b?(d.error=ca,-1):$a[WB.l]}var XB=WB;function YB(b){var d=t[K+16>>2];JA[d]&&(b=ub(b&255),JA[d].e.push(b))}function O(){aa("abort() at "+Error().stack)}function ZB(){switch(8){case 8:return cb;case 54:;case 56:;case 21:;case 61:;case 63:;case 22:;case 67:;case 23:;case 24:;case 25:;case 26:;case 27:;case 69:;case 28:;case 101:;case 70:;case 71:;case 29:;case 30:;case 199:;case 75:;case 76:;case 32:;case 43:;case 44:;case 80:;case 46:;case 47:;case 45:;case 48:;case 49:;case 42:;case 82:;case 33:;case 7:;case 108:;case 109:;case 107:;case 112:;case 119:;case 121:return 200809;case 13:;case 104:;case 94:;case 95:;case 34:;case 35:;case 77:;case 81:;case 83:;case 84:;case 85:;case 86:;case 87:;case 88:;case 89:;case 90:;case 91:;case 94:;case 95:;case 110:;case 111:;case 113:;case 114:;case 115:;case 116:;case 117:;case 118:;case 120:;case 40:;case 16:;case 79:;case 19:return-1;case 92:;case 93:;case 5:;case 72:;case 6:;case 74:;case 92:;case 93:;case 96:;case 97:;case 98:;case 99:;case 102:;case 103:;case 105:return 1;case 38:;case 66:;case 50:;case 51:;case 4:return 1024;case 15:;case 64:;case 41:return 32;case 55:;case 37:;case 17:return 2147483647;case 18:;case 1:return 47839;case 59:;case 57:return 99;case 68:;case 58:return 2048;case 0:return 2097152;case 3:return 65536;case 14:return 32768;case 73:return 32767;case 39:return 16384;case 60:return 1e3;case 106:return 700;case 52:return 256;case 62:return 255;case 2:return 100;case 65:return 64;case 36:return 20;case 100:return 16;case 20:return 6;case 53:return 4}FA(xA);return-1}function $B(b){aC||(za=za+4095>>12<<12,aC=ca);var d=za;0!=b&&ya(b);return d}var aC;function bC(b,d,c){for(var d=ub(d),e=0;e<c;e++){if(l[b]==d){return b}b++}return 0}var cC=fa,WA,XA,YA,ZA;pb.unshift({t:(function(){if(!a.noFSInit&&!bB){var b,d,c,e=(function(b){b===da||10===b?(d.p(d.buffer.join("")),d.buffer=[]):d.buffer.push(i.C(b))});ua(!bB,"FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)");bB=ca;PA();b=b||a.stdin;d=d||a.stdout;c=c||a.stderr;var f=ca,g=ca,h=ca;b||(f=fa,b=(function(){if(!b.r||!b.r.length){var c;"undefined"!=typeof window&&"function"==typeof window.prompt?(c=window.prompt("Input: "),c===da&&(c=String.fromCharCode(0))):"function"==typeof readline&&(c=readline());c||(c="");b.r=lb(c+"\n",ca)}return b.r.shift()}));var i=new wa;d||(g=fa,d=e);d.p||(d.p=a.print);d.buffer||(d.buffer=[]);c||(h=fa,c=e);c.p||(c.p=a.print);c.buffer||(c.buffer=[]);try{RA("/","tmp",ca,ca)}catch(m){}var e=RA("/","dev",ca,ca),n=$A(e,"stdin",b),q=$A(e,"stdout",da,d);c=$A(e,"stderr",da,c);$A(e,"tty",b,d);JA[1]={path:"/dev/stdin",object:n,position:0,i:ca,j:fa,n:fa,B:!f,error:fa,c:fa,e:[]};JA[2]={path:"/dev/stdout",object:q,position:0,i:fa,j:ca,n:fa,B:!g,error:fa,c:fa,e:[]};JA[3]={path:"/dev/stderr",object:c,position:0,i:fa,j:ca,n:fa,B:!h,error:fa,c:fa,e:[]};HA=y([1],"void*",Va);Ob=y([2],"void*",Va);Wb=y([3],"void*",Va);SA("/","dev/shm/tmp",ca,ca);for(f=JA.length;f<Math.max(HA,Ob,Wb)+4;f++){JA[f]=da}JA[HA]=JA[1];JA[Ob]=JA[2];JA[Wb]=JA[3];y([y([0,0,0,0,HA,0,0,0,Ob,0,0,0,Wb,0,0,0],"void*",x)],"void*",x)}})});qb.push({t:(function(){KA=fa})});rb.push({t:(function(){bB&&(JA[2]&&0<JA[2].object.k.buffer.length&&JA[2].object.k(10),JA[3]&&0<JA[3].object.k.buffer.length&&JA[3].object.k(10))})});a.FS_createFolder=RA;a.FS_createPath=SA;a.FS_createDataFile=UA;a.FS_createPreloadedFile=VA;a.FS_createLazyFile=(function(b,d,c,e,f){if("undefined"!==typeof XMLHttpRequest){ma||aa("Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc");var g=(function(b,c){this.length=c;this.z=b;this.m=[]});g.prototype.get=(function(b){if(!(b>this.length-1||0>b)){var c=b%n;return this.I(Math.floor(b/n))[c]}});g.prototype.N=(function(b){this.I=b});var h=new XMLHttpRequest;h.open("HEAD",c,fa);h.send(da);200<=h.status&&300>h.status||304===h.status||aa(Error("Couldn't load "+c+". Status: "+h.status));var i=Number(h.getResponseHeader("Content-length")),m,n=1048576;if(!((m=h.getResponseHeader("Accept-Ranges"))&&"bytes"===m)){n=i}var q=new g(n,i);q.N((function(b){var d=b*q.z,e=(b+1)*q.z-1,e=Math.min(e,i-1);if("undefined"===typeof q.m[b]){var f=q.m;d>e&&aa(Error("invalid range ("+d+", "+e+") or no bytes requested!"));e>i-1&&aa(Error("only "+i+" bytes available! programmer error!"));var g=new XMLHttpRequest;g.open("GET",c,fa);i!==n&&g.setRequestHeader("Range","bytes="+d+"-"+e);"undefined"!=typeof Uint8Array&&(g.responseType="arraybuffer");g.overrideMimeType&&g.overrideMimeType("text/plain; charset=x-user-defined");g.send(da);200<=g.status&&300>g.status||304===g.status||aa(Error("Couldn't load "+c+". Status: "+g.status));d=g.response!==ba?new Uint8Array(g.response||[]):lb(g.responseText||"",ca);f[b]=d}"undefined"===typeof q.m[b]&&aa(Error("doXHR failed!"));return q.m[b]}));g={b:fa,a:q}}else{g={b:fa,url:c}}return TA(b,d,g,e,f)});a.FS_createLink=(function(b,d,c,e,f){return TA(b,d,{b:fa,link:c},e,f)});a.FS_createDevice=$A;FA(0);pB.l=y([0],"i8",x);a.CTags_getLanguage=(function(b){b=y(lb(b),"i8",Va);b=a._getLanguage(b);return Na(b)});a.CTags_parseFile=(function(b){a.FS_createPath("/",b.substr(0,b.lastIndexOf("/")),ca,ca);b=y(lb(b),"i8",Va);a._parseURL(b)});a.CTags_setOnParsingCompleted=(function(b){RB=b});a.CTags_setOnTagEntry=(function(b){QB=b});WB.l=y([0],"i8",x);a.requestFullScreen=(function(){function b(){}function d(){var b=fa;if((document.webkitFullScreenElement||document.webkitFullscreenElement||document.mozFullScreenElement||document.mozFullscreenElement||document.fullScreenElement||document.fullscreenElement)===c){c.M=c.requestPointerLock||c.mozRequestPointerLock||c.webkitRequestPointerLock,c.M(),b=ca}if(a.onFullScreen){a.onFullScreen(b)}}var c=a.canvas;document.addEventListener("fullscreenchange",d,fa);document.addEventListener("mozfullscreenchange",d,fa);document.addEventListener("webkitfullscreenchange",d,fa);document.addEventListener("pointerlockchange",b,fa);document.addEventListener("mozpointerlockchange",b,fa);document.addEventListener("webkitpointerlockchange",b,fa);c.L=c.requestFullScreen||c.mozRequestFullScreen||(c.webkitRequestFullScreen?(function(){c.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT)}):da);c.L()});a.requestAnimationFrame=(function(b){window.requestAnimationFrame||(window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame||window.oRequestAnimationFrame||window.setTimeout);window.requestAnimationFrame(b)});a.pauseMainLoop=(function(){});a.resumeMainLoop=(function(){cC&&(cC=fa,da())});function dC(){var b=P(),d=P(),c=eC();if(0!=(c|0)){for(var e=b|0,f=0,g=c;;){var c=0==(L(l[g]&255)|0)&1,h=l[g],h=0==h<<24>>24?1:0==(bC(Dq|0,h&255,4)|0),i=0==(N(g,oq|0,2)|0),m=i?1:f,i=i?g+2|0:g,n=0==(m|0);a:do{if(n){g=i}else{for(f=i;0!=(N(f,Wp|0,2)|0);){if(f=f+1|0,0==l[f]<<24>>24){g=f;f=m;break a}}g=f+2|0}f=0}while(0);h&=0==(f|0);a:do{if(h){if(i=l[g],35==i<<24>>24){fC(g+1|0)}else{for(m=g;;){n=m+1|0;if(0==(L(i&255)|0)){break}m=n;i=l[n]}i=gC(m,b);0==(t[e>>2]|0)?m=c:(m=(n=58==l[i]<<24>>24)?1:c,i=n?i+1|0:i);do{if(0==(L(l[i]&255)|0)){if(0==l[i]<<24>>24){n=i}else{break a}}else{n=i}}while(0);for(;0!=(L(l[n]&255)|0);){n=n+1|0}i=hC(n,d);if(0==(t[e>>2]|0)){for(;0!=(L(l[i]&255)|0);){i=i+1|0}gC(i,b);var q=1}else{q=0}var i=b,n=d,p=j;j+=4;if(0!=(t[i>>2]|0)){var s=iC(n,p);0!=(t[p>>2]|0)?-1!=(s|0)&&jC(i,fA|0,s):0!=((0==(t[n>>2]|0)?0:68!=(nA(l[t[n+8>>2]]&255)|0)?0:2==(t[n>>2]|0)?1:4==(t[n>>2]|0)?46==l[t[n+8>>2]+2|0]<<24>>24:5!=(t[n>>2]|0)?0:46==l[t[n+8>>2]+3|0]<<24>>24)&1|0)?0==(q|0)&&jC(i,fA|0,0):0!=(m|0)&&(iC(i,p),0==(t[p>>2]|0)&&jC(i,fA|0,1))}j=p}}}while(0);c=eC();if(0==(c|0)){break}else{g=c}}}Q(b);Q(d)}dC.X=1;function fC(b){var d,c,e=P(),f=0==(kC(l[b]&255)|0);c=(e|0)>>2;var g=t[c];d=(e+4|0)>>2;var h=(g+1|0)==(t[d]|0);a:do{if(f){var i=b,m=h,n=g}else{for(var q=e+8|0,p=b,s=h,r=g;;){if(s&&(R(e),r=t[c]),l[t[q>>2]+r|0]=l[p],0!=l[p]<<24>>24&&(r=t[c]+1|0,t[c]=r,l[t[q>>2]+r|0]=0),p=p+1|0,r=t[c],s=(r+1|0)==(t[d]|0),0==(kC(l[p]&255)|0)){i=p;m=s;n=r;break a}}}}while(0);m?(R(e),f=t[c]):f=n;b=(e+8|0)>>2;l[t[b]+f|0]=0;if(0==(qA(t[b],zr|0)|0)){for(;0!=(L(l[i]&255)|0);){i=i+1|0}S(e);f=0==(kC(l[i]&255)|0);g=t[c];h=(g+1|0)==(t[d]|0);a:do{if(f){var u=h,v=g}else{m=i;q=h;for(n=g;;){if(q&&(R(e),n=t[c]),l[t[b]+n|0]=l[m],0!=l[m]<<24>>24&&(n=t[c]+1|0,t[c]=n,l[t[b]+n|0]=0),m=m+1|0,n=t[c],q=(n+1|0)==(t[d]|0),0==(kC(l[m]&255)|0)){u=q;v=n;break a}}}}while(0);u?(R(e),d=t[c]):d=v;l[t[b]+d|0]=0;jC(e,fA|0,0)}Q(e)}fC.X=1;function gC(b,d){var c;S(d);if(0==((0==(l[b]&255|0)?0:0!=(pA(l[b]&255)|0)?1:0!=(bC(lp|0,l[b]&255,3)|0))&1|0)){return b}var e=0==(kC(l[b]&255)|0);c=(d|0)>>2;var f=t[c],g=d+4|0,h=(f+1|0)==(t[g>>2]|0);a:do{if(e){var i=b,m=h,n=f}else{for(var q=d+8|0,p=b,s=h,r=f;;){if(s&&(R(d),r=t[c]),l[t[q>>2]+r|0]=l[p],0!=l[p]<<24>>24&&(r=t[c]+1|0,t[c]=r,l[t[q>>2]+r|0]=0),p=p+1|0,r=t[c],s=(r+1|0)==(t[g>>2]|0),0==(kC(l[p]&255)|0)){i=p;m=s;n=r;break a}}}}while(0);m?(R(d),c=t[c]):c=n;l[t[d+8>>2]+c|0]=0;return i}gC.X=1;function hC(b,d){var c,e,f;S(d);e=(d|0)>>2;var g=d+4|0;c=(d+8|0)>>2;for(var h=b;;){var i=l[h];if(0==i<<24>>24){f=74;break}var m=t[e],n=(m+1|0)==(t[g>>2]|0);if(0!=(L(i&255)|0)){f=81;break}n?(R(d),i=t[e]):i=m;l[t[c]+i|0]=l[h];0!=l[h]<<24>>24&&(i=t[e]+1|0,t[e]=i,l[t[c]+i|0]=0);h=h+1|0}if(81==f){if(n){f=82}else{var q=m}}else{74==f&&(m=t[e],(m+1|0)==(t[g>>2]|0)?f=82:q=m)}82==f&&(R(d),q=t[e]);l[t[c]+q|0]=0;return h}hC.X=1;function iC(b,d){var c=P();lC(c,t[b>>2],t[b+4>>2],t[b+8>>2]);var e=mC(t[c+8>>2],t[Sy>>2]);Q(c);c=-1!=(e|0);t[d>>2]=c&1;return!c?-1:e=t[py+(e<<3)+4>>2]}function kC(b){return(0==(b|0)?0:0!=(oA(b)|0)?1:0!=(bC(Gp|0,b,4)|0))&1}function nC(){var b,d,c,e,f=P(),g=eC();if(0!=(g|0)){c=(f|0)>>2;d=(f+4|0)>>2;b=(f+8|0)>>2;var h=g;a:for(;;){var i=l[h];do{if(0!=i<<24>>24){for(var m=h,n=i;;){var q=m+1|0;if(0==(L(n&255)|0)){break}m=q;n=l[q]}var p=l[m];if(34==p<<24>>24){for(var s=m;;){var r=s+1|0,u=l[r];if(34==u<<24>>24||0==u<<24>>24){h=r;continue a}else{s=r}}}else{if(39==p<<24>>24){break}}if(0==(sA(m,Sf|0,3)|0)){var v=m+3|0;if(0==(L(l[v]&255)|0)){h=v;continue a}else{var w=v}for(;0!=(L(l[w]&255)|0);){w=w+1|0}if(0==(sA(w,Cf|0,8)|0)){break}if(0==(sA(w,nf|0,3)|0)){break}else{h=w;continue a}}if(0==(sA(m,Ep|0,4)|0)){var C=m+4|0;if(0==(L(l[C]&255)|0)){h=C;continue a}else{var A=C}for(;0!=(L(l[A]&255)|0);){A=A+1|0}if(0==(sA(A,Cf|0,8)|0)){break}if(0==(sA(A,nf|0,3)|0)){break}else{h=A;continue a}}if(0==(sA(m,Yf|0,6)|0)){var I=m+6|0;if(0==(L(l[I]&255)|0)){h=I;continue a}else{var M=I}for(;0!=(L(l[M]&255)|0);){M=M+1|0}if(0==(sA(M,Cf|0,8)|0)){for(var B=M+8|0;;){if(0==(L(l[B]&255)|0)){var G=B;break}else{B=B+1|0}}b:for(;;){do{if(0==(oA(l[G]&255)|0)){var Z=t[c],X=(Z+1|0)==(t[d]|0);if(95!=l[G]<<24>>24){break b}if(X){e=145}else{var ga=Z}}else{var ra=t[c];(ra+1|0)==(t[d]|0)?e=145:ga=ra}}while(0);145==e&&(e=0,R(f),ga=t[c]);l[t[b]+ga|0]=l[G];if(0!=l[G]<<24>>24){var ka=t[c]+1|0;t[c]=ka;l[t[b]+ka|0]=0}G=G+1|0}if(X){R(f);var ia=t[c]}else{ia=Z}l[t[b]+ia|0]=0;jC(f,cA|0,2);S(f);h=G;continue a}if(0!=(sA(M,nf|0,3)|0)){var ea=M;b:for(;;){do{if(0==(oA(l[ea]&255)|0)){var wb=t[c],sb=(wb+1|0)==(t[d]|0);if(95!=l[ea]<<24>>24){break b}if(sb){e=170}else{var Db=wb}}else{var Za=t[c];(Za+1|0)==(t[d]|0)?e=170:Db=Za}}while(0);170==e&&(e=0,R(f),Db=t[c]);l[t[b]+Db|0]=l[ea];if(0!=l[ea]<<24>>24){var kc=t[c]+1|0;t[c]=kc;l[t[b]+kc|0]=0}ea=ea+1|0}if(sb){R(f);var $c=t[c]}else{$c=wb}l[t[b]+$c|0]=0;jC(f,cA|0,4);S(f);h=ea;continue a}for(var Ia=M+3|0;;){if(0==(L(l[Ia]&255)|0)){var Eb=Ia;break}else{Ia=Ia+1|0}}b:for(;;){do{if(0==(oA(l[Eb]&255)|0)){var Pb=t[c],He=(Pb+1|0)==(t[d]|0);if(95!=l[Eb]<<24>>24){break b}if(He){e=159}else{var Hd=Pb}}else{var de=t[c];(de+1|0)==(t[d]|0)?e=159:Hd=de}}while(0);159==e&&(e=0,R(f),Hd=t[c]);l[t[b]+Hd|0]=l[Eb];if(0!=l[Eb]<<24>>24){var ee=t[c]+1|0;t[c]=ee;l[t[b]+ee|0]=0}Eb=Eb+1|0}if(He){R(f);var Id=t[c]}else{Id=Pb}l[t[b]+Id|0]=0;jC(f,cA|0,3);S(f);h=Eb;continue a}if(0==(sA(m,nx|0,7)|0)){var Jd=m+7|0;if(0==(L(l[Jd]&255)|0)){h=Jd;continue a}else{var uc=Jd}for(;0!=(L(l[uc]&255)|0);){uc=uc+1|0}if(0==(sA(uc,Cf|0,8)|0)){for(var Kd=uc+8|0;;){if(0==(L(l[Kd]&255)|0)){var Qb=Kd;break}else{Kd=Kd+1|0}}b:for(;;){do{if(0==(oA(l[Qb]&255)|0)){var Mc=t[c],ad=(Mc+1|0)==(t[d]|0);if(95!=l[Qb]<<24>>24){break b}if(ad){e=187}else{var bb=Mc}}else{var Qa=t[c];(Qa+1|0)==(t[d]|0)?e=187:bb=Qa}}while(0);187==e&&(e=0,R(f),bb=t[c]);l[t[b]+bb|0]=l[Qb];if(0!=l[Qb]<<24>>24){var Rb=t[c]+1|0;t[c]=Rb;l[t[b]+Rb|0]=0}Qb=Qb+1|0}if(ad){R(f);var vc=t[c]}else{vc=Mc}l[t[b]+vc|0]=0;jC(f,cA|0,2);S(f);h=Qb;continue a}if(0!=(sA(uc,nf|0,3)|0)){var Sb=uc;b:for(;;){do{if(0==(oA(l[Sb]&255)|0)){var fe=t[c],vd=(fe+1|0)==(t[d]|0);if(95!=l[Sb]<<24>>24){break b}if(vd){e=212}else{var lc=fe}}else{var Nc=t[c];(Nc+1|0)==(t[d]|0)?e=212:lc=Nc}}while(0);212==e&&(e=0,R(f),lc=t[c]);l[t[b]+lc|0]=l[Sb];if(0!=l[Sb]<<24>>24){var ge=t[c]+1|0;t[c]=ge;l[t[b]+ge|0]=0}Sb=Sb+1|0}if(vd){R(f);var he=t[c]}else{he=fe}l[t[b]+he|0]=0;jC(f,cA|0,4);S(f);h=Sb;continue a}for(var Tb=uc+3|0;;){if(0==(L(l[Tb]&255)|0)){var Ub=Tb;break}else{Tb=Tb+1|0}}b:for(;;){do{if(0==(oA(l[Ub]&255)|0)){var bd=t[c],cd=(bd+1|0)==(t[d]|0);if(95!=l[Ub]<<24>>24){break b}if(cd){e=201}else{var ac=bd}}else{var ie=t[c];(ie+1|0)==(t[d]|0)?e=201:ac=ie}}while(0);201==e&&(e=0,R(f),ac=t[c]);l[t[b]+ac|0]=l[Ub];if(0!=l[Ub]<<24>>24){var Ld=t[c]+1|0;t[c]=Ld;l[t[b]+Ld|0]=0}Ub=Ub+1|0}if(cd){R(f);var gb=t[c]}else{gb=bd}l[t[b]+gb|0]=0;jC(f,cA|0,3);S(f);h=Ub;continue a}if(0==(sA(m,Cf|0,8)|0)){var dd=m+8|0;if(0==(L(l[dd]&255)|0)){h=dd;continue a}else{var Vb=dd}for(;;){if(0==(L(l[Vb]&255)|0)){var Sa=Vb;break}else{Vb=Vb+1|0}}b:for(;;){do{if(0==(oA(l[Sa]&255)|0)){var Oc=t[c],Pc=(Oc+1|0)==(t[d]|0);if(95!=l[Sa]<<24>>24){break b}if(Pc){e=226}else{var Md=Oc}}else{var ed=t[c];(ed+1|0)==(t[d]|0)?e=226:Md=ed}}while(0);226==e&&(e=0,R(f),Md=t[c]);l[t[b]+Md|0]=l[Sa];if(0!=l[Sa]<<24>>24){var je=t[c]+1|0;t[c]=je;l[t[b]+je|0]=0}Sa=Sa+1|0}if(Pc){R(f);var ke=t[c]}else{ke=Oc}l[t[b]+ke|0]=0;jC(f,cA|0,2);S(f);h=Sa;continue a}if(0==(sA(m,nf|0,3)|0)){var wd=m+3|0;if(0==(L(l[wd]&255)|0)){h=wd;continue a}else{var xd=wd}for(;;){if(0==(L(l[xd]&255)|0)){var ob=xd;break}else{xd=xd+1|0}}b:for(;;){do{if(0==(oA(l[ob]&255)|0)){var Fb=t[c],fd=(Fb+1|0)==(t[d]|0);if(95!=l[ob]<<24>>24){break b}if(fd){e=240}else{var le=Fb}}else{var gd=t[c];(gd+1|0)==(t[d]|0)?e=240:le=gd}}while(0);240==e&&(e=0,R(f),le=t[c]);l[t[b]+le|0]=l[ob];if(0!=l[ob]<<24>>24){var yd=t[c]+1|0;t[c]=yd;l[t[b]+yd|0]=0}ob=ob+1|0}if(fd){R(f);var Nd=t[c]}else{Nd=Fb}l[t[b]+Nd|0]=0;jC(f,cA|0,3);S(f);h=ob;continue a}if(0==(sA(m,xg|0,3)|0)){var Od=m+3|0;if(0==(L(l[Od]&255)|0)){h=Od;continue a}else{var wc=Od}for(;;){if(0==(L(l[wc]&255)|0)){var xc=wc;break}else{wc=wc+1|0}}b:for(;;){do{if(0==(oA(l[xc]&255)|0)){var hd=t[c],Pd=(hd+1|0)==(t[d]|0);if(95!=l[xc]<<24>>24){break b}if(Pd){e=254}else{var bc=hd}}else{var me=t[c];(me+1|0)==(t[d]|0)?e=254:bc=me}}while(0);254==e&&(e=0,R(f),bc=t[c]);l[t[b]+bc|0]=l[xc];if(0!=l[xc]<<24>>24){var Qd=t[c]+1|0;t[c]=Qd;l[t[b]+Qd|0]=0}xc=xc+1|0}if(Pd){R(f);var ne=t[c]}else{ne=hd}l[t[b]+ne|0]=0;jC(f,cA|0,4);S(f);h=xc;continue a}if(0==(sA(m,Fi|0,5)|0)){var cc=m+5|0;if(0==(L(l[cc]&255)|0)){h=cc;continue a}else{var id=cc}for(;;){if(0==(L(l[id]&255)|0)){var yb=id;break}else{id=id+1|0}}b:for(;;){do{if(0==(oA(l[yb]&255)|0)){var Rd=t[c],oe=(Rd+1|0)==(t[d]|0);if(95!=l[yb]<<24>>24){break b}if(oe){e=268}else{var jd=Rd}}else{var Qc=t[c];(Qc+1|0)==(t[d]|0)?e=268:jd=Qc}}while(0);268==e&&(e=0,R(f),jd=t[c]);l[t[b]+jd|0]=l[yb];if(0!=l[yb]<<24>>24){var mc=t[c]+1|0;t[c]=mc;l[t[b]+mc|0]=0}yb=yb+1|0}if(oe){R(f);var pe=t[c]}else{pe=Rd}l[t[b]+pe|0]=0;jC(f,cA|0,1);S(f);h=yb;continue a}if(0!=(sA(m,El|0,5)|0)){h=0==p<<24>>24?m:q;continue a}var Rc=m+5|0;if(0==(L(l[Rc]&255)|0)){h=Rc;continue a}else{var kd=Rc}for(;;){if(0==(L(l[kd]&255)|0)){var nc=kd;break}else{kd=kd+1|0}}b:for(;;){do{if(0==(oA(l[nc]&255)|0)){var Sd=t[c],Sc=(Sd+1|0)==(t[d]|0);if(95!=l[nc]<<24>>24){break b}if(Sc){e=282}else{var Td=Sd}}else{var qe=t[c];(qe+1|0)==(t[d]|0)?e=282:Td=qe}}while(0);282==e&&(e=0,R(f),Td=t[c]);l[t[b]+Td|0]=l[nc];if(0!=l[nc]<<24>>24){var hf=t[c]+1|0;t[c]=hf;l[t[b]+hf|0]=0}nc=nc+1|0}if(Sc){R(f);var jf=t[c]}else{jf=Sd}l[t[b]+jf|0]=0;jC(f,cA|0,0);S(f);h=nc;continue a}}while(0);var Ag=eC();if(0==(Ag|0)){break}else{h=Ag}}}Q(f)}nC.X=1;function oC(){var b,d,c,e=P(),f=eC();if(0!=(f|0)){d=(e|0)>>2;var g=e+4|0;for(b=(e+8|0)>>2;;){do{if(0==(N(f,Cf|0,8)|0)){var h=f+8|0;if(0!=(L(l[h]&255)|0)){for(;;){if(0==(L(l[h]&255)|0)){var i=h;break}else{h=h+1|0}}a:for(;;){do{if(0==(oA(l[i]&255)|0)){var m=t[d],n=(m+1|0)==(t[g>>2]|0);if(95!=l[i]<<24>>24){break a}if(n){c=304}else{var q=m}}else{h=t[d],(h+1|0)==(t[g>>2]|0)?c=304:q=h}}while(0);304==c&&(c=0,R(e),q=t[d]);l[t[b]+q|0]=l[i];0!=l[i]<<24>>24&&(h=t[d]+1|0,t[d]=h,l[t[b]+h|0]=0);i=i+1|0}n?(R(e),h=t[d]):h=m;l[t[b]+h|0]=0;for(h=i;0!=(L(l[h]&255)|0);){h=h+1|0}40==l[h]<<24>>24&&jC(e,aA|0,0);S(e)}}}while(0);f=eC();if(0==(f|0)){break}}}Q(e)}oC.X=1;function pC(b,d){for(var c,e,f,g=b;0!=(L(l[g]<<24>>24)|0);){g=g+1|0}S(d);e=(d|0)>>2;var h=d+4|0;for(c=(d+8|0)>>2;;){var i=l[g];if(0==i<<24>>24){f=360;break}if(0!=(L(i<<24>>24)|0)){f=360;break}var i=l[g],m=t[e],n=(m+1|0)==(t[h>>2]|0);if(44==i<<24>>24||40==i<<24>>24){f=367;break}if(n){R(d);var i=l[g],q=t[e]}else{q=m}l[t[c]+q|0]=i;0!=l[g]<<24>>24&&(i=t[e]+1|0,t[e]=i,l[t[c]+i|0]=0);g=g+1|0}if(360==f){if(m=t[e],(m+1|0)!=(t[h>>2]|0)){return c=t[c],c=c+m|0,l[c]=0,g}}else{if(367==f&&!n){return c=t[c],c=c+m|0,l[c]=0,g}}R(d);e=t[e];c=t[c];c=c+e|0;l[c]=0;return g}pC.X=1;function qC(){var b,d,c,e=P();d=(e|0)>>2;var f=e+4|0;b=(e+8|0)>>2;for(var g=0==(t[Xz+16>>2]|0),h=0==(t[Xz+48>>2]|0),i=0;;){for(S(e);;){var m=T();if(-1==(m|0)||10==(m|0)||13==(m|0)){break}var n=t[d];(n+1|0)==(t[f>>2]|0)&&(R(e),n=t[d]);l[t[b]+n|0]=m&255;0!=(m|0)&&(m=t[d]+1|0,t[d]=m,l[t[b]+m|0]=0)}m=t[d];(m+1|0)==(t[f>>2]|0)&&(R(e),m=t[d]);l[t[b]+m|0]=0;for(m=t[d];;){var q=m-1|0;if(0==(q|0)){var p=0;break}if(0==(L(l[t[b]+q|0]<<24>>24)|0)){p=0;break}else{m=q}}for(;(p|0)<(q|0)&&0!=(L(l[t[b]+p|0]<<24>>24)|0);){p=p+1|0}do{if(4<(q-p|0)){if(n=t[b],45!=l[n+p|0]<<24>>24){c=408}else{if(45!=l[p+(n+1)|0]<<24>>24){c=408}else{if(45!=l[n+q|0]<<24>>24){c=408}else{if(45!=l[n+(m-2)|0]<<24>>24){c=408}else{if(0!=(i|0)){var s=i}else{for(var s=p+2|0,r=m-3|0;;){if(0==(r|0)){var u=0;break}if(58==l[n+r|0]<<24>>24){u=r;break}else{r=r-1|0}}for(;;){if(0==(u|0)){var v=s;break}n=u-1|0;if(0==(L(l[t[b]+n|0]<<24>>24)|0)){v=s;break}else{u=n}}for(;(v|0)<(u|0)&&!(0==(L(l[t[b]+v|0]<<24>>24)|0)&&45!=l[t[b]+v|0]<<24>>24);){v=v+1|0}(v|0)<(u-1|0)&&(l[t[b]+u|0]=0,s=t[b]+v|0,0!=(sA(ip|0,s,Aa)|0)&&0!=(sA(Pm|0,s,Aa)|0)&&rC(s,0));s=0}}}}}}else{c=408}}while(0);a:do{if(408==c){c=0;m=t[d];n=m-1|0;if(0==(i|0)){var w=0}else{var C=i,A=0;c=409}b:for(;;){if(409==c){c=0;for(var I=A;;){if((I|0)>=(m|0)){s=C;break a}var M=t[b],r=l[M+I|0];if(42==r<<24>>24){var B=I+1|0;if((I|0)>=(n|0)){I=B;continue}if(41==l[M+B|0]<<24>>24){break}else{I=B}}else{I=I+1|0}if(125==r<<24>>24){w=I;continue b}}w=I+2|0}if((w|0)>=(m|0)){s=0;break a}r=t[b];I=r+w|0;M=l[I];do{if(39==M<<24>>24){for(B=w;;){var G=B+1|0;if((G|0)>=(m|0)){s=0;break a}var Z=l[r+G|0];if(92==Z<<24>>24){B=(G|0)<(n|0)?B+2|0:G}else{if(39!=Z<<24>>24){B=G}else{B=B+2|0;if((B|0)>=(m|0)){w=B;continue b}if(39!=l[r+B|0]<<24>>24){w=B;continue b}}}}}else{if(123==M<<24>>24){C=1;A=w+1|0;c=409;continue b}else{if(40==M<<24>>24){if((w|0)<(n|0)){if(42!=l[w+(r+1)|0]<<24>>24){X=w}else{C=1;A=w+2|0;c=409;continue b}}else{var X=w}}else{if(60==M<<24>>24){if(B=w+1|0,(B|0)<(m|0)){if(60!=l[r+B|0]<<24>>24){X=w}else{if(0==(tA(I,un|0)|0)){X=w}else{for(B=w+2|0;(B|0)<(m|0)&&0!=(L(l[t[b]+B|0]<<24>>24)|0);){B=B+1|0}G=B+4|0;for(B=(G|0)>(m|0)?B:0==(sA(t[b]+B|0,Ri|0,4)|0)?G:B;;){if((B|0)>=(m|0)){var ga=B;break}if(0==(L(l[t[b]+B|0]<<24>>24)|0)){ga=B;break}else{B=B+1|0}}for(;(ga|0)<(m|0);){G=t[b];Z=l[G+ga|0];if(62==Z<<24>>24||58==Z<<24>>24){var ra=G;c=430;break}if(0==(L(Z<<24>>24)|0)){ga=ga+1|0}else{c=429;break}}429==c&&(ra=t[b],c=430);430==c&&(c=0,l[ra+ga|0]=0,B=t[b]+B|0,0!=(sA(ip|0,B,Aa)|0)&&0!=(sA(Pm|0,B,Aa)|0)&&0!=(sA(Ri|0,B,Aa)|0)&&rC(B,2));B=ga+1|0;if((B|0)<(m|0)){c=t[b];var ka=B,ia=c,ea=l[c+B|0];c=436}else{X=m}}}}else{X=w}}else{ka=w,ia=r,ea=M,c=436}}}}}while(0);c:do{if(436==c){if(c=0,58!=ea<<24>>24){X=ka}else{do{if(g){if(h){X=ka;break c}w=l[ka+(ia+1)|0];if(58==w<<24>>24||60==w<<24>>24){w=ka}else{X=ka;break c}}else{w=ka}}while(0);for(;;){if(0==(w|0)){var wb=0;break}r=w-1|0;if(0==(L(l[t[b]+r|0]<<24>>24)|0)){wb=w;break}else{w=r}}w=wb;for(r=t[b];;){l[r+w|0]=0;for(r=w;0!=(r|0)&&!(I=r-1|0,0==l[Lc+(l[t[b]+I|0]&255)|0]<<24>>24);){r=I}if((r|0)==(w|0)){X=ka;break c}rC(t[b]+r|0,1);for(w=r;;){if(0==(w|0)){X=ka;break c}var sb=w-1|0;if(0==(L(l[t[b]+sb|0]<<24>>24)|0)){break}else{w=sb}}r=t[b];if(44!=l[r+sb|0]<<24>>24){X=ka;break c}}}}}while(0);w=X+1|0}}}while(0);if(0==(cB(t[K+16>>2])|0)){i=s}else{break}}Q(e)}qC.X=1;function rC(b,d){var c=j;j+=80;0!=(t[Xz+(d<<4)>>2]|0)&&(sC(c,b),t[c+36>>2]=t[Xz+(d<<4)+8>>2],l[c+40|0]=t[Xz+(d<<4)+4>>2]&255,tC(c));j=c}function uC(b,d){for(var c=0;!(0!=Pa[((d<<1)+H+8>>1)+(10*c|0)]<<16>>16&&vC(t[(H>>2)+(5*c|0)],b,t[(H+4>>2)+(5*c|0)]),c=c+1|0,100==(c|0));){}}function wC(){var b=t[Fz>>2],d=t[b+80>>2],c=b+48|0;xC(t[c>>2]);t[c>>2]=0;c=b+52|0;xC(t[c>>2]);t[c>>2]=0;c=b+56|0;xC(t[c>>2]);t[c>>2]=0;c=b+64|0;xC(t[c>>2]);t[c>>2]=0;c=b+60|0;xC(t[c>>2]);t[c>>2]=0;c=b+76|0;Q(t[c>>2]);t[c>>2]=0;vB(b);t[Fz>>2]=d}function xC(b){0!=(b|0)&&(Q(t[b+8>>2]),vB(b))}function yC(b,d){var c=j,e,f=zC(84);e=f>>2;t[e+12]=AC();t[e+13]=AC();t[e+14]=AC();t[e+15]=AC();t[e+16]=AC();t[e+19]=P();t[f+80>>2]=d;e=t[f+80>>2];0==(e|0)?e=0:(e=t[e+4>>2],e=3==(e|0)?(t[Ly>>2]|0)==(t[K+56>>2]|0)?4:0:2==(e|0)?(t[Ly>>2]|0)==(t[K+56>>2]|0)?5:2:14==(e|0)||7==(e|0)||12==(e|0)?4:0);t[f+72>>2]=e;t[f+68>>2]=e;BC(f,0);t[Fz>>2]=f;e=f+44|0;for(var g=b+1|0;;){for(var h=f,i=ba,m=h+44|0,n=h+12|0;;){var q=CC();if(91==(q|0)){DC(Fq|0)}else{if(40==(q|0)){EC(h)}else{if(59==(q|0)){FC(h,11)}else{if(60==(q|0)){GC()}else{if(42==(q|0)){t[n>>2]=0}else{if(-1==(q|0)){i=668;break}else{if(123==(q|0)){FC(h,3)}else{if(58==(q|0)){HC(h)}else{if(125==(q|0)){FC(h,2)}else{if(61==(q|0)){var q=h,p=t[q+80>>2],p=0==(p|0)?0:3==(t[p+4>>2]|0)&1,s=IC();if(61!=(s|0)){JC(s);a:{for(var s=j,r=ba,u=q+40|0,v=q+80|0,w=1;;){var C;if(!w){r=1442;break}w=CC();if(48==(w|0)){2==(t[u>>2]|0)&&(t[u>>2]=3),C=48,w=1}else{if(-1==(w|0)){r=1430;break}else{if(91==(w|0)){DC(Fq|0),C=91,w=1}else{if(40==(w|0)){DC(Mt|0),C=40,w=1}else{if(44==(w|0)||59==(w|0)){C=w,w=0}else{if(123==(w|0)){DC(fu|0),C=123,w=1}else{if(125==(w|0)){if(w=t[v>>2],0!=(w|0)&&3==(t[w+4>>2]|0)){C=125,w=0}else{if(0==(t[Vz>>2]|0)){r=1441;break}else{C=125,w=1}}}else{60==(w|0)?(GC(),C=60):C=w,w=1}}}}}}}}if(1441==r){s=t[t[K+40>>2]+8>>2],r=t[K+20>>2],KC(iu|0,(k=j,j+=8,t[k>>2]=s,t[k+4>>2]=r,k)),dB(yz|0,3)}else{if(1442==r){j=s;s=C;break a}1430==r&&dB(yz|0,2)}s=ba}t[q+32>>2]=1;125==(s|0)?0!=(p|0)&&(JC(125),FC(q,5)):59==(s|0)?FC(q,11):44==(s|0)&&FC(q,5);q|=0;2==(t[q>>2]|0)&&(t[q>>2]=0)}}else{44==(q|0)?FC(h,5):LC(h,q)}}}}}}}}}}if(0!=(t[t[h+(t[m>>2]<<2)+48>>2]>>2]|0)){i=681;break}}668==i&&dB(yz|0,1);h=t[f+(t[e>>2]<<2)+48>>2]|0;i=t[h>>2];if(2==(i|0)){break}else{if(6==(i|0)){h=MC(f,1);i=ba;8==(t[h>>2]|0)&&(i=(f+60|0)>>2,m=t[t[i]+8>>2],0!=(t[m>>2]|0)&&(n=t[K+56>>2],(t[Ry>>2]|0)==(n|0)|(t[Qy>>2]|0)==(n|0)?U(m,Bv|0):(t[Ly>>2]|0)==(n|0)|(t[Py>>2]|0)==(n|0)&&U(m,Xi|0)),U(t[t[i]+8>>2],t[t[h+8>>2]+8>>2]),t[t[i]>>2]=8);NC(f);continue}}OC(f);if(3==(t[h>>2]|0)){h=f;i=g;m=ba;n=t[h+4>>2];if(2==(n|0)||3==(n|0)||7==(n|0)||8==(n|0)||9==(n|0)||12==(n|0)||14==(n|0)){yC(i,h)}else{if(5==(n|0)||13==(n|0)){t[h+28>>2]=1}m=599}599==m&&(0==(PC(8,0)|0)?DC(fu|0):yC(i,h));NC(h);FC(h,2)}h=f;5==(t[t[h+(t[h+44>>2]<<2)+48>>2]>>2]|0)?BC(h,1):(i=t[t[h+(t[h+44>>2]<<2)+48>>2]>>2],11==(i|0)?i=1:2==(i|0)?(i=t[K+56>>2],i=((t[Ly>>2]|0)==(i|0)|(t[Py>>2]|0)==(i|0)?1:0==(QC(h)|0))&1):i=0,0==(i|0)?(t[Lz+8>>2]=1,NC(h)):(BC(h,0),t[Lz+8>>2]=0))}0==(b|0)?(c=t[t[K+40>>2]+8>>2],f=t[K+20>>2],KC(iu|0,(k=j,j+=8,t[k>>2]=c,t[k+4>>2]=f,k)),dB(yz|0,3)):(wC(),j=c)}function RC(b){return 1==(b|0)?0:2==(b|0)?5:3==(b|0)?2:4==(b|0)?3:5==(b|0)?4:7==(b|0)?6:8==(b|0)?7:10==(b|0)?8:11==(b|0)?9:14==(b|0)?10:16==(b|0)?11:18==(b|0)?12:-1}function SC(b){return 1==(b|0)?0:2==(b|0)?3:3==(b|0)?1:5==(b|0)?2:7==(b|0)?4:8==(b|0)?5:10==(b|0)?6:12==(b|0)?7:-1}function MC(b,d){return t[b+(((3-d+t[b+44>>2]|0)>>>0)%3<<2)+48>>2]}function QC(b){0==(b|0)?b=0:(b=t[b+4>>2],b=2==(b|0)||3==(b|0)||7==(b|0)||8==(b|0)||12==(b|0)||14==(b|0)?1:0);return b}function NC(b){var d=b+44|0,c=t[d>>2],c=1<c>>>0?0:c+1|0;t[d>>2]=c;TC(t[b+(c<<2)+48>>2])}function OC(b){var d,c,e=b>>2,f=j;j+=20;var g,h=t[((t[e+11]<<2)+48>>2)+e],i=MC(b,1);d=MC(b,2);c=d>>2;var m=h|0,n=t[m>>2];if(8==(n|0)){i=t[e+20],0!=(i|0)&&3==(t[i+4>>2]|0)&&8==(t[h>>2]|0)&&UC(h,b,1,3)}else{if(3==(n|0)){if(m=t[i>>2],1==(m|0)){0!=(t[e+3]|0)&&((t[Gy>>2]|0)!=(t[K+56>>2]|0)&&(t[e+1]=5),8==(t[c]|0)&&VC(t[e+16],d),WC(b,d))}else{if(0==(QC(b)|0)&&(d=t[e+1],!(8==(d|0)||11==(d|0)))){if((t[Py>>2]|0)!=(t[K+56>>2]|0)){j=f;return}UC(i,b,0,14);j=f;return}if(8==(m|0)){VC(t[e+16],i)}else{e=f|0;d=t[iA>>2]+1|0;t[iA>>2]=d;d=(k=j,j+=4,t[k>>2]=d,k);d=eB(au|0,d);c=d.length;for(m=0;m<c;m++){l[e+m]=d[m]}l[e+m]=0;d=(b+64|0)>>2;V(t[t[d]+8>>2],e);t[t[d]>>2]=8;t[t[d]+4>>2]=-1}e=t[b+4>>2];if((2==(e|0)||3==(e|0)||7==(e|0)||8==(e|0)||11==(e|0)||12==(e|0)||14==(e|0))&&8==(t[i>>2]|0)){e=XC(t[b+4>>2]),d=t[K+56>>2],d=(t[Ly>>2]|0)==(d|0)|(t[Py>>2]|0)==(d|0)?0:(t[Gy>>2]|0)!=(d|0),0!=(e|0)&&UC(i,b,d&1,e)}}}else{if(11==(n|0)||5==(n|0)){h=b+80|0,n=t[h>>2],0==(n|0)?g=568:3!=(t[n+4>>2]|0)&&(g=568),568==g&&(g=t[i>>2],8==(g|0)?0==((12==(t[c+1]|0)||23==(t[c+1]|0)||43==(t[c+1]|0)||52==(t[c+1]|0)||75==(t[c+1]|0)||91==(t[c+1]|0)?1:0)|0)?YC(b,i):UC(i,b,1,21):1==(g|0)&&8==(t[c]|0)&&(0==(t[e+6]|0)?8==(t[d>>2]|0)&&(i=t[K+56>>2],(t[Ly>>2]|0)==(i|0)|(t[Py>>2]|0)==(i|0)?WC(b,d):4==(t[b>>2]|0)?UC(d,b,1,18):0!=(ZC(t[b+4>>2])|0)&&UC(d,b,1,15)):YC(b,d))),(t[Ly>>2]|0)==(t[K+56>>2]|0)&&11==(t[m>>2]|0)&&(b=t[h>>2],0!=(b|0)&&(b=b+4|0,3==(t[b>>2]|0)&&(t[b>>2]=2)))}}}j=f}OC.X=1;function BC(b,d){var c=b>>2,e=0!=(d|0);if(e){var f=t[c+20]}else{t[c]=0,f=t[c+20],t[(b+4|0)>>2]=0==(QC(f)|0)?0:1}for(var g=(b+8|0)>>2,h=g+10;g<h;g++){t[g]=0}0==(f|0)||(t[c+7]=t[f+28>>2]);TC(t[c+12]);TC(t[c+13]);TC(t[c+14]);TC(t[c+15]);e?S(t[c+19]):(TC(t[c+16]),S(t[c+19]),t[c+17]=t[c+18])}BC.X=1;function TC(b){b>>=2;t[b]=0;t[b+1]=-1;t[b+3]=t[K+48>>2];t[b+4]=t[K+24>>2];S(t[b+2])}function PC(b,d){if(!(0==(d|0)|0!=(t[oy+8>>2]|0))){var c;return 0}c=t[K+56>>2];return(t[Py>>2]|0)==(c|0)?c=t[Jz+(RC(b)<<4)>>2]:(t[Ly>>2]|0)==(c|0)?c=t[Zy+(SC(b)<<4)>>2]:c=(t[Gy>>2]|0)==(c|0)?t[Hx+($C(b)<<4)>>2]:t[Tz+(aD(b)<<4)>>2]}function FC(b,d){var c=t[b+(t[b+44>>2]<<2)+48>>2];TC(c);t[c>>2]=d}function CC(){for(var b=0;;){var d=IC();if(0==(L(d)|0)){break}else{b=1}}if(0==(b|0)|l[Oz]^1){return d}var b=t[Vx>>2],c=t[b>>2];if((c+1|0)==(t[b+4>>2]|0)){R(b);var b=c=t[Vx>>2],e=t[c>>2]}else{e=c}c=b+8|0;l[t[c>>2]+e|0]=32;b|=0;e=t[b>>2]+1|0;t[b>>2]=e;l[t[c>>2]+e|0]=0;return d}function bD(){for(var b=IC(),d=IC();;){if(10==(b|0)){if(125==(d|0)){break}}else{if(-1==(b|0)){break}}b=d;d=IC()}}function DC(b){var d=j,c,e=0==(qA(fu|0,b)|0),f=e&0!=(t[Vz>>2]|0),g=t[Lz+28>>2],h=l[b]<<24>>24,i=l[b+1|0]<<24>>24,b=t[K+20>>2],m=0,n=1;a:for(;;){for(var q=0<(n|0),p=m;;){if(!q){var s=p;c=699;break a}var r=CC();if(-1==(r|0)){break a}if(l[Oz]){var p=t[Vx>>2],u=t[p>>2];if((u+1|0)==(t[p+4>>2]|0)){R(p);var p=u=t[Vx>>2],v=t[u>>2]}else{v=u}u=p+8|0;l[t[u>>2]+v|0]=r&255;0!=(r|0)&&(p|=0,v=t[p>>2]+1|0,t[p>>2]=v,l[t[u>>2]+v|0]=0)}if((r|0)==(h|0)){c=692;break}if((r|0)==(i|0)){c=696;break}else{p=r}}if(696==c){if(c=0,n=n-1|0,f){if((t[Lz+28>>2]|0)==(g|0)){m=r}else{c=698;break}}else{m=r}}else{if(692==c){if(c=0,n=n+1|0,f){if((t[Lz+28>>2]|0)==(g|0)){m=r}else{c=694;break}}else{m=r}}}}698==c?(bD(),s=i,c=699):694==c&&(bD(),s=h,c=699);699==c&&-1!=(s|0)?j=d:(d=t[t[K+40>>2]+8>>2],KC(Ev|0,(k=j,j+=12,t[k>>2]=d,t[k+4>>2]=h,t[k+8>>2]=b,k)),e?dB(yz|0,3):dB(yz|0,2))}DC.X=1;function $C(b){return 17==(b|0)?9:1==(b|0)?0:2==(b|0)?4:6==(b|0)?3:9==(b|0)?6:3==(b|0)?2:18==(b|0)?10:13==(b|0)?7:20==(b|0)?11:8==(b|0)?5:15==(b|0)?8:21==(b|0)?12:-1}function aD(b){return 21==(b|0)?13:8==(b|0)?5:9==(b|0)?6:11==(b|0)?7:15==(b|0)?8:6==(b|0)?3:2==(b|0)?4:19==(b|0)?11:3==(b|0)?2:18==(b|0)?10:20==(b|0)?12:1==(b|0)?0:16==(b|0)?9:-1}function ZC(b){return 1==(b|0)||2==(b|0)||3==(b|0)||4==(b|0)||12==(b|0)||14==(b|0)?1:0}function VC(b,d){var c=d>>2,e=b>>2;t[e]=t[c];t[e+1]=t[c+1];t[e+4]=t[c+4];t[e+3]=t[c+3];V(t[e+2],t[t[c+2]+8>>2])}function WC(b,d){if(8==(t[d>>2]|0)){var c=t[K+56>>2];UC(d,b,(2==(t[b+68>>2]|0)?1:0!=(cD(b)|0)?0:1==(t[b>>2]|0))&1,(t[Ly>>2]|0)==(c|0)|(t[Py>>2]|0)==(c|0)?10:(t[Gy>>2]|0)==(c|0)&&13==(t[b+4>>2]|0)?17:6)}}function UC(b,d,c,e){var f,g=j;j+=80;f=g>>2;var h=(0==(c|0)?0:0==(t[K+52>>2]|0))&1;if(8==(t[b>>2]|0)){var i=b+8|0;if(0!=(t[t[i>>2]>>2]|0)&&0!=(PC(e,h)|0)){var c=P(),m=P();sC(g,t[t[i>>2]+8>>2]);t[f+1]=t[b+12>>2];t[f+2]=t[b+16>>2];t[f+4]=h;t[f+9]=dD(e);b=t[K+56>>2];l[g+40|0]=t[((t[Py>>2]|0)==(b|0)?(RC(e)<<4)+Jz+4|0:(t[Ly>>2]|0)==(b|0)?(SC(e)<<4)+Zy+4|0:(t[Gy>>2]|0)==(b|0)?($C(e)<<4)+Hx+4|0:(aD(e)<<4)+Tz+4|0)>>2]&255;eD(c,d);fD(g,e,d,c,m);tC(g);if(!(0==(t[oy+4>>2]|0)|0==(c|0))&&0!=(t[c>>2]|0)){d=P();b=t[c+8>>2];do{if(3==(e|0)){if(f=gB(b,58),0!=(f|0)){for(i=f;;){if(58==l[i]<<24>>24&i>>>0>b>>>0){i=i-1|0}else{break}}f=d;h=b;i=i+1-b|0;S(f);gD(f,h,i)}}else{V(d,b)}}while(0);0!=(t[d>>2]|0)&&(hD(d),e=g+32|0,U(d,t[e>>2]),t[e>>2]=t[d+8>>2],tC(g));Q(d)}Q(c);Q(m)}}j=g}UC.X=1;function YC(b,d){var c=b>>2;if(8==(t[d>>2]|0)){var e=t[c];if(4==(e|0)){UC(d,b,1,18)}else{var f=t[c+1];10==(f|0)?UC(d,b,0,12):4==(f|0)?UC(d,b,2==(t[c+17]|0)&1,4):0!=(ZC(f)|0)&&0==(t[c+9]|0)&&(0!=(cD(b)|0)?(f=t[K+56>>2],(t[Ly>>2]|0)==(f|0)|(t[Py>>2]|0)==(f|0)?UC(d,b,2==(t[c+17]|0)&1,5):2>e>>>0&&UC(d,b,1,9)):2!=(e|0)&&0!=(t[c+3]|0)?(e=1==(e|0)&1,0==(t[c+7]|0)?UC(d,b,e,20):UC(d,b,e,8)):UC(d,b,0,21))}}}YC.X=1;function cD(b){if(8==(t[t[b+60>>2]>>2]|0)){return 1}b=t[b+80>>2];return b=(0==(b|0)?0:0!=(QC(b)|0))&1}function dD(b){var d=t[K+56>>2];return t[((t[Py>>2]|0)==(d|0)?(RC(b)<<4)+Jz+8|0:(t[Ly>>2]|0)==(d|0)?(SC(b)<<4)+Zy+8|0:(t[Gy>>2]|0)==(d|0)?($C(b)<<4)+Hx+8|0:(aD(b)<<4)+Tz+8|0)>>2]}function eD(b,d){var c,e;S(b);var f=t[d+60>>2];8==(t[f>>2]|0)&&V(b,t[t[f+8>>2]+8>>2]);var g=d+80|0;if(0!=(t[g>>2]|0)){var f=P(),g=t[g>>2],h=0==(g|0);a:do{if(!h){var i=b+8|0,m=f|0,n=f+8|0,q=g;for(c=q>>2;;){if(0==(QC(q)|0)){if(q=t[c+1],8==(q|0)||11==(q|0)){e=848}}else{e=848}848==e&&(e=0,V(f,t[i>>2]),S(b),q=t[c+15],8==(t[q>>2]|0)&&(q=t[q+8>>2],0!=(t[q>>2]|0)&&(U(b,t[q+8>>2]),hD(b))),U(b,t[t[t[c+16]+8>>2]+8>>2]),0!=(t[m>>2]|0)&&hD(b),U(b,t[n>>2]));c=t[c+20];if(0==(c|0)){break a}else{q=c,c=q>>2}}}}while(0);Q(f)}}eD.X=1;function fD(b,d,c,e,f){var g=c>>2,b=b>>2,h;if(6==(d|0)||10==(d|0)||15==(d|0)){h=860}else{if(1==(d|0)||2==(d|0)||3==(d|0)||4==(d|0)||5==(d|0)||7==(d|0)||9==(d|0)||11==(d|0)||14==(d|0)||16==(d|0)||17==(d|0)||18==(d|0)||19==(d|0)){h=862}else{if(20!=(d|0)){return}}}860==h&&(h=t[Vx>>2],0!=(t[h>>2]|0)&&(t[b+17]=t[h+8>>2]),h=862);if(862==h){if(0!=(t[e>>2]|0)&&!(0==(cD(c)|0)&&8!=(t[t[g+20]+4>>2]|0))){if(8==(t[t[g+15]>>2]|0)){t[b+15]=dD(1)}else{var i=t[g+20];t[b+15]=dD(XC(0==(i|0)?0:t[i+4>>2]))}t[b+16]=t[e+8>>2]}if(16==(d|0)||7==(d|0)||1==(d|0)){i=t[g+19],0!=(t[i>>2]|0)&&(t[b+14]=t[i+8>>2])}i=t[g+10];if(0!=(i|0)){var m=t[K+56>>2];(t[Qy>>2]|0)==(m|0)|(t[Py>>2]|0)==(m|0)|(t[Ly>>2]|0)==(m|0)&&(t[b+13]=t[Ic+(i<<2)>>2])}if(0!=(cD(c)|0)){var n;if((t[Qy>>2]|0)==(t[K+56>>2]|0)){if(3==(t[c>>2]|0)){var q=Nj|0}else{n=932}}else{n=932}932==n&&(n=t[c+68>>2],q=0==(n|0)?0:t[td+(n<<2)>>2]);t[b+11]=q}if(!(20==(d|0)||18==(d|0)||9==(d|0))){return}}if(0!=(QC(c)|0)){t[b+18]=dD(XC(t[g+1]));d=t[t[t[g+16]+8>>2]+8>>2];if(0==(d|0)){h=883}else{if(0==l[d]<<24>>24){h=883}else{var p=d}}883==h&&(c=MC(c,2),p=8!=(t[c>>2]|0)?d:t[t[c+8>>2]+8>>2]);0==(t[e>>2]|0)?e=p:(V(f,t[e+8>>2]),hD(f),U(f,p),e=t[f+8>>2]);t[b+19]=e}}fD.X=1;function XC(b){return 2==(b|0)?1:13==(b|0)?17:12==(b|0)?16:14==(b|0)?19:4==(b|0)?b:8==(b|0)?11:11==(b|0)?13:3==(b|0)?2:5==(b|0)?6:7==(b|0)?b:0}function hD(b){var d=t[K+56>>2];(t[Ry>>2]|0)==(d|0)|(t[Qy>>2]|0)==(d|0)?U(b,Bv|0):(t[Ly>>2]|0)==(d|0)|(t[Py>>2]|0)==(d|0)&&U(b,Xi|0)}function EC(b){var d,c=b>>2,e=j;j+=28;d=e>>2;var f=MC(b,1);0!=(t[c+7]|0)&&0==(t[c+8]|0)&&(t[c+9]=1);if(0!=(t[f>>2]|0)){var f=t[((t[c+11]<<2)+48>>2)+c],g=e>>2;t[g]=0;t[g+1]=1;t[g+2]=(t[Ry>>2]|0)==(t[K+56>>2]|0)&1;t[g+3]=1;t[g+4]=0;t[g+5]=0;t[g+6]=0;iD(b,e);g=CC();JC(g);if(0!=(t[d+4]|0)){BC(b,0)}else{var h=0==(t[d+3]|0);a:do{if(!h){var i=f|0;if(10==(t[i>>2]|0)){var m=b+16|0;if(0==(t[m>>2]|0)){do{if(0!=(t[d+1]|0)&&!(0==(t[c+3]|0)|40==(g|0))&&!(61==(g|0)&&2!=(t[c+10]|0))){if(0!=(t[c+1]|0)){break a}if(0==(bC(At|0,g,3)|0)){break a}}}while(0);t[i>>2]=8;jD(b);t[m>>2]=1;if(40==(g|0)&&0!=(t[d+5]|0)){j=e;return}t[c+6]=t[d];j=e;return}}}}while(0);f=b+20|0;if(0==(t[f>>2]|0)&&0!=(t[d+1]|0)){t[f>>2]=1;FC(b,1);NC(b);if(4==(t[c]|0)){j=e;return}d=j;c=t[K+20>>2];f=CC();JC(f);if(0!=(bC(zt|0,f,5)|0)){j=d}else{if((t[Ly>>2]|0)==(t[K+56>>2]|0)){var n,c=t[b+(t[b+44>>2]<<2)+48>>2],f=CC();if(0==(pA(f)|0)){if(126==(f|0)||95==(f|0)||36==(f|0)){n=1421}else{var q=f}}else{n=1421}a:do{if(1421==n){if(kD(c,f),82!=(t[c+4>>2]|0)){q=f}else{for(;;){g=CC();if(0==(pA(g)|0)){if(126==(g|0)||95==(g|0)||36==(g|0)){n=1424}else{var p=g}}else{n=1424}1424==n&&(n=0,kD(c,g),p=CC());if(!(46==(p|0)||44==(p|0))){q=p;break a}}}}}while(0);JC(q);FC(b,0);j=d}else{0==(lD(b,e)|0)?(b=t[t[K+40>>2]+8>>2],KC(qt|0,(k=j,j+=8,t[k>>2]=b,t[k+4>>2]=c,k)),dB(yz|0,2)):j=d}}j=e;return}FC(b,0)}}j=e}EC.X=1;function GC(){var b=IC();if(62!=(b|0)){var d=t[K+56>>2];(t[Qy>>2]|0)==(d|0)|(t[Py>>2]|0)==(d|0)?d=1:(d=(t[Ly>>2]|0)==(d|0),d&=1);0!=(d|0)&&1<(b-60|0)>>>0?(JC(b),DC(Ct|0)):60!=(b|0)?JC(b):(b=IC(),61!=(b|0)&&JC(b))}}function HC(b){var d=(t[Qy>>2]|0)==(t[K+56>>2]|0)?IC():CC();if(58==(d|0)){FC(b,6),t[b+12>>2]=0}else{if(JC(d),d=t[K+56>>2],(t[Qy>>2]|0)==(d|0)|(t[Py>>2]|0)==(d|0)&&0!=((12==(t[b+4>>2]|0)||2==(t[b+4>>2]|0)||7==(t[b+4>>2]|0)?1:3==(t[b+4>>2]|0)?(t[Py>>2]|0)==(t[K+56>>2]|0)&1:0)|0)){mD(b,58)}else{var d=t[b+80>>2],c=0==(d|0);!c&&12==(t[d+4>>2]|0)?(d=nD(At|0),59==(d|0)?FC(b,11):44==(d|0)&&FC(b,5)):(17==(t[MC(b,1)+4>>2]|0)||9==(t[MC(b,2)+4>>2]|0)|c^1)&&BC(b,0)}}}HC.X=1;function LC(b,d){var c=b>>2,e=MC(b,1);if(0==(pA(d)|0)&&!(126==(d|0)||95==(d|0)||36==(d|0))){var f=(t[Ly>>2]|0)==(t[K+56>>2]|0);if(!(-1!=(d|0)&f&191<(d&192)>>>0)){e=45==(d|0);if(2>(d-45|0)>>>0){0==(t[c+8]|0)&&(t[c+9]=1);if(!e){return}c=IC();if(62==(c|0)){return}JC(c);return}if(211==(d|0)){if(0!=(t[c+3]|0)){return}e=b|0;if(2!=(t[e>>2]|0)){return}t[c+1]=9;t[e>>2]=0}else{if(64==(d|0)){if(!f){return}oD(b)}else{if(62==(d|0)||33==(d|0)){c=IC();if(61==(c|0)){return}JC(c)}}}return}}f=t[b+(t[b+44>>2]<<2)+48>>2];kD(f,d);0!=(t[f>>2]|0)&&pD(f,b);f=t[c+15];8==(t[f>>2]|0)&&8==(t[t[((t[c+11]<<2)+48>>2)+c]>>2]|0)&&8==(t[e>>2]|0)&&TC(f)}LC.X=1;function oD(b){var d=t[b+(t[b+44>>2]<<2)+48>>2];kD(d,CC());43==(t[d+4>>2]|0)?t[b+4>>2]=7:qD()}function kD(b,d){var c,e,f=t[b+8>>2];TC(b);e=(f|0)>>2;if((t[Qy>>2]|0)==(t[K+56>>2]|0)&126==(d|0)){c=t[e];var g=f+4|0;if((c+1|0)==(t[g>>2]|0)){R(f);var h=t[e]}else{h=c}c=f+8|0;l[t[c>>2]+h|0]=126;h=t[e]+1|0;t[e]=h;l[t[c>>2]+h|0]=0;h=CC()}else{h=d,g=f+4|0,c=f+8|0}c>>=2;for(var i=1;;){var m=t[e];if((m+1|0)==(t[g>>2]|0)){R(f);var n=t[e]}else{n=m}m=h&255;l[t[c]+n|0]=m;h=0==(h|0);h||(n=t[e]+1|0,t[e]=n,l[t[c]+n|0]=0);if(l[Oz]){if(0==(i|0)){i=t[Vx>>2];n=t[i>>2];if((n+1|0)==(t[i+4>>2]|0)){R(i);var i=n=t[Vx>>2],q=t[n>>2]}else{q=n}n=i+8|0;l[t[n>>2]+q|0]=m;h||(m=i|0,h=t[m>>2]+1|0,t[m>>2]=h,l[t[n>>2]+h|0]=0)}h=0}else{h=i}m=IC();if(0!=(oA(m)|0)){i=h,h=m}else{if(95==(m|0)||36==(m|0)){i=h,h=m}else{i=t[K+56>>2];if(!((t[Ly>>2]|0)==(i|0)|(t[Py>>2]|0)==(i|0))){break}if(-1!=(m|0)&191<(m&192)>>>0|46==(m|0)){i=h,h=m}else{break}}}}h=t[e];(h+1|0)!=(t[g>>2]|0)?(f=t[c],e=f+h|0):(R(f),e=t[e],f=t[c],e=f+e|0);l[e]=0;JC(m);a:{e=j;j+=8;var p,g=e+4,f=b+8|0;c=t[f>>2];m=t[c+8>>2];t[e>>2]=0;t[g>>2]=0;if((t[Ly>>2]|0)==(t[K+56>>2]|0)){var s=c;p=1115}else{if(0==(rD(m,g,e)|0)){if(g=t[e>>2],0==(g|0)){s=t[f>>2],p=1115}else{var r=mC(g,t[K+56>>2]);t[b+4>>2]=r}}else{TC(b);if(0==(t[g>>2]|0)){j=e;break a}if(40!=(CC()|0)){j=e;break a}DC(Mt|0);j=e;break a}}1115==p&&(p=mC(t[s+8>>2],t[K+56>>2]),r=t[b+4>>2]=p);t[(b|0)>>2]=-1==(r|0)?8:7;j=e}}kD.X=1;function qD(){var b=CC();40==(b|0)?DC(Mt|0):JC(b)}function jD(b){var d=b+8|0;if(0!=(t[d>>2]|0)){var c=b+4|0;0==(t[c>>2]|0)&&(t[c>>2]=1)}t[d>>2]=1;t[b+12>>2]=1}function pD(b,d){var c=d>>2,e=t[b+4>>2];if(13==(e|0)){t[c+1]=1}else{if(72==(e|0)){t[c+1]=1}else{if(78==(e|0)){t[c+1]=13}else{if(92==(e|0)){t[c+1]=1}else{if(94==(e|0)){sD(d)}else{if(68==(e|0)){sD(d)}else{if(71==(e|0)){t[c+1]=1}else{if(32==(e|0)){t[c]=3}else{if(27==(e|0)){(t[Py>>2]|0)==(t[K+56>>2]|0)&&(t[c+1]=4)}else{if(87==(e|0)){BC(d,0),t[c]=4}else{if(25==(e|0)){(t[Py>>2]|0)==(t[K+56>>2]|0)&&0!=(t[c+2]|0)||(BC(d,0),t[c]=2,t[c+1]=1)}else{if(6==(e|0)){t[c+1]=1}else{if(10==(e|0)){qD(),c=CC(),123==(c|0)?DC(fu|0):JC(c)}else{if(82==(e|0)){for(c=CC();0!=(pA(c)|0)||126==(c|0)||95==(c|0)||36==(c|0);){kD(b,c),c=CC(),c=46==(c|0)||44==(c|0)?CC():c}JC(c)}else{91==(e|0)?t[c+1]=14:1==(e|0)?t[c+10]=1:56==(e|0)?tD(d):63==(e|0)?uD(d,2):46==(e|0)?t[c+1]=1:36==(e|0)?(mD(d,46),FC(d,0)):65==(e|0)?uD(d,3):66==(e|0)?uD(d,4):73==(e|0)?(e=t[K+56>>2],(t[Ly>>2]|0)==(e|0)|(t[Py>>2]|0)==(e|0)||(BC(d,0),t[c]=1,t[c+1]=1)):8==(e|0)?t[c+1]=1:30==(e|0)||31==(e|0)||35==(e|0)||76==(e|0)||99==(e|0)?40==(CC()|0)&&DC(Mt|0):33==(e|0)?t[c+1]=1:75==(e|0)?t[c+1]=12:74==(e|0)?t[c+1]=1:26==(e|0)?(mD(d,46),FC(d,0)):21==(e|0)?t[c+1]=1:42==(e|0)?t[c+1]=1:43==(e|0)?t[d+4>>2]=7:45==(e|0)?uD(d,1):-1==(e|0)?jD(d):0==(e|0)?(qD(),TC(b)):39==(e|0)?t[c+1]=1:12==(e|0)?t[c+1]=2:23==(e|0)?t[c+1]=3:96==(e|0)?t[c+1]=1:97==(e|0)?t[c+1]=1:98==(e|0)?t[c+1]=1:52==(e|0)?vD(d,8):62==(e|0)?vD(d,10):37==(e|0)?sD(d):95==(e|0)?t[c+10]=2:64==(e|0)?t[c+1]=11:11==(e|0)?t[c+1]=1:29==(e|0)?t[c+1]=1:34==(e|0)&&sD(d)}}}}}}}}}}}}}}}pD.X=1;function mD(b,d){var c,e,f=AC(),g=AC();c=(g+8|0)>>2;var h=f|0,i=f+8|0,m=d&255,n=0==(d|0);a:for(;;){var q=CC();do{if(0==(pA(q)|0)){if(126==(q|0)||95==(q|0)||36==(q|0)){e=1248}else{if((q|0)==(d|0)){var p=t[c],s=t[p>>2];(s+1|0)==(t[p+4>>2]|0)&&(R(p),p=s=t[c],s=t[s>>2]);l[t[p+8>>2]+s|0]=m;if(n){continue a}p=t[c]|0;s=t[p>>2]+1|0;t[p>>2]=s;l[t[t[c]+8>>2]+s|0]=0}else{if(60==(q|0)){DC(Ct|0);continue a}8==(t[h>>2]|0)&&(wD(b,g),TC(g))}}}else{e=1248}}while(0);1248==e&&(e=0,kD(f,q),8==(t[h>>2]|0)?U(t[c],t[t[i>>2]+8>>2]):(wD(b,g),TC(g)));if(-1==(q|0)||123==(q|0)){break}}JC(q);xC(g);xC(f)}mD.X=1;function sD(b){t[b+4>>2]=6;nD(Ft|0)}function uD(b,d){if(0!=(cD(b)|0)){if((t[Qy>>2]|0)==(t[K+56>>2]|0)){var c=CC();58==(c|0)?BC(b,0):JC(c);t[b+72>>2]=d}t[b+68>>2]=d}}function tD(b){var d,c,e,f,g,h;c=MC(b,1);h=t[b+(t[b+44>>2]<<2)+48>>2]>>2;var i=t[h+2],m=CC();7==(t[c>>2]|0)?(c=t[c+4>>2],23==(c|0)||75==(c|0)||91==(c|0)?d=m:f=1275):f=1275;a:do{if(1275==f){if(40==(m|0)){41!=(IC()|0)?(DC(Mt|0),d=IC()):(d=(i|0)>>2,c=t[d],(c+1|0)==(t[i+4>>2]|0)?(R(i),e=t[d]):e=c,c=i+8|0,l[t[c>>2]+e|0]=32,e=t[d]+1|0,t[d]=e,l[t[c>>2]+e|0]=0,d=CC(),40==(d|0)&&(U(i,Mt|0),d=40))}else{do{if(0==(pA(m)|0)&&!(126==(m|0)||95==(m|0)||36==(m|0))){if(0==(bC(Lt|0,m,17)|0)){d=m;break a}d=(i|0)>>2;f=t[d];g=(i+4|0)>>2;(f+1|0)==(t[g]|0)?(R(i),c=t[d]):c=f;f=(i+8|0)>>2;l[t[f]+c|0]=32;c=t[d]+1|0;t[d]=c;for(l[t[f]+c|0]=0;;){var n=t[d];(n+1|0)==(t[g]|0)&&(R(i),n=t[d]);l[t[f]+n|0]=m&255;0!=(m|0)&&(n=t[d]+1|0,t[d]=n,l[t[f]+n|0]=0);n=IC();if(0==(bC(Lt|0,n,17)|0)){break}else{m=n}}m=t[d];(m+1|0)==(t[g]|0)?(R(i),i=t[d]):i=m;l[t[f]+i|0]=0;d=n;break a}}while(0);e=(i|0)>>2;c=(i+4|0)>>2;d=(i+8|0)>>2;for(var q=1,p=m;;){if(0==(L(p)|0)?(0!=(q|0)&&(g=t[e],(g+1|0)==(t[c]|0)&&(R(i),g=t[e]),l[t[d]+g|0]=32,g=t[e]+1|0,t[e]=g,l[t[d]+g|0]=0),g=t[e],(g+1|0)==(t[c]|0)&&(R(i),g=t[e]),l[t[d]+g|0]=p&255,0!=(p|0)&&(g=t[e]+1|0,t[e]=g,l[t[d]+g|0]=0),p=0):p=1,g=IC(),0==(bC(It|0,g,3)|0)&-1!=(g|0)){q=p,p=g}else{break}}p=t[e];(p+1|0)==(t[c]|0)?(R(i),c=t[e]):c=p;l[t[d]+c|0]=0;d=g}}}while(0);JC(d);t[h]=8;t[h+1]=-1;jD(b)}tD.X=1;function vD(b,d){var c=b>>2;t[c+1]=d;if(!(8==(d|0)&&(t[Py>>2]|0)!=(t[K+56>>2]|0))){var e=t[((t[c+11]<<2)+48>>2)+c];xD(e,CC());t[e>>2]=8;t[c+2]=1;t[c+3]=1}}function xD(b,d){var c,e,f=t[b+8>>2];TC(b);e=(f|0)>>2;var g=f+4|0;c=(f+8|0)>>2;for(var h=d;0!=(oA(h)|0)||95==(h|0)||36==(h|0)||46==(h|0);){var i=t[e];(i+1|0)==(t[g>>2]|0)&&(R(f),i=t[e]);l[t[c]+i|0]=h&255;0!=(h|0)&&(h=t[e]+1|0,t[e]=h,l[t[c]+h|0]=0);h=IC()}i=t[e];(i+1|0)!=(t[g>>2]|0)?(c=t[c],c=c+i|0):(R(f),e=t[e],c=t[c],c=c+e|0);l[c]=0;JC(h)}xD.X=1;function nD(b){for(var d;;){var c=IC();if(-1==(c|0)||0==(c|0)){d=1351;break}if(0!=(mA(b,c)|0)){d=1350;break}}if(1350==d||1351==d){return c}}function AC(){var b=zC(20);t[b+8>>2]=P();TC(b);return b}function wD(b,d){var c,e=d+8|0,f=t[e>>2];c=(b+76|0)>>2;if(0==(t[f>>2]|0)){e=f}else{var g=t[c],h=t[g>>2];0==(h|0)?e=f:((h+1|0)==(t[g+4>>2]|0)?(R(g),f=h=t[c],h=t[h>>2]):f=g,l[t[f+8>>2]+h|0]=44,h=t[c]|0,f=t[h>>2]+1|0,t[h>>2]=f,l[t[t[c]+8>>2]+f|0]=0,e=t[e>>2])}U(t[c],t[e+8>>2])}function iD(b,d){var c,e,f,g,h,i,m=t[b+(t[b+44>>2]<<2)+48>>2];l[Oz]=1;f=t[Vx>>2];S(f);e=t[f>>2];(e+1|0)==(t[f+4>>2]|0)?(R(f),f=e=t[Vx>>2],g=t[e>>2]):g=e;e=f+8|0;l[t[e>>2]+g|0]=40;f|=0;g=t[f>>2]+1|0;t[f>>2]=g;l[t[e>>2]+g|0]=0;h=(d+24|0)>>2;t[h]=1;g=(d+4|0)>>2;f=(d+8|0)>>2;e=(d+12|0)>>2;var n=d+16|0;c=(m|0)>>2;var q=m+4|0,p=d+20|0,s=d|0,r=1,u=1,v=0;a:for(;;){var w=CC(),C=t[Vx>>2],A=t[C>>2];if((A+1|0)==(t[C+4>>2]|0)){R(C);var C=A=t[Vx>>2],I=t[A>>2]}else{I=A}A=C+8|0;l[t[A>>2]+I|0]=w&255;do{if(0==(w|0)){i=1395}else{var I=C|0,M=t[I>>2]+1|0;t[I>>2]=M;l[t[A>>2]+M|0]=0;if(38==(w|0)||42==(w|0)){t[s>>2]=1;t[f]=0;0==(v|0)&&(t[g]=0);TC(m);var B=u,G=v}else{if(44==(w|0)){t[e]=0,0==(t[f]|0)?(B=u,G=v):(t[h]=t[h]+1|0,B=u,G=0)}else{if(61==(w|0)){if(t[f]=0,t[e]=0,0==(r|0)){B=u,G=v}else{i=1378;break a}}else{if(91==(w|0)){t[f]=0,DC(Fq|0),B=u,G=v}else{if(60==(w|0)){t[f]=0,GC(),B=u,G=v}else{if(41==(w|0)){0!=(r|0)&&(t[h]=0),B=u-1|0,G=v}else{if(40==(w|0)){t[f]=0;if(0!=(r|0)){i=1385;break a}10!=(t[c]|0)?B=u+1|0:(B=CC(),42!=(B|0)?(JC(B),JC(40),t[p>>2]=1):(DC(Mt|0),B=CC(),40==(B|0)?DC(Mt|0):JC(B)),B=u);G=v}else{64==(w|0)?(t[Ly>>2]|0)!=(t[K+56>>2]|0)?i=1395:(oD(b),B=u,G=v):58==(w|0)?(t[f]=0,B=u,G=v):46==(w|0)?(t[e]=0,B=IC(),46!=(B|0)?(JC(B),t[f]=0):(B=IC(),46==(B|0)?U(t[Vx>>2],pt|0):(JC(B),t[f]=0)),B=u,G=v):i=1395}}}}}}}}}while(0);b:do{if(1395==i){i=0;do{if(0==(pA(w)|0)&&!(126==(w|0)||95==(w|0)||36==(w|0))){t[g]=0;t[f]=0;t[e]=0;t[n>>2]=1;B=u;G=v;break b}}while(0);var Z=v+1|0;1<Z>>>0&&(t[f]=0);kD(m,w);B=t[c];8==(B|0)?0!=(t[e]|0)&&(t[c]=10):7==(B|0)&&(B=t[q>>2],13==(B|0)||97==(B|0)||(t[f]=0,t[e]=0));B=u;G=Z}}while(0);u=t[p>>2];Z=0==(B|0);if(0!=(u|0)|Z){var X=u;i=1408;break}if(0!=(t[f]|0)){r=0,u=B,v=G}else{if(0==(t[e]|0)){X=0;i=1408;break}else{r=0,u=B,v=G}}}a:do{if(1378==i){t[g]=0,yD(b)}else{if(1385==i){t[e]=0,JC(40),S(C),yD(b),zD(t[Vx>>2])}else{if(1408==i&&!(0!=(X|0)|Z)){for(G=B;;){if(DC(Mt|0),G=G-1|0,0==(G|0)){break a}}}}}}while(0);0==(t[e]|0)&&TC(m);i=t[Vx>>2];m=t[i>>2];(m+1|0)==(t[i+4>>2]|0)&&(R(i),i=m=t[Vx>>2],m=t[m>>2]);l[t[i+8>>2]+m|0]=0;0!=(t[f]|0)&&S(i);l[Oz]=0}iD.X=1;function lD(b,d){var c,e=t[b+(t[b+44>>2]<<2)+48>>2],f=d+24|0,g=t[f>>2],h=e+4|0,i=e|0,m=d+8|0,n=e+8|0,q=CC(),p=0,s=0;a:for(;;){do{if(123==(q|0)){c=1463;break a}else{if(91==(q|0)){DC(Fq|0);var r=s,u=g,v=p}else{if(58==(q|0)){r=e;for(u=ba;;){var w=CC();b:for(;;){do{if(0==(pA(w)|0)){if(36==(w|0)||95==(w|0)||126==(w|0)){u=1494}else{if(60==(w|0)){u=1496;break b}else{if(58!=(w|0)){var C=w;break b}}}}else{58!=(w|0)&&(u=1494)}}while(0);1494==u&&(u=0,kD(r,w));w=CC()}1496==u&&(u=0,DC(Ct|0),C=CC());40==(C|0)?(DC(Mt|0),w=CC()):w=C;if(44!=(w|0)){break}}JC(w);r=s;u=g;v=p}else{if(40==(q|0)){DC(Mt|0),r=0==(s|0)?0:s+1|0,u=g,v=p}else{if(59==(q|0)){if(0==(g|0)|2>s>>>0){c=1467;break a}var A=g-1|0,I=0==(A|0)&1,M=p,B=s;c=1481}else{if(61==(q|0)){c=1462;break a}else{if(125==(q|0)){c=1464;break a}else{if(41==(q|0)){r=s,u=g,v=p}else{if(0==(pA(q)|0)&&!(126==(q|0)||95==(q|0)||36==(q|0))){r=s,u=g,v=p}else{kD(e,q);var G=t[h>>2];if(0==(G|0)){qD(),r=s,u=g,v=p}else{if(10==(G|0)||12==(G|0)||24==(G|0)||25==(G|0)||32==(G|0)||38==(G|0)||51==(G|0)||52==(G|0)||53==(G|0)||54==(G|0)||56==(G|0)||58==(G|0)||63==(G|0)||65==(G|0)||66==(G|0)||73==(G|0)||79==(G|0)||87==(G|0)||88==(G|0)||94==(G|0)||95==(G|0)){var Z=q;break a}else{if(81==(G|0)){qD(),r=s,u=g,v=p}else{if(86==(G|0)){r=s,u=g,v=p}else{if(13==(G|0)||97==(G|0)){r=t[Vx>>2],u=t[r>>2],0!=(u|0)&&((u+1|0)==(t[r+4>>2]|0)?(R(r),r=u=t[Vx>>2],v=t[u>>2]):v=u,u=r+8|0,l[t[u>>2]+v|0]=32,v=r|0,G=t[v>>2]+1|0,t[v>>2]=G,l[t[u>>2]+G|0]=0,U(r,t[t[n>>2]+8>>2])),r=s,u=g,v=p}else{if(0==(t[i>>2]|0)){r=s,u=g,v=p}else{if(0==(t[m>>2]|0)){Z=q;break a}M=0==(t[f>>2]|0);I=c=M&1;M=M?1:p;A=g;B=(c^1)+s|0;c=1481}}}}}}}}}}}}}}}}while(0);if(1481==c){if(c=0,0==(I|0)){r=B,u=A,v=M}else{var X=M,ga=q;c=1483;break}}q=CC();if(-1==(q|0)){X=v;ga=-1;c=1483;break}else{p=v,g=u,s=r}}1463==c?(JC(123),X=p,ga=123,c=1483):1462==c?(JC(61),X=p,ga=61,c=1483):1467==c?(JC(59),X=p,ga=59,c=1483):1464==c&&(JC(125),X=p,ga=125,c=1483);if(1483==c){if(0!=(X|0)){Z=ga}else{return FC(b,0),Z=-1!=(ga|0),Z&1}}e=AC();f=b+44|0;VC(e,t[b+(t[f>>2]<<2)+48>>2]);BC(b,0);f=t[b+(t[f>>2]<<2)+48>>2];VC(f,e);xC(e);pD(f,b);Z=-1!=(Z|0);return Z&1}lD.X=1;function yD(b){if(8==(t[MC(b,2)>>2]|0)){var d=b+44|0,c=t[d>>2];t[d>>2]=0==(c|0)?2:c-1|0;FC(b,0)}DC(Mt|0)}function AD(b,d){var c,e,f=j;j+=4;var g;e=f>>2;var h=d,i=b;a:for(;;){t[e]=i;i=l[i];if(0==i<<24>>24){var m=h;g=1561;break}i=0==(L(i&255)|0);b:do{if(!i){for(;;){var n=t[e]+1|0;t[e]=n;if(0==(L(l[n]&255)|0)){break b}}}}while(0);do{if(6==(h|0)||7==(h|0)){for(var q=t[e];;){var p=l[q];if(59==p<<24>>24||0==p<<24>>24){break}var s=q+1|0,q=t[e]=s}s=59==p<<24>>24?0:h}else{if(10==(h|0)){m=10;g=1562;break a}else{if(1==(h|0)){i=t[e],47!=l[i]<<24>>24?(s=1,q=i):(c=42!=l[i-1|0]<<24>>24&1,g=1558)}else{if(5==(h|0)){for(q=t[e];;){var r=l[q];if(123==r<<24>>24||0==r<<24>>24){break}s=q+1|0;q=t[e]=s}s=123==r<<24>>24?0:5}else{if(0==(h|0)){if(0!=(oA(l[t[e]]&255)|0)){c=BD(f,1),g=1558}else{if(i=t[e],n=l[i],46==n<<24>>24){c=BD(f,0),g=1558}else{if(35==n<<24>>24){c=BD(f,2),g=1558}else{if(64==n<<24>>24){t[e]=i+1|0;g=P();i=0==(L(l[t[e]]&255)|0);c=(g|0)>>2;var n=t[c],u=g+4|0,v=(n+1|0)==(t[u>>2]|0);b:do{if(i){for(var w=g+8|0,C=v,A=n;;){C&&(R(g),A=t[c]);l[t[w>>2]+A|0]=l[t[e]];A=t[e];0!=l[A]<<24>>24&&(A=t[c]+1|0,t[c]=A,l[t[w>>2]+A|0]=0,A=t[e]);C=A+1|0;t[e]=C;var A=t[c],I=(A+1|0)==(t[u>>2]|0);if(0==(L(l[C]&255)|0)){C=I}else{var M=I,B=A;break b}}}else{M=v,B=n}}while(0);M?(R(g),c=t[c]):c=B;i=g+8|0;l[t[i>>2]+c|0]=0;c=t[i>>2];c=0==(qA(c,ur|0)|0)?5:0==(qA(c,Yv|0)|0)?6:0==(qA(c,wl|0)|0)?7:0==(qA(c,ak|0)|0)?8:0==(qA(c,qi|0)|0)?9:0;Q(g);g=1558}else{42==n<<24>>24?(c=47==l[i-1|0]<<24>>24&1,g=1558):(s=0,q=i)}}}}}else{8==(h|0)||9==(h|0)||4==(h|0)?(i=t[e],n=l[i],39==n<<24>>24?(c=2,g=1558):125==n<<24>>24?(s=0,q=i):(c=34==n<<24>>24?3:h,g=1558)):3==(h|0)?(i=t[e],34!=l[i]<<24>>24?(s=3,q=i):(c=92==l[i-1|0]<<24>>24?3:4,g=1558)):2==(h|0)?(i=t[e],39!=l[i]<<24>>24?(s=2,q=i):(c=92==l[i-1|0]<<24>>24?2:4,g=1558)):(c=h,g=1558)}}}}}}while(0);1558==g&&(g=0,s=c,q=t[e]);if(0==(q|0)){m=s;g=1563;break}else{h=s,i=q+1|0}}if(1563==g||1561==g||1562==g){return j=f,m}}AD.X=1;function BD(b,d){var c,e=b>>2,f,g=P();c=(g|0)>>2;var h=g+4|0,i=g+8|0,m=t[e];a:for(;;){if(0==(oA(l[m]&255)|0)){if(0!=(L(l[m]&255)|0)){var n=1}else{n=l[m],n=95==n<<24>>24||45==n<<24>>24||43==n<<24>>24||62==n<<24>>24||123==n<<24>>24||46==n<<24>>24||44==n<<24>>24||58==n<<24>>24||42==n<<24>>24||35==n<<24>>24?1:0}}else{n=1}var n=0==(n|0),q=l[m];do{if(n){if(0==q<<24>>24){f=1568}else{f=1577;break a}}else{if(0==q<<24>>24){f=1568}else{if(44==q<<24>>24){f=1570;break a}else{if(123==q<<24>>24){f=1571;break a}else{var p=m}}}}}while(0);if(1568==f&&(f=0,p=eC(),0==(p|0))){f=1569;break}m=t[c];(m+1|0)==(t[h>>2]|0)&&(R(g),m=t[c]);l[t[i>>2]+m|0]=l[p];0!=l[p]<<24>>24&&(m=t[c]+1|0,t[c]=m,l[t[i>>2]+m|0]=0);m=p+1|0}if(1570==f){return CD(g,d),t[e]=m+1|0,0}if(1571==f){return CD(g,d),t[e]=m+1|0,4}if(1569==f){return CD(g,d),t[e]=0,10}if(1577==f){return CD(g,d),t[e]=m,0}}BD.X=1;function CD(b,d){0==(d|0)&&DD(b);var c=b|0,e=t[c>>2];(e+1|0)==(t[b+4>>2]|0)?(R(b),c=t[c>>2]):c=e;l[t[b+8>>2]+c|0]=0;jC(b,Hz|0,d);S(b);Q(b)}function ED(){var b,d=zC(24);b=d>>2;t[b]=0;t[b+1]=-1;t[b+2]=1;t[b+3]=P();t[b+4]=P();t[b+5]=P();return d}function FD(b,d){var c=b+4|0;if((t[c>>2]|0)!=(d|0)){for(;!(GD(b),(t[c>>2]|0)==(d|0));){}}}function HD(b){Q(t[b+12>>2]);Q(t[b+16>>2]);Q(t[b+20>>2]);vB(b)}function ID(b){for(var d=b|0,c=0;;){var e=t[d>>2];15==(e|0)?(GD(b),c=c+1|0):4==(e|0)?(GD(b),c=c-1|0):JD(b);if(0==(c|0)){break}}}function KD(b){var d,c;if(0==(LD(b)|0)){return 0}for(c=(b|0)>>2;!(MD(b),GD(b),7==(t[c]|0)&&GD(b),0==(LD(b)|0));){}d=(b+4|0)>>2;0==(t[d]|0)&&(GD(b),22==(t[c]|0)&&MD(b),GD(b));var e=t[c];if(16==(e|0)){e=b|0;if(5!=(t[e>>2]|0)){for(;!(GD(b),5==(t[e>>2]|0));){}}GD(b);e=t[c]}6==(e|0)&&ND(b);e=t[d];4==(e|0)?(GD(b),GD(b),d=t[d]):d=e;39==(d|0)&&(GD(b),22==(t[c]|0)&&GD(b));a:{var f;c=(b+4|0)>>2;e=t[c];if(d=34==(e|0)){GD(b),e=t[c]}if(13==(e|0)||15==(e|0)||22==(e|0)||36==(e|0)||39==(e|0)||41==(e|0)||46==(e|0)){f=1;for(d=e;;){if(36==(d|0)){d=b;GD(d);for(var e=d+4|0,g=d|0;;){var h=t[e>>2];if(15==(h|0)||41==(h|0)){break}11==(t[g>>2]|0)&&OD(d);GD(d);6==(t[g>>2]|0)&&ND(d)}}else{f=18==(d|0)?f-1|0:6==(d|0)||12==(d|0)||25==(d|0)||27==(d|0)||32==(d|0)?f+1|0:f}GD(b);if(0>=(f|0)){break}d=t[c]}}else{c=17==(t[b>>2]|0);if(d){c&&(f=1714)}else{if(c){f=1714}else{break a}}1714==f&&GD(b);GD(b)}}return 1}KD.X=1;function LD(b){var d=b+4|0;26==(t[d>>2]|0)&&GD(b);var c=b|0;if(11==(t[c>>2]|0)){b=1}else{if(d=t[d>>2],4==(d|0)){b=1}else{if(30!=(d|0)&&43!=(d|0)){b=0}else{return GD(b),22==(t[c>>2]|0)&1}}}return b}function MD(b){var d,c,e,f=j;j+=80;e=f>>2;if(0!=(t[Cz+16>>2]|0)&&(c=b+8|0,0!=(t[oy+8>>2]|t[c>>2]|0))){var g=b+12|0;sC(f,t[t[g>>2]+8>>2]);t[e+4]=0==(t[c>>2]|0)&1;t[e+9]=t[Cz+24>>2];l[f+40|0]=t[Cz+20>>2]&255;t[e+15]=t[Cz+8>>2];c=b+16|0;t[e+16]=t[t[c>>2]+8>>2];tC(f);if(0!=(t[oy+4>>2]|0)){var h=PD(t[t[c>>2]+8>>2]);c=(h|0)>>2;d=t[c];if((d+1|0)==(t[h+4>>2]|0)){R(h);var i=t[c]}else{i=d}d=(h+8|0)>>2;l[t[d]+i|0]=46;i=t[c]+1|0;t[c]=i;l[t[d]+i|0]=0;U(h,t[t[g>>2]+8>>2]);t[e+8]=t[d];tC(f);Q(h)}}V(t[b+20>>2],t[t[b+12>>2]+8>>2]);j=f}MD.X=1;function ND(b){GD(b);var d=t[b>>2];(1==(d|0)||19==(d|0))&&GD(b);JD(b)}function GD(b){var d,c;d=(b|0)>>2;t[d]=0;var e=b+4|0;t[e>>2]=-1;b=(b+12|0)>>2;for(S(t[b]);;){var f=T();if(92==(f|0)){c=1761;break}else{if(34==(f|0)){c=1765;break}else{if(39==(f|0)){c=1766;break}else{if(36==(f|0)){c=1729;break}else{if(41==(f|0)){c=1727;break}else{if(32==(f|0)||10==(f|0)||9==(f|0)){continue}else{if(62==(f|0)){c=1753;break}else{if(46==(f|0)){c=1730;break}else{if(63==(f|0)||58==(f|0)){c=1742;break}else{if(93==(f|0)){c=1726;break}else{if(33==(f|0)){c=1724;break}else{if(125==(f|0)){c=1725;break}else{if(126==(f|0)){c=1734;break}else{if(44==(f|0)){c=1728;break}else{if(-1==(f|0)){c=1722;break}else{if(59==(f|0)){c=1723;break}else{if(40==(f|0)){c=1733;break}else{if(91==(f|0)){c=1732;break}else{if(43==(f|0)||42==(f|0)||94==(f|0)||61==(f|0)){c=1735;break}else{if(47==(f|0)){c=1757;break}else{if(60==(f|0)){c=1749;break}else{if(123==(f|0)){c=1731;break}else{if(45!=(f|0)){c=1767;break}}}}}}}}}}}}}}}}}}}}}}}var g=T();if(62==(g|0)){c=1737;break}else{if(45!=(g|0)){c=1739;break}}QD(10)}if(1739==c){0==(L(g)|0)&&W(g),t[d]=17}else{if(1761==c){var h=T();92!=(h|0)&&0==(L(h)|0)&&W(h);t[d]=17}else{if(1765==c){t[d]=22,RD(t[b])}else{if(1766==c){t[d]=2,37==(T()|0)&&SD(),39!=(T()|0)&&QD(10)}else{if(1729==c){t[d]=10}else{if(1727==c){t[d]=5}else{if(1753==c){h=T(),1<(h-61|0)>>>0&&0==(L(h)|0)&&W(h),t[d]=17}else{if(1730==c){t[d]=9}else{if(1742==c){h=T(),61==(h|0)?t[d]=17:(0==(L(h)|0)&&W(h),t[d]=58==(f|0)?6:19)}else{if(1726==c){t[d]=4}else{if(1724==c){t[d]=1}else{if(1725==c){t[d]=3}else{if(1734==c){t[d]=23}else{if(1767==c){if(0!=(pA(f)|0)){TD(t[b],f),h=UD(t[b],t[Oy>>2]),t[e>>2]=h,t[d]=-1==(h|0)?11:12}else{if(10>(f-48|0)>>>0){h=VD(f),U(t[b],t[h+8>>2]),Q(h),t[d]=13}else{if(124==(f|0)||64==(f|0)||38==(f|0)||35==(f|0)){b=t[b];c=(b|0)>>2;g=b+4|0;for(e=(b+8|0)>>2;;){if(h=t[c],(h+1|0)==(t[g>>2]|0)&&(R(b),h=t[c]),l[t[e]+h|0]=f&255,0!=(f|0)&&(h=t[c]+1|0,t[c]=h,l[t[e]+h|0]=0),h=T(),32<(h|0)){f=h}else{break}}f=t[c];(f+1|0)==(t[g>>2]|0)&&(R(b),f=t[c]);l[t[e]+f|0]=0;0==(L(h)|0)&&W(h);t[d]=17}else{t[d]=0}}}}else{1728==c?t[d]=7:1722==c?dB(tz|0,1):1723==c?t[d]=20:1733==c?t[d]=16:1732==c?t[d]=15:1735==c?t[d]=17:1757==c?(h=T(),!(61==(h|0)||47==(h|0))&&0==(L(h)|0)&&W(h),t[d]=17):1737==c?t[d]=8:1749==c?(h=T(),1<(h-61|0)>>>0&&0==(L(h)|0)&&W(h),t[d]=17):1731==c&&(t[d]=14)}}}}}}}}}}}}}}}GD.X=1;function OD(b){var d,c,e,f=j;j+=80;e=f>>2;if(0!=(t[Cz+32>>2]|0)&0!=(t[oy+8>>2]|0)){c=t[t[b+12>>2]+8>>2];var g=P();sC(f,c);t[e+4]=1;t[e+9]=t[Cz+40>>2];l[f+40|0]=t[Cz+36>>2]&255;V(g,t[t[b+16>>2]+8>>2]);c=(g|0)>>2;d=t[c];if((d+1|0)==(t[g+4>>2]|0)){R(g);var h=t[c]}else{h=d}d=(g+8|0)>>2;l[t[d]+h|0]=46;h=t[c]+1|0;t[c]=h;l[t[d]+h|0]=0;U(g,t[t[b+20>>2]+8>>2]);t[e+15]=t[Cz+24>>2];t[e+16]=t[d];tC(f);Q(g)}j=f}OD.X=1;function JD(b){var d,c,e=ED();c=e>>2;WD(e,b);GD(b);d=(b|0)>>2;6==(t[d]|0)&&(GD(e),GD(b));var f=t[c+1];if(35==(f|0)){if(11!=(t[d]|0)&&11!=(t[b+4>>2]|0)){HD(e);return}GD(b)}else{if(5==(f|0)||14==(f|0)||20==(f|0)){WD(e,b),GD(b)}11==(t[c]|0)&&(15==(t[d]|0)?ID(b):0==(qA(fi|0,t[t[c+3]+8>>2])|0)&&GD(b))}HD(e)}function WD(b,d){var c=d>>2,e=b>>2;t[e]=t[c];t[e+1]=t[c+1];t[e+2]=t[c+2];V(t[e+3],t[t[c+3]+8>>2]);V(t[e+4],t[t[c+4]+8>>2]);V(t[e+5],t[t[c+5]+8>>2])}function QD(b){for(;;){var d=T();if(-1==(d|0)|(d|0)==(b|0)){break}}}function RD(b){var d,c,e,f,g,h,i,m=P(),n=P();h=(n+8|0)>>2;g=(m+8|0)>>2;f=(m|0)>>2;var q=m+4|0;e=(b+8|0)>>2;c=(b|0)>>2;var p=b+4|0;d=(n|0)>>2;var s=n+4|0,r=0,u=0,v=0;a:for(;;){var v=91==(v|0),w=0;b:for(;;){for(var C=0==(r|0),A=w;;){if(0!=(A|0)){break a}A=T();if(10==(A|0)){i=1866;break b}else{if(37==(A|0)){i=1874;break b}else{if(-1==(A|0)){A=1;continue}else{if(34!=(A|0)){var I=u,M=r,B=A;break b}}}}if(C){r=0;w=1;continue b}if(A=0==(qA(t[h],t[g])|0)){A&=1}else{I=u;M=r;B=34;break b}}}b:do{if(1866==i){if(i=0,C||S(n),v?(S(m),S(n),w=t[f],(w+1|0)==(t[q>>2]|0)&&(R(m),w=t[f]),l[t[g]+w|0]=93,w=t[f]+1|0,t[f]=w,l[t[g]+w|0]=0,gD(m,t[e],t[c]-1|0),S(b),A=w=1):(w=r,A=u),0==(w|0)|0==(A|0)){I=A,M=w,B=10}else{for(;;){var G=T();if(0==(L(G)|0)){I=A;M=w;B=G;break b}}}}else{1874==i&&(i=0,I=u,M=r,B=SD())}}while(0);u=t[c];(u+1|0)==(t[p>>2]|0)?(R(b),v=t[c]):v=u;u=B&255;l[t[e]+v|0]=u;v=0==(B|0);v||(r=t[c]+1|0,t[c]=r,l[t[e]+r|0]=0);0==(M|0)?r=0:(r=t[d],(r+1|0)==(t[s>>2]|0)&&(R(n),r=t[d]),l[t[h]+r|0]=u,v||(u=t[d]+1|0,t[d]=u,l[t[h]+u|0]=0),u=t[d],(u+1|0)==(t[s>>2]|0)&&(R(n),u=t[d]),l[t[h]+u|0]=0,r=M);u=I;v=B}d=t[c];(d+1|0)!=(t[p>>2]|0)?(e=t[e],e=e+d|0):(R(b),b=t[c],e=t[e],e=e+b|0);l[e]=0;Q(n);Q(m)}RD.X=1;function TD(b,d){var c,e;e=(b|0)>>2;var f=b+4|0;c=(b+8|0)>>2;for(var g=d;;){var h=t[e];(h+1|0)==(t[f>>2]|0)&&(R(b),h=t[e]);l[t[c]+h|0]=g&255;0!=(g|0)&&(g=t[e]+1|0,t[e]=g,l[t[c]+g|0]=0);h=T();if(0!=(oA(h)|0)|95==(h|0)){g=h}else{break}}g=t[e];(g+1|0)==(t[f>>2]|0)?(R(b),e=t[e]):e=g;l[t[c]+e|0]=0;0==(L(h)|0)&&W(h)}TD.X=1;function VD(b){var d,c=P();d=c>>2;b=XD(b);V(c,t[b+8>>2]);Q(b);b=T();if(46==(b|0)){var e=XD(0),b=(c|0)>>2,f=t[b];if((f+1|0)==(t[d+1]|0)){R(c);var g=t[b]}else{g=f}f=c+8|0;l[t[f>>2]+g|0]=46;g=t[b]+1|0;t[b]=g;l[t[f>>2]+g|0]=0;U(c,t[e+8>>2]);Q(e);f=T()}else{f=b}if(101==(rA(f)|0)){e=XD(0);b=(c|0)>>2;g=t[b];if((g+1|0)==(t[d+1]|0)){R(c);var h=t[b]}else{h=g}g=c+8|0;l[t[g>>2]+h|0]=f&255;0!=(f|0)&&(f=t[b]+1|0,t[b]=f,l[t[g>>2]+f|0]=0);U(c,t[e+8>>2]);Q(e)}else{0==(L(f)|0)&&W(f)}e=c|0;b=t[e>>2];if((b+1|0)!=(t[d+1]|0)){return d=t[(c+8|0)>>2],d=d+b|0,l[d]=0,c}R(c);b=t[e>>2];d=t[(c+8|0)>>2];d=d+b|0;l[d]=0;return c}VD.X=1;function XD(b){var d,c,e=P(),b=0==(b|0)?T():b;if(45==(b|0)){b=(e|0)>>2;d=t[b];if((d+1|0)==(t[e+4>>2]|0)){R(e);var f=t[b]}else{f=d}d=e+8|0;l[t[d>>2]+f|0]=45;f=t[b]+1|0;t[b]=f;l[t[d>>2]+f|0]=0;var g=T()}else{g=10>(b-48|0)>>>0?b:T()}d=(e|0)>>2;f=e+4|0;for(b=(e+8|0)>>2;;){if(-1==(g|0)){c=1953;break}var h=t[d],i=(h+1|0)==(t[f>>2]|0);if(!(95==(g|0)|10>(g-48|0)>>>0)){c=1960;break}if(i){R(e);var m=t[d]}else{m=h}l[t[b]+m|0]=g&255;0!=(g|0)&&(g=t[d]+1|0,t[d]=g,l[t[b]+g|0]=0);g=T()}if(1953==c){var n=t[d];if((n+1|0)==(t[f>>2]|0)){n=-1}else{return c=t[b],h=c+n|0,l[h]=0,W(-1),e}}else{if(1960==c){if(i){n=g}else{return c=t[b],h=c+h|0,l[h]=0,W(g),e}}}R(e);h=t[d];c=t[b];h=c+h|0;l[h]=0;W(n);return e}XD.X=1;function SD(){var b=T();if(72==(b|0)){b=92}else{if(66==(b|0)){b=8}else{if(82==(b|0)){b=13}else{if(81==(b|0)){b=96}else{if(76==(b|0)){b=126}else{if(70==(b|0)){b=12}else{if(86==(b|0)){b=124}else{if(84==(b|0)){b=9}else{if(41==(b|0)){b=93}else{if(62==(b|0)){b=125}else{if(65==(b|0)){b=64}else{if(78==(b|0)){b=10}else{if(83==(b|0)){b=35}else{if(37!=(b|0)&&39!=(b|0)){if(68==(b|0)){b=36}else{if(60==(b|0)){b=123}else{if(34!=(b|0)){if(10==(b|0)){QD(37),b=0}else{if(40==(b|0)){b=91}else{if(47==(b|0)){var b=XD(0),d;for(d=t[b+8>>2];L(l[d]);){d++}var c=1;45==l[d]?(c=-1,d++):43==l[d]&&d++;var e=10;!e&&48==l[d]&&(120==l[d+1]||88==l[d+1]?(e=16,d+=2):(e=8,d++));e||(e=10);for(var f,g=0;0!=(f=l[d])&&!(f=parseInt(String.fromCharCode(f),e),isNaN(f));){g=g*e+f,d++}g*=c;if(2147483647<g||-2147483648>g){g=2147483647<g?2147483647:-2147483648,FA(DA)}d=g;Q(b);return 47==(T()|0)&256>d>>>0?d:0}b=67==(b|0)?94:0}}}}}}}}}}}}}}}}}}}return b}function YD(b,d){var c;S(d);var e=0==((0!=(oA(l[b]&255)|0)|95==(l[b]&255|0)|58==(l[b]&255|0))&1|0);c=(d|0)>>2;var f=t[c],g=d+4|0,h=(f+1|0)==(t[g>>2]|0);a:do{if(e){var i=b,m=h,n=f}else{for(var q=d+8|0,p=b,s=h,r=f;;){if(s&&(R(d),r=t[c]),l[t[q>>2]+r|0]=l[p],0!=l[p]<<24>>24&&(r=t[c]+1|0,t[c]=r,l[t[q>>2]+r|0]=0),p=p+1|0,r=t[c],s=(r+1|0)==(t[g>>2]|0),0==((0!=(oA(l[p]&255)|0)|95==(l[p]&255|0)|58==(l[p]&255|0))&1|0)){i=p;m=s;n=r;break a}}}}while(0);if(!m){return c=t[(d+8|0)>>2],n=c+n|0,l[n]=0,i}R(d);n=t[c];c=t[(d+8|0)>>2];n=c+n|0;l[n]=0;return i}YD.X=1;function ZD(b,d){var c=P();YD(b,c);jC(c,Az|0,d);Q(c)}function $D(){var b,d,c,e=P(),f=eC();if(0!=(f|0)){c=(e|0)>>2;d=(e+4|0)>>2;for(b=(e+8|0)>>2;;){do{if(35!=l[f]<<24>>24){if(0==(N(f,Cf|0,8)|0)){var g=aE(f+8|0),h=0==(bE(l[g]&255)|0),i=t[c],m=(i+1|0)==(t[d]|0);a:do{if(h){var n=m,q=i}else{for(var p=g,s=m,r=i;;){if(s&&(R(e),r=t[c]),l[t[b]+r|0]=l[p],0!=l[p]<<24>>24&&(r=t[c]+1|0,t[c]=r,l[t[b]+r|0]=0),p=p+1|0,r=t[c],s=(r+1|0)==(t[d]|0),0==(bE(l[p]&255)|0)){n=s;q=r;break a}}}}while(0);n?(R(e),g=t[c]):g=q;l[t[b]+g|0]=0;jC(e,nz|0,1);S(e)}else{if(0==(N(f,Fi|0,5)|0)){g=aE(f+5|0);h=0==(bE(l[g]&255)|0);i=t[c];m=(i+1|0)==(t[d]|0);a:do{if(h){var u=m,v=i}else{p=g;s=m;for(r=i;;){if(s&&(R(e),r=t[c]),l[t[b]+r|0]=l[p],0!=l[p]<<24>>24&&(r=t[c]+1|0,t[c]=r,l[t[b]+r|0]=0),p=p+1|0,r=t[c],s=(r+1|0)==(t[d]|0),0==(bE(l[p]&255)|0)){u=s;v=r;break a}}}}while(0);u?(R(e),g=t[c]):g=v;l[t[b]+g|0]=0;jC(e,nz|0,0);S(e)}else{if(0==(N(f,Uj|0,4)|0)){g=aE(f+4|0);h=0==(bE(l[g]&255)|0);i=t[c];m=(i+1|0)==(t[d]|0);a:do{if(h){var w=m,C=i}else{p=g;s=m;for(r=i;;){if(s&&(R(e),r=t[c]),l[t[b]+r|0]=l[p],0!=l[p]<<24>>24&&(r=t[c]+1|0,t[c]=r,l[t[b]+r|0]=0),p=p+1|0,r=t[c],s=(r+1|0)==(t[d]|0),0==(bE(l[p]&255)|0)){w=s;C=r;break a}}}}while(0);w?(R(e),g=t[c]):g=C;l[t[b]+g|0]=0;jC(e,nz|0,4);S(e)}}}}}while(0);f=eC();if(0==(f|0)){break}}}Q(e)}$D.X=1;function aE(b){for(;0!=(L(l[b]<<24>>24)|0);){b=b+1|0}return b}function bE(b){return(95==(b|0)|0!=(oA(b)|0))&1}function cE(){var b,d=zC(36);b=d>>2;t[b]=0;t[b+1]=-1;t[b+2]=P();t[b+3]=P();t[b+6]=0;t[b+8]=0;t[b+7]=0;t[b+4]=t[K+48>>2];t[b+5]=t[K+24>>2];return d}function dE(b){Q(t[b+8>>2]);Q(t[b+12>>2]);vB(b)}function eE(b){var d,c=cE(),e=cE();Y(b);var f=b+4|0;if(23==(t[f>>2]|0)){for(var g=b|0;;){Y(b);var h=t[g>>2];if(23==(h|0)){d=2104;break}else{if(20==(h|0)){d=2103;break}else{if(21==(h|0)){d=2120;break}}}}if(2104==d){Y(b);f=(b|0)>>2;22!=(t[f]|0)?fE(b):(Y(b),15==(t[f]|0)&&(Y(b),24==(t[b+4>>2]|0)&&(Y(b),17==(t[f]|0)&&(fE(b),18==(t[f]|0)&&(Y(b),18==(t[f]|0)&&Y(b))))));Y(b);if(20!=(t[g>>2]|0)){dE(c);dE(e);return}Y(b);Y(b);dE(c);dE(e);return}if(2103==d){Y(b);Y(b);dE(c);dE(e);return}if(2120==d){dE(c);dE(e);return}}gE(e,b);Y(b);g=b|0;d=c+8|0;for(var h=e+8|0,i=1,m=t[g>>2];;){i=23==(m|0)?0:i;a:do{if(19==(m|0)){eE(b)}else{if(22==(m|0)){hE(b)}else{do{if(0!=(i|0)&&2>(t[f>>2]-21|0)>>>0){var n=0==(t[t[d>>2]>>2]|0);Y(b);if(!n){break a}Y(b);gE(c,b);iE(c,t[h>>2]);n=c;if(0==(t[n+28>>2]|0)){var m=P(),q=t[n+12>>2];0==(t[q>>2]|0)?V(m,t[t[n+8>>2]+8>>2]):(V(m,t[q+8>>2]),U(m,Xi|0),U(m,t[t[n+8>>2]+8>>2]));var q=m|0,p=t[q>>2];(p+1|0)==(t[m+4>>2]|0)?(R(m),q=t[q>>2]):q=p;l[t[m+8>>2]+q|0]=0;jE(n,5);Q(m)}break a}}while(0)}}Y(b)}while(0);n=t[g>>2];if(1<(n-20|0)>>>0){m=n}else{break}}20==(n|0)&&(Y(b),Y(b));dE(c);dE(e)}eE.X=1;function fE(b){var d,c,e;c=(b|0)>>2;for(d=(b+4|0)>>2;;){Y(b);var f=t[c];22==(f|0)&&(Y(b),f=t[c]);if(19==(f|0)){eE(b)}else{if(20==(f|0)){break}else{if(6==(f|0)){f=t[d];if(18==(f|0)||17==(f|0)||27==(f|0)){Y(b),f=t[d]}if(18==(f|0)||17==(f|0)||27==(f|0)){Y(b),f=t[d]}0==(f|0)?kE(b):lE(b)}else{if(18==(f|0)){if(Y(b),18==(t[c]|0)&&(Y(b),23==(t[c]|0))){e=2142;break}}else{lE(b)}}}}}2142!=e&&(Y(b),Y(b))}function kE(b){var d,c=cE();0==(t[b+4>>2]|0)&&Y(b);gE(c,b);Y(b);d=(b|0)>>2;var e=t[d];7==(e|0)&&(mE(b),e=t[d]);4==(e|0)?(Y(b),Y(b),d=t[d]):d=e;12==(d|0)&&(nE(b),oE(c));pE(b);dE(c)}function lE(b){if(6==(t[b>>2]|0)){var d=t[b+4>>2];11==(d|0)||12==(d|0)||14==(d|0)||15==(d|0)||16==(d|0)?b=qE(b):(13==(d|0)?rE(b):8==(d|0)||9==(d|0)||10==(d|0)?sE(b):tE(b),b=1)}else{b=tE(b)}return b}function sE(b){var d=b+4|0,c=t[d>>2];if(10==(c|0)){Y(b),c=b|0,12==(t[c>>2]|0)?nE(b):lE(b),Y(b),9==(t[d>>2]|0)&&(Y(b),7==(t[c>>2]|0)&&mE(b))}else{if(8==(c|0)||9==(c|0)){Y(b),d=b|0,c=t[d>>2],7==(c|0)?(mE(b),d=t[d>>2]):d=c,12==(d|0)?nE(b):lE(b)}}}function qE(b){var d,c,e=b+4|0;for(d=(b|0)>>2;;){Y(b);11==(t[e>>2]|0)&&Y(b);var f=t[d];7==(f|0)&&(mE(b),f=t[d]);if(12==(f|0)){c=2188;break}pE(b);if(13==(t[d]|0)){var g=0;break}Y(b);if(13==(t[d]|0)){g=0;break}if(12!=(t[e>>2]|0)){g=1;break}}2188==c&&(nE(b),g=1);return g}function rE(b){var d;Y(b);d=(b|0)>>2;var c=t[d];7==(c|0)&&(mE(b),c=t[d]);if(12==(c|0)){for(;!(Y(b),c=t[d],21==(c|0)||20==(c|0)||13==(c|0)||23==(c|0));){}}}function Y(b){var d,c,e,f;e=(b|0)>>2;t[e]=0;var g=b+4|0;t[g>>2]=-1;c=(b+8|0)>>2;S(t[c]);d=(b+16|0)>>2;b=(b+20|0)>>2;a:for(;;){var h=T();t[d]=t[K+48>>2];t[b]=t[K+24>>2];if(40==(h|0)){f=2203;break}else{if(63==(h|0)){f=2214;break}else{if(46==(h|0)){f=2207;break}else{if(125==(h|0)){f=2210;break}else{if(62==(h|0)){f=2258;break}else{if(33==(h|0)){f=2259;break}else{if(41==(h|0)){f=2204;break}else{if(-1==(h|0)){f=2202;break}else{if(93==(h|0)){f=2213;break}else{if(32==(h|0)||10==(h|0)||9==(h|0)){continue}else{if(92==(h|0)){f=2216;break}else{if(44==(h|0)){f=2206;break}else{if(91==(h|0)){f=2212;break}else{if(61==(h|0)){f=2211;break}else{if(58==(h|0)){f=2208;break}else{if(39==(h|0)||34==(h|0)){f=2215;break}else{if(47==(h|0)){var i=T();if(47==(i|0)){uE(10);continue}else{if(62==(i|0)){f=2225;break}else{if(42!=(i|0)){f=2221;break}}}for(;;){uE(42);var m=T();if(47==(m|0)){continue a}W(m);if(-1==(m|0)||0==(m|0)){continue a}}}else{if(123==(h|0)){f=2209;break}else{if(59==(h|0)){f=2205;break}else{if(60!=(h|0)){f=2260;break}}}}}}}}}}}}}}}}}}}}var n=T();if(115==(n|0)||109==(n|0)||102==(n|0)){f=2236;break}else{if(47==(n|0)){f=2246;break}else{if(33!=(n|0)){f=2227;break}}}var q=T();if(45!=(q|0)){f=2229;break}var p=T();if(45!=(p|0)){f=2231;break}for(;;){uE(45);m=T();if(45==(m|0)){break}W(m);if(-1==(m|0)||0==(m|0)){continue a}}m=T();62!=(m|0)&&(W(m),W(45))}if(2203==f){t[e]=7}else{if(2214==f){t[e]=24}else{if(2207==f){t[e]=11}else{if(2229==f){W(q),W(33),t[e]=22,t[d]=t[K+48>>2],t[b]=t[K+24>>2]}else{if(2210==f){t[e]=13}else{if(2258==f){t[e]=23,t[d]=t[K+48>>2],t[b]=t[K+24>>2]}else{if(2259==f){t[e]=15}else{if(2236==f){g=T();if(109==(n|0)||102==(n|0)){if(120!=(g|0)){W(g);W(n);t[e]=22;t[d]=t[K+48>>2];t[b]=t[K+24>>2];return}if(109==(n|0)||102==(n|0)){g=T();58==(g|0)?t[e]=19:(W(g),W(120),W(n),t[e]=22);t[d]=t[K+48>>2];t[b]=t[K+24>>2];return}}else{if(115==(n|0)&&58==(g|0)){t[e]=19;t[d]=t[K+48>>2];t[b]=t[K+24>>2];return}}W(g);W(n);t[e]=22;t[d]=t[K+48>>2];t[b]=t[K+24>>2]}else{if(2204==f){t[e]=2}else{if(2202==f){dB(sz|0,1)}else{if(2213==f){t[e]=18}else{if(2227==f){W(n),t[e]=22,t[d]=t[K+48>>2],t[b]=t[K+24>>2]}else{if(2216==f){g=T(),!(92==(g|0)||34==(g|0))&&0==(L(g)|0)&&W(g),t[e]=1,t[d]=t[K+48>>2],t[b]=t[K+24>>2]}else{if(2206==f){t[e]=5}else{if(2212==f){t[e]=17}else{if(2211==f){t[e]=14}else{if(2231==f){W(p),W(45),W(33),t[e]=22,t[d]=t[K+48>>2],t[b]=t[K+24>>2]}else{if(2208==f){t[e]=4}else{if(2215==f){t[e]=10,vE(t[c],h),t[d]=t[K+48>>2],t[b]=t[K+24>>2]}else{if(2209==f){t[e]=12}else{if(2225==f){t[e]=21,t[d]=t[K+48>>2],t[b]=t[K+24>>2]}else{if(2221==f){W(i),t[e]=16,t[d]=t[K+48>>2],t[b]=t[K+24>>2]}else{if(2205==f){t[e]=3}else{if(2246==f){var g=T(),s=115==(g|0);if(115==(g|0)||109==(g|0)||102==(g|0)){c=T();if(109==(g|0)||102==(g|0)){if(120!=(c|0)){W(c);W(g);t[e]=22;t[d]=t[K+48>>2];t[b]=t[K+24>>2];return}}else{if(120!=(c|0)){s&58==(c|0)?t[e]=20:(W(c),W(g),t[e]=22);t[d]=t[K+48>>2];t[b]=t[K+24>>2];return}}s=T();58==(s|0)?t[e]=20:(W(s),W(c),W(g),t[e]=22)}else{W(g),W(47),t[e]=22}t[d]=t[K+48>>2];t[b]=t[K+24>>2]}else{if(2260==f){if(0==(wE(h)|0)){t[e]=0}else{f=t[c];i=(f|0)>>2;q=f+4|0;for(n=(f+8|0)>>2;!(s=t[i],(s+1|0)==(t[q>>2]|0)&&(R(f),s=t[i]),l[t[n]+s|0]=h&255,0!=(h|0)&&(s=t[i]+1|0,t[i]=s,l[t[n]+s|0]=0),s=T(),0==(wE(s)|0));){h=s}h=t[i];(h+1|0)==(t[q>>2]|0)&&(R(f),h=t[i]);l[t[n]+h|0]=0;0==(L(s)|0)&&W(s);t[d]=t[K+48>>2];t[b]=t[K+24>>2];d=UD(t[c],t[Ky>>2]);t[g>>2]=d;t[e]=-1==(d|0)?9:6}}}}}}}}}}}}}}}}}}}}}}}}}}}Y.X=1;function tE(b){var d,c,e,f,g=cE(),h=cE(),i=P();S(i);e=(b+12|0)>>2;V(i,t[t[e]+8>>2]);c=(b+4|0)>>2;d=t[c];if(17==(d|0)){Y(b);var m=1;d=t[c]}else{m=0}18==(d|0)&&(Y(b),d=t[c]);19==(d|0)&&Y(b);d=(b|0)>>2;if(6==(t[d]|0)){var n=t[c];if(20==(n|0)){return e=cE(),f=P(),c=(b+32|0)>>2,g=t[c],S(f),h=b+12|0,V(f,t[t[h>>2]+8>>2]),20==(t[b+4>>2]|0)&&Y(b),t[c]=1,iE(b,t[b+8>>2]),gE(e,b),Y(b),12==(t[b>>2]|0)&&(xE(e),nE(b)),V(t[h>>2],t[f+8>>2]),t[c]=g,dE(e),Q(f),1}if(13==(n|0)){rE(b);var q=1}else{if(0==(n|0)){return kE(b),1}if(5==(n|0)){c=m;e=cE();f=cE();g=P();S(g);h=b+12|0;V(g,t[t[h>>2]+8>>2]);5==(t[b+4>>2]|0)&&Y(b);gE(e,b);Y(b);var i=b|0,p=t[i>>2];if(4==(p|0)){Y(b),Y(b),q=2379}else{var s=p}for(;;){2379==q&&(s=t[i>>2]);if(3==(s|0)){break}Y(b);q=2379}0!=(c|0)&&jE(e,4);V(t[h>>2],t[g+8>>2]);dE(e);dE(f);Q(g);return 1}8==(n|0)||9==(n|0)||10==(n|0)?(sE(b),q=1):11==(n|0)||12==(n|0)||14==(n|0)||15==(n|0)||16==(n|0)?q=qE(b):(Y(b),q=1)}}else{q=1}gE(g,b);s=g+8|0;m=0;a:for(;;){p=m;for(m=t[d];;){if(14==(m|0)){f=2336;break a}else{if(3==(m|0)){var r=q;break a}else{if(13==(m|0)){f=2363;break a}}}Y(b);m=t[d];n=11==(m|0);b:do{if(n){for(var u=p;;){Y(b);var v=t[c];do{if(-1==(v|0)){if(0==(u|0)){var w=b,C=ba,C=(g+8|0)>>2,A=t[C];0!=(t[A>>2]|0)&&(U(A,Xi|0),A=t[C]);U(A,t[t[w+8>>2]+8>>2]);A=t[C];w=t[A>>2];(w+1|0)!=(t[A+4>>2]|0)?C=A:(R(A),C=w=t[C],w=t[w>>2]);C=C+8|0;C=t[C>>2];C=C+w|0;C=l[C]=0}else{V(i,t[t[e]+8>>2]),iE(b,t[s>>2]),C=u}}else{if(4==(v|0)){if(xE(g),Y(b),C=t[d],14==(C|0)){if(Y(b),12==(t[d]|0)){f=2328;break a}else{C=1}}else{if(11==(C|0)){if(Y(b),-1==(t[c]|0)){f=2326;break a}else{C=1}}else{C=1}}}else{C=u}}}while(0);Y(b);u=t[d];if(11==(u|0)){u=C}else{var I=C,M=u;break b}}}else{I=p,M=m}}while(0);7==(M|0)?(mE(b),m=t[d]):m=M;4==(m|0)&&(Y(b),Y(b),m=t[d]);if(17==(m|0)){break}else{p=I}}m=b;n=m|0;if(17==(t[n>>2]|0)){Y(m);for(v=1;!(u=t[n>>2],v=(17==(u|0)&1)+v|0,v=((18==(u|0)&0<(v|0))<<31>>31)+v|0,Y(m),!(0!=(v|0)|18!=(u|0)));){}}m=I}a:do{if(2336==f){Y(b);r=t[c];do{if(0==(r|0)){Y(b);-1==(t[c]|0)?7==(t[d]|0)?f=2341:(gE(h,b),Y(b),f=2340):f=2340;if(2340==f){if(I=t[d],7==(I|0)){f=2341}else{var B=I}}2341==f&&(mE(b),B=t[d]);if(12==(B|0)){if(0==(t[b+32>>2]|0)){nE(b);oE(g);if(0==(t[t[h+8>>2]>>2]|0)){r=q;break a}oE(h);r=q;break a}jE(g,2);0!=(t[t[h+8>>2]>>2]|0)&&oE(h);nE(b)}I=q}else{I=t[d],12==(I|0)?(yE(b,g),I=13==(t[d]|0)?1:q):(7==(I|0)?(mE(b),12==(t[d]|0)&&(jE(g,2),nE(b))):6==(r|0)&&(Y(b),I=t[c],4>I>>>0&&(Y(b),M=t[d],7==(M|0)&&(mE(b),M=t[d]),3==(M|0)&&0==(t[b+24>>2]|0)&&(0==(p|0)&1<(I-2|0)>>>0?oE(g):xE(g)))),I=q)}}while(0);pE(b);r=I}else{2326==f?(V(i,t[t[e]+8>>2]),iE(b,t[s>>2]),jE(b,2),r=b+28|0,t[r>>2]=1,pE(b),t[r>>2]=0,r=1):2328==f?(yE(b,g),pE(b),t[b+28>>2]=0,r=1):2363==f&&(r=0)}}while(0);V(t[e],t[i+8>>2]);dE(g);dE(h);Q(i);return r}tE.X=1;function gE(b,d){var c=d>>2,e=b>>2;t[e+6]=t[c+6];t[e+4]=t[c+4];t[e+5]=t[c+5];t[e]=t[c];t[e+1]=t[c+1];t[e+8]=t[c+8];V(t[e+2],t[t[c+2]+8>>2]);V(t[e+3],t[t[c+3]+8>>2])}function iE(b,d){var c;c=(b+12|0)>>2;var e=t[c];0!=(t[e>>2]|0)&&(U(e,Xi|0),e=t[c]);U(e,t[d+8>>2]);var f=t[c],e=t[f>>2];(e+1|0)!=(t[f+4>>2]|0)?(f=f+8|0,f=t[f>>2],c=f+e|0):(R(f),e=t[c],c=t[e>>2],f=e+8|0,f=t[f>>2],c=f+c|0);l[c]=0}function xE(b){if(0==(t[b+28>>2]|0)){var d=P(),c=t[b+12>>2];0==(t[c>>2]|0)?V(d,t[t[b+8>>2]+8>>2]):(V(d,t[c+8>>2]),U(d,Xi|0),U(d,t[t[b+8>>2]+8>>2]));var c=d|0,e=t[c>>2];(e+1|0)==(t[d+4>>2]|0)?(R(d),c=t[c>>2]):c=e;e=d+8|0;l[t[e>>2]+c|0]=0;0==(zE(t[Rz>>2],t[e>>2])|0)&&(AE(t[Rz>>2],BE(d)),jE(b,1));Q(d)}}xE.X=1;function jE(b,d){if(0!=(t[kz+(d<<4)>>2]|0)&&0==(t[b+28>>2]|0)){var c=0==(d|0)?0==(t[b+32>>2]|0)?0:2:d,e=b+12|0;if(0!=(t[t[e>>2]>>2]|0)){var f=P();V(f,t[t[e>>2]+8>>2]);U(f,Xi|0);e=b+8|0;U(f,t[t[e>>2]+8>>2]);var g=f|0,h=t[g>>2];(h+1|0)==(t[f+4>>2]|0)?(R(f),g=t[g>>2]):g=h;h=f+8|0;l[t[h>>2]+g|0]=0;V(t[e>>2],t[h>>2]);Q(f)}e=j;j+=80;f=e>>2;0!=(t[kz+(c<<4)>>2]|0)&&0==(t[b+28>>2]|0)&&(sC(e,t[t[b+8>>2]+8>>2]),t[f+1]=t[b+16>>2],t[f+2]=t[b+20>>2],t[f+9]=t[kz+(c<<4)+8>>2],l[e+40|0]=t[kz+(c<<4)+4>>2]&255,tC(e));j=e}}jE.X=1;function pE(b){for(var d=b|0;;){var c=t[d>>2];if(13==(c|0)||3==(c|0)){break}else{7==(c|0)?mE(b):12==(c|0)?nE(b):Y(b)}}}function yE(b,d){var c,e,f=cE();c=(b|0)>>2;for(var g=b+4|0,h=d+8|0;;){Y(b);e=10==(t[c]|0)?2434:-1==(t[g>>2]|0)?2434:2441;if(2434==e){e=0;gE(f,b);Y(b);var i=t[c];if(4!=(i|0)){var m=i}else{Y(b),0!=(t[g>>2]|0)?(iE(f,t[h>>2]),jE(f,3),Y(b)):(Y(b),e=t[c],7==(e|0)&&(mE(b),e=t[c]),12==(e|0)&&(iE(f,t[h>>2]),jE(f,2),nE(b),Y(b))),e=2441}}2441==e&&(m=t[c]);if(5!=(m|0)){break}}pE(b);dE(f)}yE.X=1;function mE(b){var d=b|0;if(7==(t[d>>2]|0)){Y(b);for(var c=1;;){var e=t[d>>2],c=(7==(e|0)&1)+c|0,c=((2==(e|0)&0<(c|0))<<31>>31)+c|0;Y(b);if(!(0!=(c|0)|2!=(e|0))){break}}}}function oE(b){if(0==(t[b+28>>2]|0)){var d=P(),c=t[b+12>>2];0==(t[c>>2]|0)?V(d,t[t[b+8>>2]+8>>2]):(V(d,t[c+8>>2]),U(d,Xi|0),U(d,t[t[b+8>>2]+8>>2]));var c=d|0,e=t[c>>2];(e+1|0)==(t[d+4>>2]|0)?(R(d),c=t[c>>2]):c=e;e=d+8|0;l[t[e>>2]+c|0]=0;0==(zE(t[fz>>2],t[e>>2])|0)&&(AE(t[fz>>2],BE(d)),jE(b,0));Q(d)}}oE.X=1;function nE(b){var d,c,e,f=P();S(f);V(f,t[t[b+12>>2]+8>>2]);c=(b+24|0)>>2;t[c]=t[c]+1|0;d=(b|0)>>2;e=t[d];if(12==(e|0)){if(-1!=(t[b+4>>2]|0)){var g=1,h=12;e=2472}else{Y(b);var i=t[d];e=2471}}else{i=e,e=2471}2471==e&&13!=(i|0)&&(g=1,h=i,e=2472);a:do{if(2472==e){for(;;){12==(h|0)?nE(b):g=lE(b);if(0==(g|0)){break a}Y(b);h=t[d];if(13==(h|0)){break a}else{e=2472}}}}while(0);Q(f);t[c]=t[c]-1|0}function hE(b){var d;d=(b|0)>>2;var c=t[d];22==(c|0)&&(Y(b),c=t[d]);if(9==(c|0)&&(Y(b),4==(t[d]|0)&&(Y(b),9==(t[d]|0)))){for(c=9;!(22==(c|0)&&(hE(b),Y(b),c=t[d]),19==(c|0)?eE(b):Y(b),c=t[d],1>=(c-20|0)>>>0);){}}}function vE(b,d){var c,e,f;f=(b|0)>>2;e=(b+4|0)>>2;c=(b+8|0)>>2;var g=1;a:for(;;){for(;;){if(!g){break a}var h=T();if(92==(h|0)){var h=T(),i=t[f]}else{if(-1==(h|0)){g=0;continue a}if((h|0)==(d|0)){g=0;continue a}i=t[f]}(i+1|0)==(t[e]|0)&&(R(b),i=t[f]);l[t[c]+i|0]=h&255;0!=(h|0)&&(h=t[f]+1|0,t[f]=h,l[t[c]+h|0]=0)}}g=t[f];(g+1|0)!=(t[e]|0)?(c=t[c],c=c+g|0):(R(b),e=t[f],c=t[c],c=c+e|0);l[c]=0}vE.X=1;function wE(b){return 0!=(pA(b)|0)|10>(b-48|0)>>>0?1:95==(b|0)||64==(b|0)||36==(b|0)||35==(b|0)?1:0}function CE(){var b,d=zC(28);b=d>>2;t[b]=0;t[b+1]=-1;t[b+2]=-1;t[b+3]=P();t[b+4]=0;t[b+5]=t[K+48>>2];t[b+6]=t[K+24>>2];return d}function DE(b){if(0!=(b|0)){Q(t[b+12>>2]);var d=b+16|0;DE(t[d>>2]);t[d>>2]=0;vB(b)}}function EE(){var b;b=t[lA>>2]-1|0;t[lA>>2]=b;Q(t[(t[jA>>2]+12>>2)+(7*b|0)]);var d=t[lA>>2];b=t[jA>>2]>>2;t[b+(7*d|0)]=0;t[b+(7*d|0)+1]=-1;t[b+(7*d|0)+4]=0;t[b+(7*d|0)+2]=-1;t[b+(7*d|0)+3]=0;t[b+(7*d|0)+5]=0}function FE(b){return 17==(b|0)||47==(b|0)||50==(b|0)||55==(b|0)?1:0}function GE(b){return 4==(b|0)||28==(b|0)||48==(b|0)||16==(b|0)||9==(b|0)||7==(b|0)||32==(b|0)||49==(b|0)||60==(b|0)?1:0}function HE(b){for(var d=b|0;!(IE(b,11),JE(b),11!=(t[d>>2]|0));){}}function KE(b){for(var d=0;;){if(62==(t[b+4>>2]|0)){HE(b);var c=1}else{c=0}if(0==(c|0)){var e=d;break}else{d=1}}for(;;){if(d=b,c=t[d+4>>2],19==(c|0)?(LE(d),d=1):25==(c|0)||26==(c|0)||38==(c|0)||22==(c|0)?(HE(d),d=1):d=0,0==(d|0)){var f=e;break}else{e=1}}for(;!(e=b,d=e+4|0,c=t[d>>2],30==(c|0)?(ME(e),e=1):2==(c|0)?(JE(e),0==(GE(t[d>>2])|0)?HE(e):NE(e),e=1):55==(c|0)?(JE(e),e=1):19==(c|0)?(LE(e),e=1):0!=((5==(c|0)||6==(c|0)||13==(c|0)||14==(c|0)||21==(c|0)||22==(c|0)||26==(c|0)||27==(c|0)||38==(c|0)||39==(c|0)||40==(c|0)||41==(c|0)||54==(c|0)||63==(c|0)||64==(c|0)||65==(c|0)?1:0)|0)?(HE(e),e=1):0!=(GE(c)|0)?(NE(e),e=1):3==(t[e>>2]|0)?(JE(e),d=e|0,9!=(t[d>>2]|0)?d=0:(OE(e),d=(7==(t[d>>2]|0)?0==(qA(t[t[e+12>>2]+8>>2],mg|0)|0):0)&1),HE(e),e=d):(d=t[e+4>>2],8==(d|0)?(PE(e,1),e=1):56==(d|0)?(QE(e),e=1):35==(d|0)?(PE(e,9),e=1):0==(d|0)||11==(d|0)||12==(d|0)||20==(d|0)||21==(d|0)||29==(d|0)||31==(d|0)||37==(d|0)||42==(d|0)||44==(d|0)||46==(d|0)||51==(d|0)||58==(d|0)?(HE(e),e=1):e=0),0==(e|0));){f=1}return f}function RE(b){for(var d,c=b+4|0,e=b+16|0,f=0;;){var g=t[c>>2];if(19==(g|0)){LE(b),f=1}else{if(18==(g|0)){SE(b);g=t[e>>2];if(0==(g|0)){d=2647;break}g=t[g+4>>2];if(!(15==(g|0)||24==(g|0)||52==(g|0)||66==(g|0))){d=2649;break}HE(b);f=1}else{if(10==(g|0)||23==(g|0)||57==(g|0)){d=2648;break}else{0==(FE(g)|0)?HE(b):JE(b),f=1}}}}if(2647==d||2648==d||2649==d){return f}}function LE(b){JE(b);3==(t[b>>2]|0)&&TE(b,2);HE(b)}function SE(b){b=b+16|0;if(0==(t[b>>2]|0)){var d=CE();t[b>>2]=d;JE(d)}}function TE(b,d){var c,e=j;j+=80;c=e>>2;var f=b+8|0;t[f>>2]=d;if(0!=(UE(d)|0)){sC(e,t[t[b+12>>2]+8>>2]);f=t[f>>2];1==(f|0)&&(t[c]=2!=(t[oy+76>>2]|0)&1);t[c+1]=t[b+20>>2];t[c+2]=t[b+24>>2];t[c+4]=2>(f-6|0)>>>0&1;t[c+9]=t[iz+(f<<4)+8>>2];l[e+40|0]=t[iz+(f<<4)+4>>2]&255;t[c+6]=6!=(f|0)&1;if(0!=(t[lA>>2]|0)){var f=t[jA>>2],g=0,h=t[lA>>2];a:for(;;){for(var i=0==(g|0),m=h;;){if(!(0!=(m|0)&i)){break a}var m=m-1|0,n=f+28*m|0;if(3==(t[n>>2]|0)){var q=t[(f+8>>2)+(7*m|0)];if(!(-1==(q|0)||4==(q|0))){g=n;h=m;continue a}}}}f=g;0!=(f|0)&&(t[c+15]=t[iz+(t[f+8>>2]<<4)+8>>2],t[c+16]=t[t[f+12>>2]+8>>2])}c=t[lA>>2];if(0==(c|0)){var p=0}else{f=t[jA>>2];for(h=g=0;;){if(h=4==(t[(f+8>>2)+(7*g|0)]|0)?1:h,g=g+1|0,!(g>>>0<c>>>0&0==(h|0))){p=h;break}}}if(0!=(p|0)&&0==(UE(4)|0)){j=e;return}tC(e)}j=e}TE.X=1;function UE(b){var d=t[iz+(b<<4)>>2];return 0==(d|0)?0:0==(2>(b-6|0)>>>0&1|0)?d:t[oy+8>>2]}function ME(b){var d;JE(b);d=(b|0)>>2;if(3==(t[d]|0)){TE(b,4);var c=VE(b);d=2703}else{var e=t[b+4>>2];1==(e|0)||36==(e|0)?(JE(b),e=t[d],9==(e|0)?(JE(b),d=t[d]):d=e,7!=(d|0)?d=2704:(TE(b,4),c=VE(b),d=2703)):d=2704}if(2703==d){if(0==(c|0)){d=2704}else{var f=c}}2704==d&&(f=CE(),t[f>>2]=3,t[f+8>>2]=4);WE(f);for(c=b+4|0;;){if(d=t[c>>2],57==(d|0)){XE(b,11)}else{if(18==(d|0)){break}else{23==(d|0)?XE(b,3):0!=(FE(d)|0)?JE(b):0==(GE(d)|0)?HE(b):YE(b)}}}SE(b);HE(b);EE();DE(f)}ME.X=1;function NE(b){var d,c;YE(b);d=(b|0)>>2;var e=t[d];if(1==(e|0)){ZE(b);var f=t[d];c=2717}else{11!=(e|0)&&(f=e,c=2717)}if(2717==c&&(2==(f|0)&&JE(b),$E(b),11!=(t[d]|0))){return}HE(b)}function JE(b){var d,c,e;d=b+16|0;DE(t[d>>2]);c=(b|0)>>2;t[c]=0;t[b+8>>2]=-1;t[b+4>>2]=-1;t[d>>2]=0;d=(b+12|0)>>2;S(t[d]);for(var f=b+20|0,g=b+24|0;;){var h=aF();t[f>>2]=t[K+48>>2];t[g>>2]=t[K+24>>2];if(46==(h|0)){e=2744;break}else{if(42==(h|0)||47==(h|0)||43==(h|0)||45==(h|0)||61==(h|0)||60==(h|0)||62==(h|0)){var i=h;e=2731;break}else{if(44==(h|0)){e=2727;break}else{if(41==(h|0)){e=2729;break}else{if(10==(h|0)){break}else{if(40==(h|0)){e=2728;break}else{if(33==(h|0)){e=2739;break}else{if(-1==(h|0)){e=2726;break}else{if(37==(h|0)){e=2730;break}else{if(34==(h|0)||39==(h|0)){e=2751;break}else{if(59==(h|0)){e=2752;break}else{if(58==(h|0)){e=2753;break}else{if(!(32==(h|0)||9==(h|0))){e=2756;break}}}}}}}}}}}}}}a:do{if(2744==e){bF(t[d],46);i=aF();if(46!=(i|0)){cF(i);t[c]=0;return}i=t[d];h=t[i>>2];(h+1|0)==(t[i+4>>2]|0)&&(R(i),i=h=t[d],h=t[h>>2]);l[t[i+8>>2]+h|0]=46;i=t[d]|0;h=t[i>>2]+1|0;t[i>>2]=h;l[t[t[d]+8>>2]+h|0]=0;h=t[d];i=t[h>>2];(i+1|0)==(t[h+4>>2]|0)?(R(h),d=i=t[d],i=t[i>>2]):d=h;l[t[d+8>>2]+i|0]=0;t[c]=7;return}if(2731==e){for(;;){h=t[d];b=t[h>>2];(b+1|0)==(t[h+4>>2]|0)&&(R(h),h=b=t[d],b=t[b>>2]);l[t[h+8>>2]+b|0]=i&255;0!=(i|0)&&(i=t[d]|0,h=t[i>>2]+1|0,t[i>>2]=h,l[t[t[d]+8>>2]+h|0]=0);var m=aF();if(0==(bC(bg|0,m,7)|0)){break}else{i=m}}cF(m);h=t[d];i=t[h>>2];(i+1|0)==(t[h+4>>2]|0)?(R(h),d=i=t[d],i=t[i>>2]):d=h;l[t[d+8>>2]+i|0]=0;t[c]=7;return}if(2727==e){t[c]=1;return}if(2729==e){t[c]=8;return}if(2756==e){if(0!=(pA(h)|0)){c=b;i=ba;i=(c+12|0)>>2;bF(t[i],h);h=UD(t[i],t[Ny>>2]);d=c+4|0;t[d>>2]=h;b=c|0;-1!=(h|0)?t[b>>2]=4:(t[b>>2]=3,i=t[t[i]+8>>2],0==(N(i,Sf|0,3)|0)&&(h=PD(i+3|0),i=UD(h,t[Ny>>2]),Q(h),-1!=(i|0)&&(h=CE(),c=c+16|0,t[c>>2]=h,t[h>>2]=4,t[t[c>>2]+4>>2]=i,t[d>>2]=18)));return}10>(h-48|0)>>>0?(i=dF(h),U(t[d],t[i+8>>2]),Q(i),t[c]=6):t[c]=0;return}if(2728==e){t[c]=9;return}if(2739==e){if(0==(t[gz>>2]|0)){eF(),t[Nz>>2]=0}else{for(;;){if(f=aF(),-1==(f|0)||10==(f|0)){break a}}}}else{if(2726==e){dB(rz|0,1)}else{if(2730==e){t[c]=10;return}if(2751==e){fF(t[d],h);t[c]=12;return}if(2752==e){t[c]=11;return}if(2753==e){d=aF();58==(d|0)?t[c]=2:(cF(d),t[c]=0);return}}}}while(0);t[c]=11;0!=(t[gz>>2]|0)&&gF()}JE.X=1;function PE(b,d){var c,e;JE(b);c=(b|0)>>2;for(var f=b+12|0,g=t[c];;){if(7==(g|0)){if(0==(qA(t[t[f>>2]+8>>2],dh|0)|0)){JE(b);3==(t[c]|0)&&(TE(b,d),JE(b));hF(b);var h=t[c];e=2801}}else{h=g,e=2801}2801==e&&(e=0,3==(h|0)&&TE(b,7));JE(b);g=t[c];9==(g|0)&&(OE(b),g=t[c]);1==(g|0)&&(JE(b),g=t[c]);if(11==(g|0)){break}}HE(b)}function QE(b){var d,c,e;JE(b);c=(b|0)>>2;7==(t[c]|0)?0!=(qA(t[t[b+12>>2]+8>>2],dh|0)|0)?e=2814:(JE(b),3==(t[c]|0)&&TE(b,12),d=VE(b),hF(b)):e=2814;2814==e&&(e=CE(),d=e>>2,t[d]=3,t[d+2]=12,V(t[d+3],tg|0),d=e);a:for(;;){for(e=t[c];;){if(3!=(e|0)){break a}TE(b,5);JE(b);e=t[c];if(1==(e|0)){break}}JE(b)}HE(b);WE(d);c=b+4|0;if(18!=(t[c>>2]|0)){for(;!(iF(b),18==(t[c>>2]|0));){}}SE(b);HE(b);EE();DE(d)}QE.X=1;function VE(b){var d,c,e=CE();c=e>>2;d=b>>2;t[c]=t[d];t[c+1]=t[d+1];t[c+2]=t[d+2];t[c+3]=t[d+3];t[c+4]=t[d+4];t[c+5]=t[d+5];t[c+6]=t[d+6];t[e+12>>2]=BE(t[b+12>>2]);t[b+16>>2]=0;return e}function hF(b){IE(b,7);11!=(t[b>>2]|0)&&JE(b)}function WE(b){var d,c;d=t[jA>>2];0==(d|0)?(t[lA>>2]=0,t[kA>>2]=10,d=zC(280),t[jA>>2]=d):(c=t[lA>>2],(c|0)==(t[kA>>2]|0)&&(c=c+10|0,t[kA>>2]=c,d=jF(d,28*c|0),t[jA>>2]=d));c=(d+28*t[lA>>2]|0)>>2;d=b>>2;t[c]=t[d];t[c+1]=t[d+1];t[c+2]=t[d+2];t[c+3]=t[d+3];t[c+4]=t[d+4];t[c+5]=t[d+5];t[c+6]=t[d+6];b=BE(t[b+12>>2]);d=t[lA>>2];t[(t[jA>>2]+12>>2)+(7*d|0)]=b;t[lA>>2]=d+1|0}function iF(b){var d=t[b+4>>2];if(0!=(GE(d)|0)){NE(b)}else{if(61==(d|0)){HE(b);var d=b+4|0,c=33==(t[d>>2]|0);a:do{if(c){for(;;){var e=b;HE(e);var f=e+4|0,g=18==(t[f>>2]|0);b:do{if(!g){for(;;){if(iF(e),18==(t[f>>2]|0)){break b}}}}while(0);SE(e);HE(e);if(33!=(t[d>>2]|0)){break a}}}}while(0);SE(b);HE(b)}else{56==(d|0)?QE(b):HE(b)}}}function IE(b,d){for(var c=b|0,e=b+16|0;;){var f=t[c>>2];if((f|0)==(d|0)|11==(f|0)){break}f=t[e>>2];if(0!=(f|0)&&11==(t[f>>2]|0)){break}JE(b)}}function OE(b){for(var d=b|0,c=0;;){var e=t[d>>2];if(11==(e|0)){break}else{c=9==(e|0)?c+1|0:8==(e|0)?c-1|0:c}JE(b);if(0>=(c|0)){break}}}function YE(b){var d=b>>2,c=b+4|0,e=t[c>>2];if(16==(e|0)){JE(b);var f=t[c>>2];9==(f|0)||43==(f|0)?JE(b):IE(b,11)}else{if(4==(e|0)||9==(e|0)||28==(e|0)||32==(e|0)||48==(e|0)){JE(b);var f=b|0,g=t[f>>2];9==(g|0)?(OE(b),f=t[f>>2]):f=g;7==(f|0)&&0==(qA(t[t[d+3]+8>>2],wo|0)|0)&&(JE(b),JE(b))}else{if(7==(e|0)){JE(b);f=b|0;g=t[f>>2];if(7==(g|0)){if(0==(qA(t[t[d+3]+8>>2],wo|0)|0)){JE(b),f=t[f>>2]}else{return}}else{f=g}9==(f|0)?OE(b):6==(f|0)&&JE(b)}else{if(49==(e|0)){JE(b),7==(t[d]|0)&&0==(qA(t[t[d+3]+8>>2],dh|0)|0)&&(JE(b),JE(b),JE(b))}else{if(60==(e|0)){if(JE(b),9==(t[d]|0)){OE(b)}else{d=(b|0)>>2;c=t[d];1==(c|0)&&(ZE(b),c=t[d]);2==(c|0)?(JE(b),d=t[d]):d=c;3==(d|0)&&TE(b,12);WE(b);HE(b);d=b+4|0;c=t[d>>2];44==(c|0)||53==(c|0)?(HE(b),g=2964):f=c;for(;;){2964==g&&(f=t[d>>2]);if(18==(f|0)){break}0==(GE(f)|0)?HE(b):(g=b,YE(g),c=g|0,e=t[c>>2],1==(e|0)?(ZE(g),c=t[c>>2]):c=e,2==(c|0)&&JE(g),$E(g));g=2964}SE(b);IE(b,11);EE()}}else{IE(b,11)}}}}}}YE.X=1;function ZE(b){for(var d,c=b+4|0,e=b|0;;){JE(b);var f=t[c>>2];12==(f|0)||29==(f|0)?(JE(b),OE(b)):38==(f|0)||0==(f|0)||21==(f|0)||31==(f|0)||37==(f|0)||44==(f|0)||42==(f|0)||46==(f|0)||51==(f|0)||58==(f|0)?JE(b):IE(b,11);f=t[e>>2];if(2==(f|0)){d=2915;break}else{if(1!=(f|0)){break}}}2915!=d&&IE(b,11)}function $E(b){var d,c;d=(b|0)>>2;var e=t[d];if(10==(e|0)){HE(b)}else{for(var f=b+4|0;;){if(4==(e|0)){e=t[f>>2];if(23==(e|0)||57==(e|0)){c=2929;break}t[d]=3}else{if(3!=(e|0)){c=2927;break}}kF(b);e=t[d];if(11==(e|0)){c=2925;break}else{if(1!=(e|0)){continue}}JE(b);e=t[d]}2929!=c&&2927!=c&&2925==c&&HE(b)}}function kF(b){var d;0==(t[lA>>2]|0)?d=13:(d=t[(t[jA>>2]+28*(t[lA>>2]-1)|0)+8>>2],d=3==(d|0)?7:12==(d|0)?5:11==(d|0)?7:13);TE(b,d);JE(b);d=(b|0)>>2;var c=t[d];9==(c|0)&&(OE(b),c=t[d]);7==(c|0)&&0==(qA(t[t[b+12>>2]+8>>2],wo|0)|0)&&(JE(b),9==(t[d]|0)?OE(b):JE(b));if(7==(t[d]|0)){if(c=t[t[b+12>>2]+8>>2],0==(qA(c,dh|0)|0)){JE(b),hF(b)}else{if(0==(qA(c,mg|0)|0)){for(c=7;!(1==(c|0)||11==(c|0));){JE(b),c=t[d],9==(c|0)&&(OE(b),c=t[d])}}}}}kF.X=1;function XE(b,d){JE(b);3==(t[b>>2]|0)&&TE(b,d);WE(b);HE(b);KE(b);RE(b);10==(t[b+4>>2]|0)&&lF(b);SE(b);HE(b);EE()}function cF(b){t[Jx>>2]=b}function lF(b){var d,c=b+4|0,e=t[c>>2];if(10==(e|0)){HE(b),d=2987}else{var f=e}for(;;){if(2987==d&&(f=t[c>>2]),23==(f|0)){XE(b,3),d=2987}else{if(18==(f|0)){break}else{57==(f|0)?XE(b,11):0!=(FE(f)|0)?JE(b):0==(GE(f)|0)?JE(b):YE(b),d=2987}}}}function aF(){var b=t[Jx>>2];0==(b|0)?b=0==(t[gz>>2]|0)?mF():nF():t[Jx>>2]=0;return b}function eF(){for(;;){var b=T();if(-1==(b|0)||10==(b|0)){break}}return b}function gF(){for(var b;;){var d=aF();if(!(32==(d|0)||9==(d|0))){break}}if(10>(d-48|0)>>>0){for(var c=d,e=d=0;;){if(0==(e|0)){var f=CE();t[f>>2]=5}else{f=e}b=(f+12|0)>>2;var g=t[b],e=t[g>>2];(e+1|0)==(t[g+4>>2]|0)&&(R(g),g=e=t[b],e=t[e>>2]);l[t[g+8>>2]+e|0]=c&255;0!=(c|0)&&(c=t[b]|0,g=t[c>>2]+1|0,t[c>>2]=g,l[t[t[b]+8>>2]+g|0]=0);g=aF();e=d+1|0;if(10>(g-48|0)>>>0&5>(e|0)){c=g,d=e,e=f}else{break}}0>(d|0)|0==(f|0)||(c=t[b],d=t[c>>2],(d+1|0)==(t[c+4>>2]|0)?(R(c),b=d=t[b],d=t[d>>2]):b=c,l[t[b+8>>2]+d|0]=0,TE(f,6),DE(f));f=g}else{f=d}cF(f)}gF.X=1;function bF(b,d){var c,e;e=(b|0)>>2;var f=b+4|0;c=(b+8|0)>>2;for(var g=d;;){var h=t[e];(h+1|0)==(t[f>>2]|0)&&(R(b),h=t[e]);l[t[c]+h|0]=g&255;0!=(g|0)&&(h=t[e]+1|0,t[e]=h,l[t[c]+h|0]=0);h=aF();if(0!=(oA(h)|0)|95==(h|0)){g=h}else{break}}g=t[e];(g+1|0)!=(t[f>>2]|0)?(c=t[c],c=c+g|0):(R(b),e=t[e],c=t[c],c=c+e|0);l[c]=0;cF(h)}function dF(b){var d,c=P(),b=oF(b);V(c,t[b+8>>2]);Q(b);b=aF();if(46==(b|0)){d=oF(0);var b=(c|0)>>2,e=t[b];if((e+1|0)==(t[c+4>>2]|0)){R(c);var f=t[b]}else{f=e}e=c+8|0;l[t[e>>2]+f|0]=46;f=t[b]+1|0;t[b]=f;l[t[e>>2]+f|0]=0;U(c,t[d+8>>2]);Q(d);var g=aF()}else{g=b}if(101==(rA(g)|0)){e=oF(0);f=c|0;d=f>>2;var h=t[d],b=c+4|0;if((h+1|0)==(t[b>>2]|0)){R(c);var i=t[d]}else{i=h}h=c+8|0;l[t[h>>2]+i|0]=g&255;0!=(g|0)&&(g=t[d]+1|0,t[d]=g,l[t[h>>2]+g|0]=0);U(c,t[e+8>>2]);Q(e);d=f;e=b}else{cF(g),d=c|0,e=c+4|0}b=t[d>>2];if((b+1|0)!=(t[e>>2]|0)){return d=t[(c+8|0)>>2],b=d+b|0,l[b]=0,c}R(c);b=t[d>>2];d=t[(c+8|0)>>2];b=d+b|0;l[b]=0;return c}dF.X=1;function oF(b){var d,c,e=P();if(45==(b|0)){b=(e|0)>>2;d=t[b];if((d+1|0)==(t[e+4>>2]|0)){R(e);var f=t[b]}else{f=d}d=e+8|0;l[t[d>>2]+f|0]=45;f=t[b]+1|0;t[b]=f;l[t[d>>2]+f|0]=0;var g=aF()}else{g=10>(b-48|0)>>>0?b:aF()}d=(e|0)>>2;f=e+4|0;for(b=(e+8|0)>>2;;){if(-1==(g|0)){c=3069;break}var h=t[d],i=(h+1|0)==(t[f>>2]|0);if(10<=(g-48|0)>>>0){c=3077;break}if(i){R(e);var m=t[d]}else{m=h}l[t[b]+m|0]=g&255;0!=(g|0)&&(g=t[d]+1|0,t[d]=g,l[t[b]+g|0]=0);g=aF()}if(3077==c){if(i){var n=g;c=3078}else{var q=g,p=h}}else{if(3069==c){if(c=t[d],(c+1|0)==(t[f>>2]|0)){n=-1,c=3078}else{l[t[b]+c|0]=0;var s;cF(-1);return e}}}3078==c&&(R(e),q=n,p=t[d]);l[t[b]+p|0]=0;if(95!=(q|0)){return cF(q),e}for(;;){q=aF();if(-1==(q|0)){s=-1;c=3083;break}if(0==(pA(q)|0)){s=q;c=3086;break}}if(3086==c||3083==c){return cF(s),e}}oF.X=1;function nF(){var b=T();do{if(38==(b|0)){for(;;){var d=T();if(!(0!=(L(d)|0)&10!=(d|0))){break}}if(10==(d|0)){t[Vc>>2]=1;var c=0,e=10}else{33==(d|0)?(c=0,e=33):(W(d),c=1,e=38)}}else{c=0==(t[Vc>>2]|0)?1:35==(b|0)||33==(b|0)?0:1,e=b}}while(0);a:for(;;){var f=e;b:for(;;){if(c){break a}b=0==(L(f)|0);c:do{if(b){var g=f}else{for(;;){if(d=T(),0==(L(d)|0)){g=d;break c}}}}while(0);do{if(33!=(g|0)&&!(0!=(t[Vc>>2]|0)&35==(g|0))){if(38!=(g|0)){c=1;e=g;continue a}f=T();continue b}}while(0);f=-1==(eF()|0)?-1:T();t[Vc>>2]=1}}t[Vc>>2]=10==(f|0)&1;return f}nF.X=1;function fF(b,d){var c,e,f=j,g=t[K+20>>2];l[ly]=1;e=(b|0)>>2;var h=b+4|0;c=(b+8|0)>>2;for(var i=aF();(i|0)!=(d|0)&&!(-1==(i|0)||10==(i|0));){var m=t[e];(m+1|0)==(t[h>>2]|0)&&(R(b),m=t[e]);l[t[c]+m|0]=i&255;0!=(i|0)&&(i=t[e]+1|0,t[e]=i,l[t[c]+i|0]=0);i=aF()}m=-1==(i|0);if(-1==(i|0)||10==(i|0)){i=t[t[K+40>>2]+8>>2],KC(Qf|0,(k=j,j+=8,t[k>>2]=i,t[k+4>>2]=g,k)),m&&dB(rz|0,1),0==(t[gz>>2]|0)&&dB(rz|0,2)}g=t[e];(g+1|0)!=(t[h>>2]|0)?(c=t[c],c=c+g|0):(R(b),e=t[e],c=t[c],c=c+e|0);l[c]=0;l[ly]=0;j=f}fF.X=1;function mF(){var b;if(0==(t[Nz>>2]|0)){var d=0,c=0,e=1}else{var f=T();t[Nz>>2]=t[Nz>>2]+1|0;if(10==(f|0)){t[Nz>>2]=0,d=1,c=10,e=1}else{if(33!=(f|0)|l[ly]){if(38!=(f|0)){var g=0,h=f;b=3132}else{f=T(),10==(f|0)?dB(rz|0,2):(W(f),g=0,h=38,b=3132)}}else{c=eF(),t[Nz>>2]=0,e=d=1}}}a:for(;;){3132==b&&(b=0,d=g,c=h,e=0==(t[Nz>>2]|0));var h=(g=0==(d|0))?-1:10,i=c,f=e;b:for(;;){if(!f){b=3146;break a}f=pF();if(4==(f|0)){t[Nz>>2]=6,i=h,f=0}else{if(2==(f|0)){b=3137;break}else{if(0==(f|0)||1==(f|0)){b=3136;break a}else{if(5==(f|0)){b=3139}else{if(3!=(f|0)){g=d;h=i;b=3132;continue a}}}}do{if(3139==b&&(b=0,!g)){t[Nz>>2]=6;i=10;f=0;continue b}}while(0);for(t[Nz>>2]=5;;){var m=T(),n=t[Nz>>2]+1|0;t[Nz>>2]=n;if(10==(m|0)){break}else{if(!(32==(m|0)||9==(m|0))){break b}}}t[Nz>>2]=0;i=10;f=1}}3137==b?(eF(),g=d,h=i):6<n>>>0?(W(m),g=d,h=32):(g=d,h=m);b=3132}if(3146==b){return i}3136==b&&dB(rz|0,2)}mF.X=1;function pF(){var b,d,c,e=P();d=(e|0)>>2;var f=e+4|0;b=(e+8|0)>>2;var g=0;a:for(;;){var h=T();if(0==(g|0)&&0!=(bC(Kf|0,h,9)|0)){var i=2;c=3162;break}if(9==(h|0)){i=5;c=3162;break}if(5==(g|0)){c=3152;break}do{if(-1==(h|0)){i=4;c=3162;break a}else{if(10==(h|0)){c=3161;break a}else{if(32!=(h|0)){if(10<=(h-48|0)>>>0){i=1;c=3162;break a}var m=t[d];(m+1|0)==(t[f>>2]|0)&&(R(e),m=t[d]);l[t[b]+m|0]=h&255;0!=(h|0)&&(m=t[d]+1|0,t[d]=m,l[t[b]+m|0]=0)}}}}while(0);g=g+1|0;if(6<=(g|0)){i=0;c=3162;break}}if(3152==c){if(48==(h|0)||32==(h|0)){i=5,c=3162}else{var h=t[d],n=0==(h|0)?3:1,q=h}}else{3161==c&&(i=6,c=3162)}3162==c&&(n=i,q=t[d]);if(0==(q|0)){return Q(e),n}(q+1|0)==(t[f>>2]|0)?(R(e),d=t[d]):d=q;l[t[b]+d|0]=0;b=CE();t[b>>2]=5;V(t[b+12>>2],t[e+8>>2]);TE(b,6);DE(b);Q(e);return n}pF.X=1;function qF(){var b,d=zC(20);b=d>>2;t[b]=-1;t[b+1]=-1;t[b+2]=P();t[b+3]=t[K+48>>2];t[b+4]=t[K+24>>2];return d}function rF(b){0!=(b|0)&&(Q(t[b+8>>2]),vB(b))}function sF(b,d){var c,e=qF();tF(e);var f=e|0;if(5==(t[f>>2]|0)){tF(e);var g=0}else{g=1}for(var h=b|0;;){uF(e,d);tF(b);var i=t[h>>2];if(15==(i|0)||6==(i|0)){tF(e)}else{vF(b);var i=b,m=i|0;if(11!=(t[m>>2]|0)){for(;!(tF(i),wF(i),11==(t[m>>2]|0));){}}if(g){c=3210;break}tF(e);if(6==(t[f>>2]|0)){c=3211;break}}}3211==c?rF(e):3210==c&&rF(e)}function uF(b,d){var c,e=j;j+=80;c=e>>2;var f=b+8|0;sC(e,t[t[f>>2]+8>>2]);if(0!=(t[dz+(d<<4)>>2]|0)&&(t[c+1]=t[b+12>>2],t[c+2]=t[b+16>>2],t[c+9]=t[dz+(d<<4)+8>>2],l[e+40|0]=t[dz+(d<<4)+4>>2]&255,tC(e),0!=(t[Zb>>2]|0)&0!=(t[oy+4>>2]|0))){var g=P();V(g,t[t[Zb>>2]+8>>2]);U(g,Xi|0);U(g,t[t[f>>2]+8>>2]);t[c+8]=t[g+8>>2];tC(e);Q(g)}j=e}uF.X=1;function vF(b){var d,c=b|0,e=b+4|0;a:for(;;){var f=t[c>>2];if(3==(f|0)){d=3222;break}else{if(5==(f|0)){d=3221;break}}var g=t[e>>2];if(2>(g-6|0)>>>0){d=3225;break}if(9==(f|0)){wF(b)}else{12!=(f|0)&&(d=3228);do{if(3228==d&&(d=0,!(9==(g|0)|13==(f|0)))){if(5==(g|0)){tF(b);wF(b);continue a}else{if(8==(g|0)){tF(b);wF(b);continue a}else{d=3238;break a}}}}while(0);tF(b)}}3238!=d&&(3222==d?(tF(b),14==(t[c>>2]|0)&&(tF(b),tF(b))):3221==d?wF(b):3225==d&&(tF(b),wF(b)))}function wF(b){var d=b|0,c=t[d>>2];if(5==(c|0)){var e=6}else{if(7==(c|0)){e=8}else{if(9==(c|0)){e=10}else{return}}}tF(b);for(var f=1;;){var g=t[d>>2],f=((g|0)==(c|0)&1)+f|0,f=(((g|0)==(e|0)&0<(f|0))<<31>>31)+f|0;tF(b);if(!(0!=(f|0)|(g|0)!=(e|0))){break}}}function xF(b,d){var c,e,f;f=(b|0)>>2;e=(b+4|0)>>2;c=(b+8|0)>>2;var g=96==(d|0),h=1;a:for(;;){b:for(;;){if(!h){break a}var i=T();do{if(-1==(i|0)){h=0;continue a}else{if(92==(i|0)&&!g){var i=T(),m=t[f];(m+1|0)==(t[e]|0)&&(R(b),m=t[f]);l[t[c]+m|0]=i&255;if(0==(i|0)){continue b}i=t[f]+1|0;t[f]=i;l[t[c]+i|0]=0;continue b}}}while(0);if((i|0)==(d|0)){h=0;continue a}m=t[f];(m+1|0)==(t[e]|0)&&(R(b),m=t[f]);l[t[c]+m|0]=i&255;0!=(i|0)&&(i=t[f]+1|0,t[f]=i,l[t[c]+i|0]=0)}}g=t[f];(g+1|0)!=(t[e]|0)?(c=t[c],c=c+g|0):(R(b),e=t[f],c=t[c],c=c+e|0);l[c]=0}xF.X=1;function tF(b){var d,c,e,f;e=(b|0)>>2;t[e]=-1;var g=b+4|0;t[g>>2]=-1;c=(b+8|0)>>2;S(t[c]);d=(b+12|0)>>2;for(b=(b+16|0)>>2;;){var h=T();t[d]=t[K+48>>2];t[b]=t[K+24>>2];if(91==(h|0)){f=3307;break}else{if(!(32==(h|0)||13==(h|0)||9==(h|0))){if(46==(h|0)){f=3310;break}else{if(41==(h|0)){f=3304;break}else{if(125==(h|0)){f=3306;break}else{if(40==(h|0)){f=3303;break}else{if(42==(h|0)){f=3309;break}else{if(34==(h|0)||39==(h|0)||96==(h|0)){f=3300;break}else{if(10==(h|0)){var i=t[$b>>2];if(2>(i-3|0)>>>0|6==(i|0)|8==(i|0)|10==(i|0)){f=3291;break}}else{if(-1==(h|0)){f=3292;break}else{if(60==(h|0)){if(45==(T()|0)){f=3302;break}}else{if(44==(h|0)){f=3311;break}else{if(93==(h|0)){f=3308;break}else{if(47==(h|0)){var m=T();if(47==(m|0)){uE(10),W(10)}else{if(42==(m|0)){i=0}else{f=3299;break}for(;;){var n=T(),q=10==(n|0)?1:i;if(-1==(n|0)||42==(n|0)){i=T();if(47==(i|0)){break}W(i);if(-1==(i|0)||0==(i|0)){break}else{i=q}}else{i=q}}W(0!=(q|0)?10:32)}}else{f=123==(h|0)?3305:3312;break}}}}}}}}}}}}}}}if(3307==f){t[e]=9}else{if(3312==f){m=t[c];q=(m|0)>>2;i=m+4|0;for(f=(m+8|0)>>2;;){var p=t[q];(p+1|0)==(t[i>>2]|0)&&(R(m),p=t[q]);l[t[f]+p|0]=h&255;0!=(h|0)&&(p=t[q]+1|0,t[q]=p,l[t[f]+p|0]=0);p=T();if(0==((0!=(pA(p)|0)|10>(p-48|0)>>>0?1:95==(p|0)||64==(p|0)||36==(p|0)||35==(p|0)?1:128<(p|0))&1|0)){break}else{h=p}}h=t[q];(h+1|0)==(t[i>>2]|0)&&(R(m),h=t[q]);f=t[f];h=f+h|0;l[h]=0;W(p);t[d]=t[K+48>>2];t[b]=t[K+24>>2];d=mC(t[t[c]+8>>2],t[My>>2]);t[g>>2]=d;t[e]=-1==(d|0)?3:2}else{3291==f?t[e]=11:3310==f?t[e]=14:3304==f?t[e]=6:3306==f?t[e]=8:3302==f?t[e]=13:3303==f?t[e]=5:3299==f?(t[e]=1,W(m)):3309==f?t[e]=12:3300==f?(t[e]=4,xF(t[c],h),t[d]=t[K+48>>2],t[b]=t[K+24>>2]):3292==f?dB(qz|0,1):3311==f?t[e]=15:3308==f?t[e]=10:3305==f&&(t[e]=7)}}t[$b>>2]=t[e]}tF.X=1;function yF(){var b,d=zC(32);b=d>>2;t[b]=0;t[b+1]=-1;t[b+2]=P();t[b+3]=P();t[b+6]=0;t[b+7]=0;t[b+4]=t[K+48>>2];t[b+5]=t[K+24>>2];return d}function zF(b){Q(t[b+8>>2]);Q(t[b+12>>2]);vB(b)}function AF(b){var d,c=yF();BF(c);CF(c,t[b+12>>2]);BF(b);d=(b|0)>>2;var e=t[d],f=11==(e|0);a:do{if(f){for(var g=b+4|0;;){BF(b);-1==(t[g>>2]|0)&&(DF(c,b),BF(b));var h=t[d];if(11!=(h|0)){var i=h;break a}}}else{i=e}}while(0);7==(i|0)?(EF(b),d=t[d]):d=i;12==(d|0)&&(0==(FF(b,c)|0)?GF(c):HF(c));IF(b);zF(c)}function JF(b,d){if(6==(t[b>>2]|0)){var c=t[b+4>>2];if(8==(c|0)||9==(c|0)||10==(c|0)){var e=b+4|0,f=t[e>>2];if(10==(f|0)){BF(b),f=b|0,12==(t[f>>2]|0)?FF(b,b):JF(b,0),BF(b),9==(t[e>>2]|0)&&(BF(b),7==(t[f>>2]|0)&&EF(b))}else{if(8==(f|0)||9==(f|0)){BF(b),e=b|0,f=t[e>>2],7==(f|0)?(EF(b),e=t[e>>2]):e=f,12==(e|0)?FF(b,b):JF(b,0)}}e=1}else{if(13==(c|0)){BF(b),e=b|0,f=t[e>>2],7==(f|0)?(EF(b),e=t[e>>2]):e=f,12==(e|0)&&FF(b,b),e=1}else{if(11==(c|0)||12==(c|0)||14==(c|0)||15==(c|0)||16==(c|0)){for(var g=b+4|0,c=(b|0)>>2;;){BF(b);11==(t[g>>2]|0)&&BF(b);var h=t[c];7==(h|0)&&(EF(b),h=t[c]);if(12==(h|0)){e=3377;break}IF(b);if(13==(t[c]|0)){f=0;break}BF(b);if(13==(t[c]|0)){f=0;break}if(12!=(t[g>>2]|0)){f=1;break}}3377==e&&(FF(b,b),f=1);e=f}else{KF(b,d),e=1}}}}else{e=KF(b,d)}return e}function BF(b){var d,c,e,f;e=(b|0)>>2;t[e]=0;var g=b+4|0;t[g>>2]=-1;c=(b+8|0)>>2;S(t[c]);d=(b+16|0)>>2;b=(b+20|0)>>2;a:for(;;){var h=T();t[d]=t[K+48>>2];t[b]=t[K+24>>2];if(58==(h|0)){f=3397;break}else{if(44==(h|0)){f=3395;break}else{if(123==(h|0)){f=3398;break}else{if(46==(h|0)){f=3396;break}else{if(39==(h|0)||34==(h|0)){f=3403;break}else{if(92==(h|0)){f=3404;break}else{if(61==(h|0)){f=3400;break}else{if(59==(h|0)){f=3394;break}else{if(93==(h|0)){f=3402;break}else{if(40==(h|0)){f=3392;break}else{if(-1==(h|0)){f=3391;break}else{if(125==(h|0)){f=3399;break}else{if(41==(h|0)){f=3393;break}else{if(91==(h|0)){f=3401;break}else{if(32==(h|0)||10==(h|0)||9==(h|0)){continue}else{if(47!=(h|0)){f=3413;break}}}}}}}}}}}}}}}}var i=T();if(47==(i|0)){uE(10)}else{if(42!=(i|0)){f=3409;break}for(;;){uE(42);var m=T();if(47==(m|0)){continue a}W(m);if(-1==(m|0)||0==(m|0)){continue a}}}}if(3409==f){t[e]=15,W(i)}else{if(3397==f){t[e]=4}else{if(3395==f){t[e]=5}else{if(3398==f){t[e]=12}else{if(3396==f){t[e]=11}else{if(3403==f){t[e]=10,LF(t[c],h),t[d]=t[K+48>>2],t[b]=t[K+24>>2]}else{if(3404==f){g=T(),!(92==(g|0)||34==(g|0))&&0==(L(g)|0)&&W(g),t[e]=1,t[d]=t[K+48>>2],t[b]=t[K+24>>2]}else{if(3400==f){t[e]=14}else{if(3394==f){t[e]=3}else{if(3402==f){t[e]=17}else{if(3392==f){t[e]=7}else{if(3391==f){dB(pz|0,1)}else{if(3399==f){t[e]=13}else{if(3393==f){t[e]=2}else{if(3401==f){t[e]=16}else{if(3413==f){if(0==(MF(h)|0)){t[e]=0}else{var i=t[c],m=(i|0)>>2,n=i+4|0;for(f=(i+8|0)>>2;;){var q=t[m];(q+1|0)==(t[n>>2]|0)&&(R(i),q=t[m]);l[t[f]+q|0]=h&255;0!=(h|0)&&(q=t[m]+1|0,t[m]=q,l[t[f]+q|0]=0);q=T();if(0==(MF(q)|0)){break}else{h=q}}h=t[m];(h+1|0)==(t[n>>2]|0)?(R(i),i=t[m]):i=h;l[t[f]+i|0]=0;0==(L(q)|0)&&W(q);t[d]=t[K+48>>2];t[b]=t[K+24>>2];d=UD(t[c],t[Iy>>2]);t[g>>2]=d;t[e]=-1==(d|0)?9:6}}}}}}}}}}}}}}}}}}BF.X=1;function KF(b,d){var c,e,f,g,h=b>>2,i,m=yF(),n=yF(),q=P();S(q);var p=0!=(d|0),s=p&1;g=(b+4|0)>>2;e=t[g];if(5==(e|0)){e=0==(t[h+6]|0)&1;BF(b);var r=e;e=t[g]}else{r=0}7==(e|0)?(BF(b),e=b|0,11==(t[e>>2]|0)&&BF(b)):e=b|0;f=e>>2;NF(m,b);e=(b+12|0)>>2;var u=m+8|0;a:for(;;){var v=t[f];if(3==(v|0)){i=3459;break}else{if(14==(v|0)){i=3461;break}else{if(13==(v|0)){var w=0;break}}}BF(b);var v=t[f],C=11==(v|0);b:do{if(C){for(var A=s;;){BF(b);var I=t[g];do{if(-1==(I|0)){if(0==(A|0)){DF(m,b);var M=0}else{V(q,t[t[e]+8>>2]),CF(b,t[u>>2]),M=A}}else{if(4==(I|0)){if(HF(m),BF(b),M=t[f],11==(M|0)){if(BF(b),-1==(t[g]|0)){i=3451;break a}else{M=1}}else{if(14==(M|0)){if(BF(b),12==(t[f]|0)){i=3453;break a}else{M=1}}else{M=1}}}else{M=A}}}while(0);BF(b);A=t[f];if(11==(A|0)){A=M}else{var B=0;c=M;var G=A;break b}}}else{B=r,c=s,G=v}}while(0);7==(G|0)?(EF(b),r=t[f]):r=G;if(16==(r|0)&&(r=b,s=r|0,16==(t[s>>2]|0))){BF(r);for(C=1;!(v=t[s>>2],C=(16==(v|0)&1)+C|0,C=((17==(v|0)&0<(C|0))<<31>>31)+C|0,BF(r),!(0!=(C|0)|17!=(v|0)));){}}r=B;s=c}a:do{if(3451==i){V(q,t[t[e]+8>>2]),CF(b,t[u>>2]),OF(b,2),w=b+28|0,t[w>>2]=1,IF(b),t[w>>2]=0,w=1}else{if(3453==i){PF(b,m),IF(b),t[h+7]=0,w=1}else{if(3459==i){0!=(t[h+6]|0)|0==(r|0)||OF(m,4),w=1}else{if(3461==i){BF(b);w=t[g];do{if(0==(w|0)){BF(b);-1==(t[g]|0)?7==(t[f]|0)?i=3466:(NF(n,b),BF(b),i=3465):i=3465;if(3465==i){if(B=t[f],7==(B|0)){i=3466}else{var Z=B}}3466==i&&(EF(b),Z=t[f]);if(12==(Z|0)){if(p){OF(m,2),0!=(t[t[n+8>>2]>>2]|0)&&GF(n),FF(b,m)}else{0==(FF(b,m)|0)?GF(m):HF(m);if(0==(t[t[n+8>>2]>>2]|0)){w=1;break a}GF(n);w=1;break a}}}else{if(B=t[f],12==(B|0)){if(0==(PF(b,m)|0)&&!(0!=(t[h+6]|0)|0==(r|0))){B=P();c=t[e];0==(t[c>>2]|0)?V(B,t[t[h+2]+8>>2]):(V(B,t[c+8>>2]),U(B,Xi|0),U(B,t[t[h+2]+8>>2]));c=B|0;G=t[c>>2];(G+1|0)==(t[B+4>>2]|0)&&(R(B),G=t[c>>2]);c=(B+8|0)>>2;l[t[c]+G|0]=0;do{if(0==(zE(t[ez>>2],t[c])|0)&&0==(zE(t[Qz>>2],t[c])|0)){BF(b);if(3!=(t[f]|0)&&(IF(b),3!=(t[f]|0))){break}OF(m,4)}}while(0);Q(B)}}else{7==(B|0)?(EF(b),12==(t[f]|0)&&(OF(m,2),FF(b,m))):6==(w|0)?(BF(b),B=t[g],4>B>>>0&&(BF(b),c=t[f],7==(c|0)&&(EF(b),c=t[f]),3==(c|0)&&0==(t[h+6]|0)&&(0==(s|0)&1<(B-2|0)>>>0?GF(m):HF(m)))):-1==(w|0)&&!(0!=(t[h+6]|0)|0==(r|0))&&(B=P(),c=t[e],0==(t[c>>2]|0)?V(B,t[t[h+2]+8>>2]):(V(B,t[c+8>>2]),U(B,Xi|0),U(B,t[t[h+2]+8>>2])),c=B|0,G=t[c>>2],(G+1|0)==(t[B+4>>2]|0)&&(R(B),G=t[c>>2]),c=(B+8|0)>>2,l[t[c]+G|0]=0,0==(zE(t[ez>>2],t[c])|0)&&0==(zE(t[Qz>>2],t[c])|0)&&(IF(b),3==(t[f]|0)&&OF(m,4)),Q(B))}}}while(0);IF(b);w=1}}}}}while(0);V(t[e],t[q+8>>2]);zF(m);zF(n);Q(q);return w}KF.X=1;function NF(b,d){var c=d>>2,e=b>>2;t[e+6]=t[c+6];t[e+4]=t[c+4];t[e+5]=t[c+5];t[e]=t[c];t[e+1]=t[c+1];V(t[e+2],t[t[c+2]+8>>2]);V(t[e+3],t[t[c+3]+8>>2])}function CF(b,d){var c;c=(b+12|0)>>2;var e=t[c];0!=(t[e>>2]|0)&&(U(e,Xi|0),e=t[c]);U(e,t[d+8>>2]);var f=t[c],e=t[f>>2];(e+1|0)!=(t[f+4>>2]|0)?(f=f+8|0,f=t[f>>2],c=f+e|0):(R(f),e=t[c],c=t[e>>2],f=e+8|0,f=t[f>>2],c=f+c|0);l[c]=0}function DF(b,d){var c;c=(b+8|0)>>2;var e=t[c];0!=(t[e>>2]|0)&&(U(e,Xi|0),e=t[c]);U(e,t[t[d+8>>2]+8>>2]);var f=t[c],e=t[f>>2];(e+1|0)!=(t[f+4>>2]|0)?(f=f+8|0,f=t[f>>2],c=f+e|0):(R(f),e=t[c],c=t[e>>2],f=e+8|0,f=t[f>>2],c=f+c|0);l[c]=0}function HF(b){if(0==(t[b+28>>2]|0)){var d=P(),c=t[b+12>>2];0==(t[c>>2]|0)?V(d,t[t[b+8>>2]+8>>2]):(V(d,t[c+8>>2]),U(d,Xi|0),U(d,t[t[b+8>>2]+8>>2]));var c=d|0,e=t[c>>2];(e+1|0)==(t[d+4>>2]|0)?(R(d),c=t[c>>2]):c=e;e=d+8|0;l[t[e>>2]+c|0]=0;0==(zE(t[Qz>>2],t[e>>2])|0)&&(AE(t[Qz>>2],BE(d)),OF(b,1));Q(d)}}HF.X=1;function OF(b,d){if(0!=(t[Vy+(d<<4)>>2]|0)&&0==(t[b+28>>2]|0)){var c=b+12|0;if(0!=(t[t[c>>2]>>2]|0)){var e=P();V(e,t[t[c>>2]+8>>2]);U(e,Xi|0);c=b+8|0;U(e,t[t[c>>2]+8>>2]);var f=e|0,g=t[f>>2];(g+1|0)==(t[e+4>>2]|0)?(R(e),f=t[f>>2]):f=g;g=e+8|0;l[t[g>>2]+f|0]=0;V(t[c>>2],t[g>>2]);Q(e)}c=j;j+=80;e=c>>2;0!=(t[Vy+(d<<4)>>2]|0)&&0==(t[b+28>>2]|0)&&(sC(c,t[t[b+8>>2]+8>>2]),t[e+1]=t[b+16>>2],t[e+2]=t[b+20>>2],t[e+9]=t[Vy+(d<<4)+8>>2],l[c+40|0]=t[Vy+(d<<4)+4>>2]&255,tC(c));j=c}}function IF(b){for(var d=b|0;;){var c=t[d>>2];if(13==(c|0)||3==(c|0)){break}else{7==(c|0)?EF(b):12==(c|0)?FF(b,b):BF(b)}}}function PF(b,d){var c,e,f=yF();c=(b|0)>>2;var g=b+4|0,h=d+8|0,i=0;a:for(;;){BF(b);var m=t[c];do{if(13==(m|0)){var n=0;e=3574;break a}else{if(10==(m|0)){e=3562}else{if(-1==(t[g>>2]|0)){e=3562}else{var q=i;e=3569}}}}while(0);if(3562==e){if(e=0,NF(f,b),BF(b),m=t[c],4!=(m|0)){var p=i,s=m}else{BF(b),0!=(t[g>>2]|0)?(CF(f,t[h>>2]),OF(f,3),BF(b),q=1):(BF(b),e=t[c],7==(e|0)&&(EF(b),e=t[c]),12!=(e|0)?q=i:(CF(f,t[h>>2]),OF(f,2),FF(b,f),BF(b),q=1)),e=3569}}3569==e&&(e=0,p=q,s=t[c]);if(5==(s|0)){i=p}else{break}}if(3574==e){return zF(f),n}IF(b);n=p;zF(f);return n}PF.X=1;function EF(b){var d=b|0;if(7==(t[d>>2]|0)){BF(b);for(var c=1;;){var e=t[d>>2],c=(7==(e|0)&1)+c|0,c=((2==(e|0)&0<(c|0))<<31>>31)+c|0;BF(b);if(!(0!=(c|0)|2!=(e|0))){break}}}}function QF(b){var d=l[b+1|0];100==d<<24>>24||68==d<<24>>24?(d=l[b+2|0],101==d<<24>>24||69==d<<24>>24?(b=l[b+3|0],b=102==b<<24>>24|70==b<<24>>24):b=0):b=0;return b&1}function GF(b){if(0==(t[b+28>>2]|0)){var d=P(),c=t[b+12>>2];0==(t[c>>2]|0)?V(d,t[t[b+8>>2]+8>>2]):(V(d,t[c+8>>2]),U(d,Xi|0),U(d,t[t[b+8>>2]+8>>2]));var c=d|0,e=t[c>>2];(e+1|0)==(t[d+4>>2]|0)?(R(d),c=t[c>>2]):c=e;e=d+8|0;l[t[e>>2]+c|0]=0;0==(zE(t[ez>>2],t[e>>2])|0)&&(AE(t[ez>>2],BE(d)),OF(b,0));Q(d)}}GF.X=1;function FF(b,d){var c,e,f,g,h,i,m=P();h=(b+24|0)>>2;t[h]=t[h]+1|0;g=(b|0)>>2;e=t[g];if(12==(e|0)){if(e=b+4|0,-1!=(t[e>>2]|0)){var n=12,q=e}else{BF(b),c=t[g],i=3606}}else{c=e,i=3606}if(3606==i){if(13==(c|0)){var p=0;Q(m);g=t[h];t[h]=g-1|0;return p}n=c;q=b+4|0}f=(b+12|0)>>2;e=(d+8|0)>>2;c=(m+8|0)>>2;var s=0,r=n;a:for(;;){var u=t[q>>2];do{if(0==(u|0)){V(m,t[t[f]+8>>2]),CF(b,t[e]),AF(b),V(t[f],t[c]),n=s}else{if(7==(u|0)){V(m,t[t[f]+8>>2]),CF(b,t[e]),JF(b,1),V(t[f],t[c]),n=1}else{if(5==(u|0)){V(m,t[t[f]+8>>2]),CF(b,t[e]),JF(b,s),V(t[f],t[c]),n=s}else{if(12==(r|0)){FF(b,d),n=s}else{if(0==(JF(b,s)|0)){p=s;i=3620;break a}else{n=s}}}}}}while(0);BF(b);r=t[g];if(13==(r|0)){p=n;i=3618;break}else{s=n}}if(3620==i||3618==i){return Q(m),g=t[h],t[h]=g-1|0,p}}FF.X=1;function LF(b,d){var c,e,f;f=(b|0)>>2;e=(b+4|0)>>2;c=(b+8|0)>>2;var g=1;a:for(;;){for(;;){if(!g){break a}var h=T();if(92==(h|0)){var h=T(),i=t[f]}else{if(-1==(h|0)){g=0;continue a}if((h|0)==(d|0)){g=0;continue a}i=t[f]}(i+1|0)==(t[e]|0)&&(R(b),i=t[f]);l[t[c]+i|0]=h&255;0!=(h|0)&&(h=t[f]+1|0,t[f]=h,l[t[c]+h|0]=0)}}g=t[f];(g+1|0)!=(t[e]|0)?(c=t[c],c=c+g|0):(R(b),e=t[f],c=t[c],c=c+e|0);l[c]=0}LF.X=1;function MF(b){return 0!=(pA(b)|0)|10>(b-48|0)>>>0?1:95==(b|0)||64==(b|0)||36==(b|0)||35==(b|0)?1:0}function RF(){var b,d=P(),c=eC();if(0!=(c|0)){for(;;){var e=40==l[c]<<24>>24;a:do{if(e){if(0==(QF(c)|0)){for(var f=c;;){var g=f+1|0,f=l[g];if(0==f<<24>>24){break a}var h=l[g];if(0!=(L(f&255)|0)){b=3677;break}if(40==h<<24>>24||41==h<<24>>24){break a}else{if(58==h<<24>>24){var i=g;break}else{f=g}}}do{if(3677==b){if(b=0,58==h<<24>>24){i=g}else{break a}}}while(0);for(;;){var m=i+1|0,n=l[m];if(58==n<<24>>24){i=m}else{break}}if(0!=(QF(i)|0)){for(var f=m,q=n;;){if(0==q<<24>>24){var p=f;break}var s=f+1|0;if(0!=(L(q&255)|0)){p=f;break}f=s;q=l[s]}for(;0!=(L(l[p]&255)|0);){p=p+1|0}SF(d,p)}}else{f=c;for(q=40;;){if(0==q<<24>>24){var r=f;break}s=f+1|0;if(0!=(L(q&255)|0)){r=f;break}f=s;q=l[s]}for(;0!=(L(l[r]&255)|0);){r=r+1|0}SF(d,r)}}}while(0);c=eC();if(0==(c|0)){break}}}Q(d)}RF.X=1;function SF(b,d){var c,e,f;c=l[d];a:do{if(39==c<<24>>24){var g=d+1|0}else{if(40==c<<24>>24){if(e=l[d+1|0],113==e<<24>>24||81==e<<24>>24?(e=l[d+2|0],117==e<<24>>24||85==e<<24>>24?(e=l[d+3|0],111==e<<24>>24||79==e<<24>>24?(e=l[d+4|0],116==e<<24>>24||84==e<<24>>24?(e=l[d+5|0],e=101==e<<24>>24||69==e<<24>>24?0!=(L(l[d+6|0]&255)|0):0):e=0):e=0):e=0):e=0,0==(e&1|0)){g=d}else{for(e=d+7|0;;){if(0==(L(l[e]&255)|0)){g=e;break a}else{e=e+1|0}}}}else{g=d}}}while(0);e=(b|0)>>2;var h=b+4|0;for(c=(b+8|0)>>2;;){var i=l[g];if(0==i<<24>>24||40==i<<24>>24){f=3697;break}if(0!=(L(i&255)|0)){f=3697;break}var i=l[g],m=t[e],n=(m+1|0)==(t[h>>2]|0);if(41==i<<24>>24){f=3704;break}if(n){R(b);var i=l[g],q=t[e]}else{q=m}l[t[c]+q|0]=i;0!=l[g]<<24>>24&&(i=t[e]+1|0,t[e]=i,l[t[c]+i|0]=0);g=g+1|0}if(3697==f){if(m=t[e],(m+1|0)==(t[h>>2]|0)){f=3705}else{var p=m}}else{3704==f&&(n?f=3705:p=m)}3705==f&&(R(b),p=t[e]);l[t[c]+p|0]=0;0!=(t[e]|0)&&jC(b,By|0,0);S(b)}SF.X=1;function TF(b,d,c){if(0!=(d|0)&0!=(b|0)&b>>>0<d>>>0){for(;;){if(0==(L(l[b]<<24>>24)|0)){var e=d;break}else{b=b+1|0}}for(;0!=(L(l[e]<<24>>24)|0);){e=e-1|0}if(b>>>0<e>>>0){var f=(b|0)==(e|0),d=(c|0)>>2,g=t[d],h=c+4|0,i=(g+1|0)==(t[h>>2]|0);a:do{if(f){var m=i,n=g}else{for(var q=c+8|0,p=b,s=i,r=g;;){if(s&&(R(c),r=t[d]),l[t[q>>2]+r|0]=l[p],0!=l[p]<<24>>24&&(r=t[d]+1|0,t[d]=r,l[t[q>>2]+r|0]=0),p=p+1|0,r=t[d],s=(r+1|0)==(t[h>>2]|0),(p|0)==(e|0)){m=s;n=r;break a}}}}while(0);m?(R(c),e=t[d]):e=n;l[t[c+8>>2]+e|0]=0;jC(c,zy|0,0);S(c)}}}TF.X=1;function UF(){var b,d=P(),c=VF();if(-1!=(c|0)){for(var e=d+8|0,f=1,g=0,h=0,i=1;;){if(0==(i|0)){var m=g,n=f;b=3760}else{if(0!=(g|0)&9==(c|0)){WF();var q=i,p=h,s=g,r=f}else{m=0,n=1,b=3760}}a:do{if(3760==b){if(b=0,10==(c|0)){q=1,p=h,s=m,r=n}else{if(0!=(L(c)|0)){q=0,p=h,s=m,r=n}else{if(123==(c|0)){XF(123,125),q=0,p=h,s=m,r=n}else{if(35==(c|0)){WF(),q=0,p=h,s=m,r=n}else{if(40==(c|0)){XF(40,41),q=0,p=h,s=m,r=n}else{if(58==(c|0)){q=0,p=h,r=s=1}else{if(0==(n|0)){q=0,p=h,s=m,r=0}else{if(0==(YF(c)|0)){q=0,p=h,s=m,r=0}else{ZF(c,d);q=t[e>>2];if(0==(qA(q,Fg|0)|0)){p=q=0,s=m}else{if(0!=(h|0)){WF(),q=0,p=h,s=m}else{do{if(0==(qA(q,zr|0)|0)){if(0==(YF(c)|0)){p=t[e>>2]}else{ZF($F(),d);jC(d,xy|0,0);WF();q=0;p=1;s=m;r=n;break a}}else{p=q}}while(0);0==(qA(p,ce|0)|0)&&0!=(YF(c)|0)&&ZF($F(),d);q=$F();do{if(0==(bC(Uw|0,q,4)|0)){if(61!=(q|0)){p=q=0;s=m;r=n;break a}}else{f=58==(q|0)?1:m;p=VF();if(61!=(p|0)){W(p);p=q=0;s=f;r=n;break a}if(43==(q|0)){WF();p=q=0;s=f;r=n;break a}}}while(0);jC(d,xy|0,0);WF();s=p=q=0}}r=n}}}}}}}}}}while(0);c=VF();if(-1==(c|0)){break}else{f=r,g=s,h=p,i=q}}}Q(d)}UF.X=1;function VF(){var b=T();92==(b|0)&&(b=T(),b=10!=(b|0)?b:T());return b}function WF(){for(var b;;){var d=VF();if(-1==(d|0)){b=3796;break}else{if(10==(d|0)){break}}}3796!=b&&W(10)}function XF(b,d){var c=j,e,f=b<<24>>24,g=d<<24>>24,h=t[K+20>>2],i=0,m=1;a:for(;;){if(0>=(m|0)){var n=i;break}for(;;){var q=VF();if((q|0)==(f|0)){e=3803;break}if((q|0)==(g|0)){e=3804;break}if(-1==(q|0)||10==(q|0)){n=q;break a}}3803==e?(e=0,i=f,m=m+1|0):3804==e&&(e=0,i=g,m=m-1|0)}-1==(n|0)&&(e=t[t[K+40>>2]+8>>2],KC(Ev|0,(k=j,j+=12,t[k>>2]=e,t[k+4>>2]=f,t[k+8>>2]=h,k)));j=c}function YF(b){return(0==(b|0)?0:0!=(oA(b)|0)?1:0!=(bC(hw|0,b,4)|0))&1}function ZF(b,d){var c;S(d);var e=0==(YF(b)|0);c=(d|0)>>2;var f=d+4|0;a:do{if(e){var g=b}else{for(var h=d+8|0,i=b;;){var m=t[c];(m+1|0)==(t[f>>2]|0)&&(R(d),m=t[c]);l[t[h>>2]+m|0]=i&255;0!=(i|0)&&(i=t[c]+1|0,t[c]=i,l[t[h>>2]+i|0]=0);i=VF();if(0==(YF(i)|0)){g=i;break a}}}}while(0);W(g);e=t[c];(e+1|0)!=(t[f>>2]|0)?(c=t[(d+8|0)>>2],c=c+e|0):(R(d),f=t[c],c=t[(d+8|0)>>2],c=c+f|0);l[c]=0}ZF.X=1;function $F(){for(var b;;){var d=VF();if(10==(d|0)){b=3830;break}if(0==(L(d)|0)){b=3831;break}}if(3831==b||3830==b){return d}}function aG(b,d){V(t[rc>>2],b);t[qc>>2]=d}function bG(){S(t[rc>>2])}function cG(b){var d,c;d=(b+4|0)>>2;a:for(;;){for(var e=t[d];;){if(0==(e|0)){c=3867;break a}var f=l[e];if(0==f<<24>>24){c=3867;break a}if(0!=(dG(f)|0)){c=3869;break a}if(64==f<<24>>24){c=3871;break a}if(0!=((32==f<<24>>24|9==f<<24>>24)&1|0)){c=3873;break}f&=255;if(123==(f|0)){c=3883;break a}else{if(40==(f|0)){c=3875;break a}else{if(45==(f|0)){c=3892;break a}else{if(44==(f|0)){c=3887;break a}else{if(34==(f|0)){c=3890;break a}else{if(43==(f|0)){c=3891;break a}else{if(58==(f|0)){c=3889;break a}else{if(93==(f|0)){c=3886;break a}else{if(125==(f|0)){c=3884;break a}else{if(35==(f|0)){c=3877;break a}else{if(59==(f|0)){c=3888;break a}else{if(92==(f|0)){c=3876;break a}else{if(41==(f|0)){c=3882;break a}else{if(91==(f|0)){c=3885;break a}else{if(47!=(f|0)){c=3893;break a}}}}}}}}}}}}}}}var g=e+1|0,f=l[g];if(42==f<<24>>24){c=3879;break}else{if(47!=f<<24>>24){c=3881;break a}}e=t[d]=0}if(3873==c){c=0;for(var f=b+4|0,h=t[f>>2];0!=((32==l[h]<<24>>24|9==l[h]<<24>>24)&1|0);){h=h+1|0}t[f>>2]=h}else{if(3879==c){c=0;var h=f=ba,f=(b+4|0)>>2,i=t[f]+2|0,m=1,n=1;b:for(;;){c:for(;;){for(var q=0==(m|0),p=i;;){if(q){break b}if(0!=(p|0)){var s=l[p];if(47==s<<24>>24){break}else{if(0!=s<<24>>24){break c}}}i=eC();t[f]=i;if(0==(i|0)){h=3980;break b}else{p=i}}if(n){break}else{i=p,m=0}}i=p+1|0;n=42!=s<<24>>24}3980!=h&&(t[f]=p)}}}if(3871==c){eG(b);var r=mC(t[t[b>>2]+8>>2],t[Uy>>2]),u=-1==(r|0)?37:r}else{if(3883==c){t[d]=e+1|0,u=28}else{if(3875==c){t[d]=e+1|0,u=26}else{if(3892==c){t[d]=e+1|0,u=25}else{if(3887==c){t[d]=e+1|0,u=23}else{if(3890==c){d=(b+4|0)>>2;b=t[d];c=0;a:for(;;){e=b;for(g=0;;){var v=e+1|0;if(c|0==(v|0)){r=3947;break a}p=l[v];if(0==p<<24>>24){r=3948;break a}else{if(34==p<<24>>24&&0==(g|0)){b=v;c=1;continue a}}e=v;g=92==p<<24>>24&1}}3947==r?t[d]=v:3948==r&&(t[d]=v);u=37}else{3891==c?(t[d]=e+1|0,u=24):3893==c?(t[d]=e+1|0,u=37):3869==c?(fG(b),r=mC(t[t[b>>2]+8>>2],t[Uy>>2]),u=-1==(r|0)?22:r):3889==c?(t[d]=e+1|0,u=33):3886==c?(t[d]=e+1|0,u=31):3884==c?(t[d]=e+1|0,u=29):3867==c?(r=eC(),t[d]=r,u=0==(r|0)?38:36):3877==c?(t[d]=e+1|0,u=34):3888==c?(t[d]=e+1|0,u=32):3876==c?(t[d]=e+1|0,u=35):3881==c?(t[d]=g,u=37):3882==c?(t[d]=e+1|0,u=27):3885==c&&(t[d]=e+1|0,u=30)}}}}}}return u}cG.X=1;function dG(b){return(0==(26>(b-97&255)&1|0)?0!=(26>(b-65&255)&1|0):1)&1}function fG(b){var d;d=(b|0)>>2;S(t[d]);var b=(b+4|0)>>2,c=t[b],e=l[c];if(0!=(dG(e)|0)|95==e<<24>>24){var f=t[d],c=t[f>>2];(c+1|0)==(t[f+4>>2]|0)&&(R(f),c=t[d],e=l[t[b]],f=c,c=t[c>>2]);l[t[f+8>>2]+c|0]=e;e=t[b];0!=l[e]<<24>>24&&(e=t[d]|0,c=t[e>>2]+1|0,t[e>>2]=c,l[t[t[d]+8>>2]+c|0]=0,e=t[b])}else{e=c}e=e+1|0;c=l[e];f=0==(gG(c)|0);a:do{if(f){var g=e}else{for(var h=e,i=c;;){var m=t[d],n=t[m>>2];(n+1|0)==(t[m+4>>2]|0)&&(R(m),n=t[d],i=l[h],m=n,n=t[n>>2]);l[t[m+8>>2]+n|0]=i;0!=l[h]<<24>>24&&(i=t[d]|0,n=t[i>>2]+1|0,t[i>>2]=n,l[t[t[d]+8>>2]+n|0]=0);h=h+1|0;i=l[h];if(0==(gG(i)|0)){g=h;break a}}}}while(0);t[b]=g;b=t[d];g=t[b>>2];(g+1|0)!=(t[b+4>>2]|0)?(b=b+8|0,b=t[b>>2],d=b+g|0):(R(b),g=t[d],d=t[g>>2],b=g+8|0,b=t[b>>2],d=b+d|0);l[d]=0}fG.X=1;function hG(b,d){if(27==(d|0)||29==(d|0)||31==(d|0)){var c=t[Kc>>2]-1|0;t[Kc>>2]=c}else{26==(d|0)||28==(d|0)||30==(d|0)?(c=t[Kc>>2]+1|0,t[Kc>>2]=c):c=t[Kc>>2]}0==(c|0)&&(t[z>>2]=t[rd>>2])}function eG(b){var d;d=(b|0)>>2;S(t[d]);var b=(b+4|0)>>2,c=t[b];if(64==l[c]<<24>>24){var e=t[d],f=t[e>>2];(f+1|0)==(t[e+4>>2]|0)?(R(e),f=t[d],c=l[t[b]],e=f,f=t[f>>2]):c=64;l[t[e+8>>2]+f|0]=c;c=t[b];0!=l[c]<<24>>24&&(c=t[d]|0,e=t[c>>2]+1|0,t[c>>2]=e,l[t[t[d]+8>>2]+e|0]=0,c=t[b])}c=c+1|0;e=l[c];f=0==(gG(e)|0);a:do{if(f){var g=c}else{for(var h=c,i=e;;){var m=t[d],n=t[m>>2];(n+1|0)==(t[m+4>>2]|0)&&(R(m),n=t[d],i=l[h],m=n,n=t[n>>2]);l[t[m+8>>2]+n|0]=i;0!=l[h]<<24>>24&&(i=t[d]|0,n=t[i>>2]+1|0,t[i>>2]=n,l[t[t[d]+8>>2]+n|0]=0);h=h+1|0;i=l[h];if(0==(gG(i)|0)){g=h;break a}}}}while(0);t[b]=g;b=t[d];g=t[b>>2];(g+1|0)!=(t[b+4>>2]|0)?(b=b+8|0,b=t[b>>2],d=b+g|0):(R(b),g=t[d],d=t[g>>2],b=g+8|0,b=t[b>>2],d=b+d|0);l[d]=0}eG.X=1;function gG(b){return(0==(10>(b-48&255)&1|0)?95==b<<24>>24|0!=(dG(b)|0):1)&1}function iG(b,d){var c=j;j+=80;sC(c,b);t[c+36>>2]=t[uy+(d<<4)+8>>2];l[c+40|0]=t[uy+(d<<4)+4>>2]&255;var e=t[rc>>2];0!=(e|0)&&(t[c+60>>2]=t[uy+(t[qc>>2]<<4)+8>>2],t[c+64>>2]=t[e+8>>2]);tC(c);j=c}function jG(b,d){24==(d|0)?(t[z>>2]=238,t[Ac>>2]=4):10==(d|0)?(bG(),t[z>>2]=16):25==(d|0)?(t[z>>2]=238,t[Ac>>2]=3):28==(d|0)&&(t[z>>2]=250,hG(0,28),t[rd>>2]=26)}function kG(b){return 32==b<<24>>24||9==b<<24>>24||13==b<<24>>24||10==b<<24>>24?1:0}function lG(b){var d,b=(b+4|0)>>2,c=t[b],e=0;a:for(;;){for(var f=c,g=0;;){var h=f+1|0;if(e|0==(h|0)){d=24;break a}var i=l[h];if(34==i<<24>>24){if(0==(g|0)){c=h;e=1;continue a}}else{if(0==i<<24>>24){d=25;break a}}f=h;g=92==i<<24>>24&1}}24==d?t[b]=h:25==d&&(t[b]=h)}function mG(){for(var b,d=t[t[K+40>>2]+8>>2],c=tb(d),e=P();;){var f=c-1|0;if(0<(f|0)&46!=l[d+f|0]<<24>>24){c=f}else{var g=f;break}}for(;;){if(0>=(g|0)){var h=g;break}c=l[d+g|0];if(92==c<<24>>24||47==c<<24>>24){b=41;break}g=g-1|0}41==b&&(h=g+1|0);b=d+h|0;f=f-h|0;S(e);gD(e,b,f);f=e|0;h=t[f>>2];(h+1|0)==(t[e+4>>2]|0)?(R(e),f=t[f>>2]):f=h;h=e+8|0;l[t[h>>2]+f|0]=0;f=t[h>>2];h=l[f];0!=(26>(h-97&255)&1|0)&&(l[f]=h-32&255);nG(e,2);Q(e)}mG.X=1;function oG(b,d){27==(d|0)||14==(d|0)||13==(d|0)?(pG(),t[z>>2]=248,t[Tc>>2]=248):7==(d|0)?(pG(),t[z>>2]=128,t[Tc>>2]=122):0==(d|0)?(pG(),t[z>>2]=t[Tc>>2]):26==(d|0)?(pG(),t[z>>2]=86,t[Tc>>2]=86):17==(d|0)?(pG(),t[z>>2]=68,t[Tc>>2]=68):6==(d|0)?(l[yc]=0,qG()):16==(d|0)?(pG(),t[z>>2]=88):2==(d|0)&&(pG(),t[z>>2]=24,t[Tc>>2]=24)}function rG(b){var d,c;d=(b+4|0)>>2;a:for(;;){for(var e=t[d];;){if(0!=(e|0)){var f=l[e];if(0!=f<<24>>24){break}}var g=eC();t[d]=g;if(0==(g|0)){var h=48;break a}else{e=g}}if(0!=(sG(f)|0)){c=75;break}if(0!=(10>(f-48&255)&1|0)){c=77;break}if(0!=(kG(f)|0)){for(var g=b+4|0,i=t[g>>2];0!=(kG(l[i])|0);){i=i+1|0}t[g>>2]=i}else{g=f&255;if(0!=(t[Gc+(g<<2)>>2]|0)){c=81;break}if(123==(g|0)){c=89;break}else{if(125==(g|0)){c=90;break}else{if(39==(g|0)){c=91;break}else{if(41==(g|0)){c=86;break}else{if(91==(g|0)){c=87;break}else{if(93==(g|0)){c=88;break}else{if(44==(g|0)){c=92;break}else{if(61==(g|0)){c=93;break}else{if(59==(g|0)){c=94;break}else{if(34==(g|0)){c=95;break}else{if(95==(g|0)){c=96;break}else{if(35==(g|0)){c=97;break}else{if(92==(g|0)){c=98;break}else{if(40!=(g|0)){c=99;break}}}}}}}}}}}}}}var m=e+1|0;if(42!=l[m]<<24>>24){c=85;break}tG(b)}}if(89==c){t[d]=e+1|0,h=36}else{if(90==c){t[d]=e+1|0,h=37}else{if(91==c){t[d]=e+1|0,h=38}else{if(85==c){t[d]=m,h=32}else{if(86==c){t[d]=e+1|0,h=33}else{if(81==c){h=uG(b)}else{if(87==c){t[d]=e+1|0,h=34}else{if(88==c){t[d]=e+1|0,h=35}else{if(75==c){vG(b),b=mC(t[t[b>>2]+8>>2],t[Ty>>2]),h=-1==(b|0)?31:b}else{if(77==c){b=b+4|0;d=t[b>>2];if(0!=(10>(l[d]-48&255)&1|0)){for(;!(d=d+1|0,t[b>>2]=d,0==(10>(l[d]-48&255)&1|0));){}}h=41}else{92==c?(t[d]=e+1|0,h=44):93==c?(t[d]=e+1|0,h=40):94==c?(t[d]=e+1|0,h=43):95==c?(lG(b),h=41):96==c?(t[d]=e+1|0,h=41):97==c?(t[d]=e+1|0,h=46):98==c?(t[d]=e+1|0,h=47):99==c&&(t[d]=e+1|0,h=41)}}}}}}}}}}return h}rG.X=1;function sG(b){return(0==(26>(b-97&255)&1|0)?0!=(26>(b-65&255)&1|0):1)&1}function vG(b){var d;d=(b|0)>>2;S(t[d]);var b=(b+4|0)>>2,c=t[b],e=l[c];if(0!=(sG(e)|0)|95==e<<24>>24){var f=t[d],c=t[f>>2];(c+1|0)==(t[f+4>>2]|0)&&(R(f),c=t[d],e=l[t[b]],f=c,c=t[c>>2]);l[t[f+8>>2]+c|0]=e;e=t[b];0!=l[e]<<24>>24&&(e=t[d]|0,c=t[e>>2]+1|0,t[e>>2]=c,l[t[t[d]+8>>2]+c|0]=0,e=t[b])}else{e=c}e=e+1|0;c=l[e];f=0==(wG(c)|0);a:do{if(f){var g=e}else{for(var h=e,i=c;;){var m=t[d],n=t[m>>2];(n+1|0)==(t[m+4>>2]|0)&&(R(m),n=t[d],i=l[h],m=n,n=t[n>>2]);l[t[m+8>>2]+n|0]=i;0!=l[h]<<24>>24&&(i=t[d]|0,n=t[i>>2]+1|0,t[i>>2]=n,l[t[t[d]+8>>2]+n|0]=0);h=h+1|0;i=l[h];if(0==(wG(i)|0)){g=h;break a}}}}while(0);t[b]=g;b=t[d];g=t[b>>2];(g+1|0)!=(t[b+4>>2]|0)?(b=b+8|0,b=t[b>>2],d=b+g|0):(R(b),g=t[d],d=t[g>>2],b=g+8|0,b=t[b>>2],d=b+d|0);l[d]=0}vG.X=1;function uG(b){var d;d=(b+4|0)>>2;var c=t[d],b=(b|0)>>2;S(t[b]);var e=t[d],f=0==(t[Gc+((l[e]&255)<<2)>>2]|0),g=t[b],h=(t[g>>2]+1|0)==(t[g+4>>2]|0);a:do{if(f){var i=0,m=h,n=g}else{for(var q=0,p=g,s=h,r=e;;){if(s&&(R(p),r=t[d],p=t[b]),l[t[p+8>>2]+t[p>>2]|0]=l[r+q|0],p=t[d],0==l[p+q|0]<<24>>24?r=p:(p=t[b]|0,r=t[p>>2]+1|0,t[p>>2]=r,l[t[t[b]+8>>2]+r|0]=0,r=t[d]),q=q+1|0,p=t[b],s=(t[p>>2]+1|0)==(t[p+4>>2]|0),0==(t[Gc+((l[r+q|0]&255)<<2)>>2]|0)){i=q;m=s;n=p;break a}}}}while(0);m?(R(n),m=t[b]):m=n;l[t[m+8>>2]+t[m>>2]|0]=0;t[d]=t[d]+i|0;if(2>(i|0)){d=l[c]&255,d=61==(d|0)?40:124==(d|0)?39:42}else{if(2==(i|0)&&45==l[c]<<24>>24&&62==l[c+1|0]<<24>>24){return 45}d=42}return d}uG.X=1;function tG(b){var d,c;d=(b+4|0)>>2;var e=t[d]+2|0,f=1,g=0;a:for(;;){var g=0==(g|0),h=e;b:for(;;){var e=0==(f|0),i=h;c:for(;;){if(e){c=167;break a}do{if(0!=(i|0)&&(h=l[i],0!=h<<24>>24)){if(42==h<<24>>24){var m=1;c=166;break b}else{if(41==h<<24>>24){break c}else{if(40==h<<24>>24){c=161;break b}else{if(34!=h<<24>>24){c=165;break b}}}}t[d]=i;lG(b);i=t[d];continue c}}while(0);h=eC();t[d]=h;if(0==(h|0)){c=169;break a}else{i=h}}if(g){m=0;c=166;break}else{h=i,f=0}}do{if(161==c){if(c=0,42!=l[i+1|0]<<24>>24){m=0,c=166}else{t[d]=i;tG(b);var n=t[d];if(0==(n|0)){c=170;break a}else{var q=0}}}else{165==c&&(m=0,c=166)}}while(0);166==c&&(c=0,n=i,q=m&1);e=n+1|0;g=q}167==c&&(t[d]=i)}function xG(){for(var b,d=t[Xb>>2];;){var c=d-1|0;if(0>=(d|0)){var e=-1;b=205;break}if(0==(t[t[Yb+(c<<4)+12>>2]>>2]|0)){d=c}else{e=c;b=204;break}}if(205==b||204==b){return e}}function yG(b,d){if(42==(d|0)){var c=l[t[b+8>>2]]<<24>>24;58==(c|0)?(t[rd>>2]=20,t[z>>2]=154,t[Ib>>2]=40):126==(c|0)?(t[z>>2]=172,l[md]=0):63==(c|0)&&(t[z>>2]=144,l[md]=0)}else{40==(d|0)&&(t[z>>2]=20)}}function wG(b){if(0!=(10>(b-48&255)&1|0)){return 1}b=0!=(sG(b)|0)|95==b<<24>>24|39==b<<24>>24;return b&1}function pG(){l[yc]&&(l[yc]=0,zG())}function qG(){var b=zG();5==(b|0)?zG():4==(b|0)?zG():3==(b|0)?zG():0==(b|0)&&zG()}function nG(b,d){var c=j;j+=80;!(0==(t[ry+(d<<4)>>2]|0)|0==(b|0))&&0!=(t[b>>2]|0)&&(AG(c,t[b+8>>2],d),tC(c));j=c}function AG(b,d,c){var e=b>>2;sC(b,d);t[e+9]=t[ry+(c<<4)+8>>2];l[b+40|0]=t[ry+(c<<4)+4>>2]&255;2==(c|0)&&(t[e]=1,t[e+1]=1);b=xG();-1<(b|0)&&(t[e+15]=0==(t[Yb+(b<<4)+4>>2]|0)?wf|0:6==(t[Yb+(b<<4)+4>>2]|0)?al|0:2==(t[Yb+(b<<4)+4>>2]|0)?Fi|0:3==(t[Yb+(b<<4)+4>>2]|0)?Eq|0:1==(t[Yb+(b<<4)+4>>2]|0)?ll|0:4==(t[Yb+(b<<4)+4>>2]|0)?Cf|0:5==(t[Yb+(b<<4)+4>>2]|0)?Bw|0:0,t[e+16]=t[t[Yb+(b<<4)+12>>2]+8>>2])}function zG(){for(var b,d=t[Xb>>2];;){var c=d-1|0;if(0>=(d|0)){b=300;break}if(0==(t[Yb+(c<<4)>>2]|0)){b=299;break}else{d=c}}if(299==b){return t[Xb>>2]=c,t[z>>2]=t[Yb+(c<<4)+8>>2],S(t[Yb+(c<<4)+12>>2]),b=t[Yb+(c<<4)+4>>2]}if(300==b){return t[Xb>>2]=0,t[z>>2]=122,-1}}function BG(b,d,c,e){var f=j,g=t[Xb>>2];255<(g|0)?KC(Qk|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k)):(t[Yb+(g<<4)>>2]=b,t[Yb+(g<<4)+4>>2]=d,t[Yb+(g<<4)+8>>2]=c,b=xG(),0==(e|0)?(t[Xb>>2]=g+1|0,S(t[Yb+(g<<4)+12>>2])):(g=t[Yb+(g<<4)+12>>2],-1<(b|0)?(V(g,t[t[Yb+(b<<4)+12>>2]+8>>2]),g=t[Yb+(t[Xb>>2]<<4)+12>>2],d=t[g>>2],(d+1|0)==(t[g+4>>2]|0)&&(R(g),g=d=t[Yb+(t[Xb>>2]<<4)+12>>2],d=t[d>>2]),c=4==(t[Yb+(b<<4)+4>>2]|0)||5==(t[Yb+(b<<4)+4>>2]|0)||3==(t[Yb+(b<<4)+4>>2]|0)||1==(t[Yb+(b<<4)+4>>2]|0)?47:0==(t[Yb+(b<<4)+4>>2]|0)?46:6==(t[Yb+(b<<4)+4>>2]|0)?32:2==(t[Yb+(b<<4)+4>>2]|0)?35:36,b=g+8|0,l[t[b>>2]+d|0]=c,0!=c<<24>>24&&(d=g|0,c=t[d>>2]+1|0,t[d>>2]=c,l[t[b>>2]+c|0]=0),U(g,t[e+8>>2])):V(g,t[e+8>>2]),t[Xb>>2]=t[Xb>>2]+1|0));j=f}BG.X=1;function CG(b,d){30==(d|0)?(DG(),t[z>>2]=160,EG(160)):11==(d|0)?(EG(12),t[z>>2]=20):1==(d|0)?(BG(0,6,20,0),t[z>>2]=20):6==(d|0)?qG():10==(d|0)?(t[rd>>2]=20,t[z>>2]=114,t[Ib>>2]=45):36==(d|0)?(t[z>>2]=104,t[Ib>>2]=37,t[rd>>2]=12,FG(0,36)):39==(d|0)||33==(d|0)||35==(d|0)||37==(d|0)?DG():12==(d|0)?GG():5==(d|0)||24==(d|0)?(DG(),EG(12),t[z>>2]=20):0==(d|0)?(GG(),t[z>>2]=188):15==(d|0)?(EG(12),t[z>>2]=20):32==(d|0)||34==(d|0)?(EG(12),t[z>>2]=20):43==(d|0)?t[z>>2]=20:4==(d|0)||27==(d|0)||(l[yc]=1,oG(0,d))}function EG(b){BG(1,3,b,0)}function GG(){var b=xG();-1<(b|0)?(t[Xb>>2]=b,t[z>>2]=t[Yb+(b<<4)+8>>2],S(t[Yb+(b<<4)+12>>2])):(t[Xb>>2]=0,t[z>>2]=122)}function DG(){var b=t[Xb>>2];1>(b|0)?t[z>>2]=122:(b=b-1|0,t[Xb>>2]=b,t[z>>2]=t[Yb+(b<<4)+8>>2],S(t[Yb+(b<<4)+12>>2]))}function FG(b,d){35==(d|0)?t[qd>>2]=t[qd>>2]+1|0:33==(d|0)?t[od>>2]=t[od>>2]+1|0:34==(d|0)?t[qd>>2]=t[qd>>2]-1|0:37==(d|0)?t[pd>>2]=t[pd>>2]+1|0:36==(d|0)?t[pd>>2]=t[pd>>2]-1|0:32==(d|0)&&(t[od>>2]=t[od>>2]-1|0);(t[Ib>>2]|0)==(d|0)&0==(t[od>>2]|0)&0==(t[qd>>2]|0)&0==(t[pd>>2]|0)?t[z>>2]=t[rd>>2]:6==(d|0)&&(zG(),t[z>>2]=122)}function HG(){var b=j;j+=80;var d,c=P(),e=eC();t[nd>>2]=e;if(0!=(e|0)){for(var f=0,g=0,h=0,i=0,m=0,n=0,q=0,p=0;;){var s=e+1|0;t[nd>>2]=s;var r=l[e],e=r&255;if(0==r<<24>>24){if(r=eC(),t[nd>>2]=r,0==(r|0)){var u=p,v=q,w=n,C=m,A=i,I=h,M=g,B=f}else{if(s=l[r],0==s<<24>>24){u=p,v=q,w=n,C=m,A=i,I=h,M=g,B=f}else{if((0==(h|0)|0==(f|0))&0==(i|0)){d=r+1|0,t[nd>>2]=d,G=s&255,Z=d}else{var G=e,Z=r}d=522}}}else{G=e,Z=s,d=522}a:do{if(522==d){if(d=0,0!=(q|0)){123==(n|0)&125==(G|0)?(u=p,v=0,w=n):40==(n|0)&42==(G|0)?(41!=l[Z]<<24>>24?(u=p,v=q):(t[nd>>2]=Z+1|0,u=p,v=0),w=40):(u=p,v=q,w=n),C=m,A=i,I=h,M=g,B=f}else{if(0!=(m|0)){u=p,v=0,w=n,C=39==(G|0)?0:m,A=i,I=h,M=g,B=f}else{if(40==(G|0)){42==l[Z]<<24>>24?(t[nd>>2]=Z+1|0,u=p,v=1,w=40,C=0,A=i,I=h,M=g):(u=p,v=0,w=n,C=0,A=i,I=h,M=0==(h|0)?g:1),B=f}else{if(123==(G|0)){u=p,v=1,w=123,C=0,A=i,I=h,M=g,B=f}else{if(39==(G|0)){u=p,v=0,w=n,C=1,A=i,I=h,M=g,B=f}else{if(41==(G|0)){u=p,v=0,w=n,C=0,A=i,I=h,M=0,B=f}else{if(59==(G|0)){if(0!=(h|0)&0==(g|0)){e=1}else{u=p;v=0;w=n;C=0;A=i;I=h;M=g;B=f;break}}else{e=f}do{if(0==(h|0)|0==(e|0)){I=h,B=e}else{B=l[Z];if(0==B<<24>>24){u=p;v=0;w=n;C=0;A=i;I=h;M=g;B=e;break a}else{if(32==B<<24>>24){I=h;B=e;break}}0==(rA(101==B<<24>>24&1)|0)?102!=(rA(l[t[nd>>2]]&255)|0)?(B=h,u=e):(B=(u=0==(IG(cl|0)|0))?h:0,u=u?e:0):(B=(u=0==(IG(Vn|0)|0))?h:0,u=u?e:0);if(0==(B|0)|0==(u|0)){I=B,B=u}else{0!=(t[b+32>>2]|0)&&tC(b);u=p;v=0;w=n;C=0;A=i;I=0;M=g;B=0;break a}}}while(0);if(0==(i|0)){0!=(I|0)?(u=p,v=0,w=n,A=C=0):(u=rA(G),99==(u|0)?(u=(A=0==(IG(oj|0)|0))?p:1,v=0,w=n,C=0,A=A&1^1):100==(u|0)?(u=(A=0==(IG(Mh|0)|0))?p:1,v=0,w=n,C=0,A=A&1^1):112==(u|0)?(u=(A=0==(IG(sg|0)|0))?p:1,v=0,w=n,C=0,A=A&1^1):102==(u|0)?(u=(A=0==(IG(of|0)|0))?p:0,v=0,w=n,C=0,A=A&1^1):(u=p,v=0,w=n,A=C=0),I=0)}else{if(u=l[t[nd>>2]],0==u<<24>>24){u=p,v=0,w=n,C=0,A=i}else{u=0==(L(u&255)|0);v=t[nd>>2];b:do{if(u){var X=v}else{for(w=v;;){if(w=w+1|0,t[nd>>2]=w,C=t[nd>>2],0==(L(l[w]&255)|0)){X=C;break b}else{w=C}}}}while(0);b:for(;;){u=l[X];if(0==u<<24>>24){break}do{if(0==(oA(u&255)|0)&&(v=l[X],!(95==v<<24>>24||46==v<<24>>24)&&10<=((v&255)-48|0)>>>0)){break b}}while(0);X=X+1|0}w=t[nd>>2];u=c;v=w;w=X-w|0;S(u);gD(u,v,w);u=b;v=p;!(0==(t[ky+(v<<4)>>2]|0)|0==(c|0))&&0!=(t[c>>2]|0)?(sC(u,t[c+8>>2]),t[u+36>>2]=t[ky+(v<<4)+8>>2],l[u+40|0]=t[ky+(v<<4)+4>>2]&255):sC(u,0);t[nd>>2]=X;u=p;v=0;w=n;A=C=0;I=1}}M=g}}}}}}}}while(0);e=t[nd>>2];if(0==(e|0)){break}else{f=B,g=M,h=I,i=A,m=C,n=w,q=v,p=u}}}Q(c);j=b}HG.X=1;function IG(b){for(var d,c=0;;){var e=l[b];if(0==e<<24>>24){break}if((rA(e<<24>>24)|0)!=(rA(l[t[nd>>2]+c|0]&255)|0)){d=568;break}b=b+1|0;c=c+1|0}if(568==d&&0!=l[b]<<24>>24||0!=(oA(l[t[nd>>2]+c|0]&255)|0)){return 0}d=t[nd>>2]+c|0;b=l[d];if(95==b<<24>>24||46==b<<24>>24){return 0}t[nd>>2]=d;return 1}function JG(){var b,d,c,e,f=j;j+=80;var g,h=P();e=(h|0)>>2;var i=h+4|0;c=(h+8|0)>>2;var m=f+40|0,n=f+36|0,q=f+32|0,p=0,s=0;a:for(;;){var r=eC();if(0==(r|0)){var u=p;break}if(0!=(s|0)){s=0==(N(r,nj|0,4)|0)?0:s}else{if(s=l[r],61==s<<24>>24){r=r+1|0;if(0==(pA(l[r]<<24>>24)|0)){r=0}else{c:{for(var s=r,v=aq|0,w=ba,C={};;){w=l[v++];if(!w){break}C[w]=1}for(;;){w=l[s];if(!w){break}if(w in C){break c}s++}s=0}v=0==(s|0)?tb(r):s-r|0;s=zC(v+1|0);iB(s,r,v);for(v=r=l[s+v|0]=0;;){var A=0==(qA(s,t[Fc+(v<<2)>>2])|0)?1:r,v=v+1|0;if(11>v>>>0&0==(A|0)){r=A}else{break}}vB(s);r=A}s=r}else{if(0==(qA(r,Lh|0)|0)){u=p;break}if(0==(qA(r,rg|0)|0)){u=p;break}if(35!=s<<24>>24){for(;;){v=r+1|0;if(0==(L(s&255)|0)){break}r=v;s=l[v]}do{if(0==(N(r,nf|0,3)|0)){b=p;var I=4,M=r+3|0}else{if(0==(N(r,Ze|0,3)|0)){s=r+3|0;if(0==(L(l[s]&255)|0)){s=0;continue a}for(;;){v=l[s];if(0==v<<24>>24){break}if(0==(L(v&255)|0)){break}else{s=s+1|0}}if(0!=(N(s,Rr|0,8)|0)){s=0;continue a}b=p;I=0;M=s+8|0}else{if(0!=(N(r,Gi|0,7)|0)){if(0==(N(r,as|0,6)|0)){b=p;I=1;M=r+6|0;g=631;break}if(0==((95==(l[r]&255|0)|0!=(pA(l[r]&255)|0))&1|0)){s=0;continue a}else{s=r}for(;;){if(0==(KG(l[s]&255)|0)){var B=s;break}else{s=s+1|0}}for(;;){var G=B+1|0;if(0==(L(l[B]&255)|0)){break}else{B=G}}if(58!=l[B]<<24>>24){s=0;continue a}if(s=58==l[G]<<24>>24){s=0;continue a}else{var Z=r,X=p;d=X>>2;var ga=s?-1:2,ra=1;break}}g=r+7|0;0==(p|0)?I=P():(S(p),I=p);for(v=g;0!=(L(l[v]&255)|0);){v=v+1|0}b=(I|0)>>2;M=I+4|0;for(s=I+8|0;;){w=l[v];if(59==w<<24>>24){break}if(0!=(L(w&255)|0)){break}w=t[b];(w+1|0)==(t[M>>2]|0)&&(R(I),w=t[b]);l[t[s>>2]+w|0]=l[v];0!=l[v]<<24>>24&&(w=t[b]+1|0,t[b]=w,l[t[s>>2]+w|0]=0);v=v+1|0}U(I,Bv|0);b=I;I=3;M=g}}g=631}while(0);do{if(631==g){if(g=0,p=l[M],0==p<<24>>24){Z=M,X=b,d=X>>2,ga=I,ra=0}else{if(0==(L(p&255)|0)){p=b;s=0;continue a}else{Z=M,X=b,d=X>>2,ga=I,ra=0}}}}while(0);for(p=Z;;){if(0==(L(l[p]&255)|0)){var ka=p;break}p=p+1|0}b:for(;;){p=l[ka];if(!(0==p<<24>>24||35==p<<24>>24)){var ia=ka,ea=p;break}p=eC();if(0==(p|0)){u=X;break a}for(;;){if(0==(L(l[p]&255)|0)){ka=p;continue b}else{p=p+1|0}}}for(;;){if(0==(KG(ea&255)|0)){if(1==(ga|0)){g=647;break}else{if(3!=(ga|0)){break}}if(58!=l[ia]<<24>>24){break}}ea=t[e];(ea+1|0)==(t[i>>2]|0)&&(R(h),ea=t[e]);l[t[c]+ea|0]=l[ia];0!=l[ia]<<24>>24&&(ea=t[e]+1|0,t[e]=ea,l[t[c]+ea|0]=0);ia=ea=ia+1|0;ea=l[ea]}647==g&&(g=0,0==(t[e]|0)&&61==l[ia]<<24>>24&&U(h,Fu|0));p=t[e];(p+1|0)==(t[i>>2]|0)&&(R(h),p=t[e]);l[t[c]+p|0]=0;if(0!=(t[e]|0)){do{if(4==(ga|0)){sC(f,t[c]);do{p=ba;s=ia;r=v=0;b:for(;;){for(w=s;;){var wb=l[w];if(0!=wb<<24>>24){break}s=eC();if(0==(s|0)){var sb=0;break b}else{w=s}}s=0==(r|0);for(C=wb;;){C&=255;if(32==(C|0)||9==(C|0)){var Db=v,Za=r;break}else{if(58==(C|0)){p=688;break}else{if(40==(C|0)){p=690;break}else{if(41==(C|0)){p=691;break}else{if(59==(C|0)){if(s){sb=1;break b}}else{if(123==(C|0)&&s){sb=0;break b}}}}}}if(0==(v|0)){p=697;break}if(0==((95==(C|0)|0!=(pA(C)|0))&1|0)){sb=0;break b}else{v=w}for(;;){var kc=v+1|0;if(0==(KG(l[kc]&255)|0)){break}else{v=kc}}w=kc;v=0;C=l[kc]}do{if(688==p){if(p=0,s){if(1==(v|0)){sb=0;break b}else{Db=1,Za=0}}else{Db=v,Za=r}}else{if(690==p){p=0,Db=v,Za=r+1|0}else{if(691==p){p=0,Db=v,Za=r-1|0}else{if(697==p){if(p=0,s){sb=0;break b}else{Db=0,Za=r}}}}}}while(0);s=w+1|0;v=Db;r=Za}if(1==(sb|0)){if(1==(t[iy+80>>2]|0)){p=5}else{S(h);p=X;s=0;continue a}}else{p=4}}while(0);l[m]=t[iy+(p<<4)+4>>2]&255;t[n>>2]=t[iy+(p<<4)+8>>2];tC(f);!(0==(t[oy+4>>2]|0)|ra|0==(X|0))&&0!=(t[d]|0)&&(p=P(),V(p,t[d+2]),U(p,t[c]),t[q>>2]=t[p+8>>2],tC(f),Q(p))}else{jC(h,iy|0,ga),!(0==(t[oy+4>>2]|0)|ra|3==(ga|0)|0==(X|0))&&0!=(t[d]|0)&&(p=P(),V(p,t[d+2]),U(p,t[c]),jC(p,iy|0,ga),Q(p))}}while(0)}S(h);p=X}s=0}}}Q(h);0!=(u|0)&&Q(u);j=f}JG.X=1;function KG(b){return(95==(b|0)|0!=(oA(b)|0))&1}function LG(){var b,d,c,e=j;j+=12;var f,g=e+4;c=g>>2;var h=e+8,i=P(),m=P(),n=P(),q=MG(12);t[e>>2]=0;var p=i|0,s=i+8|0;d=(m|0)>>2;var r=m+4|0;b=(m+8|0)>>2;var u=n|0,v=0,w=1;a:for(;;){for(;;){var C=eC();if(0==(C|0)){break a}var A=l[NG(C)];if(0!=A<<24>>24){if(35!=A<<24>>24){break}if(!w){break}}}0==(v|0)&&S(i);U(i,C);DD(i);var I=t[s>>2],M=92==l[I+(t[p>>2]-1)|0]<<24>>24;b:do{if(M){zD(i);U(i,Eo|0);var B=1}else{var G=NG(I),Z=G-I|0;if(w){for(var X=ba,ga=t[q+4>>2],ra=q|0,ka=n+8|0,ia=0;;){if((ia|0)>=(ga|0)){X=770;break}var ea=t[ra>>2],wb=ea+12*ia|0;if(0!=(wb|0)){var sb=t[(ea+4>>2)+(3*ia|0)];if(0==(qA(t[ka>>2],t[sb+8>>2])|0)){break}}ia=ia+1|0}770!=X&&((t[wb>>2]|0)<(Z|0)||S(sb));var Db=OG(G,e);if(0!=(Db|0)){PG(Db+3|0,e)}else{for(var Za,kc=G;;){if(0==l[kc]<<24>>24){var $c=0;break}var Ia=QG(kc);if(0==(N(Ia,wk|0,3)|0)){$c=Ia;break}if(0==(N(Ia,Fi|0,5)|0)){$c=Ia;break}if(0==(N(Ia,kn|0,4)|0)){$c=Ia;break}if(0==(N(Ia,Ym|0,5)|0)){$c=Ia;break}kc=RG(Ia)}Za=$c;var Eb=0==(Za|0);c:do{if(!Eb){t[c]=0;do{if(0==(N(Za,ng|0,4)|0)){var Pb=NG(Za+3|0)}else{if(0==(N(Za,gf|0,6)|0)){var He=NG(Za+5|0);t[c]=1;Pb=He}else{if(0==(N(Za,Fd|0,5)|0)){var Hd=SG(NG(Za+4|0),g);if(0==(Hd|0)){break c}else{Pb=Hd;break}}if(0!=(N(Za,Mw|0,6)|0)){break c}var de=SG(NG(Za+5|0),g);if(0==(de|0)){break c}else{Pb=de}}}}while(0);var ee=TG(q,Z,n),Id=t[c];if(0==(Id|0)){var Jd=m,uc=n,Kd=ee,Qb;var Mc=UG(Pb,Jd),ad=ba;if(0==(Mc|0)){var bb=0}else{var Qa=mA(Mc,40);if(0==(Qa|0)){bb=0}else{var Rb=1,vc=Qa;e:for(;;){for(var Sb=0<(Rb|0),fe=vc;;){var vd=fe+1|0;if(!Sb){break e}var lc=l[vd];if(41==lc<<24>>24){ad=981;break}else{if(40==lc<<24>>24){ad=980;break}else{if(0==lc<<24>>24){break e}else{fe=vd}}}}981==ad?(ad=0,Rb=Rb-1|0,vc=vd):980==ad&&(ad=0,Rb=Rb+1|0,vc=vd)}l[vd]=0;bb=jB(Qa)}}Qb=bb;VG(Jd,uc,Kd);0!=(Qb|0)&&vB(Qb)}else{WG(Pb,m,n,ee)}for(var Nc=Z,ge=m,he=Id,Tb=q|0,Ub=q+4|0,bd=t[Ub>>2],cd=0,ac=0;;){if((ac|0)>=(bd|0)){var ie=cd;break}var Ld=t[Tb>>2]+12*ac|0;if((t[Ld>>2]|0)<(Nc|0)){cd=Ld,ac=ac+1|0}else{ie=Ld;break}}if((ac|0)==(bd|0)){var gb=q,dd=ge,Vb=ba,Sa=ba,Sa=(gb+4|0)>>2,Oc=t[Sa],Pc=gb+8|0,Md=t[Pc>>2];if((Oc|0)<(Md|0)){var ed=Oc,je=gb|0}else{var ke=Md+1|0;t[Pc>>2]=ke;var wd=gb|0,Vb=wd>>2;t[Vb]=jF(t[Vb],12*ke|0);var xd=P();t[(t[Vb]+4>>2)+(3*t[Sa]|0)]=xd;ed=t[Sa];je=wd}var ob=t[je>>2];t[Sa]=ed+1|0;V(t[(ob+4>>2)+(3*ed|0)],t[dd+8>>2]);t[(ob+8>>2)+(3*ed|0)]=0;var Fb=t[Tb>>2]+12*bd|0}else{t[Ub>>2]=ac+1|0,V(t[ie+4>>2],t[ge+8>>2]),Fb=ie}t[Fb>>2]=Nc;t[Fb+8>>2]=0==(he|0)&1}}while(0);var fd=XG(I);do{if(0!=(fd|0)){S(m);var le=0==(YG(l[fd]<<24>>24)|0),gd=t[d],yd=(gd+1|0)==(t[r>>2]|0);c:do{if(le){var Nd=yd,Od=gd}else{for(var wc=fd,xc=yd,hd=gd;;){if(xc){R(m);var Pd=t[d]}else{Pd=hd}l[t[b]+Pd|0]=l[wc];if(0!=l[wc]<<24>>24){var bc=t[d]+1|0;t[d]=bc;l[t[b]+bc|0]=0}var me=wc+1|0,Qd=t[d],ne=(Qd+1|0)==(t[r>>2]|0);if(0==(YG(l[me]<<24>>24)|0)){Nd=ne;Od=Qd;break c}else{wc=me,xc=ne,hd=Qd}}}}while(0);if(Nd){R(m);var cc=t[d]}else{cc=Od}l[t[b]+cc|0]=0;var id=TG(q,Z,n),yb=0!=(id|0);if(0==(ZG(fd,h)|0)){if(!yb&&0!=(t[u>>2]|0)){B=0;break b}var Rd=t[b],oe=n,jd=ba,Qc=j;j+=80;jd=Qc>>2;sC(Qc,Rd);t[jd+9]=qf|0;l[Qc+40|0]=118;0!=(t[oe>>2]|0)&&(t[jd+15]=Fi|0,t[jd+16]=t[oe+8>>2]);tC(Qc);j=Qc}else{yb?f=743:0==(t[u>>2]|0)&&(f=743),743==f&&(f=0,VG(m,n,id)),vB(t[h>>2])}}}while(0);var mc=tA(QG(I),Yv|0);if(0!=(mc|0)&&0!=(L(l[mc+6|0]<<24>>24)|0)){var pe=NG(mc+7|0),Rc=P(),kd=P(),nc=QG(pe),Sd=0==l[nc]<<24>>24;c:do{if(!Sd){for(var Sc=kd+8|0,Td=Rc+8|0,qe=nc;;){var hf=QG(UG(qe,Rc));UG(hf,kd);0!=(qA(t[Sc>>2],Ur|0)|0)&&0!=(qA(t[Td>>2],Ur|0)|0)&&jC(Rc,fy|0,4);if(0==l[hf]<<24>>24){break c}else{qe=hf}}}}while(0);Q(Rc);Q(kd)}}}else{PG(G,e)}B=0}}while(0);v=B;w=0==(t[e>>2]|0)}Q(n);Q(m);Q(i);var jf=q+8|0,Ag=0<(t[jf>>2]|0),JH=q|0,KH=t[JH>>2];a:do{if(Ag){for(var Xp=0,LH=KH;;){Q(t[(LH+4>>2)+(3*Xp|0)]);var MH=Xp+1|0,NH=t[JH>>2];if((MH|0)<(t[jf>>2]|0)){Xp=MH,LH=NH}else{var Yp=NH;break a}}}else{Yp=KH}}while(0);if(0==(Yp|0)){var OH=q}else{vB(Yp),OH=q}vB(OH);j=e}LG.X=1;function NG(b){for(;0!=(L(l[b]<<24>>24)|0);){b=b+1|0}return b}function PG(b,d){for(var c=b;;){c=tA(c,t[d>>2]);if(0==(c|0)){break}t[d>>2]=0;c=OG(c+3|0,d);if(0==(c|0)){break}else{c=c+3|0}}}function OG(b,d){for(var c,e=b;;){var f=l[e];if(34==f<<24>>24||39==f<<24>>24){if(0==(N(e,Cm|0,3)|0)){c=774;break}if(0==(N(e,Lm|0,3)|0)){c=776;break}f=$G(e);if(0==l[f]<<24>>24){var g=0;break}else{e=f}}else{if(0==f<<24>>24||35==f<<24>>24){g=0;break}}e=e+1|0}776==c?(t[d>>2]=Lm|0,g=e):774==c&&(t[d>>2]=Cm|0,g=e);return g}function SG(b,d){var c,e=NG(b);if(0==(N(Vn|0,e,6)|0)){e=NG(e+6|0);if(0==(N(Gn|0,e,4)|0)){var f;return 0}var g=e}else{g=e}if(0==(N(Fi|0,g,5)|0)){return t[d>>2]=1,f=NG(g+5|0)}var e=0,h=b;a:for(;;){var i=l[g];if(0==i<<24>>24){f=0;c=804;break}var m=e+1|0;if(2>(e|0)){var n=g}else{f=0;c=806;break}for(;;){if(0==i<<24>>24||61==i<<24>>24||40==i<<24>>24){var q=i;break}var p=n+1|0;if(0!=(L(i<<24>>24)|0)){c=797;break}n=p;i=l[p]}797==c&&(c=0,q=l[n]);if(40==q<<24>>24){c=801;break}else{if(0==q<<24>>24||61==q<<24>>24){f=0;c=807;break}}for(i=n=NG(n);;){if(42==l[i]<<24>>24){i=i+1|0}else{e=m;g=n;h=i;continue a}}}if(801==c){return h}if(804==c||806==c||807==c){return f}}SG.X=1;function TG(b,d,c){var e;S(c);for(var f=b|0,b=b+4|0,g=0,h=0,i=0;;){if((i|0)>=(t[b>>2]|0)){e=817;break}var m=t[f>>2],n=m+12*i|0;if((t[n>>2]|0)>=(d|0)){e=816;break}0!=(h|0)&&U(c,Xi|0);U(c,t[t[(m+4>>2)+(3*i|0)]+8>>2]);g=0==(t[(m+8>>2)+(3*i|0)]|0)&1;h=n;i=i+1|0}if(817==e||816==e){return g}}function WG(b,d,c,e){var f,g,h=P();S(h);var i=NG(UG(b,d));if(40==l[i]<<24>>24){g=(h|0)>>2;f=(h+4|0)>>2;b=(h+8|0)>>2;for(i=i+1|0;;){var m=l[i];if(0==m<<24>>24){i=eC();if(0==(i|0)){break}var n=t[g];(n+1|0)==(t[f]|0)&&(R(h),n=t[g]);l[t[b]+n|0]=32;n=t[g]+1|0;t[g]=n;l[t[b]+n|0]=0}else{if(41==m<<24>>24){break}n=t[g];(n+1|0)==(t[f]|0)&&(R(h),m=l[i],n=t[g]);l[t[b]+n|0]=m;0!=l[i]<<24>>24&&(n=t[g]+1|0,t[g]=n,l[t[b]+n|0]=0);i=i+1|0}}i=t[g];(i+1|0)==(t[f]|0)?(R(h),f=t[g]):f=i;l[t[b]+f|0]=0}d=t[(d+8|0)>>2];f=j;j+=80;b=f>>2;sC(f,d);t[b+9]=Fi|0;l[f+40|0]=99;0!=(t[c>>2]|0)&&(t[(f+60|0)>>2]=0==(e|0)?Cf|0:Fi|0,t[b+16]=t[c+8>>2]);t[b+14]=t[h+8>>2];tC(f);j=f;Q(h)}WG.X=1;function XG(b){var d,c=mA(b,61);if(0==(c|0)){var e;return 0}for(var f=c;;){var f=f+1|0,g=l[f];if(0==g<<24>>24||40==g<<24>>24||35==g<<24>>24){var h=c;break}else{if(61==g<<24>>24){e=0;d=860;break}}}if(860==d){return e}for(;;){d=h-1|0;if(d>>>0<b>>>0){var i=d;break}if(0==(L(l[d]<<24>>24)|0)){i=d;break}else{h=d}}for(;i>>>0>=b>>>0&&0!=(YG(l[i]<<24>>24)|0);){i=i-1|0}d=i+1|0;if(0==((95==(l[d]<<24>>24|0)|0!=(pA(l[d]<<24>>24)|0))&1|0)){return 0}for(;i>>>0>=b>>>0&&0!=(L(l[i]<<24>>24)|0);){i=i-1|0}return(i+1|0)==(b|0)?d:0}function YG(b){return(95==(b|0)|0!=(oA(b)|0))&1}function ZG(b,d){var c,e,f,g=NG(RG(NG(b)));if(61!=l[g]<<24>>24){return 0}g=NG(g+1|0);if(0!=(N(g,xo|0,6)|0)){return 0}var g=g+6|0,h=NG(g);if((h|0)==(g|0)){return 0}g=P();f=(g|0)>>2;c=t[f];e=(g+4|0)>>2;if((c+1|0)==(t[e]|0)){R(g);var i=t[f]}else{i=c}c=(g+8|0)>>2;l[t[c]+i|0]=40;i=t[f]+1|0;t[f]=i;for(l[t[c]+i|0]=0;;){var i=l[h],m=t[f],n=(m+1|0)==(t[e]|0);if(58==i<<24>>24||0==i<<24>>24){break}if(n){R(g);var i=l[h],q=t[f]}else{q=m}l[t[c]+q|0]=i;0!=l[h]<<24>>24&&(i=t[f]+1|0,t[f]=i,l[t[c]+i|0]=0);h=h+1|0}n&&(R(g),m=t[f]);l[t[c]+m|0]=41;m=t[f]+1|0;t[f]=m;l[t[c]+m|0]=0;m=t[f];(m+1|0)==(t[e]|0)?(R(g),e=t[f]):e=m;l[t[c]+e|0]=0;0!=(d|0)&&(t[d>>2]=jB(t[c]));Q(g);return 1}ZG.X=1;function VG(b,d,c){var e,f=j;j+=80;e=f>>2;b=b+8|0;sC(f,t[b>>2]);var g=f+36|0;t[g>>2]=Cf|0;var h=f+40|0;l[h]=102;0!=(t[d>>2]|0)&&(0==(c|0)?t[e+15]=Cf|0:(t[g>>2]=$p|0,l[h]=109,t[e+15]=Fi|0),t[e+16]=t[d+8>>2]);d=t[b>>2];0==(N(d,Jp|0,2)|0)&&0!=(qA(d,sp|0)|0)?(t[e+11]=nx|0,t[e+4]=1):t[e+11]=Yf|0;tC(f);j=f}function $G(b){var d,c=b,e=0;a:for(;;){for(var f=0==(e|0),g=c;;){var h=g+1|0,c=l[h];if(0==c<<24>>24){var i=h;d=934;break a}if(!f){break}if(92==c<<24>>24){c=h;e=1;continue a}if(c<<24>>24==l[b]<<24>>24){break a}else{g=h}}c=h;e=e-1|0}return 934==d?i:g+2|0}function QG(b){var d;a:for(;;){var c=l[b];b:do{if(34==c<<24>>24||39==c<<24>>24||35==c<<24>>24){var e=b;d=949}else{if(0==c<<24>>24){var f=b;d=953;break a}else{do{if(0!=(sA(b,bv|0,2)|0)&&0!=(sA(b,Du|0,2)|0)&&0!=(sA(b,bu|0,2)|0)&&0!=(sA(b,Dt|0,2)|0)&&0!=(sA(b,ct|0,2)|0)&&0!=(sA(b,Es|0,2)|0)){do{if(0!=(sA(b,ms|0,3)|0)&&0!=(sA(b,Xr|0,3)|0)&&0!=(sA(b,xr|0,3)|0)&&0!=(sA(b,gr|0,3)|0)){var g=b,h=c;break b}}while(0);e=b+2|0;d=949;break b}}while(0);e=b+1|0;d=949}}}while(0);if(949==d&&(d=0,g=$G(e),h=l[g],0==h<<24>>24)){f=g;d=954;break}if(0==((95==(h<<24>>24|0)|0!=(pA(h<<24>>24)|0))&1|0)){b=g+1|0}else{f=g;d=952;break}}if(952==d||953==d||954==d){return f}}QG.X=1;function UG(b,d){var c;S(d);var e=0==(YG(l[b]<<24>>24)|0);c=(d|0)>>2;var f=t[c],g=d+4|0,h=(f+1|0)==(t[g>>2]|0);a:do{if(e){var i=b,m=h,n=f}else{for(var q=d+8|0,p=b,s=h,r=f;;){if(s&&(R(d),r=t[c]),l[t[q>>2]+r|0]=l[p],0!=l[p]<<24>>24&&(r=t[c]+1|0,t[c]=r,l[t[q>>2]+r|0]=0),p=p+1|0,r=t[c],s=(r+1|0)==(t[g>>2]|0),0==(YG(l[p]<<24>>24)|0)){i=p;m=s;n=r;break a}}}}while(0);if(!m){return c=t[(d+8|0)>>2],n=c+n|0,l[n]=0,i}R(d);n=t[c];c=t[(d+8|0)>>2];n=c+n|0;l[n]=0;return i}UG.X=1;function RG(b){for(;0!=(YG(l[b]<<24>>24)|0);){b=b+1|0}return b}function aH(){var b,d=j;j+=4;var c;b=d>>2;var e=bH();t[tc>>2]=e;e=1;a:for(;;){b:for(;;){var f=eC();if(0==(f|0)){break a}t[b]=f;if(0!=(cH(d,Zm|0)|0)){e=0;continue a}if(0!=(cH(d,Ok|0)|0)){e=1;continue a}dH(d);0==(cH(d,Vs|0)|0)?0!=(cH(d,bp|0)|0)?c=1005:0!=(cH(d,im|0)|0)?c=1005:0!=(cH(d,ff|0)|0)?c=1005:0!=(cH(d,ye|0)|0)&&(c=1005):c=1005;1005==c&&(c=0,AE(t[tc>>2],PD(hm|0)));0==(cH(d,Uf|0)|0)?0!=(cH(d,Fi|0)|0)?eH(d,0):0!=(cH(d,wk|0)|0)?eH(d,1):0!=(cH(d,av|0)|0)?eH(d,4):0!=(cH(d,Bu|0)|0)&&eH(d,5):eH(d,2);c:for(;;){var f=t[b],g=l[f];if(0==g<<24>>24){continue b}do{if(e){var h=t[b];if(0==(L(g&255)|0)){if(35==l[h]<<24>>24){continue b}do{if(0==(cH(d,ov|0)|0)&&0==(cH(d,Zs|0)|0)){do{if(0!=(cH(d,Sf|0)|0)&&(f=t[tc>>2],g=t[f+4>>2],0!=(g|0))){Q(t[t[f+8>>2]+(g-1<<2)>>2]);f=t[tc>>2];g=f+4|0;h=t[g>>2]-1|0;t[g>>2]=h;t[t[f+8>>2]+(h<<2)>>2]=0;continue c}}while(0);f=t[b];g=l[f];if(34==g<<24>>24){for(;;){if(f=f+1|0,t[b]=f,g=l[f],0==g<<24>>24||34==g<<24>>24){continue c}}}else{if(0==g<<24>>24){continue c}else{var i=f}}for(;;){if(f=i+1|0,t[b]=f,g=t[b],0!=(oA(l[f]&255)|0)){i=g}else{if(95==l[g]<<24>>24){i=g}else{continue c}}}}}while(0);AE(t[tc>>2],PD(hm|0));continue c}}else{h=f}}while(0);t[b]=h+1|0}}}fH(t[tc>>2]);j=d}aH.X=1;function cH(b,d){var c=tb(d),e=t[b>>2],f=l[e+c|0];if(0!=(N(e,d,c)|0)){return 0}if(0!=f<<24>>24){if(0!=(L(f&255)|0)|40==f<<24>>24){e=t[b>>2]}else{return 0}}t[b>>2]=e+c|0;return 1}function dH(b){if(0!=(L(l[t[b>>2]]&255)|0)){for(;;){var d=t[b>>2]+1|0;t[b>>2]=d;if(0==(L(l[d]&255)|0)){break}}}}function eH(b,d){if(0!=(L(l[t[b>>2]]&255)|0)){var c=P(),e=gH(b,c,d);if(-1!=(e|0)&&0!=(t[c>>2]|0)){var f,g=j;j+=80;f=g>>2;var h=c|0,i=t[h>>2];(i+1|0)==(t[c+4>>2]|0)&&(R(c),i=t[h>>2]);h=c+8|0;l[t[h>>2]+i|0]=0;var m=t[tc>>2],i=P(),n=t[m+4>>2];if(0!=(n|0)){for(var m=m+8|0,q=0,p=0;;){var s=t[t[m>>2]+(q<<2)>>2];0!=(t[s>>2]|0)&&(U(i,0!=(p|0)?Xi|0:hm|0),U(i,t[s+8>>2]),p=p+1|0);q=q+1|0;if((q|0)==(n|0)){break}}}sC(g,t[h>>2]);0!=(t[i>>2]|0)&&(t[f+15]=Fi|0,t[f+16]=t[i+8>>2]);t[f+9]=t[cy+(e<<4)+8>>2];l[g+40|0]=t[cy+(e<<4)+4>>2]&255;tC(g);AE(t[tc>>2],BE(c));S(c);Q(i);j=g}Q(c)}}function gH(b,d,c){var e,f,g=b>>2,h;f=(d|0)>>2;var i=d+4|0;e=(d+8|0)>>2;a:for(;;){var m=1==(c|0);do{if(m){dH(b);var n=Wr|0;h=1061}else{var q=2>(c-4|0)>>>0?vr|0:fr|0;dH(b);if(3==(c|0)){n=q,h=1061}else{if(0!=(c|0)){var p=q}else{if(p=t[g],60!=l[p]<<24>>24){p=q}else{if(60==l[p+1|0]<<24>>24){var s=-1;h=1081;break a}else{p=q}}}}}}while(0);if(1061==h){h=0;for(var p=d,q=b,r=ba,u=0;;){if(28==(u|0)){var v=0,r=1101;break}var w=t[hc+(u<<2)>>2];if(0==(cH(q,w)|0)){u=u+1|0}else{break}}1101!=r&&(U(p,w),v=1);p=v;if(0==(p|0)){p=n}else{s=c;h=1078;break}}for(q=t[g];;){r=l[q];if(0==r<<24>>24){s=c;h=1077;break a}q=l[t[g]];if(0==(oA(r&255)|0)&&0==(0!=(mA(p,q<<24>>24)|0)&1|0)){s=c;h=1079;break a}r=t[f];(r+1|0)==(t[i>>2]|0)&&(R(d),r=t[f]);l[t[e]+r|0]=q;0!=q<<24>>24&&(r=t[f]+1|0,t[f]=r,l[t[e]+r|0]=0);r=t[g]+1|0;t[g]=r;if(m){if(46==q<<24>>24){break}if(0==(0!=(mA(Pq|0,q<<24>>24)|0)&1|0)){q=r}else{s=1;h=1080;break a}}else{q=r}}c=t[f];(c+1|0)==(t[i>>2]|0)&&(R(d),c=t[f]);l[t[e]+c|0]=0;S(d);c=3}if(1081==h||1077==h||1078==h||1080==h||1079==h){return s}}gH.X=1;function hH(){var b=P(),d=eC();if(0!=(d|0)){for(;;){var c=40==l[d]<<24>>24;a:do{if(c){var e=l[d+1|0];do{if(68==e<<24>>24||100==e<<24>>24){var f=l[d+2|0];if(69==f<<24>>24||101==f<<24>>24){if(f=l[d+3|0],70==f<<24>>24||102==f<<24>>24){for(var f=d,g=40;;){var h=f+1|0;if(0!=(L(g)|0)){var i=f;break}f=h;g=l[h]&255}for(;;){f=l[i];if(0==f<<24>>24){break}if(0==(L(f&255)|0)&&40!=l[i]<<24>>24){break}i=i+1|0}iH(b,i);jC(b,ay|0,0);if(40!=l[i]<<24>>24){break a}f=i;g=l[i+1|0]}else{f=d,g=e}}else{f=d,g=e}}else{f=d,g=e}}while(0);if(83==g<<24>>24||115==g<<24>>24){if(e=l[f+2|0],69==e<<24>>24||101==e<<24>>24){if(e=l[f+3|0],(84==e<<24>>24||116==e<<24>>24)&&33==l[f+4|0]<<24>>24&&0!=(L(l[f+5|0]&255)|0)){for(e=f;;){f=l[e];if(0==f<<24>>24){var m=e;break}if(0==(L(f&255)|0)){e=e+1|0}else{m=e;break}}for(;0!=(L(l[m]&255)|0);){m=m+1|0}iH(b,m);jC(b,ay|0,1)}}}}}while(0);d=eC();if(0==(d|0)){break}}}Q(b)}hH.X=1;function iH(b,d){var c,e,f;S(b);e=(b|0)>>2;var g=b+4|0;c=(b+8|0)>>2;for(var h=d;;){var i=l[h];if(0==i<<24>>24||40==i<<24>>24||41==i<<24>>24){f=1133;break}var m=t[e],n=(m+1|0)==(t[g>>2]|0);if(0!=(L(i&255)|0)){f=1140;break}n?(R(b),i=t[e]):i=m;l[t[c]+i|0]=l[h];0!=l[h]<<24>>24&&(i=t[e]+1|0,t[e]=i,l[t[c]+i|0]=0);h=h+1|0}if(1133==f){if(h=t[e],(h+1|0)==(t[g>>2]|0)){f=1141}else{var q=h}}else{1140==f&&(n?f=1141:q=m)}1141==f&&(R(b),q=t[e]);l[t[c]+q|0]=0}iH.X=1;function jH(){var b,d,c,e=P(),f=eC();if(0!=(f|0)){d=(e|0)>>2;var g=e+4|0;for(b=(e+8|0)>>2;;){var h=l[f],i=35==h<<24>>24;a:do{if(!i){for(var m=f,n=h;;){var q=m+1|0;if(0==(L(n&255)|0)){break}m=q;n=l[q]}n=0==(N(m,Cf|0,8)|0);b:do{if(n){if(q=m+8|0,0==(L(l[q]&255)|0)){var p=0,s=m}else{if(0==(L(l[q]&255)|0)){break a}for(;;){if(0==(L(l[q]&255)|0)){p=1;s=q;break b}else{q=q+1|0}}}}else{p=0,s=m}}while(0);do{if(0==(oA(l[s]&255)|0)){if(95==l[s]<<24>>24){m=s}else{break a}}else{m=s}}while(0);b:for(;;){do{if(0==(oA(l[m]&255)|0)){var r=t[d],u=(r+1|0)==(t[g>>2]|0);if(95!=l[m]<<24>>24){break b}if(u){c=1159}else{var v=r}}else{n=t[d],(n+1|0)==(t[g>>2]|0)?c=1159:v=n}}while(0);1159==c&&(c=0,R(e),v=t[d]);l[t[b]+v|0]=l[m];0!=l[m]<<24>>24&&(n=t[d]+1|0,t[d]=n,l[t[b]+n|0]=0);m=m+1|0}u?(R(e),n=t[d]):n=r;for(l[t[b]+n|0]=0;;){var w=m+1|0;if(0==(L(l[m]&255)|0)){break}else{m=w}}if(40==l[m]<<24>>24){for(n=w;0!=(L(l[n]&255)|0);){n=n+1|0}41!=l[n]<<24>>24?n=p:(n=0!=(qA(kH(t[t[K>>2]+8>>2]),bf|0)|0)?0:0==(qA(t[e+8>>2],zd|0)|0),n&=1,n=0==(n|0)?1:p)}else{n=p}0!=(n|0)&&jC(e,Xx|0,0);S(e)}}while(0);f=eC();if(0==(f|0)){break}}}Q(e)}jH.X=1;function lH(){var b,d=j;j+=4;var c;b=d>>2;var e=P(),f=eC();if(0!=(f|0)){for(var g=e+8|0,h=-1;;){for(var f=mH(f),i=t[b]=f;;){f=t[Mz>>2];if(0!=(f|0)){i=tA(i,Mm|0);t[b]=i;if(0==(i|0)){var m=h;break}t[Mz>>2]=f-1|0;t[b]=i+2|0}var n,f=d;n=P();t[f>>2]=nH(t[f>>2],n);for(var f=t[n+8>>2],i=-1,q=0;;){var p=0==(qA(f,t[Tx+(q<<3)>>2])|0)?t[Tx+(q<<3)+4>>2]:i,q=q+1|0;if(10>q>>>0&-1==(p|0)){i=p}else{break}}Q(n);n=p;f=t[b];-1==(n|0)?n=h:(f=nH(mH(f),e),t[b]=f,i=t[g>>2],-2==(n|0)?(oH(h,i),n=h):oH(n,i));h=f;if(0==(tA(h,Dk|0)|0)){if(0==(h|0)){m=n;break}else{f=h}}else{if(h=tA(h+2|0,Mm|0),t[b]=h,0==(h|0)){c=1199;break}else{f=h}}if(0==l[f]<<24>>24){m=n;break}else{h=n,i=f}}1199==c&&(c=0,t[Mz>>2]=t[Mz>>2]+1|0,m=n);f=eC();if(0==(f|0)){break}else{h=m}}}Q(e);j=d}lH.X=1;function mH(b){for(;0!=(L(l[b]&255)|0);){b=b+1|0}return b}function nH(b,d){var c;S(d);var e=b,f=0,g=l[b];a:for(;;){for(var h=0!=(f|0),i=0==(f|0),m=e,n=g;;){if(0==n<<24>>24){var q=m;c=1233;break a}var p=l[m];if(!(0==(pH(n&255)|0)|h)){c=1221;break a}var n=m+1|0,s=l[n];if(40==p<<24>>24&&42==s<<24>>24&i){c=1219;break a}if(34!=s<<24>>24|92==p<<24>>24){m=n,n=s}else{e=n;f=1;g=34;continue a}}}if(1221==c){if(0==p<<24>>24|0==(m|0)){return m}e=0==(pH(p&255)|0);c=(d|0)>>2;f=t[c];g=d+4|0;h=(f+1|0)==(t[g>>2]|0);a:do{if(e){var r=m,u=h,v=f}else{i=d+8|0;q=m;n=h;for(p=f;;){if(n&&(R(d),p=t[c]),l[t[i>>2]+p|0]=l[q],0!=l[q]<<24>>24&&(p=t[c]+1|0,t[c]=p,l[t[i>>2]+p|0]=0),q=q+1|0,p=t[c],n=(p+1|0)==(t[g>>2]|0),0==(pH(l[q]&255)|0)){r=q;u=n;v=p;break a}}}}while(0);u?(R(d),m=t[c]):m=v;l[t[d+8>>2]+m|0]=0;return r}if(1233==c){return q}if(1219==c){return t[Mz>>2]=t[Mz>>2]+1|0,m+2|0}}nH.X=1;function oH(b,d){var c=j;j+=80;sC(c,d);t[c+36>>2]=t[Sx+(b<<4)+8>>2];l[c+40|0]=t[Sx+(b<<4)+4>>2]&255;tC(c);j=c}function pH(b){return 0!=(oA(b)|0)?1:0==(b|0)?0:0!=(bC(wh|0,b,21)|0)&1}function qH(){var b,d=zC(28);b=d>>2;t[b]=0;t[b+1]=-1;t[b+2]=P();t[b+3]=P();t[b+4]=0;t[b+5]=t[K+48>>2];t[b+6]=t[K+24>>2];return d}function rH(b){Q(t[b+8>>2]);Q(t[b+12>>2]);vB(b)}function sH(b){$(b);8==(t[b>>2]|0)&&(tH(b,5),$(b))}function uH(b){var d=t[b+4>>2];if(27==(d|0)){vH(b)}else{if(1==(d|0)){wH(b,0)}else{if(55==(d|0)){xH(b)}else{if(28==(d|0)){yH(b)}else{if(31==(d|0)){var c,d=qH();$(d);$(b);var e=b|0;14==(t[e>>2]|0)&&$(d);for(c=(b+4|0)>>2;68!=(t[c]|0)&&6!=(t[e>>2]|0);){$(b)}tH(d,14);68==(t[c]|0)&&($(b),1==(t[c]|0)&&wH(b,1),zH(b,1));rH(d)}else{if(53==(d|0)){xH(b)}else{if(54==(d|0)){xH(b)}else{if(17==(d|0)){d=qH();c=d>>2;$(d);2==(t[c+1]|0)&&$(d);var e=b+4|0,f=0==(t[e>>2]|0);a:do{if(!f){for(var g=b|0;;){if($(b),14==(t[g>>2]|0)&&$(d),0==(t[e>>2]|0)){break a}}}}while(0);e=t[c];(8==(e|0)||13==(e|0))&&tH(d,6);AH(b,t[c+2]);wH(b,0);S(t[b+12>>2]);zH(b,0);rH(d)}else{if(69==(d|0)){for(c=b+4|0;!(d=0==(t[c>>2]|0),$(b),d);){}15==(t[b>>2]|0)&&BH(b,16);zH(b,1)}else{if(3==(d|0)){CH(b,0)}else{if(65==(d|0)){zH(b,0)}else{if(30==(d|0)){c=qH();d=qH();$(c);$(b);e=b|0;14==(t[e>>2]|0)&&($(c),$(b));if(45==(t[b+4>>2]|0)&&(f=t[c>>2],8==(f|0)||13==(f|0))){$(d),$(b),14==(t[e>>2]|0)&&($(d),$(b)),AH(c,t[d+8>>2]),tH(c,13)}zH(b,0);rH(c);rH(d)}else{if(52==(d|0)){xH(b)}else{if(34==(d|0)){DH(b)}else{if(26==(d|0)){CH(b,9)}else{if(66==(d|0)){d=qH();$(d);$(b);e=(b|0)>>2;f=t[e];14==(f|0)&&($(d),$(b),f=t[e]);10==(f|0)&&EH(b);for(f=b+4|0;!(c=0==(t[f>>2]|0))&&6!=(t[e]|0);){$(b)}e=t[d>>2];(8==(e|0)||13==(e|0))&&c&&tH(d,18);zH(b,1);rH(d)}else{32==(d|0)?(c=qH(),$(c),$(b),d=b|0,e=t[d>>2],14==(e|0)?($(c),$(b),d=t[d>>2]):d=e,10==(d|0)&&(d=t[c>>2],(8==(d|0)||13==(d|0))&&tH(c,15)),zH(b,0),rH(c)):35==(d|0)?DH(b):33==(d|0)?(c=qH(),$(c),$(b),29==(t[b+4>>2]|0)&&(d=t[c>>2],(8==(d|0)||13==(d|0))&&tH(c,16)),zH(b,0),rH(c)):67==(d|0)?(c=qH(),$(c),$(b),d=t[c>>2],(8==(d|0)||13==(d|0))&&14==(t[b+4>>2]|0)&&tH(c,19),zH(b,1),rH(c)):59==(d|0)?FH(b):62==(d|0)?GH(b):61==(d|0)?FH(b):42==(d|0)?(c=qH(),$(c),$(b),d=t[c>>2],(8==(d|0)||13==(d|0))&&6!=(t[b>>2]|0)&&tH(c,12),zH(b,1),rH(c)):58==(d|0)?FH(b):19==(d|0)?HH(b):7==(d|0)?IH(b,0):4==(d|0)?wH(b,0):56==(d|0)?xH(b):29==(d|0)?PH(b):57==(d|0)?FH(b):6==(d|0)?HH(b):60==(d|0)&&FH(b)}}}}}}}}}}}}}}}}}uH.X=1;function wH(b,d){var c,e;1==(t[b>>2]|0)&&(sH(b),$(b));e=(b+4|0)>>2;if(1!=(t[e]|0)&&($(b),QH(b,d),1!=(t[e]|0))){return}$(b);var f=qH();c=(b+4|0)>>2;if(4==(t[c]|0)){for(var g=f+4|0,h=b|0,i=0==(d|0);;){$(b);$(f);var m=t[g>>2];if(3==(m|0)){tH(b,0)}else{if(63==(t[c]|0)&64==(m|0)){$(b),27==(t[c]|0)&&($(b),m=t[h>>2],(8==(m|0)||13==(m|0))&&tH(b,10))}else{if(m=t[h>>2],8==(m|0)||13==(m|0)){i?tH(b,12):tH(b,4)}}}BH(b,6);$(b);if(4!=(t[c]|0)){break}}}rH(f);c=(b+16|0)>>2;f=t[c]+1|0;t[c]=f;if(5==(t[e]|0)){e=f}else{for(;!(IH(b,0),0!=(RH(b)|0)&&$(b),5==(t[e]|0));){}e=t[c]}t[c]=e-1|0;$(b)}function CH(b,d){$(b);var c=t[b>>2];(8==(c|0)||13==(c|0))&&tH(b,d)}function DH(b){var d=qH();$(d);0==(t[d+4>>2]|0)&&$(d);$(b);var c=t[d>>2];(8==(c|0)||13==(c|0))&&tH(d,17);zH(b,0);rH(d)}function HH(b){var d,c,e,f,g,h=qH();f=h>>2;var i=P();e=(b+4|0)>>2;var m=6==(t[e]|0),n=m?2:7;d=(b+12|0)>>2;V(i,t[t[d]+8>>2]);$(b);SH(h,b);$(b);c=(b|0)>>2;var q=t[c];14==(q|0)&&(0!=(t[i>>2]|0)&&AH(b,t[f+2]),$(b),SH(h,b),$(b),q=t[c]);10==(q|0)&&EH(b);m&&2>(t[e]-24|0)>>>0&&($(b),$(b),10==(t[c]|0)&&EH(b));if(0!=(RH(b)|0)){tH(h,1)}else{for(;;){var p=t[e];if(0==(p|0)||1==(p|0)){break}else{if(44==(p|0)||37==(p|0)||38==(p|0)||39==(p|0)){g=1362;break}}if(21==(t[c]|0)){g=1361;break}if(0!=(RH(b)|0)){g=1361;break}$(b);36==(p|0)&&10==(t[c]|0)&&EH(b)}if(1361==g&&(44==(p|0)||37==(p|0)||38==(p|0)||39==(p|0))){g=1362}1362==g&&(AH(b,t[f+2]),m=t[f],8==(m|0)||13==(m|0)?g=1364:-1!=(t[e]|0)&&(g=1364),1364==g&&tH(h,n),S(t[d]));21==(t[c]|0)&&$(b);c=t[e];4==(c|0)&&(QH(b,0),c=t[e]);2>c>>>0&&(AH(b,t[f+2]),f=t[f],8==(f|0)||13==(f|0)?g=1373:-1!=(t[e]|0)&&(g=1373),1373==g&&tH(h,n),wH(b,1),S(t[d]))}b=t[d];d=(i+8|0)>>2;d=t[d];V(b,d);rH(h);Q(i)}HH.X=1;function $(b){var d,c,e,f;e=(b|0)>>2;t[e]=0;var g=b+4|0;t[g>>2]=-1;c=(b+8|0)>>2;S(t[c]);d=(b+20|0)>>2;b=(b+24|0)>>2;a:for(;;){var h=T();t[d]=t[K+48>>2];t[b]=t[K+24>>2];if(46==(h|0)){f=1386;break}else{if(125==(h|0)){f=1389;break}else{if(40==(h|0)){f=1382;break}else{if(126==(h|0)){f=1390;break}else{if(58==(h|0)){f=1384;break}else{if(41==(h|0)){f=1383;break}else{if(91==(h|0)){f=1391;break}else{if(123==(h|0)){f=1388;break}else{if(93==(h|0)){f=1392;break}else{if(61==(h|0)){f=1393;break}else{if(39==(h|0)||34==(h|0)){f=1394;break}else{if(45==(h|0)){var i=T();if(45!=(i|0)){f=1397;break}uE(10)}else{if(60==(h|0)||62==(h|0)){f=1400;break}else{if(92==(h|0)){f=1405;break}else{if(47==(h|0)){var m=T();if(47==(m|0)){uE(10)}else{if(42!=(m|0)){f=1410;break}for(;;){uE(42);var n=T();if(47==(n|0)){continue a}W(n);if(-1==(n|0)||0==(n|0)){continue a}}}}else{if(!(32==(h|0)||10==(h|0)||9==(h|0))){if(-1==(h|0)){f=1381;break}else{if(59==(h|0)){f=1385;break}else{if(44==(h|0)){f=1387;break}else{if(0==((0!=(pA(h)|0)|64==(h|0)|95==(h|0))&1|0)){f=1415;break}for(var q=t[c],p=n=ba,p=(q|0)>>2,s=q+4|0,n=(q+8|0)>>2,r=h;;){var u=t[p];(u+1|0)==(t[s>>2]|0)&&(R(q),u=t[p]);l[t[n]+u|0]=r&255;0!=(r|0)&&(u=t[p]+1|0,t[p]=u,l[t[n]+u|0]=0);u=T();if(0==((0!=(pA(u)|0)|10>(u-48|0)>>>0?1:95==(u|0)||64==(u|0)||36==(u|0)||35==(u|0)?1:0)|0)){break}else{r=u}}r=t[p];(r+1|0)==(t[s>>2]|0)?(R(q),q=t[p]):q=r;l[t[n]+q|0]=0;0==(L(u)|0)&&W(u);t[d]=t[K+48>>2];t[b]=t[K+24>>2];n=UD(t[c],t[Hy>>2]);t[g>>2]=n;if(-1==(n|0)){f=1418;break}else{if(23!=(n|0)){f=1419;break}}S(t[c]);uE(10)}}}}}}}}}}}}}}}}}}}}if(1386==f){t[e]=14}else{if(1389==f){t[e]=16}else{if(1382==f){t[e]=10}else{if(1390==f){t[e]=19}else{if(1415==f){t[e]=0}else{if(1384==f){t[e]=5}else{if(1383==f){t[e]=4}else{if(1391==f){t[e]=17}else{if(1388==f){t[e]=15}else{if(1392==f){t[e]=18}else{if(1393==f){t[e]=21}else{if(1394==f){t[e]=13;e=t[c];g=h;c=(e|0)>>2;f=e+4|0;h=(e+8|0)>>2;i=1;a:for(;;){for(;;){if(!i){break a}m=T();if(-1==(m|0)|(m|0)==(g|0)){i=0;continue a}n=t[c];(n+1|0)==(t[f>>2]|0)&&(R(e),n=t[c]);l[t[h]+n|0]=m&255;0!=(m|0)&&(m=t[c]+1|0,t[c]=m,l[t[h]+m|0]=0)}}g=t[c];(g+1|0)!=(t[f>>2]|0)?(h=t[h],e=h+g|0):(R(e),e=t[c],h=t[h],e=h+e|0);l[e]=0;t[d]=t[K+48>>2];t[b]=t[K+24>>2]}else{1397==f?(0==(L(i)|0)&&W(i),t[e]=11):1400==f?(d=T(),(d|0)!=(h|0)?(W(d),t[e]=0):t[e]=60==(h|0)?1:2):1405==f?(h=T(),!(92==(h|0)||39==(h|0)||34==(h|0))&&0==(L(h)|0)&&W(h),t[e]=3,t[d]=t[K+48>>2],t[b]=t[K+24>>2]):1410==f?(t[e]=20,W(m)):1419==f?t[e]=9:1418==f?t[e]=8:1381==f?dB(xz|0,1):1385==f?t[e]=6:1387==f&&(t[e]=7)}}}}}}}}}}}}}$.X=1;function IH(b,d){var c,e,f;e=(b|0)>>2;c=(b+4|0)>>2;var g=0==(d|0);a:for(;;){var h=1==(t[e]|0);b:do{if(h){sH(b);var i=0;f=1488}else{var m=t[c];c:do{if(40==(m|0)){for($(b);;){var n=41==(t[c]|0);$(b);if(n){var q=0;break b}}}else{if(43==(m|0)){$(b);q=0;break b}else{if(70==(m|0)){$(b);uH(b);var p=0}else{if(1==(m|0)||4==(m|0)){wH(b,1),p=0}else{if(11==(m|0)||13==(m|0)){f=1465}else{if(7==(m|0)){for(p=7;41!=(p|0);){if(1==(p|0)){f=1452;break}$(b);p=t[c]}if(1452==f){f=0,wH(b,0),p=0!=(RH(b)|0)&1}else{$(b);var p=t[c],n=5==(p|0),s=10!=(p|0)&(n^1);d:do{if(s){for(var r=p;;){2>(r-8|0)>>>0&&$(b);IH(b,1);0!=(RH(b)|0)&&$(b);var r=t[c],u=5==(r|0);if(!(10!=(r|0)&(u^1))){var v=u,w=r;break d}}}else{v=n,w=p}}while(0);v?($(b),p=t[c]):p=w;7==(p|0)||10==(p|0)?($(b),p=0!=(RH(b)|0)&1):p=0}}else{if(14==(m|0)){$(b);$(b);if(0!=(t[c]|0)){break a}for(;;){if($(b),15==(t[c]|0)){f=1465;break c}}}else{5!=(m|0)&&$(b),p=0}}}}}}}}while(0);if(1465==f){f=0;$(b);m=5==(t[c]|0);c:do{if(!m){for(;;){if(IH(b,0),0!=(RH(b)|0)&&$(b),5==(t[c]|0)){break c}}}}while(0);$(b);m=t[c];(11==(m|0)||13==(m|0)||14==(m|0))&&$(b);p=0!=(RH(b)|0)&1}m=0==(p|0);c:for(;;){if(!m){i=p;f=1488;break b}n=t[c];if(5==(n|0)){i=0;f=1488;break b}if(0!=(RH(b)|0)){i=0;f=1488;break b}if(!(10!=(n|0)|g)){break a}if(5==(t[e]|0)&&($(b),n=t[c],11==(n|0)||12==(n|0)||14==(n|0))){break a}$(b);n=t[e];if(10==(n|0)||15==(n|0)||17==(n|0)){TH(b),n=t[e]}do{if(1!=(n|0)&&(s=t[c],!(43==(s|0)||11==(s|0)||13==(s|0)||14==(s|0)||1==(s|0)))){if(7!=(s|0)){continue c}IH(b,1);continue c}}while(0);IH(b,0)}}}while(0);1488==f&&(f=0,q=0!=(RH(b)|0)&0==(i|0)?1:i);h=t[c];if(5==(h|0)){break}if(!((10!=(h|0)|g)&0==(q|0))){break}}}IH.X=1;function xH(b){var d,c=qH(),e=qH(),f=qH();$(b);d=(b|0)>>2;do{if(10==(t[d]|0)){$(c);$(b);var g=t[d],h=7==(g|0),g=4!=(g|0)&(h^1);a:do{if(g){for(;;){$(b);var i=t[d],m=7==(i|0);if(!(4!=(i|0)&(m^1))){var n=m;break a}}}else{n=h}}while(0);if(n){$(e);$(b);g=t[d];h=7==(g|0);g=4!=(g|0)&(h^1);a:do{if(g){for(;;){if($(b),i=t[d],m=7==(i|0),!(4!=(i|0)&(m^1))){var q=m;break a}}}else{q=h}}while(0);q&&($(f),13==(t[c>>2]|0)&&13==(t[e>>2]|0)&&13==(t[f>>2]|0)&&(AH(c,t[e+8>>2]),AH(c,t[f+8>>2]),tH(c,20)));4!=(t[d]|0)&&BH(b,4)}}}while(0);zH(b,1);rH(c);rH(e);rH(f)}xH.X=1;function FH(b){var d,c=qH(),e=qH();$(b);d=(b|0)>>2;if(10==(t[d]|0)){$(c);$(b);var f=t[d],g=7==(f|0),f=4!=(f|0)&(g^1);a:do{if(f){for(;;){$(b);var h=t[d],i=7==(h|0);if(!(4!=(h|0)&(i^1))){var m=i;break a}}}else{m=g}}while(0);m&&($(e),13==(t[c>>2]|0)&&13==(t[e>>2]|0)&&(AH(c,t[e+8>>2]),tH(c,21)));4!=(t[d]|0)&&BH(b,4)}zH(b,1);rH(c);rH(e)}function GH(b){var d,c=qH(),e=qH(),f=qH();$(b);d=(b|0)>>2;do{if(10==(t[d]|0)){$(c);$(b);var g=t[d],h=7==(g|0),g=4!=(g|0)&(h^1);a:do{if(g){for(;;){$(b);var i=t[d],m=7==(i|0);if(!(4!=(i|0)&(m^1))){var n=m;break a}}}else{n=h}}while(0);if(n){$(e);$(b);g=t[d];h=7==(g|0);g=4!=(g|0)&(h^1);a:do{if(g){for(;;){if($(b),i=t[d],m=7==(i|0),!(4!=(i|0)&(m^1))){var q=m;break a}}}else{q=h}}while(0);q&&($(f),13==(t[c>>2]|0)&&13==(t[e>>2]|0)&&13==(t[f>>2]|0)&&(AH(c,t[e+8>>2]),AH(c,t[f+8>>2]),tH(c,22)));4!=(t[d]|0)&&BH(b,4)}}}while(0);zH(b,1);rH(c);rH(e);rH(f)}GH.X=1;function vH(b){var d,c,e=qH();$(e);c=(e|0)>>2;17==(t[c]|0)&&($(e),$(b));$(b);d=(b|0)>>2;var f=t[d];14==(f|0)?($(e),f=t[c],17==(f|0)&&($(e),$(b),f=t[c]),14==(f|0)&&($(e),17==(t[c]|0)&&($(e),$(b))),$(b),f=t[d],14!=(f|0)?d=f:($(e),17==(t[c]|0)&&($(e),$(b)),$(b),d=t[d])):d=f;if(10==(d|0)){if(c=t[c],8==(c|0)||13==(c|0)){tH(e,10),c=b+12|0,V(t[c>>2],t[t[e+8>>2]+8>>2]),UH(b),S(t[c>>2])}}else{44==(t[b+4>>2]|0)&&8==(t[c]|0)&&tH(e,10)}zH(b,0);rH(e)}vH.X=1;function RH(b){var d=t[b>>2];return(6==(d|0)||19==(d|0)||20==(d|0)?1:71==(t[b+4>>2]|0))&1}function yH(b){var d,c,e=qH(),f=qH();$(e);$(b);var g=b|0;14==(t[g>>2]|0)&&($(e),$(b));for(d=(b+4|0)>>2;45!=(t[d]|0)&&0==(RH(b)|0);){$(b)}if(0==(RH(b)|0)){$(f);$(b);14==(t[g>>2]|0)&&($(f),$(b));for(var h=e+8|0,g=b+12|0;;){var i=t[d];if(1==(i|0)||16==(i|0)){break}if(0!=(RH(b)|0)){c=1618;break}4==(i|0)?(AH(b,t[h>>2]),QH(b,1),S(t[g>>2])):$(b)}if(1618==c&&!(1==(i|0)||16==(i|0))){zH(b,1);rH(e);rH(f);return}c=f+8|0;AH(e,t[c>>2]);tH(e,11);AH(b,t[c>>2]);1==(t[d]|0)&&wH(b,1);S(t[g>>2])}zH(b,1);rH(e);rH(f)}yH.X=1;function PH(b){var d,c,e=qH(),f=P();c=(b+12|0)>>2;V(f,t[t[c]+8>>2]);AH(e,t[c]);$(e);if(8==(t[e>>2]|0)&&($(b),d=(b+4|0)>>2,0==(t[d]|0))){$(b);AH(b,t[e+8>>2]);var g=t[d];20==(g|0)||21==(g|0)?(tH(e,8),UH(b)):27==(g|0)?tH(e,10):22==(g|0)&&($(b),3==(t[d]|0)&&tH(e,0));S(t[c])}V(t[c],t[f+8>>2]);rH(e);Q(f)}function EH(b){10==(t[b>>2]|0)&&TH(b)}function tH(b,d){if(0!=(t[Qx+(d<<4)>>2]|0)){var c=b+12|0;if(0!=(t[t[c>>2]>>2]|0)){var e=P();V(e,t[t[c>>2]+8>>2]);U(e,Xi|0);c=b+8|0;U(e,t[t[c>>2]+8>>2]);var f=e|0,g=t[f>>2];(g+1|0)==(t[e+4>>2]|0)?(R(e),f=t[f>>2]):f=g;g=e+8|0;l[t[g>>2]+f|0]=0;V(t[c>>2],t[g>>2]);Q(e)}c=j;j+=80;e=c>>2;0!=(t[Qx+(d<<4)>>2]|0)&&(sC(c,t[t[b+8>>2]+8>>2]),t[e+1]=t[b+20>>2],t[e+2]=t[b+24>>2],t[e+9]=t[Qx+(d<<4)+8>>2],l[c+40|0]=t[Qx+(d<<4)+4>>2]&255,tC(c));j=c}}function zH(b,d){var c=t[b+16>>2];if(!(0!=(d|0)&&0!=(RH(b)|0))){for(;;){$(b);if(0!=(RH(b)|0)){break}if(0!=((0>=(c|0)?0:5==(t[b+4>>2]|0)?(t[b+16>>2]|0)==(c|0)&1:0)|0)){break}}}}function TH(b){var d=b|0,c=t[d>>2];if(10==(c|0)){var e=4}else{if(15==(c|0)){e=16}else{if(17==(c|0)){e=18}else{return}}}$(b);for(var f=1;;){var g=t[d>>2],f=((g|0)==(c|0)&1)+f|0,f=(((g|0)==(e|0)&0<(f|0))<<31>>31)+f|0;$(b);if(!(0!=(f|0)|(g|0)!=(e|0))){break}}}function AH(b,d){var c;c=(b+12|0)>>2;var e=t[c];0!=(t[e>>2]|0)&&(U(e,Xi|0),e=t[c]);U(e,t[d+8>>2]);var f=t[c],e=t[f>>2];(e+1|0)!=(t[f+4>>2]|0)?(f=f+8|0,f=t[f>>2],c=f+e|0):(R(f),e=t[c],c=t[e>>2],f=e+8|0,f=t[f>>2],c=f+c|0);l[c]=0}function UH(b){var d,c;d=(b|0)>>2;if(10==(t[d]|0)){var e=10}else{$(b),e=t[d]}var f=b+4|0;a:for(;;){(7==(e|0)||10==(e|0))&&$(b);if(6>(t[f>>2]-46|0)>>>0){c=1701}else{var g=t[d];if(8==(g|0)||13==(g|0)){tH(b,3),c=1701}else{var h=g}}for(;;){1701==c&&(c=0,h=t[d]);if(7==(h|0)||10==(h|0)){e=h;continue a}else{if(4==(h|0)){break a}}$(b);g=t[d];10!=(g|0)?h=g:(EH(b),c=1701)}}}function QH(b,d){var c,e=b+4|0,f=t[e>>2];if(4==(f|0)){$(b),c=1708}else{var g=f}a:for(;;){1708==c&&(g=t[e>>2]);do{if(19==(g|0)){HH(b)}else{if(3==(g|0)){CH(b,0)}else{if(6==(g|0)){HH(b)}else{if(29==(g|0)){PH(b)}else{if(28==(g|0)){CH(b,11)}else{if(26==(g|0)){CH(b,9)}else{if(1==(g|0)||5==(g|0)){break a}else{8==(t[b>>2]|0)&&(0==(d|0)?tH(b,12):tH(b,4))}}}}}}}}while(0);BH(b,6);$(b);c=1708}}function BH(b,d){var c=b|0;if((t[c>>2]|0)!=(d|0)){for(;!($(b),(t[c>>2]|0)==(d|0));){}}}function SH(b,d){var c=d>>2,e=b>>2;t[e+5]=t[c+5];t[e+6]=t[c+6];t[e]=t[c];t[e+1]=t[c+1];V(t[e+2],t[t[c+2]+8>>2]);V(t[e+3],t[t[c+3]+8>>2])}function VH(){var b,d=P(),c=eC();if(0!=(c|0)){for(;;){if(0!=(L(l[c]&255)|0)){c=c+1|0}else{var e=l[c];a:do{if(!(0==e<<24>>24||35==e<<24>>24)){for(var f=c,g=e;;){if(0==g<<24>>24){var h=0;break}var i=f+1|0;if(0!=(L(g&255)|0)){b=1782;break}f=i;g=l[i]}1782==b&&(b=0,h=l[f]&255);if(0!=(L(h)|0)){for(;0!=(L(l[f]&255)|0);){f=f+1|0}if(0!=(WH(c,ok|0)|0)){XH(f,d,2)}else{do{if(0==(WH(c,Fi|0)|0)&&0==(WH(c,kh|0)|0)){do{if(0==(WH(c,Yf|0)|0)&&0==(WH(c,Ve|0)|0)&&0==(WH(c,nx|0)|0)){break a}}while(0);if(0==(WH(f,Bw|0)|0)){break a}for(c=f+6|0;0!=(L(l[c]&255)|0);){c=c+1|0}XH(c,d,1);break a}}while(0);XH(f,d,0)}}}}while(0);c=eC();if(0==(c|0)){break}}}}Q(d)}VH.X=1;function WH(b,d){return 0==(N(b,d,tb(d))|0)&1}function XH(b,d,c){var e,f,g;S(d);f=(d|0)>>2;var h=d+4|0;for(e=(d+8|0)>>2;;){var i=l[b];if(0==i<<24>>24){g=1804;break}var m=t[f],n=(m+1|0)==(t[h>>2]|0);if(0!=(L(i&255)|0)){g=1811;break}n?(R(d),i=t[f]):i=m;l[t[e]+i|0]=l[b];0!=l[b]<<24>>24&&(i=t[f]+1|0,t[f]=i,l[t[e]+i|0]=0);b=b+1|0}if(1811==g){if(n){g=1812}else{var q=m}}else{1804==g&&(m=t[f],(m+1|0)==(t[h>>2]|0)?g=1812:q=m)}1812==g&&(R(d),q=t[f]);l[t[e]+q|0]=0;jC(d,Nx|0,c)}XH.X=1;function YH(){var b,d=zC(24);b=d>>2;t[b]=0;t[b+1]=-1;t[b+2]=P();t[b+3]=P();t[b+4]=t[K+48>>2];t[b+5]=t[K+24>>2];return d}function ZH(b){Q(t[b+8>>2]);Q(t[b+12>>2]);vB(b)}function $H(b,d){var c,e,f=YH(),g=P();S(g);e=(b|0)>>2;c=t[e];if(4==(c|0)){c=b>>2;var h=f>>2;t[h+4]=t[c+4];t[h+5]=t[c+5];t[h]=t[c];t[h+1]=t[c+1];V(t[h+2],t[t[c+2]+8>>2]);V(t[h+3],t[t[c+3]+8>>2]);aI(b);h=t[e]}else{h=c}if(10==(h|0)){aI(b);c=(g|0)>>2;for(h=b+8|0;;){var i=t[e];if(6==(i|0)){0!=(t[c]|0)&&U(g,Eo|0),U(g,t[t[h>>2]+8>>2])}else{if(11==(i|0)){break}}aI(b)}h=t[c];(h+1|0)==(t[g+4>>2]|0)?(R(g),c=t[c]):c=h;h=g+8|0;l[t[h>>2]+c|0]=0;V(t[f+8>>2],t[h>>2]);bI(f,d);c=0;h=t[e]}else{c=1}13==(h|0)&&(aI(b),h=t[e]);if(8==(h|0)){aI(b);h=9==(t[e]|0);c=0!=(c|0);a:do{if(!h){for(var i=g|0,m=b+8|0;;){if(c&&(0!=(t[i>>2]|0)&&U(g,Eo|0),U(g,t[t[m>>2]+8>>2])),aI(b),9==(t[e]|0)){break a}}}}while(0);c&&(e=g|0,c=t[e>>2],(c+1|0)==(t[g+4>>2]|0)?(R(g),e=t[e>>2]):e=c,c=g+8|0,l[t[c>>2]+e|0]=0,V(t[f+8>>2],t[c>>2]),bI(f,d))}ZH(f);Q(g)}$H.X=1;function bI(b,d){if(0!=(t[Lx+(d<<4)>>2]|0)){var c=b+12|0;if(0!=(t[t[c>>2]>>2]|0)){var e=P();V(e,t[t[c>>2]+8>>2]);U(e,Xi|0);c=b+8|0;U(e,t[t[c>>2]+8>>2]);var f=e|0,g=t[f>>2];(g+1|0)==(t[e+4>>2]|0)?(R(e),f=t[f>>2]):f=g;g=e+8|0;l[t[g>>2]+f|0]=0;V(t[c>>2],t[g>>2]);Q(e)}c=j;j+=80;e=c>>2;0!=(t[Lx+(d<<4)>>2]|0)&&(sC(c,t[t[b+8>>2]+8>>2]),t[e+1]=t[b+16>>2],t[e+2]=t[b+20>>2],t[e+9]=t[Lx+(d<<4)+8>>2],l[c+40|0]=t[Lx+(d<<4)+4>>2]&255,tC(c));j=c}}function cI(b,d){var c,e,f;f=(b|0)>>2;e=(b+4|0)>>2;c=(b+8|0)>>2;var g=1;a:for(;;){for(;;){if(!g){break a}var h=T();if(-1==(h|0)){g=0;continue a}else{if(92==(h|0)){var h=T(),i=t[f];(i+1|0)==(t[e]|0)&&(R(b),i=t[f]);l[t[c]+i|0]=h&255;if(0==(h|0)){continue}h=t[f]+1|0;t[f]=h;l[t[c]+h|0]=0;continue}}if((h|0)==(d|0)){g=0;continue a}i=t[f];(i+1|0)==(t[e]|0)&&(R(b),i=t[f]);l[t[c]+i|0]=h&255;0!=(h|0)&&(h=t[f]+1|0,t[f]=h,l[t[c]+h|0]=0)}}g=t[f];(g+1|0)!=(t[e]|0)?(c=t[c],c=c+g|0):(R(b),e=t[f],c=t[c],c=c+e|0);l[c]=0}cI.X=1;function dI(b,d){var c,e;e=(b|0)>>2;var f=b+4|0;c=(b+8|0)>>2;for(var g=d;;){var h=t[e];(h+1|0)==(t[f>>2]|0)&&(R(b),h=t[e]);l[t[c]+h|0]=g&255;0!=(g|0)&&(g=t[e]+1|0,t[e]=g,l[t[c]+g|0]=0);h=T();if(0==(eI(h)|0)){break}else{g=h}}g=t[e];(g+1|0)==(t[f>>2]|0)?(R(b),e=t[e]):e=g;l[t[c]+e|0]=0;0==(L(h)|0)&&W(h)}function aI(b){var d,c,e,f;e=(b|0)>>2;t[e]=0;var g=b+4|0;t[g>>2]=-1;c=(b+8|0)>>2;S(t[c]);d=(b+16|0)>>2;for(b=(b+20|0)>>2;;){var h=T();t[d]=t[K+48>>2];t[b]=t[K+24>>2];if(42==(h|0)){f=1916;break}else{if(-1==(h|0)){f=1908;break}else{if(40==(h|0)){f=1909;break}else{if(44==(h|0)){f=1911;break}else{if(125==(h|0)){f=1913;break}else{if(39==(h|0)||34==(h|0)){f=1917;break}else{if(123==(h|0)){f=1912;break}else{if(32==(h|0)||10==(h|0)||9==(h|0)){continue}else{if(93==(h|0)){f=1915;break}else{if(92==(h|0)){f=1918;break}else{if(91==(h|0)){f=1914;break}else{if(41==(h|0)){f=1910;break}else{if(37!=(h|0)){f=1924;break}}}}}}}}}}}}}uE(10)}1916==f?t[e]=13:1908==f?dB(wz|0,1):1909==f?t[e]=5:1911==f?t[e]=3:1924==f?0==(eI(h)|0)?t[e]=0:(dI(t[c],h),t[d]=t[K+48>>2],t[b]=t[K+24>>2],t[e]=6):1913==f?t[e]=9:1917==f?(t[e]=7,cI(t[c],h),t[d]=t[K+48>>2],t[b]=t[K+24>>2]):1912==f?t[e]=8:1915==f?t[e]=11:1918==f?(f=T(),0==(pA(f)|0)?W(f):(dI(t[c],f),t[d]=t[K+48>>2],t[b]=t[K+24>>2],d=UD(t[c],t[Jy>>2]),t[g>>2]=d,t[e]=-1==(d|0)?6:4)):1914==f?t[e]=10:1910==f&&(t[e]=2)}aI.X=1;function fI(b){t[Ix>>2]=b}function eI(b){return 0!=(pA(b)|0)|10>(b-48|0)>>>0?1:95==(b|0)||45==(b|0)||36==(b|0)||35==(b|0)||46==(b|0)?1:0}function gI(b,d){var c;S(b);if(0==(hI(d)|0)){var e=t[(b|0)>>2];return e=0!=(e|0)&1}var f=0==(hI(d)|0),e=b|0;c=e>>2;var g=b+4|0;a:do{if(f){var h=d}else{for(var i=b+8|0,m=d;;){var n=t[c];(n+1|0)==(t[g>>2]|0)&&(R(b),n=t[c]);l[t[i>>2]+n|0]=m&255;0!=(m|0)&&(m=t[c]+1|0,t[c]=m,l[t[i>>2]+m|0]=0);m=iI();if(0==(hI(m)|0)){h=m;break a}}}}while(0);fI(h);f=t[c];(f+1|0)==(t[g>>2]|0)?(R(b),c=t[c]):c=f;l[t[b+8>>2]+c|0]=0;e=t[e>>2];return e=0!=(e|0)&1}gI.X=1;function jI(b){var d=0==(L(b)|0);a:do{if(d){var c=b}else{for(;;){var e=iI();if(0==(L(e)|0)){c=e;break a}}}}while(0);return c}function kI(b,d){for(var c=b<<24>>24,e=d<<24>>24,f=1;;){var g=iI(),f=(g|0)==(c|0)?f+1|0:(((g|0)==(e|0))<<31>>31)+f|0;if(0>=(f|0)){break}}return iI()}function hI(b){return(0!=(oA(b)|0)|95==(b|0)|96==(b|0))&1}function lI(){var b,d=zC(24);b=d>>2;t[b]=0;t[b+1]=-1;t[b+2]=P();t[b+3]=P();t[b+4]=t[K+48>>2];t[b+5]=t[K+24>>2];return d}function mI(b){0!=(b|0)&&(Q(t[b+8>>2]),Q(t[b+12>>2]),vB(b))}function nI(b,d){var c=t[b+4>>2];83==(c|0)?oI(b):23==(c|0)?uE(59):28==(c|0)?pI(b):79==(c|0)?oI(b):58==(c|0)?(c=lI(),qI(b),12==(t[b+4>>2]|0)?(qI(c),rI(c,9)):4==(t[b>>2]|0)&&rI(b,9),mI(c)):18==(c|0)?(c=lI(),qI(c),0==(d|0)?rI(c,0):rI(c,10),uE(59),mI(c)):16==(c|0)?sI(b):24==(c|0)?sI(b):61==(c|0)&&pI(b)}function oI(b){var d,c=lI();d=(b+4|0)>>2;var e=t[d];qI(c);qI(b);if(38==(t[d]|0)&&(qI(b),d=65==(t[d]|0),rI(c,83==(e|0)?1:2),d)){e=lI();qI(e);for(d=e+4|0;!(qI(b),uE(59),rI(e,3),qI(e),23==(t[d>>2]|0));){}uE(59);mI(e)}mI(c)}function sI(b){var d=lI(),c=b+4|0,e=t[c>>2];qI(d);24!=(e|0)?(rI(d,5),tI(),uE(59)):(qI(b),38==(t[c>>2]|0)&&(rI(d,4),tI(),uE(59)));mI(d)}function pI(b){var d,c,e,f=lI();c=(b+4|0)>>2;var g=28==(t[c]|0);qI(f);qI(b);d=(b|0)>>2;if(1==(t[d]|0)){var h=b|0;if(1==(t[h>>2]|0)){qI(b);for(var i=1;;){var m=t[h>>2],i=(1==(m|0)&1)+i|0,i=((2==(m|0)&0<(i|0))<<31>>31)+i|0;qI(b);if(!(0!=(i|0)|2!=(m|0))){break}}}}a:do{if(g){if(68!=(t[c]|0)){e=2060}else{for(qI(b);;){if(38==(t[c]|0)){e=2060;break a}if(8==(t[d]|0)){break a}qI(b)}}}else{e=2060}}while(0);do{if(2060==e&&8!=(t[d]|0)){if(38!=(t[c]|0)){mI(f);return}if(g){rI(f,7);for(d=f+8|0;;){if(qI(b),23==(t[c]|0)){if(qI(b),e=(28==(t[b+4>>2]|0)?1:0!=(uI(b,t[d>>2])|0))&1,uE(59),0!=(e|0)){break}}else{nI(b,1)}}}else{rI(f,8);for(d=f+8|0;;){if(qI(b),23==(t[c]|0)){if(qI(b),e=(61==(t[b+4>>2]|0)?1:0!=(uI(b,t[d>>2])|0))&1,uE(59),0!=(e|0)){break}}else{nI(b,1)}}}mI(f);return}}while(0);rI(f,6);mI(f)}pI.X=1;function iI(){var b,d=t[Ix>>2];0==(d|0)?d=T():t[Ix>>2]=0;if(34==(d|0)){for(;;){if(b=T(),-1==(b|0)||34==(b|0)){var c=64;break}}return c}if(47==(d|0)){b=2086}else{var e=d}a:do{if(2086==b){if(c=T(),-1==(c|0)){dB(vz|0,1)}else{if(42==(c|0)){e=vI()}else{if(47==(c|0)){for(;;){if(c=T(),-1==(c|0)||10==(c|0)){e=c;break a}}}else{return W(c),c=47}}}}}while(0);if(-1==(e|0)){dB(vz|0,1)}else{return e}}function qI(b){var d,c,e,f;e=(b|0)>>2;t[e]=0;var g=b+4|0;t[g>>2]=-1;c=(b+8|0)>>2;S(t[c]);d=(b+16|0)>>2;for(b=(b+20|0)>>2;;){var h=T();t[d]=t[K+48>>2];t[b]=t[K+24>>2];if(34==(h|0)){f=2106;break}else{if(59==(h|0)){f=2103;break}else{if(41==(h|0)){f=2102;break}else{if(-1==(h|0)){f=2100;break}else{if(46==(h|0)){f=2104;break}else{if(44==(h|0)){f=2105;break}else{if(40==(h|0)){f=2101;break}else{if(32==(h|0)||10==(h|0)||9==(h|0)){continue}else{if(39==(h|0)){f=2128;break}else{if(45!=(h|0)){f=2112;break}}}}}}}}}}var i=T();if(45!=(i|0)){f=2109;break}uE(10)}if(2106==f){t[e]=9,wI(t[c]),t[d]=t[K+48>>2],t[b]=t[K+24>>2]}else{if(2103==f){t[e]=8}else{if(2102==f){t[e]=2}else{if(2100==f){dB(uz|0,1)}else{if(2112==f){if(0==((95==(h|0)|0!=(pA(h)|0))&1|0)){t[e]=0}else{var i=t[c],m;m=(i|0)>>2;var n=i+4|0;for(f=(i+8|0)>>2;;){var q=t[m];(q+1|0)==(t[n>>2]|0)&&(R(i),q=t[m]);l[t[f]+q|0]=h&255;0!=(h|0)&&(q=t[m]+1|0,t[m]=q,l[t[f]+q|0]=0);q=T();if(0==((0==(pA(q)|0)?95==(q|0)|10>(q-48|0)>>>0:1)&1|0)){break}else{h=q}}h=t[m];(h+1|0)==(t[n>>2]|0)?(R(i),i=t[m]):i=h;l[t[f]+i|0]=0;0==(L(q)|0)&&W(q);t[d]=t[K+48>>2];t[b]=t[K+24>>2];d=UD(t[c],t[Ey>>2]);t[g>>2]=d;t[e]=-1==(d|0)?4:5}}else{2104==f?t[e]=6:2105==f?t[e]=3:2101==f?t[e]=1:2109==f&&(0==(L(i)|0)&&W(i),t[e]=7)}}}}}}qI.X=1;function rI(b,d){if(0!=(t[Cx+(d<<4)>>2]|0)){var c=b+12|0;if(0!=(t[t[c>>2]>>2]|0)){var e=P();V(e,t[t[c>>2]+8>>2]);U(e,Xi|0);c=b+8|0;U(e,t[t[c>>2]+8>>2]);var f=e|0,g=t[f>>2];(g+1|0)==(t[e+4>>2]|0)?(R(e),f=t[f>>2]):f=g;g=e+8|0;l[t[g>>2]+f|0]=0;V(t[c>>2],t[g>>2]);Q(e)}c=j;j+=80;e=c>>2;0!=(t[Cx+(d<<4)>>2]|0)&&(sC(c,t[t[b+8>>2]+8>>2]),t[e+1]=t[b+16>>2],t[e+2]=t[b+20>>2],t[e+9]=t[Cx+(d<<4)+8>>2],l[c+40|0]=t[Cx+(d<<4)+4>>2]&255,tC(c));j=c}}function uI(b,d){if(4!=(t[b>>2]|0)){var c;return 0}c=0==(sA(t[t[b+8>>2]+8>>2],t[d+8>>2],Aa)|0);return c&1}function tI(){for(var b=lI(),d=b+4|0;!(qI(b),23==(t[d>>2]|0));){}mI(b)}function wI(b){var d,c,e;e=(b|0)>>2;c=(b+4|0)>>2;d=(b+8|0)>>2;var f=1;a:for(;;){for(;;){if(!f){break a}var g=T();if(-1==(g|0)||34==(g|0)){f=0;continue a}else{if(92==(g|0)){var g=T(),h=t[e]}else{h=t[e]}(h+1|0)==(t[c]|0)&&(R(b),h=t[e]);l[t[d]+h|0]=g&255;0!=(g|0)&&(g=t[e]+1|0,t[e]=g,l[t[d]+g|0]=0)}}}f=t[e];(f+1|0)!=(t[c]|0)?(d=t[d],d=d+f|0):(R(b),b=t[e],d=t[d],d=d+b|0);l[d]=0}wI.X=1;function xI(){for(var b;;){var d=eC();if(0==(d|0)){var c=0;b=2211;break}for(;0!=(L(l[d]&255)|0);){d=d+1|0}if(34!=l[d]<<24>>24){c=d;b=2210;break}}if(2210==b||2211==b){return c}}function yI(b){var d,c,e=P(),f=92==l[b]<<24>>24;a:do{if(f){for(var g=b;;){var g=g+1|0,h=l[g];if(0==h<<24>>24){c=g;break a}if(0==(L(h&255)|0)){c=g;break a}}}else{if(0==(N(b,Hr|0,4)|0)){var i=0;Q(e);return i}if(0==(N(b,Go|0,4)|0)||0!=(N(b,om|0,3)|0)){return i=0,Q(e),i}g=b+3|0;h=l[g];109==h<<24>>24&&(g=b+4|0,h=l[g],97==h<<24>>24&&(g=b+5|0,h=l[g],110==h<<24>>24&&(g=b+6|0,g=h=100==l[g]<<24>>24?b+7|0:g,h=l[h])));g=33==h<<24>>24?g+1|0:g;if(32==l[g]<<24>>24){h=32}else{return i=1,Q(e),i}for(;;){if(0==h<<24>>24){c=g;break a}var m=g+1|0;if(0==(L(h&255)|0)){c=g;break a}g=m;h=l[m]}}}while(0);for(;;){b=0==(L(l[c]&255)|0);a:do{if(b){if(45==l[c]<<24>>24){f=c;for(g=45;;){if(0==g<<24>>24){i=f;break a}h=f+1|0;if(0!=(L(g&255)|0)){i=f;break a}f=h;g=l[h]}}else{i=c}}else{i=c+1|0}}while(0);c=l[i];if(0==c<<24>>24){break}if(0==(oA(c&255)|0)){c=i}else{d=2249;break}}if(2249==d&&0!=l[i]<<24>>24){c=(e|0)>>2;b=e+4|0;for(d=(e+8|0)>>2;!(f=t[c],(f+1|0)==(t[b>>2]|0)&&(R(e),f=t[c]),l[t[d]+f|0]=l[i],0!=l[i]<<24>>24&&(f=t[c]+1|0,t[c]=f,l[t[d]+f|0]=0),i=i+1|0,0==(oA(l[i]&255)|0)&&95!=l[i]<<24>>24);){}i=t[c];(i+1|0)==(t[b>>2]|0)&&(R(e),i=t[c]);l[t[d]+i|0]=0;jC(e,Ax|0,1);S(e);i=1;Q(e);return i}yI(xI());i=1;Q(e);return i}yI.X=1;function zI(b){return 0==(N(b,ys|0,3)|0)||0==(N(b,hs|0,2)|0)||0==(N(b,Or|0,3)|0)||0==(N(b,nr|0,4)|0)||0==(N(b,Yq|0,2)|0)||0==(N(b,Lq|0,3)|0)||0==(N(b,yq|0,4)|0)||0==(N(b,kq|0,2)|0)||0==(N(b,Sp|0,3)|0)||0==(N(b,Cp|0,4)|0)||0==(N(b,np|0,2)|0)||0==(N(b,ap|0,3)|0)||0==(N(b,No|0,4)|0)||0==(N(b,so|0,2)|0)||0==(N(b,jo|0,3)|0)||0==(N(b,$n|0,4)|0)||0==(N(b,Pn|0,2)|0)||0==(N(b,An|0,3)|0)||0==(N(b,pn|0,4)|0)||0==(N(b,br|0,2)|0)||0==(N(b,Tm|0,3)|0)||0==(N(b,Gm|0,4)|0)||0==(N(b,tm|0,5)|0)||0==(N(b,bm|0,6)|0)||0==(N(b,Tl|0,7)|0)||0==(N(b,Jl|0,3)|0)||0==(N(b,Bl|0,4)|0)||0==(N(b,rl|0,5)|0)||0==(N(b,gl|0,6)|0)||0==(N(b,Wk|0,7)|0)||0==(N(b,Kk|0,8)|0)||0==(N(b,xk|0,3)|0)||0==(N(b,nk|0,4)|0)||0==(N(b,Zj|0,5)|0)||0==(N(b,Rj|0,6)|0)||0==(N(b,Kj|0,7)|0)||0==(N(b,Fj|0,8)|0)||0==(N(b,yj|0,3)|0)||0==(N(b,rj|0,4)|0)||0==(N(b,fj|0,5)|0)||0==(N(b,Yi|0,6)|0)||0==(N(b,Mi|0,7)|0)||0==(N(b,Di|0,8)|0)||0==(N(b,mi|0,3)|0)||0==(N(b,gi|0,4)|0)||0==(N(b,bi|0,5)|0)||0==(N(b,Zh|0,6)|0)||0==(N(b,Vh|0,7)|0)||0==(N(b,Oh|0,8)|0)||0==(N(b,Gh|0,3)|0)||0==(N(b,Ah|0,4)|0)||0==(N(b,qh|0,5)|0)||0==(N(b,jh|0,6)|0)||0==(N(b,Yg|0,7)|0)||0==(N(b,Tg|0,8)|0)||0==(N(b,Og|0,3)|0)||0==(N(b,Jg|0,4)|0)||0==(N(b,Cg|0,5)|0)||0==(N(b,ug|0,6)|0)?1:0==(N(b,og|0,7)|0)?1:0==(N(b,kg|0,8)|0)&1}zI.X=1;function AI(b){for(var d,c,e=P();;){var f=l[b];if(0==f<<24>>24){c=b;break}var g=b+1|0;if(0==(oA(f&255)|0)){d=2393;break}else{b=g}}2393==d&&(c=33==l[b]<<24>>24?g:b);a:for(;;){g=l[c];do{if(0!=g<<24>>24&&0!=(L(g&255)|0)){c=c+1|0;continue a}}while(0);if(0==(N(c,Nv|0,8)|0)){var h=c;break}do{if(0==(N(c,nv|0,8)|0)){d=2402}else{if(0==(N(c,Ru|0,8)|0)){d=2402}else{if(0==(N(c,su|0,8)|0)){d=2402}else{if(0==(N(c,Ut|0,8)|0)){d=2402}else{if(0==(N(c,tt|0,6)|0)){var i=c+6|0}else{if(0!=(N(c,Ts|0,9)|0)){h=c;break a}i=c+9|0}}}}}}while(0);2402==d&&(d=0,i=c+8|0);if(0==l[i]<<24>>24){h=i;break}else{c=i}}c=(e|0)>>2;i=e+4|0;for(d=(e+8|0)>>2;!(g=t[c],(g+1|0)==(t[i>>2]|0)&&(R(e),g=t[c]),l[t[d]+g|0]=l[h],0!=l[h]<<24>>24&&(g=t[c]+1|0,t[c]=g,l[t[d]+g|0]=0),h=h+1|0,g=l[h],0==g<<24>>24||32==g<<24>>24);){}h=t[c];(h+1|0)==(t[i>>2]|0)&&(R(e),h=t[c]);d=t[d];d=d+h|0;l[d]=0;jC(e,Ax|0,3);S(e);Q(e)}AI.X=1;function BI(b){var d,c,e=j;j+=4;var f,g=P();d=b+2|0;var h=l[d];110==h<<24>>24?(d=b+3|0,h=l[d],99!=h<<24>>24?b=d:(d=b+4|0,h=l[d],116!=h<<24>>24?b=d:(d=b+5|0,h=l[d],105!=h<<24>>24?b=d:(d=b+6|0,h=l[d],111!=h<<24>>24?b=d:(h=b+7|0,b=h=110==l[h]<<24>>24?b+8|0:h,h=l[h]))))):b=d;b=33==h<<24>>24?b+1|0:b;h=0==(L(l[b]&255)|0);a:do{if(!h){for(d=b;;){c=l[d];if(0==c<<24>>24){break a}if(0==(L(c&255)|0)){break}else{d=d+1|0}}if(0!=l[d]<<24>>24){var i=CI(d,e);if(0==((65<=(l[i]&255)&&90>=(l[i]&255))|0)&&(d=t[e>>2],!(115==(d|0)||100==(d|0)||97==(d|0)||60==(d|0)))){break}c=(g|0)>>2;var m=g+4|0;for(d=(g+8|0)>>2;;){var n=t[c];(n+1|0)==(t[m>>2]|0)&&(R(g),n=t[c]);l[t[d]+n|0]=l[i];0!=l[i]<<24>>24&&(n=t[c]+1|0,t[c]=n,l[t[d]+n|0]=0);i=i+1|0;if(0==(oA(l[i]&255)|0)&&(n=l[i],!(95==n<<24>>24||46==n<<24>>24||35==n<<24>>24))){break}}i=t[c];(i+1|0)==(t[m>>2]|0)?(R(g),c=t[c]):c=i;l[t[d]+c|0]=0;jC(g,Ax|0,2);S(g)}}}while(0);for(;;){b=xI();if(0==(b|0)){f=2445;break}if(0!=(N(b,Re|0,5)|0)&&0==(N(b,jx|0,4)|0)){f=2446;break}}2446==f?(Q(g),j=e):2445==f&&(Q(g),j=e)}BI.X=1;function DI(b){var d,c=P(),e=b+3|0,f=l[e];114==f<<24>>24?(e=b+4|0,f=l[e],111!=f<<24>>24?b=e:(e=b+5|0,f=l[e],117!=f<<24>>24?b=e:(f=b+6|0,b=f=112==l[f]<<24>>24?b+7|0:f,f=l[f]))):b=e;if(0!=(L(f&255)|0)){for(e=b;;){b=l[e];if(0==b<<24>>24){d=2469;break}if(0==(L(b&255)|0)){break}else{e=e+1|0}}if(2469!=d&&0!=l[e]<<24>>24&&0!=(sA(e,Sf|0,3)|0)){b=(c|0)>>2;f=c+4|0;for(d=(c+8|0)>>2;;){var g=t[b];(g+1|0)==(t[f>>2]|0)&&(R(c),g=t[b]);l[t[d]+g|0]=l[e];0!=l[e]<<24>>24&&(g=t[b]+1|0,t[b]=g,l[t[d]+g|0]=0);e=e+1|0;if(0==(oA(l[e]&255)|0)&&95!=l[e]<<24>>24){break}}e=t[b];(e+1|0)==(t[f>>2]|0)?(R(c),b=t[b]):b=e;l[t[d]+b|0]=0;jC(c,Ax|0,0);S(c)}}Q(c)}DI.X=1;function EI(b){var d,c,e=P(),b=b+3|0;if(0!=(L(l[b]&255)|0)){for(;;){var f=l[b];if(0==f<<24>>24){d=2495;break}var g=b+1|0;if(0==(L(f&255)|0)){break}else{b=g}}if(2495!=d){f=l[b];if(118==f<<24>>24){d=2476}else{if(0==f<<24>>24||38==f<<24>>24||64==f<<24>>24||91==f<<24>>24){Q(e);return}var h=b;c=f}if(2476==d){if(58!=l[g]<<24>>24){h=b,c=118}else{Q(e);return}}for(;;){if(0==c<<24>>24||36==c<<24>>24){var i=c;break}g=h+1|0;if(0!=(oA(c&255)|0)){d=2480;break}h=g;c=l[g]}2480==d&&(i=l[h]);if(0!=i<<24>>24){c=(e|0)>>2;g=e+4|0;d=(e+8|0)>>2;for(b=i;0!=b<<24>>24;){if(i=t[c],(i+1|0)==(t[g>>2]|0)&&(R(e),b=l[h],i=t[c]),l[t[d]+i|0]=b,0!=l[h]<<24>>24&&(i=t[c]+1|0,t[c]=i,l[t[d]+i|0]=0),h=h+1|0,i=l[h],0!=(oA(l[h]&255)|0)){b=i}else{if(95==i<<24>>24||35==i<<24>>24||58==i<<24>>24||36==i<<24>>24){b=i}else{break}}}i=t[c];(i+1|0)==(t[g>>2]|0)&&(R(e),i=t[c]);l[t[d]+i|0]=0;jC(e,Ax|0,4);S(e)}}}Q(e)}EI.X=1;function FI(b){return-2==(b|0)?b=Lu|0:b=t[t[t[Cy>>2]+(b<<2)>>2]>>2]}function CI(b,d){var c=d>>2,e=tb(b),f=0!=(d|0);f&&(t[c]=0);if(3<e>>>0){if(58==l[b+1|0]<<24>>24){f&&(t[c]=l[b]&255);var g;return b+2|0}if(5<e>>>0){if(0!=(sA(b,xw|0,5)|0)){e=0}else{return f&&(t[c]=l[b]&255),b+5|0}}else{e=0}}else{e=0}for(;;){if(f=l[b+e|0]&255,35==(f|0)?t[c]=97:46==(f|0)&&(t[c]=100),e=e+1|0,f=b+e|0,0==(oA(l[f]&255)|0)&&(f=l[f],!(95==f<<24>>24||46==f<<24>>24||35==f<<24>>24))){g=b;break}}return g}CI.X=1;function jC(b,d,c){var e=j;j+=80;!(0==(t[d+(c<<4)>>2]|0)|0==(b|0))&&0!=(t[b>>2]|0)&&(sC(e,t[b+8>>2]),t[e+36>>2]=t[d+(c<<4)+8>>2],l[e+40|0]=t[d+(c<<4)+4>>2]&255,tC(e));j=e}function GI(b){var d=MG(52);t[d>>2]=HI(b);return d}function II(b){var d=t[oy+128>>2];if(-1==(d|0)){if(d=JI(KI(b)),-2!=(d|0)){var c=d}else{var e;var d=kH(b),f=t[Dy>>2];if(0==(f|0)){e=-2}else{for(var g=t[Cy>>2],h=-2,i=0;;){var m=t[t[g+(i<<2)>>2]+44>>2];if(0!=(m|0)){var n;n=ba;for(var q=m+4|0,m=m+8|0,p=0,s=0;;){if(0!=(s|0)){var r=s;n=2999;break}if(p>>>0>=t[q>>2]>>>0){r=0;n=3e3;break}s=0==(sA(t[t[t[m>>2]+(p<<2)>>2]+8>>2],d,Aa)|0)&1;p=p+1|0}n=2999==n||3e3==n?r:ba;h=0==(n|0)?h:i}i=i+1|0;if(!(i>>>0<f>>>0&-2==(h|0))){e=h;break}}}if(-2!=(e|0)){c=e}else{if(LI(b),0==(t[ld+20>>2]|0)){c=-2}else{if(b=tB(b,Wv|0),0==(b|0)){c=-2}else{e=P();r=MI(e,b);if(0==(r|0)){c=-2}else{if(35!=l[r]<<24>>24){c=-2}else{if(33!=l[r+1|0]<<24>>24){c=-2}else{d=gB(r,47);r=NI(0==(d|0)?r+2|0:d+1|0);d=r+8|0;f=JI(t[d>>2]);if(-2==(f|0)){if(f=t[Dy>>2],0==(f|0)){c=-2}else{g=t[Cy>>2];i=-2;for(h=0;;){if(n=t[t[g+(h<<2)>>2]>>2],i=0==(n|0)?i:0==(sA(t[d>>2],n,Aa)|0)?h:i,h=h+1|0,!(h>>>0<f>>>0&-2==(i|0))){c=i;break}}}}else{c=f}Q(r)}}}Q(e);uB(b)}}}}}else{c=d}return c}function JI(b){var d=t[Dy>>2];if(0==(d|0)){var c;return-2}for(var e=0,f=d;;){if(d=t[t[t[Cy>>2]+(e<<2)>>2]+48>>2],0==(d|0)?d=-2:(d=0==(-1!=(OI(d,b,186)|0)&1|0)?-2:e,f=t[Dy>>2]),e=e+1|0,!(e>>>0<f>>>0&-2==(d|0))){c=d;break}}return c}function PI(b){for(var d=j,c,e=t[t[t[Cy>>2]+(b<<2)>>2]+44>>2],f=0==(e|0),g=e+4|0,h=e+8|0,e=1,i=0;!f&&i>>>0<t[g>>2]>>>0;){var e=0!=(e|0)?hm|0:Eo|0,m=t[t[t[h>>2]+(i<<2)>>2]+8>>2];mB(lw|0,(k=j,j+=8,t[k>>2]=e,t[k+4>>2]=m,k));e=0;i=i+1|0}g=t[t[t[Cy>>2]+(b<<2)>>2]+48>>2];b=0==(g|0);f=g+4|0;g=g+8|0;h=e;for(e=0;;){if(b){c=2587;break}if(e>>>0>=t[f>>2]>>>0){c=2586;break}h=0!=(h|0)?hm|0:Eo|0;i=t[t[t[g>>2]+(e<<2)>>2]+8>>2];mB(lm|0,(k=j,j+=8,t[k>>2]=h,t[k+4>>2]=i,k));h=0;e=e+1|0}2587==c?j=d:2586==c&&(j=d)}PI.X=1;function QI(){var b,d=j;b=zC(176);t[Cy>>2]=b;KC(Rf|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k));for(var c=0;;){var e=ab[t[Uz+(c<<2)>>2]]();b=e>>2;var f=0==(e|0);a:do{if(!f){var g=t[b];do{if(0!=(g|0)&&0!=l[g]<<24>>24){f=e+24|0;do{if(0==(t[b+8]|0)){if(!(0==(t[f>>2]|0)^0==(t[b+7]|0))){RI(1,ix|0,(k=j,j+=4,t[k>>2]=g,k));break a}}else{t[f>>2]=132}}while(0);f=0!=(c|0)?Cr|0:hm|0;KC(cw|0,(k=j,j+=8,t[k>>2]=f,t[k+4>>2]=g,k));g=t[Dy>>2];t[Dy>>2]=g+1|0;t[b+9]=g;t[t[Cy>>2]+(g<<2)>>2]=e;break a}}while(0);RI(1,Qe|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k))}}while(0);b=c+1|0;if(44==(b|0)){break}else{c=b}}KC(Jq|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k));b=t[Dy>>2];if(0!=(b|0)){for(c=0;!(t[t[t[Cy>>2]+(c<<2)>>2]+40>>2]=1,c=c+1|0,c>>>0>=b>>>0);){}}c=t[Dy>>2];if(0!=(c|0)){for(b=0;!(e=t[t[t[Cy>>2]+(b<<2)>>2]+20>>2],0!=(e|0)&&(ab[e](b),c=t[Dy>>2]),b=b+1|0,b>>>0>=c>>>0);){}}j=d}QI.X=1;function NI(b){var d,c,e,f=P();c=(f|0)>>2;var g=f+4|0;for(d=(f+8|0)>>2;;){for(S(f);;){if(0==(L(l[b]<<24>>24)|0)){var h=b;break}else{b=b+1|0}}for(;;){b=l[h];if(0==b<<24>>24){e=2676;break}var i=t[c],m=(i+1|0)==(t[g>>2]|0);if(0!=(L(b<<24>>24)|0)){e=2683;break}m?(R(f),b=t[c]):b=i;l[t[d]+b|0]=l[h];0!=l[h]<<24>>24&&(b=t[c]+1|0,t[c]=b,l[t[d]+b|0]=0);h=h+1|0}if(2676==e){if(e=0,b=t[c],(b+1|0)==(t[g>>2]|0)){e=2684}else{var n=b}}else{2683==e&&(e=0,m?e=2684:n=i)}2684==e&&(e=0,R(f),n=t[c]);l[t[d]+n|0]=0;if(0==(qA(t[d],Lo|0)|0)){b=h}else{break}}return f}NI.X=1;function KC(b){var d=j;j+=4;0!=(t[oy+88>>2]|0)&&(t[d>>2]=arguments[KC.length],wB(b,t[d>>2]));j=d}function rD(b,d,c){var e,f=t[oy+60>>2];if(0==(f|0)){var g;return 0}var h=tb(b),i=0!=(d|0);i&&(t[d>>2]=0);for(var m=t[f+4>>2],n=h+1|0,f=f+8|0,q=0;;){if(q>>>0>=m>>>0){g=0;e=2724;break}var p=t[t[f>>2]+(q<<2)>>2],s=t[p+8>>2];if(0==(N(s,b,h)|0)){p=t[p>>2];if((h|0)==(p|0)){g=1;e=2720;break}var r=l[s+h|0];if((p|0)==(n|0)&43==r<<24>>24){e=2711;break}if(61==r<<24>>24){e=2714;break}}q=q+1|0}if(2714==e){if(0==(c|0)){return 0}t[c>>2]=s+n|0;return 0}if(2711==e){return!i?1:t[d>>2]=1}if(2720==e||2724==e){return g}}function SI(b){var d=j,c=b+1|0,e=l[b];if(0==e<<24>>24){c=oz,b=t[c>>2],0!=(b|0)&&(fH(b),t[c>>2]=0)}else{if(64==e<<24>>24){b=tB(c,Wv|0);if(0==(b|0)){var f=0}else{if(e=bH(),0!=(cB(b)|0)){f=e}else{for(;;){var g=P();MI(g,b);DD(g);0==(t[g>>2]|0)?Q(g):AE(e,g);if(0!=(cB(b)|0)){f=e;break}}}}b=f;0==(b|0)&&RI(5,Xv|0,(k=j,j+=4,t[k>>2]=c,k));f=t[oz>>2];if(0==(f|0)){t[oz>>2]=b}else{e=b+4|0;if(0!=(t[e>>2]|0)){for(var g=b+8|0,h=0;!(AE(f,t[t[g>>2]+(h<<2)>>2]),t[t[g>>2]+(h<<2)>>2]=0,h=h+1|0,h>>>0>=t[e>>2]>>>0);){}}fH(b)}KC(Fm|0,(k=j,j+=4,t[k>>2]=c,k))}else{c=PD(b),f=t[oz>>2],0==(f|0)&&(f=bH(),t[oz>>2]=f),AE(f,c),KC(rm|0,(k=j,j+=4,t[k>>2]=b,k))}}j=d}function kH(b){var d=gB(b,47);return 0==(d|0)?b:d+1|0}function zC(b){var d=j,b=Xa(b);if(0!=(b|0)){return j=d,b}RI(1,gk|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k));j=d;return b}function MG(b){var d=j;var c=Xa(b);0==(c|0)||0==(t[c-4>>2]&3|0)||Ya(c,b);if(0!=(c|0)){return j=d,c}RI(1,gk|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k));j=d;return c}function jF(b,d){var c=j;if(0==(b|0)){var e=zC(d)}else{e=0==(b|0)?Xa(d):TI(b,d),0==(e|0)&&(RI(1,gk|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k)),e=0)}j=c;return e}function HI(b){var d=zC(tb(b)+1|0);AB(d,b);return d}function LI(b){var d=j;j+=72;var c=t[ld>>2];if(!(0!=(c|0)&&0==(qA(b,c)|0))){if(c=t[ld>>2],0!=(c|0)&&(vB(c),t[ld>>2]=0),b=HI(b),t[ld>>2]=b,0!=(PB(b,d,ca)|0)){t[ld+4>>2]=0}else{var b=d+8|0,c=t[b>>2],e=40960==(c&61440|0);t[ld+8>>2]=e&1;if(e){if(0==(PB(t[ld>>2],d)|0)){b=t[b>>2]}else{t[ld+4>>2]=0;j=d;return}}else{b=c}t[ld+4>>2]=1;c=b&61440;t[ld+12>>2]=16384==(c|0)&1;t[ld+16>>2]=32768==(c|0)&1;t[ld+20>>2]=0!=(b&73|0)&1;t[ld+24>>2]=b>>>11&1;t[ld+28>>2]=t[d+28>>2]}}j=d}LI.X=1;function KI(b){b=gB(kH(b),46);return 0==(b|0)?hm|0:b+1|0}function UI(b,d,c,e,f){var g=j;j+=12;var h=g+4,i=g+8;var m=j;j+=256;var n=0==(f|0);b:do{if(n){var q=9}else{for(var p=0,s=9;;){var r=l[f+p|0];if(0==r<<24>>24){q=s;break b}r=r<<24>>24;101==(r|0)?s|=1:98==(r|0)?s&=-2:105==(r|0)?s|=2:RI(2,Qu|0,(k=j,j+=4,t[k>>2]=l[f]<<24>>24,k));p=p+1|0}}}while(0);f=zC(16);n="";q&2&&(n+="i");SB[f]=RegExp(TB(d),n);j=m;0!=(f|0)&&(VI(e,g,h,i),WI(b,f,HI(c),l[g],t[h>>2],t[i>>2]));j=g}function VI(b,d,c,e){c>>=2;l[d]=0;t[c]=0;t[e>>2]=0;var f=0==(b|0);a:do{if(!f){f=l[b];do{if(0==f<<24>>24){break a}else{if(44==f<<24>>24){var g=b,h=114}else{g=b+1|0,h=l[g],44==h<<24>>24||0==h<<24>>24?h=f:(g=b,h=114)}}}while(0);l[d]=h;b=44==l[g]<<24>>24?g+1|0:g;if(0==l[b]<<24>>24){t[c]=HI(yt|0);return}d=mA(b,44);if(0==(d|0)){t[c]=HI(b);return}f=d-b|0;g=zC(f+1|0);t[c]=g;iB(g,b,f);l[t[c]+f|0]=0;c=d+1|0;if(0==l[c]<<24>>24){return}t[e>>2]=HI(c);return}}while(0);l[d]=114;t[c]=HI(yt|0)}VI.X=1;function WI(b,d,c,e,f,g){var h,i=t[Yx>>2];if((t[Zx>>2]|0)<(b|0)){i=jF(i,(b<<3)+8|0);t[Yx>>2]=i;h=t[Zx>>2]+1|0;var m=(h|0)>(b|0);a:do{if(!m){for(var n=h;;){if(t[i+(n<<3)>>2]=0,t[i+(n<<3)+4>>2]=0,n=n+1|0,(n|0)>(b|0)){break a}}}}while(0);t[Zx>>2]=b}h=i;i=(b<<3)+h|0;h=((b<<3)+h+4|0)>>2;m=jF(t[i>>2],28*t[h]+28|0);b=m>>2;t[i>>2]=m;i=t[h];t[h]=i+1|0;t[b+(7*i|0)]=d;t[b+(7*i|0)+1]=0;t[b+(7*i|0)+2]=c;t[b+(7*i|0)+3]=1;l[m+28*i+16|0]=e;t[b+(7*i|0)+5]=f;t[b+(7*i|0)+6]=g}WI.X=1;function RI(b,d){var c=j;j+=4;t[c>>2]=arguments[RI.length];var e=0!=(b&2|0)?fw|0:hm|0;lB(t[Wb>>2],Ht|0,(k=j,j+=8,t[k>>2]=0,t[k+4>>2]=e,k));xB(t[Wb>>2],d,t[c>>2]);if(0!=(b&4|0)){var e=t[Wb>>2],f,g=t[GA>>2];zB||(zB=Xa(256));f=zB;if(g in yB){if(255<yB[g].length){FA(DA)}else{for(var g=yB[g],h=0;h<g.length;h++){l[f+h]=g.charCodeAt(h)}l[f+h]=0}}else{FA(xA)}f=zB;lB(e,Co|0,(k=j,j+=4,t[k>>2]=f,k))}pB(10,t[Wb>>2]);0==(b&1|0)?j=c:(nb(rb),aa("exit(1) called, at "+Error().stack))}function S(b){t[b>>2]=0;l[t[b+8>>2]]=0}function zD(b){var d=b|0,c=t[d>>2];0!=(c|0)&&(c=c-1|0,t[d>>2]=c,l[t[b+8>>2]+c|0]=0)}function XI(b){var d=l[b];if(0==d<<24>>24){return 0}for(var c=0;;){var c=c<<1,e=d&255^(0==(c&256|0)?c:c&254|1),b=b+1|0,d=l[b];if(0==d<<24>>24){break}else{c=e}}return(40503*e|0)>>>9&127}function YI(b,d,c){var e,f,g,h=P();f=(h|0)>>2;var i=h+4|0;e=(h+8|0)>>2;a:for(;;){var m=l[d];do{if(92==m<<24>>24){var n=d+1|0,q=l[n],p=q<<24>>24,s=p-48|0;if(10>s>>>0){if(9>(p-49|0)>>>0){var r=t[c+(s<<3)>>2];-1!=(r|0)&&gD(h,b+r|0,t[c+(s<<3)+4>>2]-r|0)}r=n}else{var u=n,v=q;g=2926}}else{if(0==m<<24>>24){break a}else{u=d,v=m,g=2926}}}while(0);2926==g&&(g=0,10==v<<24>>24||13==v<<24>>24||(m=t[f],(m+1|0)==(t[i>>2]|0)?(R(h),d=l[u],m=t[f]):d=v,l[t[e]+m|0]=d,0!=l[u]<<24>>24&&(d=t[f]+1|0,t[f]=d,l[t[e]+d|0]=0)),r=u);d=r+1|0}b=t[f];if((b+1|0)!=(t[i>>2]|0)){return e=t[e],e=e+b|0,l[e]=0,h}R(h);f=t[f];e=t[e];e=e+f|0;l[e]=0;return h}YI.X=1;function bH(){var b,d=zC(12);b=d>>2;t[b]=0;t[b+1]=0;t[b+2]=0;return d}function AE(b,d){var c,e;e=(b+8|0)>>2;var f=t[e];c=(b+4|0)>>2;if(0==(f|0)){t[c]=0,t[b>>2]=10,f=zC(40),t[e]=f}else{var g=t[c],h=b|0;(g|0)==(t[h>>2]|0)&&(g=g+10|0,t[h>>2]=g,f=jF(f,g<<2),t[e]=f)}e=f;f=t[c];t[c]=f+1|0;t[e+(f<<2)>>2]=d}function fH(b){var d;if(0!=(b|0)){d=(b+8|0)>>2;if(0!=(t[d]|0)){var c;c=(b+4|0)>>2;if(0!=(t[c]|0)){for(var e=b+8|0,f=0;!(Q(t[t[e>>2]+(f<<2)>>2]),t[t[e>>2]+(f<<2)>>2]=0,f=f+1|0,f>>>0>=t[c]>>>0);){}}t[c]=0;vB(t[d]);t[d]=0}t[b>>2]=0;t[b+4>>2]=0;vB(b)}}function ZI(b){var d=bH(),c=t[b>>2];if(0==(c|0)){return d}for(;!(AE(d,PD(c)),b=b+4|0,c=t[b>>2],0==(c|0));){}return d}function zE(b,d){return-1!=(OI(b,d,66)|0)&1}function OI(b,d,c){for(var e,f=b+4|0,b=b+8|0,g=0,h=-1;;){if(-1!=(h|0)){var i=h;e=2989;break}if(g>>>0>=t[f>>2]>>>0){i=-1;e=2988;break}h=0==(ab[c](d,t[t[b>>2]+(g<<2)>>2])|0)?-1:g;g=g+1|0}if(2988==e||2989==e){return i}}function R(b){var d=t[b+4>>2];1073741824>d>>>0&&$I(b,d<<1)}function $I(b,d){var c=b+8|0,e=jF(t[c>>2],d);t[b+4>>2]=d;t[c>>2]=e}function Q(b){if(0!=(b|0)){var d=t[b+8>>2];0!=(d|0)&&vB(d);vB(b)}}function P(){var b,d=zC(12);b=d>>2;t[b]=0;t[b+1]=32;t[b+2]=zC(32);S(d);return d}function U(b,d){var c,e=tb(d);c=(b|0)>>2;var f=t[c],g=e+1|0,h=b+4|0,i=(g+f|0)>>>0<t[h>>2]>>>0;a:do{if(i){var m=f}else{for(;;){R(b);var n=t[c];if((g+n|0)>>>0<t[h>>2]>>>0){m=n;break a}}}}while(0);AB(t[b+8>>2]+m|0,d);t[c]=t[c]+e|0}function BE(b){var d=P();U(d,t[b+8>>2]);return d}function PD(b){var d=P();U(d,b);return d}function gD(b,d,c){var e,f=l[d],g=0!=(c|0)&0!=f<<24>>24;e=(b|0)>>2;var h=t[e],i=b+4|0,m=(h+1|0)==(t[i>>2]|0);a:do{if(g){for(var n=b+8|0,q=d,p=c,s=m,r=f,u=h;;){if(s&&(R(b),r=l[q],u=t[e]),l[t[n>>2]+u|0]=r,0!=l[q]<<24>>24&&(u=t[e]+1|0,t[e]=u,l[t[n>>2]+u|0]=0),p=p-1|0,q=q+1|0,r=l[q],u=t[e],s=(u+1|0)==(t[i>>2]|0),!(0!=(p|0)&0!=r<<24>>24)){var v=s,w=u;break a}}}else{v=m,w=h}}while(0);v&&(R(b),w=t[e]);b=t[(b+8|0)>>2];b=b+w|0;l[b]=0}gD.X=1;function DD(b){var d;d=(b|0)>>2;for(b=b+8|0;0!=(L(l[t[b>>2]+(t[d]-1)|0]<<24>>24)|0);){var c=t[d];if(0==(c|0)){break}c=c-1|0;t[d]=c;l[t[b>>2]+c|0]=0}}function V(b,d){S(b);U(b,d)}function lC(b,d,c,e){t[b+4>>2]>>>0<c>>>0&&$I(b,c);b=t[b+8>>2];if(0==(d|0)){var f,d=b+0|0}else{for(c=0;;){if(l[b+c|0]=rA(l[e+c|0]<<24>>24)&255,c=c+1|0,(c|0)==(d|0)){f=d;break}}d=b+f|0}l[d]=0}function vC(b,d,c){var e=XI(b),f=t[aJ()+(e<<2)>>2];if(0==(f|0)){t[aJ()+(e<<2)>>2]=bJ(b,d,c)}else{for(e=f;;){var g=e|0,e=t[g>>2];if(0==(e|0)){break}}t[g>>2]=bJ(b,d,c)}}function JC(b){t[Lz+4>>2]=t[Lz>>2];t[Lz>>2]=b}function cJ(){return t[Lz+(t[Lz+28>>2]<<4)+44>>2]}function dJ(){return(t[Lz+28>>2]<<4)+Lz+32|0}function aJ(){if(l[Uc]){var b=t[bz>>2];return b}b=zC(512);t[bz>>2]=b;for(var d=0;!(t[b+(d<<2)>>2]=0,d=d+1|0,128==(d|0));){}l[Uc]=1;return b}function bJ(b,d,c){var e,f=zC(16);e=f>>2;t[e]=0;t[e+1]=b;t[e+2]=d;t[e+3]=c;return f}function mC(b,d){var c,e,f=t[aJ()+(XI(b)<<2)>>2];for(c=f>>2;;){if(0==(f|0)){var g=-1;e=3099;break}if((t[c+2]|0)==(d|0)&&0==(qA(b,t[c+1])|0)){break}f=t[c];c=f>>2}return 3099==e?g:g=t[c+3]}function UD(b,d){var c=P();lC(c,t[b>>2],t[b+4>>2],t[b+8>>2]);var e=mC(t[c+8>>2],d);Q(c);return e}function vI(){for(var b,d=T();;){if(-1==(d|0)){var c=-1;b=3117;break}var e=T();if(42==(d|0)&47==(e|0)){c=32;b=3116;break}else{d=e}}if(3117==b||3116==b){return c}}function IC(){var b,d=t[Lz>>2];if(0==(d|0)){var c=d=0}else{t[Lz>>2]=t[Lz+4>>2];t[Lz+4>>2]=0;var e;return d}a:for(;;){b:for(;;){for(var f=T();;){if(9==(f|0)||32==(f|0)){var g=f;b=3150;break b}else{if(-1==(f|0)){var h=0,i=0,m=-1;b=3151;break b}else{if(10==(f|0)){b=3122;break b}else{if(34==(f|0)){b=3123;break b}else{if(39==(f|0)){b=3126;break b}else{if(35==(f|0)){break}else{if(47==(f|0)){b=3127;break b}else{if(92==(f|0)){b=3132;break b}else{if(63!=(f|0)){b=3144;break b}}}}}}}}}var n=T();if(63!=(n|0)){b=3136;break b}var q=T();if(40==(q|0)){g=91;b=3150;break b}else{if(41==(q|0)){h=d;i=c;m=93;b=3151;break b}else{if(60==(q|0)){var p=d,s=c,r=123;break b}else{if(47==(q|0)){f=92;continue}else{if(62==(q|0)){b=3138;break b}else{if(33==(q|0)){b=3139;break b}else{if(39==(q|0)){b=3140;break b}else{if(45==(q|0)){b=3141;break b}else{if(61!=(q|0)){b=3143;break b}}}}}}}}}f=35}if(0==(t[Lz+20>>2]|0)){p=d;s=c;r=35;break}t[Lz+16>>2]=2;t[Lz+20>>2]=0;d=1}b:do{if(3150==b){b=0,p=d,s=c,r=g}else{if(3151==b){b=0,p=h,s=i,r=m}else{if(3136==b){b=0,W(n),p=d,s=c,r=63}else{if(3144==b){b=0;do{if(64==(f|0)&0!=(t[Lz+12>>2]|0)&&34==(T()|0)){t[Lz+20>>2]=0;eJ(1);p=d;s=c;r=211;break b}}while(0);t[Lz+20>>2]=0;if(0==(d|0)){p=0,s=c,r=f}else{var c=f,u=cJ(),v=t[Lz+16>>2];if(2==(v|0)){c=fJ(c)}else{if(3==(v|0)){u=ba;c=48!=(c|0)&1;u=ba;v=cJ();u=t[Lz+28>>2];if(19>u>>>0){t[Lz+28>>2]=u+1|0;u=dJ()>>2;t[u]=v;var w=t[Lz+8>>2];t[u+1]=w;t[u+2]=c;c=(0==(v|0)?0!=(t[Vz>>2]|c|0)?0:0!=(w|0)?1:0==(t[oy+120>>2]|0):1)&1;t[u+3]=c}else{c=0}u=c;t[Lz+16>>2]=0}else{if(4==(v|0)){c:{if(0!=(pA(c)|0)||126==(c|0)||95==(c|0)||36==(c|0)){if(gJ(c),0==(qA(t[t[Lz+24>>2]+8>>2],Ys|0)|0)){for(;;){var C=T();if(32!=(C|0)){break}}if(0==(pA(C)|0)&&!(126==(C|0)||95==(C|0)||36==(C|0))){t[Lz+16>>2]=0;break c}gJ(C);hJ()}}t[Lz+16>>2]=0}}else{1==(v|0)?iJ(c):5==(v|0)&&iJ(c)}}c=u}continue a}}else{if(3122==b){b=0,t[Lz+20>>2]=1,p=0!=(d|0)&0==(c|0)?0:d,s=c,r=10}else{if(3123==b){b=0,t[Lz+20>>2]=0,eJ(0),p=d,s=c,r=211}else{if(3143==b){b=0,W(q),JC(63),p=d,s=c,r=63}else{if(3126==b){b=0;t[Lz+20>>2]=0;p=ba;r=s=0;c:for(;;){if(0==(s|0)){for(s=r;;){var A=T();if(-1==(A|0)){p=3180;break c}var I=s+1|0;if(10==(A|0)){p=3174;break c}else{if(39==(A|0)){p=3183;break c}else{if(92!=(A|0)){break}}}T();s=I}s=0==(s|0)&&0!=(bC(Pe|0,nA(A),5)|0)?A:0;r=I}else{for(u=r;;){var M=T();if(-1==(M|0)){p=3185;break c}v=u+1|0;if(10==(M|0)){p=3174;break c}else{if(39==(M|0)){p=3184;break c}else{if(92==(M|0)){T();u=v;continue}}}if(0==(u|0)&&0!=(bC(Pe|0,nA(M),5)|0)){s=M;r=v;continue c}if(0==(oA(M)|0)){p=3178;break c}else{u=v}}}}3178==p?W(M):3174==p&&W(10);p=d;s=c;r=195}else{if(3127==b){if(b=0,p=T(),42==(p|0)?p=1:47==(p|0)?p=2:(W(p),p=0),2==(p|0)){for(;;){var B=T();if(-1==(B|0)||10==(B|0)){break}else{if(92!=(B|0)){continue}}T()}r=B;10!=(r|0)?(p=d,s=c):(W(10),p=d,s=c,r=10)}else{1==(p|0)?(p=d,s=c,r=vI()):(t[Lz+20>>2]=0,p=d,s=c,r=47)}}else{3138==b?(b=0,p=d,s=c,r=125):3139==b?(b=0,p=d,s=c,r=124):3140==b?(b=0,p=d,s=c,r=94):3141==b?(b=0,p=d,s=c,r=126):3132==b&&(b=0,p=T(),10!=(p|0)&&(63==(p|0)?JC(63):W(p)),p=d,s=c,r=92)}}}}}}}}}}while(0);if(0==(p|s|0)){e=r;break}else{d=p,c=s}}return e}IC.X=1;function eJ(b){if(0!=(b|0)){for(;!(b=T(),-1==(b|0)||34==(b|0));){}}else{for(;;){b=T();if(-1==(b|0)||34==(b|0)){break}else{if(92!=(b|0)){continue}}T()}}}function iJ(b){var d;if(0==(pA(b)|0)){if(126==(b|0)||95==(b|0)||36==(b|0)){d=3203}}else{d=3203}3203==d&&(gJ(b),0==(cJ()|0)&&hJ());t[Lz+16>>2]=0}function fJ(b){var d=j;j+=12;for(var c=d|0,e,f=b,b=0;;){if(9<=b>>>0){e=3274;break}if(0!=(b|0)){var g=T();if(-1==(g|0)){break}if(0==(pA(g)|0)){break}else{f=g}}l[c+b|0]=f&255;b=b+1|0}3274!=e&&W(g);e=c+b|0;l[e]=0;e=0==(qA(c,zr|0)|0);a:do{if(e){t[Lz+16>>2]=1,g=0}else{if(0==(qA(c,zo|0)|0)){t[Lz+16>>2]=5,g=0}else{if(0==(N(c,im|0,2)|0)){t[Lz+16>>2]=3,g=0}else{do{if(0!=(qA(c,dk|0)|0)&&0!=(qA(c,ti|0)|0)){if(0==(qA(c,ch|0)|0)){c=t[Lz+28>>2];0!=(c|0)&&(t[Lz+28>>2]=c-1|0);c=cJ();t[Lz+16>>2]=0;g=c;break a}t[Lz+16>>2]=0==(qA(c,Of|0)|0)?4:0;g=0;break a}}while(0);g=jJ();t[Lz+(t[Lz+28>>2]<<4)+44>>2]=g;0==(g|0)&&0==(qA(c,ti|0)|0)&&0==(t[Vz>>2]|0)&&(b=dJ(),t[b+8>>2]=(0==(t[b+4>>2]|0)?0!=(t[Lz+8>>2]|0):1)&1);t[Lz+16>>2]=0}}}}while(0);j=d;return g}fJ.X=1;function gJ(b){var d=t[Lz+24>>2],c,e;S(d);e=(d|0)>>2;var f=d+4|0;for(c=(d+8|0)>>2;;){var g=t[e];(g+1|0)==(t[f>>2]|0)&&(R(d),g=t[e]);l[t[c]+g|0]=b&255;0!=(b|0)&&(b=t[e]+1|0,t[e]=b,l[t[c]+b|0]=0);g=T();if(-1==(g|0)){break}if(0!=(oA(g)|0)){b=g}else{if(95==(g|0)||36==(g|0)){b=g}else{break}}}W(g);b=t[e];(b+1|0)!=(t[f>>2]|0)?(c=t[c],c=c+b|0):(R(d),d=t[e],c=t[c],c=c+d|0);l[c]=0}function hJ(){var b=t[t[Lz+24>>2]+8>>2],d,c=j;j+=80;d=c>>2;var e=0==(t[K+52>>2]|0);0!=(t[Tz+16>>2]|0)&&0!=(t[oy+8>>2]|0)|e^1&&(sC(c,b),t[d]=2!=(t[oy+76>>2]|0)&1,t[d+4]=e&1,t[d+6]=1,t[d+9]=Zv|0,l[c+40|0]=100,tC(c));j=c}function W(b){t[K+28>>2]=b}function jJ(){var b;b=dJ()>>2;0==(t[Lz+8>>2]|0)|0!=(t[Vz>>2]|0)||(t[b+1]=1);if(0!=(t[b]|0)){return 1}if(0==(t[b+2]|0)){return 0}b=0!=(t[b+1]|0);return b&1}function kJ(b){var d,c;d=t[K+40>>2];0!=(d|0)&&Q(d);t[K+40>>2]=b;d=t[K+44>>2];0!=(d|0)&&vB(d);d=(b+8|0)>>2;var e=t[d];if(0==(t[oy+144>>2]|0)){c=3323}else{if(0!=(47==(l[e]<<24>>24|0)&1|0)){c=3323}else{var f;f=t[NaN>>2];var g,h;var i;if(0==(47==(l[e]<<24>>24|0)&1|0)){i=tb(0);var m=tb(e)+i|0,n=zC(m+1|0);AB(n,0);AB(n+i|0,e);l[n+m|0]=0;i=n}else{i=HI(e)}m=mA(i,47);c:for(;;){var q=m+1|0,p=m+2|0,n=m+3|0;if(0==(m|0)){break}for(;;){if(0==l[m]<<24>>24){break c}if(46!=l[q]<<24>>24){break}var s=l[p];if(46==s<<24>>24){h=2791;break}else{if(!(47==s<<24>>24||0==s<<24>>24)){break}}AB(m,p)}do{if(2791==h&&(h=0,p=l[n],47==p<<24>>24||0==p<<24>>24)){for(q=m;;){q=q-1|0;if(q>>>0<i>>>0){var r=m;break}if(0!=(47==(l[q]<<24>>24|0)&1|0)){r=q;break}}AB(r,n);m=r;continue c}}while(0);m=mA(q,47)}h=0!=l[i]<<24>>24?i:HI(dh|0);r=f;for(f=h;;){if(l[f]<<24>>24==l[r]<<24>>24){r=r+1|0,f=f+1|0}else{var u=r,v=f;break}}for(;;){if((v|0)==(h|0)){var w=h;g=2824;break}r=v-1|0;u=u-1|0;if(47==l[r]<<24>>24){var C=0,A=u;break}else{v=r}}if(2824!=g){for(;!(g=mA(A+1|0,47),0==(g|0));){C=C+1|0,A=g}g=zC(3*C+tb(v)+1|0);l[g]=0;w=0<(C|0);b:do{if(w){for(A=C;;){if(A=A-1|0,u=g+tb(g)|0,Fa=3092014,l[u]=Fa&255,Fa>>=8,l[u+1]=Fa&255,Fa>>=8,l[u+2]=Fa&255,Fa>>=8,l[u+3]=Fa&255,0>=(A|0)){break b}}}}while(0);C=tb(g);w=0;do{l[g+C+w]=l[v+w],w++}while(0!=l[v+(w-1)]);vB(h);w=g}f=w}}3323==c&&(f=HI(e));t[K+44>>2]=f;b=t[b>>2];b>>>0>t[NaN>>2]>>>0&&(t[NaN>>2]=b);b=t[oy+104>>2];b=0==(b|0)?0:-1!=(OI(b,KI(t[d]),186)|0)&1;t[K+52>>2]=b;d=II(t[d]);t[K+56>>2]=d}function T(){var b=t[K+28>>2];if(0!=(b|0)){t[K+28>>2]=0;var d;return b}for(var c=t[K+12>>2];;){if(0==(c|0)){b=lJ(),0==(b|0)?b=t[K+12>>2]:(b=t[b+8>>2],t[K+12>>2]=b),c=(0==(b|0))<<31>>31}else{b=c+1|0;t[K+12>>2]=b;var c=l[c],e=c&255;0!=c<<24>>24?c=e:(t[K+12>>2]=0,c=e,b=0)}if(0==(c|0)){c=b}else{d=c;break}}return d}function lJ(){var b,d=t[K+8>>2];0==(d|0)&&(d=P(),t[K+8>>2]=d);S(d);a:for(;;){for(var c,d=ba;;){c=XB(t[K+16>>2]);if(0==(t[K+36>>2]|0)|-1==(c|0)){var e=c;break}t[K+24>>2]=t[Ox>>2];t[K+36>>2]=0;t[K+20>>2]=t[K+20>>2]+1|0;t[K+48>>2]=t[K+48>>2]+1|0;if(!(35==(c|0)&0!=(t[oy+152>>2]|0))){e=c;break}if(0==(mJ()|0)){d=3399;break}}3399==d&&(oB(t[K+16>>2],Ox),e=XB(t[K+16>>2]));-1==(e|0)?(t[K+32>>2]=1,d=-1):10==(e|0)?(t[K+36>>2]=1,nB(t[K+16>>2],Ox),d=10):13==(e|0)?(d=XB(t[K+16>>2]),10==(d|0)?(t[K+36>>2]=1,nB(t[K+16>>2],Ox),d=10):(YB(d),d=13)):d=e;c=d;d=-1!=(c|0);do{if(d){var f=t[K+8>>2],g=t[f>>2];(g+1|0)==(t[f+4>>2]|0)&&(R(f),f=g=t[K+8>>2],g=t[g>>2]);l[t[f+8>>2]+g|0]=c&255;if(0!=(c|0)){if(f=t[K+8>>2]|0,g=t[f>>2]+1|0,t[f>>2]=g,l[t[t[K+8>>2]+8>>2]+g|0]=0,10==(c|0)){b=3357;break a}else{-1==(c|0)&&(b=3358)}}}else{b=3358}}while(0);if(3358==b&&(b=0,c=t[K+8>>2],f=t[c>>2],0!=(f|0))){var h=c,i=f;break}if(!d){var m=0;b=3367;break}}if(3357==b){h=i=t[K+8>>2],i=t[i>>2]}else{if(3367==b){return m}}(i+1|0)==(t[h+4>>2]|0)&&(R(h),h=i=t[K+8>>2],i=t[i>>2]);l[t[h+8>>2]+i|0]=0;h=t[K+8>>2];if(0==(t[h>>2]|0)){return h}b=t[K+56>>2];if(!(-2==(b|0)|(t[Zx>>2]|0)<(b|0))&&(e=t[Yx>>2],i=(b<<3)+e+4|0,0!=(t[i>>2]|0))){b=(b<<3)+e|0;for(e=0;;){c=h;d=t[b>>2]+28*e|0;m=j;j+=80;for(var n=c+8|0,f=m|0,g=TB(t[n>>2]),q=SB[t[d>>2]].exec(g),p=0;10>p;p++){var s=-1,r=-1;q&&p<q.length&&(s=g.indexOf(q[p]),r=s+q[p].length);t[f+8*p>>2]=s;t[f+(8*p+4)>>2]=r}if(0==((q?0:1)|0)){if(g=t[d+4>>2],1==(g|0)){g=j;j+=80;for(n=0;10>(n|0);){q=t[f+(n<<3)>>2];if(-1==(q|0)){break}t[g+(n<<3)>>2]=q;t[g+(n<<3)+4>>2]=t[f+(n<<3)+4>>2]-q|0;n=n+1|0}ab[t[d+8>>2]](t[c+8>>2],g|0,n);j=g}else{if(0==(g|0)){c=j;g=d+8|0;f=YI(t[n>>2],t[g>>2],f);q=n=ba;q=(f|0)>>2;for(n=(f+8|0)>>2;0!=(L(l[t[n]]<<24>>24)|0);){p=t[q];if(0==(p|0)){break}if(1<p>>>0){for(p=1;;){var u=t[n];l[u+(p-1)|0]=l[u+p|0];p=p+1|0;u=t[q];if(p>>>0>=u>>>0){break}}p=u-1|0}else{p=0}t[q]=p;l[t[n]+p|0]=0}DD(f);0==(t[f>>2]|0)?(d=t[t[K+40>>2]+8>>2],n=t[K+20>>2],g=t[g>>2],RI(2,St|0,(k=j,j+=12,t[k>>2]=d,t[k+4>>2]=n,t[k+8>>2]=g,k))):(g=f,d=d+12|0,n=j,j+=80,0!=(t[d>>2]|0)&&(sC(n,t[g+8>>2]),l[n+40|0]=l[d+4|0],t[n+36>>2]=t[d+8>>2],tC(n)),j=n);Q(f);j=c}}}j=m;e=e+1|0;if(e>>>0>=t[i>>2]>>>0){break}}}return m=t[K+8>>2]}lJ.X=1;function uE(b){for(;;){var d=T();if(-1==(d|0)|(d|0)==(b|0)){break}}}function eC(){var b=lJ();if(0==(b|0)){return 0}var d=t[b+8>>2],c;c=(b|0)>>2;b=t[b+8>>2]+(t[c]-1)|0;10==l[b]<<24>>24&&(l[b]=0,t[c]=t[c]-1|0);return d}function MI(b,d){var c,e=j;j+=4;var f;S(b);if(0==(d|0)){return RI(1,ck|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k)),j=e,0}c=(b+8|0)>>2;for(var g=b+4|0;;){var h=t[c]+(t[g>>2]-2)|0;nB(d,e);l[h]=0;var i;a:{i=t[c];var m=t[g>>2],n=d;if(JA[n]){var q=JA[n];if(q.error||q.c){i=0}else{for(var p=ba,s=0;s<m-1&&10!=p;s++){p=WB(n);if(-1==p){if(q.error){i=0;break a}if(q.c){break}}l[i+s]=p}l[i+s]=0}}else{i=0}}if(0==(i|0)){f=3380;break}h=l[h];if(0==h<<24>>24||10==h<<24>>24||13==h<<24>>24){break}R(b);oB(d,e)}if(3380==f){if(0!=(cB(d)|0)){return j=e,0}RI(5,si|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k));j=e;return 0}t[b>>2]=tb(t[b+8>>2]);h=t[c];c=(b|0)>>2;m=t[c];f=h+(m-1)|0;g=l[f];if(13==g<<24>>24){return l[f]=10,j=e,i}h=h+(m-2)|0;if(!(13==l[h]<<24>>24&10==g<<24>>24)){return j=e,i}l[h]=10;l[f]=0;t[c]=t[c]-1|0;j=e;return i}MI.X=1;function mJ(){var b,d=j;j+=80;var c;b=d>>2;var e=nJ();if(10>(e-48|0)>>>0){YB(e),c=3419}else{if(108!=(e|0)){var f=0}else{105!=(XB(t[K+16>>2])|0)?f=0:110!=(XB(t[K+16>>2])|0)?f=0:101!=(XB(t[K+16>>2])|0)?f=0:(e=XB(t[K+16>>2]),32==(e|0)||9==(e|0)?c=3419:f=0)}}if(3419==c){var g;a:{c=0;for(f=nJ();;){if(-1==(f|0)){g=3434;break}e=f-48|0;if(10<=e>>>0){g=3437;break}c=e+10*c|0;f=XB(t[K+16>>2])}if(3437==g){if(YB(f),32==(f|0)||9==(f|0)){g=c;break a}}else{3434==g&&YB(-1)}g=0}if(0==(g|0)){f=0}else{c=oJ();f=c|0;if(0==(t[f>>2]|0)){t[K+48>>2]=g-1|0}else{e=c+8|0;if(-2==(II(t[e>>2])|0)){e=0}else{var e=t[e>>2],h=t[K+4>>2];if(0!=(47==(l[e]<<24>>24|0)&1|0)|0==(h|0)){e=BE(c)}else{var i=t[h+8>>2],m,h=P();m=47==(l[i+(tb(i)-1)|0]<<24>>24|0)&1;V(h,i);if(0==(m|0)){m=(h|0)>>2;var i=t[m],n=h+4|0;if((i+1|0)==(t[n>>2]|0)){R(h);var q=t[m]}else{q=i}i=(h+8|0)>>2;l[t[i]+q|0]=47;q=t[m]+1|0;t[m]=q;l[t[i]+q|0]=0;q=t[m];(q+1|0)==(t[n>>2]|0)?(R(h),m=t[m]):m=q;l[t[i]+m|0]=0}U(h,e);e=h}kJ(e);e=1}0!=(e|0)&&(t[K+48>>2]=g-1|0)}0!=(t[oy>>2]|0)&&0!=(t[f>>2]|0)&1==(g|0)&&(sC(d,kH(t[c+8>>2])),t[b+5]=1,t[b]=1,t[b+1]=1,t[b+9]=Ne|0,l[d+40|0]=70,tC(d));Q(c);f=1}}j=d;return f}mJ.X=1;function nJ(){for(;;){var b=XB(t[K+16>>2]);if(!(32==(b|0)||9==(b|0))){break}}return b}function oJ(){var b,d,c=P(),e=nJ(),f=34==(e|0);a:do{if(f){var g=c|0;b=g>>2;for(var h=c+4|0,i=c+8|0,m=XB(t[K+16>>2]);;){if(-1==(m|0)||34==(m|0)){var n=g,q=h,p=i;break a}else{if(10==(m|0)){var s=g,r=h,u=i;d=3457;break a}}var v=t[b];(v+1|0)==(t[h>>2]|0)&&(R(c),v=t[b]);l[t[i>>2]+v|0]=m&255;0!=(m|0)&&(m=t[b]+1|0,t[b]=m,l[t[i>>2]+m|0]=0);m=XB(t[K+16>>2])}}else{g=c|0;b=g>>2;h=c+4|0;i=c+8|0;for(m=e;;){if(-1==(m|0)||9==(m|0)||32==(m|0)){n=g;q=h;p=i;break a}else{if(10==(m|0)){s=g;r=h;u=i;d=3457;break a}}v=t[b];(v+1|0)==(t[h>>2]|0)&&(R(c),v=t[b]);l[t[i>>2]+v|0]=m&255;0!=(m|0)&&(m=t[b]+1|0,t[b]=m,l[t[i>>2]+m|0]=0);m=XB(t[K+16>>2])}}}while(0);3457==d&&(YB(10),n=s,q=r,p=u);d=t[n>>2];if((d+1|0)!=(t[q>>2]|0)){return p=t[p>>2],p=p+d|0,l[p]=0,c}R(c);n=t[n>>2];p=t[p>>2];p=p+n|0;l[p]=0;return c}oJ.X=1;function pJ(){if(!l[Hc]){l[Hc]=1;QI();var b=j,d=bH();t[ny>>2]=d;KC(st|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k));var d=j,c=ZI(az|0);t[oy+104>>2]=c;if(0!=(t[oy+88>>2]|0)){mB(am|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k));var e=t[oy+104>>2],c=j,f=e+4|0;if(0!=(t[f>>2]|0)){for(var e=e+8|0,g=0;;){var h=0!=(g|0)?Cr|0:hm|0,i=t[t[t[e>>2]+(g<<2)>>2]+8>>2];mB(cw|0,(k=j,j+=8,t[k>>2]=h,t[k+4>>2]=i,k));g=g+1|0;if(g>>>0>=t[f>>2]>>>0){break}}}j=c;qB(10,t[Ob>>2])}j=d;KC(Ss|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k));d=j;if(0!=(t[Dy>>2]|0)){for(c=0;;){f=FI(c);KC(vi|0,(k=j,j+=4,t[k>>2]=f,k));f=c;e=j;h=t[t[Cy>>2]+(f<<2)>>2];i=h+44|0;g=t[i>>2];0!=(g|0)&&fH(g);var g=h+48|0,m=t[g>>2];0!=(m|0)&&fH(m);m=t[h+16>>2];m=0==(m|0)?bH():ZI(m);t[i>>2]=m;h=t[h+12>>2];h=0==(h|0)?bH():ZI(h);t[g>>2]=h;0!=(t[oy+88>>2]|0)&&PI(f);KC(Jq|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k));j=e;c=c+1|0;if(c>>>0>=t[Dy>>2]>>>0){break}}}j=d;KC(xs|0,(k=j,j+=1,j=j+3>>2<<2,t[k>>2]=0,k));SI(fs|0);SI(Lr|0);SI(mr|0);SI(Xq|0);SI(Kq|0);SI(wq|0);SI(jq|0);SI(Rp|0);SI(Bp|0);SI(mp|0);SI($o|0);SI(Ko|0);SI(ro|0);SI(ho|0);SI(Zn|0);SI(On|0);SI(zn|0);SI(on|0);SI(dn|0);j=b}}function qJ(b){pJ();return FI(II(b))}a._getLanguage=qJ;function rJ(b){var d=j,c=t[oy+128>>2],c=-1==(c|0)?II(b):c;if(-2==(c|0)){KC(gs|0,(k=j,j+=4,t[k>>2]=b,k))}else{if(0==(t[t[t[Cy>>2]+(c<<2)>>2]+40>>2]|0)){KC(Mr|0,(k=j,j+=4,t[k>>2]=b,k))}else{0!=(t[oy+136>>2]|0)&&ba();var e=j;j+=4;var f=t[NaN>>2];nB(t[NaN>>2],e);var g=0,h=0;a:for(;;){var i=g,g=h;b:for(;;){for(;;){var m=g+1|0;var h=b,n=c,g=m,q;var p=h,s=n;q=j;var r=t[K+16>>2];0!=(r|0)&&(uB(r),t[K+16>>2]=0);r=tB(p,Ns|0);t[K+16>>2]=r;if(0==(r|0)){RI(6,Xv|0,(k=j,j+=4,t[k>>2]=p,k)),p=0}else{var r=kH(p),u=t[K>>2];0!=(u|0)&&Q(u);u=PD(p);t[K>>2]=u;u=t[K+4>>2];0!=(u|0)&&Q(u);(r|0)==(p|0)?t[K+4>>2]=0:(u=P(),t[K+4>>2]=u,r=r+(p^-1)|0,S(u),gD(u,p,r));nB(t[K+16>>2],Ox);nB(t[K+16>>2],K+24|0);t[K+12>>2]=0;t[K+20>>2]=0;t[K+32>>2]=0;t[K+36>>2]=1;r=t[K+8>>2];0!=(r|0)&&S(r);kJ(PD(p));t[K+48>>2]=0;s=FI(s);r=0!=(t[K+52>>2]|0)?yo|0:hm|0;KC(wr|0,(k=j,j+=12,t[k>>2]=p,t[k+4>>2]=s,t[k+8>>2]=r,k));p=1}j=q;q=p;0==(q|0)?g=0:(n=t[t[Cy>>2]+(n<<2)>>2],0!=(t[oy+72>>2]|0)&&ba(),q=ba,p=j,j+=80,q=p>>2,0!=(t[oy>>2]|0)&&(sC(p,kH(h)),t[q+5]=1,t[q]=1,t[q+1]=1,t[q+9]=Ne|0,l[p+40|0]=70,tC(p)),j=p,h=t[n+24>>2],0==(h|0)?(h=t[n+28>>2],g=0==(h|0)?0:ab[h](g)):(ab[h](),g=0),0!=(t[oy+72>>2]|0)&&ba(t[K+44>>2]),h=t[K+16>>2],0!=(h|0)&&(0!=(t[oy+148>>2]|0)&&(LI(t[t[K>>2]+8>>2]),h=t[K+16>>2]),uB(h),t[K+16>>2]=0));if(0==(g|0)){break a}else{if(2==(g|0)){break b}else{if(1==(g|0)){break}else{g=m}}}}oB(t[NaN>>2],e);t[NaN>>2]=f;i=1;g=m}nB(t[NaN>>2],e);g=i;h=m;f=t[NaN>>2]}j=e;0!=(t[oy+136>>2]|0)&&ba(i)}}j=d;RB&&RB(Na(b))}function sJ(b){var d=j;pJ();if(4294967293<II(b)>>>0){mB(Ks|0,(k=j,j+=4,t[k>>2]=b,k))}else{var c=tB(b,Wv|0);if(0==(c|0)){var c=Na(b),e=Na(b),f=e.lastIndexOf("/");VA(e.substr(0,f),e.substr(f+1),c,ca,ca,(function(){ab[38](b)}),(function(){ab[82](b)}))}else{uB(c),rJ(b)}}j=d}a._parseURL=sJ;function tC(b){var b=b>>2,d=t[b+9],c=t[b+1],e=t[b+7],f=t[b+3];QB&&QB(Na(t[b+8]),Na(d),c,Na(e),Na(f))}function sC(b,d){for(var c=b>>2,e=b>>2,f=e+20;e<f;e++){t[e]=0}t[c]=1==(t[oy+76>>2]|0)&1;t[c+1]=t[K+48>>2];t[c+3]=FI(t[K+56>>2]);t[c+2]=t[K+24>>2];t[c+7]=t[K+44>>2];t[c+8]=d}function Xa(b){do{if(245>b>>>0){var d=11>b>>>0?16:b+11&-8,c=d>>>3,e=t[D>>2],f=e>>>(c>>>0);if(0!=(f&3|0)){var g=(f&1^1)+c|0,h=g<<1,d=(h<<2)+D+40|0,c=(h+2<<2)+D+40|0,b=t[c>>2],h=b+8|0,f=t[h>>2];(d|0)==(f|0)?t[D>>2]=e&(1<<g^-1):f>>>0<t[D+16>>2]>>>0?O():(t[c>>2]=f,t[f+12>>2]=d);g<<=3;t[b+4>>2]=g|3;g=b+(g|4)|0;t[g>>2]|=1;return h}if(d>>>0>t[D+8>>2]>>>0){if(0==(f|0)){if(0==(t[D+4>>2]|0)){e=d;break}h=tJ(d);if(0==(h|0)){e=d;break}return h}var b=2<<c,b=f<<c&(b|-b),c=(b&-b)-1|0,b=c>>>12&16,f=c>>>(b>>>0),c=f>>>5&8,i=f>>>(c>>>0),f=i>>>2&4,m=i>>>(f>>>0),i=m>>>1&2,m=m>>>(i>>>0),n=m>>>1&1,f=(c|b|f|i|n)+(m>>>(n>>>0))|0,b=f<<1,i=(b<<2)+D+40|0,m=(b+2<<2)+D+40|0,c=t[m>>2],b=c+8|0,n=t[b>>2];(i|0)==(n|0)?t[D>>2]=e&(1<<f^-1):n>>>0<t[D+16>>2]>>>0?O():(t[m>>2]=n,t[n+12>>2]=i);f<<=3;e=f-d|0;t[c+4>>2]=d|3;i=c;c=i+d|0;t[i+(d|4)>>2]=e|1;t[i+f>>2]=e;n=t[D+8>>2];0!=(n|0)&&(d=t[D+20>>2],i=n>>>2&1073741822,f=(i<<2)+D+40|0,m=t[D>>2],n=1<<(n>>>3),0==(m&n|0)?(t[D>>2]=m|n,h=f,g=(i+2<<2)+D+40|0):(i=(i+2<<2)+D+40|0,m=t[i>>2],m>>>0<t[D+16>>2]>>>0?O():(h=m,g=i)),t[g>>2]=d,t[h+12>>2]=d,t[d+8>>2]=h,t[d+12>>2]=f);t[D+8>>2]=e;t[D+20>>2]=c;return h=b}e=d}else{if(4294967231<b>>>0){e=-1}else{if(e=b+11&-8,0!=(t[D+4>>2]|0)&&(d=uJ(e),0!=(d|0))){return h=d}}}}while(0);g=t[D+8>>2];e>>>0>g>>>0?(h=t[D+12>>2],e>>>0<h>>>0?(h=h-e|0,t[D+12>>2]=h,g=t[D+24>>2],t[D+24>>2]=g+e|0,t[e+(g+4)>>2]=h|1,t[g+4>>2]=e|3,h=g+8|0):h=vJ(e)):(d=g-e|0,h=t[D+20>>2],15<d>>>0?(t[D+20>>2]=h+e|0,t[D+8>>2]=d,t[e+(h+4)>>2]=d|1,t[h+g>>2]=d,t[h+4>>2]=e|3):(t[D+8>>2]=0,t[D+20>>2]=0,t[h+4>>2]=g|3,g=g+(h+4)|0,t[g>>2]|=1),h=h+8|0);return h}Xa.X=1;function tJ(b){var d,c,e=t[D+4>>2],f=(e&-e)-1|0,e=f>>>12&16,g=f>>>(e>>>0),f=g>>>5&8;c=g>>>(f>>>0);var g=c>>>2&4,h=c>>>(g>>>0);c=h>>>1&2;var h=h>>>(c>>>0),i=h>>>1&1,e=g=f=t[D+((f|e|g|c|i)+(h>>>(i>>>0))<<2)+304>>2];c=e>>2;for(f=(t[f+4>>2]&-8)-b|0;;){h=t[g+16>>2];if(0==(h|0)){if(g=t[g+20>>2],0==(g|0)){break}else{c=g}}else{c=h}h=(t[c+4>>2]&-8)-b|0;i=h>>>0<f>>>0;g=c;e=i?c:e;c=e>>2;f=i?h:f}var h=e,m=t[D+16>>2];h>>>0<m>>>0&&O();g=h+b|0;h>>>0<g>>>0||O();var i=t[c+6],n=t[c+3],q=(n|0)==(e|0);a:do{if(q){var p=e+20|0,s=t[p>>2];do{if(0==(s|0)){var r=e+16|0,u=t[r>>2];if(0==(u|0)){var v=0;d=v>>2;break a}}else{r=p,u=s}}while(0);for(;;){if(p=u+20|0,s=t[p>>2],0!=(s|0)){r=p,u=s}else{if(p=u+16|0,s=t[p>>2],0==(s|0)){break}else{r=p,u=s}}}r>>>0<m>>>0?O():(t[r>>2]=0,v=u,d=v>>2)}else{r=t[c+2],r>>>0<m>>>0?O():(t[r+12>>2]=n,t[n+8>>2]=r,v=n,d=v>>2)}}while(0);m=0==(i|0);a:do{if(!m){n=e+28|0;q=(t[n>>2]<<2)+D+304|0;do{if((e|0)==(t[q>>2]|0)){if(t[q>>2]=v,0==(v|0)){t[D+4>>2]&=1<<t[n>>2]^-1;break a}}else{if(i>>>0<t[D+16>>2]>>>0&&O(),r=i+16|0,(t[r>>2]|0)==(e|0)?t[r>>2]=v:t[i+20>>2]=v,0==(v|0)){break a}}}while(0);v>>>0<t[D+16>>2]>>>0&&O();t[d+6]=i;n=t[c+4];0!=(n|0)&&(n>>>0<t[D+16>>2]>>>0?O():(t[d+4]=n,t[n+24>>2]=v));n=t[c+5];0!=(n|0)&&(n>>>0<t[D+16>>2]>>>0?O():(t[d+5]=n,t[n+24>>2]=v))}}while(0);if(16>f>>>0){var w=f+b|0;t[c+1]=w|3;w=w+(h+4)|0;t[w>>2]|=1;return w=e+8|0}t[c+1]=b|3;t[b+(h+4)>>2]=f|1;t[h+f+b>>2]=f;h=t[D+8>>2];if(0!=(h|0)){b=t[D+20>>2];v=h>>>2&1073741822;d=(v<<2)+D+40|0;c=t[D>>2];h=1<<(h>>>3);if(0==(c&h|0)){t[D>>2]=c|h;var w=d,C=(v+2<<2)+D+40|0}else{v=(v+2<<2)+D+40|0,c=t[v>>2],c>>>0<t[D+16>>2]>>>0?O():(w=c,C=v)}t[C>>2]=b;t[w+12>>2]=b;t[b+8>>2]=w;t[b+12>>2]=d}t[D+8>>2]=f;t[D+20>>2]=g;return w=e+8|0}tJ.X=1;function vJ(b){var d,c;0==(t[zc>>2]|0)&&wJ();var e=0==(t[D+440>>2]&4|0);a:do{if(e){var f=t[D+24>>2];if(0==(f|0)){c=3592}else{if(f=xJ(f),0==(f|0)){c=3592}else{var g=t[zc+8>>2],g=b+47-t[D+12>>2]+g&-g;if(2147483647>g>>>0){c=$B(g);var h=(c|0)==(t[f>>2]+t[f+4>>2]|0);d=h?c:-1;var h=h?g:0,i=g,m=c;c=3599}else{var n=0}}}if(3592==c){if(f=$B(0),-1==(f|0)){n=0}else{var g=t[zc+8>>2],g=g+(b+47)&-g,q=f,p=t[zc+4>>2],s=p-1|0,g=0==(s&q|0)?g:g-q+(s+q&-p)|0;2147483647>g>>>0?(c=$B(g),d=(h=(c|0)==(f|0))?f:-1,h=h?g:0,i=g,m=c,c=3599):n=0}}b:do{if(3599==c){c=-i|0;if(-1!=(d|0)){var r=h,u=d;c=3612;break a}do{if(-1!=(m|0)&2147483647>i>>>0){if(i>>>0<(b+48|0)>>>0){if(n=t[zc+8>>2],n=b+47-i+n&-n,2147483647>n>>>0){if(-1==($B(n)|0)){$B(c);n=h;break b}else{n=n+i|0}}else{n=i}}else{n=i}}else{n=i}}while(0);if(-1!=(m|0)){r=n;u=m;c=3612;break a}t[D+440>>2]|=4;var v=h;c=3609;break a}}while(0);t[D+440>>2]|=4;v=n}else{v=0}c=3609}while(0);3609==c&&(e=t[zc+8>>2],e=e+(b+47)&-e,2147483647>e>>>0&&(e=$B(e),d=$B(0),-1!=(d|0)&-1!=(e|0)&e>>>0<d>>>0&&(d=d-e|0,e=(h=d>>>0>(b+40|0)>>>0)?e:-1,-1!=(e|0)&&(r=h?d:v,u=e,c=3612))));do{if(3612==c){v=t[D+432>>2]+r|0;t[D+432>>2]=v;v>>>0>t[D+436>>2]>>>0&&(t[D+436>>2]=v);v=t[D+24>>2];e=0==(v|0);a:do{if(e){d=t[D+16>>2];0==(d|0)|u>>>0<d>>>0&&(t[D+16>>2]=u);t[D+444>>2]=u;t[D+448>>2]=r;t[D+456>>2]=0;t[D+36>>2]=t[zc>>2];t[D+32>>2]=-1;for(d=0;!(h=d<<1,i=(h<<2)+D+40|0,t[D+(h+3<<2)+40>>2]=i,t[D+(h+2<<2)+40>>2]=i,d=d+1|0,32==(d|0));){}yJ(u,r-40|0)}else{h=D+444|0;for(d=h>>2;0!=(h|0);){var w=t[d],C=h+4|0,A=t[C>>2];if((u|0)==(w+A|0)){c=3621;break}h=t[d+2];d=h>>2}do{if(3621==c&&0==(t[d+3]&8|0)&&(h=v,h>>>0>=w>>>0&h>>>0<u>>>0)){t[C>>2]=A+r|0;yJ(t[D+24>>2],t[D+12>>2]+r|0);break a}}while(0);u>>>0<t[D+16>>2]>>>0&&(t[D+16>>2]=u);d=u+r|0;for(h=D+444|0;0!=(h|0);){var I=h|0;if((t[I>>2]|0)==(d|0)){c=3630;break}h=t[h+8>>2]}if(3630==c&&0==(t[h+12>>2]&8|0)){return t[I>>2]=u,w=h+4|0,t[w>>2]=t[w>>2]+r|0,b=zJ(u,d,b)}AJ(u,r)}}while(0);v=t[D+12>>2];if(v>>>0>b>>>0){return r=v-b|0,t[D+12>>2]=r,w=u=t[D+24>>2],t[D+24>>2]=w+b|0,t[b+(w+4)>>2]=r|1,t[u+4>>2]=b|3,b=u+8|0}}}while(0);t[GA>>2]=12;return 0}vJ.X=1;function uJ(b){var d,c,e,f,g,h=b>>2,i,m=-b|0,n=b>>>8;if(0==(n|0)){var q=0}else{if(16777215<b>>>0){q=31}else{var p=(n+1048320|0)>>>16&8,s=n<<p,r=(s+520192|0)>>>16&4,u=s<<r,v=(u+245760|0)>>>16&2,w=14-(r|p|v)+(u<<v>>>15)|0,q=b>>>((w+7|0)>>>0)&1|w<<1}}var C=t[D+(q<<2)+304>>2],A=0==(C|0);a:do{if(A){var I=0,M=m,B=0}else{var G=31==(q|0)?0:25-(q>>>1)|0,Z=0,X=m,ga=C;g=ga>>2;for(var ra=b<<G,ka=0;;){var ia=t[g+1]&-8,ea=ia-b|0;if(ea>>>0<X>>>0){if((ia|0)==(b|0)){I=ga;M=ea;B=ga;break a}else{var wb=ga,sb=ea}}else{wb=Z,sb=X}var Db=t[g+5],Za=t[((ra>>>31<<2)+16>>2)+g],kc=0==(Db|0)|(Db|0)==(Za|0)?ka:Db;if(0==(Za|0)){I=wb;M=sb;B=kc;break a}else{Z=wb,X=sb,ga=Za,g=ga>>2,ra<<=1,ka=kc}}}}while(0);if(0==(B|0)&0==(I|0)){var $c=2<<q,Ia=t[D+4>>2]&($c|-$c);if(0==(Ia|0)){var Eb=0;return Eb}var Pb=(Ia&-Ia)-1|0,He=Pb>>>12&16,Hd=Pb>>>(He>>>0),de=Hd>>>5&8,ee=Hd>>>(de>>>0),Id=ee>>>2&4,Jd=ee>>>(Id>>>0),uc=Jd>>>1&2,Kd=Jd>>>(uc>>>0),Qb=Kd>>>1&1,Mc=t[D+((de|He|Id|uc|Qb)+(Kd>>>(Qb>>>0))<<2)+304>>2]}else{Mc=B}var ad=0==(Mc|0);a:do{if(ad){var bb=M,Qa=I;f=Qa>>2}else{var Rb=Mc;e=Rb>>2;for(var vc=M,Sb=I;;){var fe=(t[e+1]&-8)-b|0,vd=fe>>>0<vc>>>0,lc=vd?fe:vc,Nc=vd?Rb:Sb,ge=t[e+4];if(0!=(ge|0)){Rb=ge,e=Rb>>2,vc=lc,Sb=Nc}else{var he=t[e+5];if(0==(he|0)){bb=lc;Qa=Nc;f=Qa>>2;break a}else{Rb=he,e=Rb>>2,vc=lc,Sb=Nc}}}}}while(0);if(0==(Qa|0)||bb>>>0>=(t[D+8>>2]-b|0)>>>0){return Eb=0}var Tb=Qa;c=Tb>>2;var Ub=t[D+16>>2];Tb>>>0<Ub>>>0&&O();var bd=Tb+b|0;Tb>>>0<bd>>>0||O();var cd=t[f+6],ac=t[f+3],ie=(ac|0)==(Qa|0);a:do{if(ie){var Ld=Qa+20|0,gb=t[Ld>>2];do{if(0==(gb|0)){var dd=Qa+16|0,Vb=t[dd>>2];if(0==(Vb|0)){var Sa=0;d=Sa>>2;break a}else{var Oc=dd,Pc=Vb}}else{Oc=Ld,Pc=gb}}while(0);for(;;){var Md=Pc+20|0,ed=t[Md>>2];if(0!=(ed|0)){Oc=Md,Pc=ed}else{var je=Pc+16|0,ke=t[je>>2];if(0==(ke|0)){break}else{Oc=je,Pc=ke}}}Oc>>>0<Ub>>>0?O():(t[Oc>>2]=0,Sa=Pc,d=Sa>>2)}else{var wd=t[f+2];wd>>>0<Ub>>>0?O():(t[wd+12>>2]=ac,t[ac+8>>2]=wd,Sa=ac,d=Sa>>2)}}while(0);var xd=0==(cd|0);a:do{if(xd){var ob=Qa}else{var Fb=Qa+28|0,fd=(t[Fb>>2]<<2)+D+304|0;do{if((Qa|0)==(t[fd>>2]|0)){if(t[fd>>2]=Sa,0==(Sa|0)){t[D+4>>2]&=1<<t[Fb>>2]^-1;ob=Qa;break a}}else{cd>>>0<t[D+16>>2]>>>0&&O();var le=cd+16|0;(t[le>>2]|0)==(Qa|0)?t[le>>2]=Sa:t[cd+20>>2]=Sa;if(0==(Sa|0)){ob=Qa;break a}}}while(0);Sa>>>0<t[D+16>>2]>>>0&&O();t[d+6]=cd;var gd=t[f+4];0!=(gd|0)&&(gd>>>0<t[D+16>>2]>>>0?O():(t[d+4]=gd,t[gd+24>>2]=Sa));var yd=t[f+5];0==(yd|0)?ob=Qa:yd>>>0<t[D+16>>2]>>>0?O():(t[d+5]=yd,t[yd+24>>2]=Sa,ob=Qa)}}while(0);do{if(16>bb>>>0){var Nd=bb+b|0;t[ob+4>>2]=Nd|3;var Od=Nd+(Tb+4)|0;t[Od>>2]|=1}else{if(t[ob+4>>2]=b|3,t[h+(c+1)]=bb|1,t[(bb>>2)+c+h]=bb,256>bb>>>0){var wc=bb>>>2&1073741822,xc=(wc<<2)+D+40|0,hd=t[D>>2],Pd=1<<(bb>>>3);if(0==(hd&Pd|0)){t[D>>2]=hd|Pd;var bc=xc,me=(wc+2<<2)+D+40|0}else{var Qd=(wc+2<<2)+D+40|0,ne=t[Qd>>2];ne>>>0<t[D+16>>2]>>>0?O():(bc=ne,me=Qd)}t[me>>2]=bd;t[bc+12>>2]=bd;t[h+(c+2)]=bc;t[h+(c+3)]=xc}else{var cc=bd,id=bb>>>8;if(0==(id|0)){var yb=0}else{if(16777215<bb>>>0){yb=31}else{var Rd=(id+1048320|0)>>>16&8,oe=id<<Rd,jd=(oe+520192|0)>>>16&4,Qc=oe<<jd,mc=(Qc+245760|0)>>>16&2,pe=14-(jd|Rd|mc)+(Qc<<mc>>>15)|0,yb=bb>>>((pe+7|0)>>>0)&1|pe<<1}}var Rc=(yb<<2)+D+304|0;t[h+(c+7)]=yb;t[h+(c+5)]=0;t[h+(c+4)]=0;var kd=t[D+4>>2],nc=1<<yb;if(0==(kd&nc|0)){t[D+4>>2]=kd|nc,t[Rc>>2]=cc,t[h+(c+6)]=Rc,t[h+(c+3)]=cc,t[h+(c+2)]=cc}else{for(var Sd=bb<<(31==(yb|0)?0:25-(yb>>>1)|0),Sc=t[Rc>>2];(t[Sc+4>>2]&-8|0)!=(bb|0);){var Td=(Sd>>>31<<2)+Sc+16|0,qe=t[Td>>2];if(0==(qe|0)){i=3709;break}else{Sd<<=1,Sc=qe}}if(3709==i){if(Td>>>0<t[D+16>>2]>>>0){O()}else{t[Td>>2]=cc;t[h+(c+6)]=Sc;t[h+(c+3)]=cc;t[h+(c+2)]=cc;break}}var hf=Sc+8|0,jf=t[hf>>2],Ag=t[D+16>>2];Sc>>>0<Ag>>>0&&O();jf>>>0<Ag>>>0?O():(t[jf+12>>2]=cc,t[hf>>2]=cc,t[h+(c+2)]=jf,t[h+(c+3)]=Sc,t[h+(c+6)]=0)}}}}while(0);return Eb=ob+8|0}uJ.X=1;function BJ(){var b;0==(t[zc>>2]|0)&&wJ();b=t[D+24>>2];if(0!=(b|0)){var d=t[D+12>>2];if(40<d>>>0){var c=t[zc+8>>2],e=(Math.floor(((d-41+c|0)>>>0)/(c>>>0))-1)*c|0,f=xJ(b);if(0==(t[f+12>>2]&8|0)&&(d=$B(0),b=(f+4|0)>>2,(d|0)==(t[f>>2]+t[b]|0)&&(e=$B(-(2147483646<e>>>0?-2147483648-c|0:e)|0),c=$B(0),-1!=(e|0)&c>>>0<d>>>0&&(e=d-c|0,(d|0)!=(c|0))))){t[b]=t[b]-e|0;t[D+432>>2]=t[D+432>>2]-e|0;yJ(t[D+24>>2],t[D+12>>2]-e|0);return}}t[D+12>>2]>>>0>t[D+28>>2]>>>0&&(t[D+28>>2]=-1)}}BJ.X=1;function vB(b){var d,c,e,f,g,h,i,m=b>>2,n;if(0!=(b|0)){var q=b-8|0,p=t[D+16>>2];q>>>0<p>>>0&&O();var s=t[b-4>>2],r=s&3;1==(r|0)&&O();var u=s&-8;i=u>>2;var v=b+(u-8)|0,w=0==(s&1|0);a:do{if(w){var C=t[q>>2];if(0==(r|0)){return}var A=-8-C|0;h=A>>2;var I=b+A|0,M=I,B=C+u|0;I>>>0<p>>>0&&O();if((M|0)==(t[D+20>>2]|0)){g=(b+(u-4)|0)>>2;if(3!=(t[g]&3|0)){var G=M;f=G>>2;var Z=B;break}t[D+8>>2]=B;t[g]&=-2;t[h+(m+1)]=B|1;t[v>>2]=B;return}var X=C>>>3;if(256>C>>>0){var ga=t[h+(m+2)],ra=t[h+(m+3)];if((ga|0)==(ra|0)){t[D>>2]&=1<<X^-1;G=M;f=G>>2;Z=B;break}var ka=((C>>>2&1073741822)<<2)+D+40|0;(ga|0)!=(ka|0)&ga>>>0<p>>>0&&O();if((ra|0)==(ka|0)|ra>>>0>=p>>>0){t[ga+12>>2]=ra;t[ra+8>>2]=ga;G=M;f=G>>2;Z=B;break}else{O()}}var ia=I,ea=t[h+(m+6)],wb=t[h+(m+3)],sb=(wb|0)==(ia|0);b:do{if(sb){var Db=A+(b+20)|0,Za=t[Db>>2];do{if(0==(Za|0)){var kc=A+(b+16)|0,$c=t[kc>>2];if(0==($c|0)){var Ia=0;e=Ia>>2;break b}else{var Eb=kc,Pb=$c}}else{Eb=Db,Pb=Za}}while(0);for(;;){var He=Pb+20|0,Hd=t[He>>2];if(0!=(Hd|0)){Eb=He,Pb=Hd}else{var de=Pb+16|0,ee=t[de>>2];if(0==(ee|0)){break}else{Eb=de,Pb=ee}}}Eb>>>0<p>>>0?O():(t[Eb>>2]=0,Ia=Pb,e=Ia>>2)}else{var Id=t[h+(m+2)];Id>>>0<p>>>0?O():(t[Id+12>>2]=wb,t[wb+8>>2]=Id,Ia=wb,e=Ia>>2)}}while(0);if(0==(ea|0)){G=M,f=G>>2,Z=B}else{var Jd=A+(b+28)|0,uc=(t[Jd>>2]<<2)+D+304|0;do{if((ia|0)==(t[uc>>2]|0)){if(t[uc>>2]=Ia,0==(Ia|0)){t[D+4>>2]&=1<<t[Jd>>2]^-1;G=M;f=G>>2;Z=B;break a}}else{ea>>>0<t[D+16>>2]>>>0&&O();var Kd=ea+16|0;(t[Kd>>2]|0)==(ia|0)?t[Kd>>2]=Ia:t[ea+20>>2]=Ia;if(0==(Ia|0)){G=M;f=G>>2;Z=B;break a}}}while(0);Ia>>>0<t[D+16>>2]>>>0&&O();t[e+6]=ea;var Qb=t[h+(m+4)];0!=(Qb|0)&&(Qb>>>0<t[D+16>>2]>>>0?O():(t[e+4]=Qb,t[Qb+24>>2]=Ia));var Mc=t[h+(m+5)];0==(Mc|0)?(G=M,f=G>>2,Z=B):Mc>>>0<t[D+16>>2]>>>0?O():(t[e+5]=Mc,t[Mc+24>>2]=Ia,G=M,f=G>>2,Z=B)}}else{G=q,f=G>>2,Z=u}}while(0);var ad=G;c=ad>>2;ad>>>0<v>>>0||O();var bb=b+(u-4)|0,Qa=t[bb>>2];0==(Qa&1|0)&&O();do{if(0==(Qa&2|0)){if((v|0)==(t[D+24>>2]|0)){var Rb=t[D+12>>2]+Z|0;t[D+12>>2]=Rb;t[D+24>>2]=G;t[f+1]=Rb|1;(G|0)==(t[D+20>>2]|0)&&(t[D+20>>2]=0,t[D+8>>2]=0);if(Rb>>>0<=t[D+28>>2]>>>0){return}BJ();return}if((v|0)==(t[D+20>>2]|0)){var vc=t[D+8>>2]+Z|0;t[D+8>>2]=vc;t[D+20>>2]=G;t[f+1]=vc|1;t[(vc>>2)+c]=vc;return}var Sb=(Qa&-8)+Z|0,fe=Qa>>>3,vd=256>Qa>>>0;a:do{if(vd){var lc=t[m+i],Nc=t[((u|4)>>2)+m];if((lc|0)==(Nc|0)){t[D>>2]&=1<<fe^-1}else{var ge=((Qa>>>2&1073741822)<<2)+D+40|0;(lc|0)!=(ge|0)&&lc>>>0<t[D+16>>2]>>>0&&O();(Nc|0)!=(ge|0)&&Nc>>>0<t[D+16>>2]>>>0&&O();t[lc+12>>2]=Nc;t[Nc+8>>2]=lc}}else{var he=v,Tb=t[i+(m+4)],Ub=t[((u|4)>>2)+m],bd=(Ub|0)==(he|0);b:do{if(bd){var cd=u+(b+12)|0,ac=t[cd>>2];do{if(0==(ac|0)){var ie=u+(b+8)|0,Ld=t[ie>>2];if(0==(Ld|0)){var gb=0;d=gb>>2;break b}else{var dd=ie,Vb=Ld}}else{dd=cd,Vb=ac}}while(0);for(;;){var Sa=Vb+20|0,Oc=t[Sa>>2];if(0!=(Oc|0)){dd=Sa,Vb=Oc}else{var Pc=Vb+16|0,Md=t[Pc>>2];if(0==(Md|0)){break}else{dd=Pc,Vb=Md}}}dd>>>0<t[D+16>>2]>>>0?O():(t[dd>>2]=0,gb=Vb,d=gb>>2)}else{var ed=t[m+i];ed>>>0<t[D+16>>2]>>>0?O():(t[ed+12>>2]=Ub,t[Ub+8>>2]=ed,gb=Ub,d=gb>>2)}}while(0);if(0!=(Tb|0)){var je=u+(b+20)|0,ke=(t[je>>2]<<2)+D+304|0;do{if((he|0)==(t[ke>>2]|0)){if(t[ke>>2]=gb,0==(gb|0)){t[D+4>>2]&=1<<t[je>>2]^-1;break a}}else{Tb>>>0<t[D+16>>2]>>>0&&O();var wd=Tb+16|0;(t[wd>>2]|0)==(he|0)?t[wd>>2]=gb:t[Tb+20>>2]=gb;if(0==(gb|0)){break a}}}while(0);gb>>>0<t[D+16>>2]>>>0&&O();t[d+6]=Tb;var xd=t[i+(m+2)];0!=(xd|0)&&(xd>>>0<t[D+16>>2]>>>0?O():(t[d+4]=xd,t[xd+24>>2]=gb));var ob=t[i+(m+3)];0!=(ob|0)&&(ob>>>0<t[D+16>>2]>>>0?O():(t[d+5]=ob,t[ob+24>>2]=gb))}}}while(0);t[f+1]=Sb|1;t[(Sb>>2)+c]=Sb;if((G|0)!=(t[D+20>>2]|0)){var Fb=Sb}else{t[D+8>>2]=Sb;return}}else{t[bb>>2]=Qa&-2,t[f+1]=Z|1,Fb=t[(Z>>2)+c]=Z}}while(0);if(256>Fb>>>0){var fd=Fb>>>2&1073741822,le=(fd<<2)+D+40|0,gd=t[D>>2],yd=1<<(Fb>>>3);if(0==(gd&yd|0)){t[D>>2]=gd|yd;var Nd=le,Od=(fd+2<<2)+D+40|0}else{var wc=(fd+2<<2)+D+40|0,xc=t[wc>>2];xc>>>0<t[D+16>>2]>>>0?O():(Nd=xc,Od=wc)}t[Od>>2]=G;t[Nd+12>>2]=G;t[f+2]=Nd;t[f+3]=le}else{var hd=G,Pd=Fb>>>8;if(0==(Pd|0)){var bc=0}else{if(16777215<Fb>>>0){bc=31}else{var me=(Pd+1048320|0)>>>16&8,Qd=Pd<<me,ne=(Qd+520192|0)>>>16&4,cc=Qd<<ne,id=(cc+245760|0)>>>16&2,yb=14-(ne|me|id)+(cc<<id>>>15)|0,bc=Fb>>>((yb+7|0)>>>0)&1|yb<<1}}var Rd=(bc<<2)+D+304|0;t[f+7]=bc;t[f+5]=0;t[f+4]=0;var oe=t[D+4>>2],jd=1<<bc;do{if(0==(oe&jd|0)){t[D+4>>2]=oe|jd,t[Rd>>2]=hd,t[f+6]=Rd,t[f+3]=G,t[f+2]=G}else{for(var Qc=Fb<<(31==(bc|0)?0:25-(bc>>>1)|0),mc=t[Rd>>2];(t[mc+4>>2]&-8|0)!=(Fb|0);){var pe=(Qc>>>31<<2)+mc+16|0,Rc=t[pe>>2];if(0==(Rc|0)){n=3862;break}else{Qc<<=1,mc=Rc}}if(3862==n){if(pe>>>0<t[D+16>>2]>>>0){O()}else{t[pe>>2]=hd;t[f+6]=mc;t[f+3]=G;t[f+2]=G;break}}var kd=mc+8|0,nc=t[kd>>2],Sd=t[D+16>>2];mc>>>0<Sd>>>0&&O();nc>>>0<Sd>>>0?O():(t[nc+12>>2]=hd,t[kd>>2]=hd,t[f+2]=nc,t[f+3]=mc,t[f+6]=0)}}while(0);var Sc=t[D+32>>2]-1|0;t[D+32>>2]=Sc;if(0==(Sc|0)){for(var Td=D+452|0;;){var qe=t[Td>>2];if(0==(qe|0)){break}else{Td=qe+8|0}}t[D+32>>2]=-1}}}}vB.X=1;function xJ(b){var d,c,e=D+444|0;for(d=e>>2;;){var f=t[d];if(f>>>0<=b>>>0&&(f+t[d+1]|0)>>>0>b>>>0){var g=e;c=3904;break}d=t[d+2];if(0==(d|0)){g=0;c=3905;break}else{e=d,d=e>>2}}if(3904==c||3905==c){return g}}function yJ(b,d){var c=b+8|0,c=0==(c&7|0)?0:-c&7,e=d-c|0;t[D+24>>2]=b+c|0;t[D+12>>2]=e;t[c+(b+4)>>2]=e|1;t[d+(b+4)>>2]=40;t[D+28>>2]=t[zc+16>>2]}function TI(b,d){var c,e,f;if(4294967231<d>>>0){return t[GA>>2]=12,0}var g=b-8|0;e=(b-4|0)>>2;var h=t[e],i=h&-8,m=i-8|0,n=b+m|0;g>>>0<t[D+16>>2]>>>0&&O();var q=h&3;1!=(q|0)&-8<(m|0)||O();c=(b+(i-4)|0)>>2;0==(t[c]&1|0)&&O();m=11>d>>>0?16:d+11&-8;if(0==(q|0)){var p=0,s,h=t[g+4>>2]&-8;s=256>m>>>0?0:h>>>0>=(m+4|0)>>>0&&(h-m|0)>>>0<=t[zc+8>>2]<<1>>>0?g:0;f=3939}else{i>>>0<m>>>0?(n|0)==(t[D+24>>2]|0)&&(c=t[D+12>>2]+i|0,c>>>0>m>>>0&&(p=c-m|0,t[e]=m|h&1|2,t[b+(m-4)>>2]=p|1,t[D+24>>2]=b+(m-8)|0,t[D+12>>2]=p,p=0,s=g,f=3939)):(p=i-m|0,15<p>>>0?(t[e]=m|h&1|2,t[b+(m-4)>>2]=p|3,t[c]|=1,p=b+m|0):p=0,s=g,f=3939)}if(3939==f&&0!=(s|0)){return 0!=(p|0)&&vB(p),s+8|0}g=Xa(d);if(0==(g|0)){return 0}e=i-(0==(t[e]&3|0)?8:4)|0;hB(g,b,e>>>0<d>>>0?e:d);vB(b);return g}TI.X=1;function wJ(){if(0==(t[zc>>2]|0)){var b=ZB();0!=(b-1&b|0)&&O();t[zc+8>>2]=b;t[zc+4>>2]=b;t[zc+12>>2]=-1;t[zc+16>>2]=2097152;t[zc+20>>2]=0;t[D+440>>2]=0;b=Math.floor(Date.now()/1e3);t[zc>>2]=b&-16^1431655768}}function zJ(b,d,c){var e,f,g,h=d>>2,i=b>>2,m,n=b+8|0,n=0==(n&7|0)?0:-n&7;f=d+8|0;var q=0==(f&7|0)?0:-f&7;g=q>>2;var p=d+q|0,s=n+c|0;f=s>>2;var s=b+s|0,r=p-(b+n)-c|0;t[(n+4>>2)+i]=c|3;if((p|0)==(t[D+24>>2]|0)){return m=t[D+12>>2]+r|0,t[D+12>>2]=m,t[D+24>>2]=s,t[f+(i+1)]=m|1,b=b+(n|8)|0}if((p|0)==(t[D+20>>2]|0)){return m=t[D+8>>2]+r|0,t[D+8>>2]=m,t[D+20>>2]=s,t[f+(i+1)]=m|1,t[(m>>2)+i+f]=m,b=b+(n|8)|0}var u=t[g+(h+1)];if(1==(u&3|0)){var c=u&-8,v=u>>>3,w=256>u>>>0;a:do{if(w){var C=t[((q|8)>>2)+h],A=t[g+(h+3)];if((C|0)==(A|0)){t[D>>2]&=1<<v^-1}else{var I=((u>>>2&1073741822)<<2)+D+40|0;(C|0)!=(I|0)&&C>>>0<t[D+16>>2]>>>0&&O();(A|0)!=(I|0)&&A>>>0<t[D+16>>2]>>>0&&O();t[C+12>>2]=A;t[A+8>>2]=C}}else{var C=p,A=t[((q|24)>>2)+h],I=t[g+(h+3)],M=(I|0)==(C|0);b:do{if(M){var B=q|16,G=B+(d+4)|0,Z=t[G>>2];do{if(0==(Z|0)){var X=d+B|0,ga=t[X>>2];if(0==(ga|0)){var ra=0;e=ra>>2;break b}}else{X=G,ga=Z}}while(0);for(;;){if(B=ga+20|0,G=t[B>>2],0!=(G|0)){X=B,ga=G}else{if(B=ga+16|0,G=t[B>>2],0==(G|0)){break}else{X=B,ga=G}}}X>>>0<t[D+16>>2]>>>0?O():(t[X>>2]=0,ra=ga,e=ra>>2)}else{X=t[((q|8)>>2)+h],X>>>0<t[D+16>>2]>>>0?O():(t[X+12>>2]=I,t[I+8>>2]=X,ra=I,e=ra>>2)}}while(0);if(0!=(A|0)){I=q+(d+28)|0;M=(t[I>>2]<<2)+D+304|0;do{if((C|0)==(t[M>>2]|0)){if(t[M>>2]=ra,0==(ra|0)){t[D+4>>2]&=1<<t[I>>2]^-1;break a}}else{if(A>>>0<t[D+16>>2]>>>0&&O(),X=A+16|0,(t[X>>2]|0)==(C|0)?t[X>>2]=ra:t[A+20>>2]=ra,0==(ra|0)){break a}}}while(0);ra>>>0<t[D+16>>2]>>>0&&O();t[e+6]=A;C=q|16;A=t[(C>>2)+h];0!=(A|0)&&(A>>>0<t[D+16>>2]>>>0?O():(t[e+4]=A,t[A+24>>2]=ra));C=t[(C+4>>2)+h];0!=(C|0)&&(C>>>0<t[D+16>>2]>>>0?O():(t[e+5]=C,t[C+24>>2]=ra))}}}while(0);e=d+(c|q)|0;d=c+r|0}else{e=p,d=r}e=e+4|0;t[e>>2]&=-2;t[f+(i+1)]=d|1;t[(d>>2)+i+f]=d;if(256>d>>>0){var ka=d>>>2&1073741822;m=(ka<<2)+D+40|0;e=t[D>>2];d=1<<(d>>>3);if(0==(e&d|0)){t[D>>2]=e|d;var ia=m,ea=(ka+2<<2)+D+40|0}else{ka=(ka+2<<2)+D+40|0,d=t[ka>>2],d>>>0<t[D+16>>2]>>>0?O():(ia=d,ea=ka)}t[ea>>2]=s;t[ia+12>>2]=s;t[f+(i+2)]=ia;t[f+(i+3)]=m;return b=b+(n|8)|0}ea=d>>>8;0==(ea|0)?ea=0:16777215<d>>>0?ea=31:(ia=(ea+1048320|0)>>>16&8,e=ea<<ia,ea=(e+520192|0)>>>16&4,e<<=ea,h=(e+245760|0)>>>16&2,ia=14-(ea|ia|h)+(e<<h>>>15)|0,ea=d>>>((ia+7|0)>>>0)&1|ia<<1);ia=(ea<<2)+D+304|0;t[f+(i+7)]=ea;t[f+(i+5)]=0;t[f+(i+4)]=0;e=t[D+4>>2];h=1<<ea;if(0==(e&h|0)){return t[D+4>>2]=e|h,t[ia>>2]=s,t[f+(i+6)]=ia,t[f+(i+3)]=s,t[f+(i+2)]=s,b=b+(n|8)|0}ea=d<<(31==(ea|0)?0:25-(ea>>>1)|0);for(ia=t[ia>>2];(t[ia+4>>2]&-8|0)!=(d|0);){if(ka=(ea>>>31<<2)+ia+16|0,e=t[ka>>2],0==(e|0)){m=4026;break}else{ea<<=1,ia=e}}if(4026==m){return ka>>>0<t[D+16>>2]>>>0&&O(),t[ka>>2]=s,t[f+(i+6)]=ia,t[f+(i+3)]=s,t[f+(i+2)]=s,b=b+(n|8)|0}m=ia+8|0;ka=t[m>>2];ea=t[D+16>>2];ia>>>0<ea>>>0&&O();ka>>>0<ea>>>0&&O();t[ka+12>>2]=s;t[m>>2]=s;t[f+(i+2)]=ka;t[f+(i+3)]=ia;t[f+(i+6)]=0;return b=b+(n|8)|0}zJ.X=1;function AJ(b,d){var c,e,f,g=t[D+24>>2];e=g>>2;var h=xJ(g),i=t[h>>2];c=t[h+4>>2];var h=i+c|0,m=i+(c-39)|0,i=i+(c-47)+(0==(m&7|0)?0:-m&7)|0,i=i>>>0<(g+16|0)>>>0?g:i,m=i+8|0;c=m>>2;yJ(b,d-40|0);t[i+4>>2]=27;t[c]=t[D+444>>2];t[c+1]=t[D+448>>2];t[c+2]=t[D+452>>2];t[c+3]=t[D+456>>2];t[D+444>>2]=b;t[D+448>>2]=d;t[D+456>>2]=0;t[D+452>>2]=m;c=i+28|0;t[c>>2]=7;m=(i+32|0)>>>0<h>>>0;a:do{if(m){for(var n=c;;){var q=n+4|0;t[q>>2]=7;if((n+8|0)>>>0<h>>>0){n=q}else{break a}}}}while(0);if((i|0)!=(g|0)){if(h=i-g|0,i=h+(g+4)|0,t[i>>2]&=-2,t[e+1]=h|1,t[g+h>>2]=h,256>h>>>0){var p=h>>>2&1073741822;f=(p<<2)+D+40|0;i=t[D>>2];h=1<<(h>>>3);if(0==(i&h|0)){t[D>>2]=i|h;var s=f,r=(p+2<<2)+D+40|0}else{p=(p+2<<2)+D+40|0,h=t[p>>2],h>>>0<t[D+16>>2]>>>0?O():(s=h,r=p)}t[r>>2]=g;t[s+12>>2]=g;t[e+2]=s;t[e+3]=f}else{if(r=h>>>8,0==(r|0)?r=0:16777215<h>>>0?r=31:(s=(r+1048320|0)>>>16&8,i=r<<s,r=(i+520192|0)>>>16&4,i<<=r,c=(i+245760|0)>>>16&2,s=14-(r|s|c)+(i<<c>>>15)|0,r=h>>>((s+7|0)>>>0)&1|s<<1),s=(r<<2)+D+304|0,t[e+7]=r,t[e+5]=0,t[e+4]=0,i=t[D+4>>2],c=1<<r,0==(i&c|0)){t[D+4>>2]=i|c,t[s>>2]=g,t[e+6]=s,t[e+3]=g,t[e+2]=g}else{r=h<<(31==(r|0)?0:25-(r>>>1)|0);for(s=t[s>>2];(t[s+4>>2]&-8|0)!=(h|0);){if(p=(r>>>31<<2)+s+16|0,i=t[p>>2],0==(i|0)){f=4065;break}else{r<<=1,s=i}}4065==f?(p>>>0<t[D+16>>2]>>>0&&O(),t[p>>2]=g,t[e+6]=s,t[e+3]=g,t[e+2]=g):(f=s+8|0,p=t[f>>2],r=t[D+16>>2],s>>>0<r>>>0&&O(),p>>>0<r>>>0&&O(),t[p+12>>2]=g,t[f>>2]=g,t[e+2]=p,t[e+3]=s,t[e+6]=0)}}}}AJ.X=1;var fB=da;a.H=(function(b){function d(){for(var b=0;3>b;b++){e.push(0)}}var c=b.length+1,e=[y(lb("/bin/this.program"),"i8",x)];d();for(var f=0;f<c-1;f+=1){e.push(y(lb(b[f]),"i8",x)),d()}e.push(0);e=y(e,"i32",x);return _main(c,e,0)});ab=[0,0,(function(b){UI(b,Fr|0,Fo|0,mm|0,0)}),0,(function(b){t[Fy>>2]=b;for(var d=0;!(vC(t[Fx+(d<<3)>>2],b,t[Fx+(d<<3)+4>>2]),d=d+1|0,26==(d|0));){}}),0,(function(){var b,d=GI(hn|0);b=d>>2;t[b+3]=gy|0;t[b+5]=272;t[b+8]=1;return d}),0,JG,0,(function(b){t[Hy>>2]=b;for(b=0;!(vC(t[F+(b<<3)>>2],t[Hy>>2],t[F+(b<<3)+4>>2]),b=b+1|0,73==(b|0));){}}),0,CG,0,(function(b){t[Ty>>2]=b;t[Gc+132>>2]=1;t[Gc+144>>2]=1;t[Gc+148>>2]=1;t[Gc+152>>2]=1;t[Gc+168>>2]=1;t[Gc+172>>2]=1;t[Gc+180>>2]=1;t[Gc+184>>2]=1;t[Gc+188>>2]=1;t[Gc+232>>2]=1;t[Gc+240>>2]=1;t[Gc+244>>2]=1;t[Gc+248>>2]=1;t[Gc+252>>2]=1;t[Gc+256>>2]=1;t[Gc+376>>2]=1;t[Gc+504>>2]=1;t[Gc+496>>2]=1;for(b=0;!(vC(t[sy+(b<<3)>>2],t[Ty>>2],t[sy+(b<<3)+4>>2]),b=b+1|0,42==(b|0));){}}),0,(function(b,d){0==(d|0)?(t[z>>2]=260,t[rd>>2]=16):26==(d|0)?(iG(t[t[Mb>>2]+8>>2],7),S(t[Mb>>2]),t[rd>>2]=16,t[z>>2]=250,hG(0,26)):22==(d|0)?V(t[Mb>>2],t[b+8>>2]):34==(d|0)?t[z>>2]=150:5==(d|0)?t[z>>2]=62:3==(d|0)?t[z>>2]=174:4==(d|0)?t[z>>2]=124:28==(d|0)?(t[rd>>2]=16,t[z>>2]=250,hG(0,28)):1==(d|0)&&(t[z>>2]=198,t[rd>>2]=16)}),0,(function(b,d){31==(d|0)?(nG(b,7),l[Kb]=1,t[Ib>>2]=43,t[rd>>2]=18,t[z>>2]=208):37==(d|0)&&(zG(),t[z>>2]=122)}),0,(function(b,d){8==(d|0)||29==(d|0)?(t[z>>2]=114,t[Ib>>2]=3,t[rd>>2]=20):14==(d|0)?oG(0,14):13==(d|0)||27==(d|0)?t[z>>2]=188:19==(d|0)?(S(t[Ec>>2]),BG(0,2,12,0),l[yc]=0,t[z>>2]=122):25==(d|0)?(t[z>>2]=20,BG(1,4,160,b)):10==(d|0)?t[z>>2]=160:(t[z>>2]=12,CG(0,d))}),0,(function(){var b=j;j+=8;var d=P(),c=P();t[rc>>2]=c;c=P();t[Mb>>2]=c;c=P();t[Wc>>2]=c;c=P();t[ec>>2]=c;c=b|0;t[c>>2]=P();t[b+4>>2]=eC();t[z>>2]=16;var e=cG(b),f=38==(e|0);a:do{if(!f){for(var g=e;;){if(ab[t[z>>2]](t[c>>2],g),g=cG(b),38==(g|0)){break a}}}}while(0);Q(d);Q(t[rc>>2]);Q(t[Mb>>2]);Q(t[Wc>>2]);Q(t[ec>>2]);t[rc>>2]=0;t[Mb>>2]=0;t[ec>>2]=0;t[Wc>>2]=0;j=b}),0,(function(b,d){34==(d|0)?(t[z>>2]=114,t[Ib>>2]=35,t[rd>>2]=24):31==(d|0)&&(nG(b,0),V(t[Ec>>2],t[b+8>>2]),t[z>>2]=104,t[Ib>>2]=40,t[rd>>2]=268)}),0,jG,0,(function(){var b,d=GI(Vl|0);b=d>>2;t[b+1]=Az|0;t[b+2]=4;t[b+3]=zz|0;t[b+6]=286;return d}),0,(function(){var b,d=GI(yh|0);b=d>>2;t[b+1]=Xx|0;t[b+2]=1;t[b+3]=Wx|0;t[b+6]=190;return d}),0,(function(){var b,d=GI(xq|0);b=d>>2;t[b+3]=$y|0;t[b+5]=164;t[b+8]=1;return d}),0,(function(){var b,d=GI(nu|0);b=d>>2;t[b+3]=Xy|0;t[b+1]=Vy|0;t[b+2]=5;t[b+6]=202;t[b+5]=288;return d}),0,(function(b){t[Qy>>2]=b;uC(b,1)}),0,rJ,0,(function(){var b,d=GI(ei|0);b=d>>2;t[b+1]=iz|0;t[b+2]=14;t[b+3]=hz|0;t[b+7]=162;t[b+5]=216;return d}),0,(function(){var b,d=GI(uu|0);b=d>>2;t[b+1]=Jz|0;t[b+2]=13;t[b+3]=Iz|0;t[b+7]=142;t[b+5]=254;return d}),0,(function(b){t[Gy>>2]=b;uC(b,4)}),0,(function(b,d){26==(d|0)?(t[z>>2]=48,t[rd>>2]=46,t[Ib>>2]=27):32==(d|0)?(iG(t[t[Mb>>2]+8>>2],8),S(t[Mb>>2])):22==(d|0)&&V(t[Mb>>2],t[b+8>>2])}),0,(function(b,d){(t[Ib>>2]|0)==(d|0)&&(t[z>>2]=t[rd>>2])}),0,(function(){var b;b=2;for(var d={},c={2:(function(c){b=5;f=c}),g:0};;){try{switch(b){case 2:var e=qH(),f=(k=Da++,d[k]=1,Ea[k]=b,t[xz>>2]=k,0);b=5;break;case 5:b=0==(f|0)?3:4;break;case 3:for(var g=e,h=g|0,i=g+4|0;!($(g),1==(t[h>>2]|0)?sH(g):uH(g),5==(t[i>>2]|0));){}b=3;break;case 4:rH(e);return;default:ua(0,"bad label: "+b)}}catch(m){(!m.f||!(m.id in d))&&aa(m),c[Ea[m.id]](m.value)}}}),0,(function(){var b,d=GI(zh|0);b=d>>2;t[b+1]=ay|0;t[b+2]=2;t[b+3]=$x|0;t[b+6]=224;return d}),0,(function(){var b,d=GI(um|0);b=d>>2;t[b+1]=Nx|0;t[b+2]=3;t[b+3]=Mx|0;t[b+6]=94;return d}),0,(function(){var b,d=GI(bl|0);b=d>>2;t[b+1]=iy|0;t[b+2]=6;t[b+3]=hy|0;t[b+6]=8;return d}),0,(function(){var b,d=GI(Op|0);b=d>>2;t[b+3]=jy|0;t[b+1]=ky|0;t[b+2]=2;t[b+6]=232;return d}),0,(function(b){UI(b,ls|0,Fo|0,Jm|0,0);UI(b,Bk|0,Fo|0,Pi|0,0)}),0,(function(b,d){if(22==(d|0)){var c=b+8|0;aG(t[c>>2],2);iG(t[c>>2],2)}t[z>>2]=74}),0,(function(b){t[Ry>>2]=b;uC(b,0)}),0,(function(b,d){return 0==(qA(b,t[d+8>>2])|0)&1}),0,(function(b,d){31==(d|0)&&(nG(b,2),V(t[Dc>>2],t[b+8>>2]),t[Ib>>2]=40,t[rd>>2]=280,t[z>>2]=104)}),0,nC,0,(function(){var b,d=GI(cr|0);b=d>>2;t[b+1]=nz|0;t[b+2]=5;t[b+3]=mz|0;t[b+6]=276;return d}),0,(function(b,d){24==(d|0)?(t[z>>2]=284,t[Ac>>2]=4):9==(d|0)?t[z>>2]=46:25==(d|0)?(t[z>>2]=284,t[Ac>>2]=3):10==(d|0)?(bG(),t[z>>2]=16):28==(d|0)&&(t[z>>2]=256)}),0,(function(){var b,d=GI(jm|0);b=d>>2;t[b+3]=Pz|0;t[b+5]=78;t[b+8]=1;return d}),0,(function(b){UI(b,ek|0,Fo|0,bh|0,Ti|0);UI(b,Oe|0,Fo|0,hx|0,Ti|0);UI(b,uw|0,Fo|0,Kv|0,Ti|0);UI(b,mv|0,Fo|0,Pu|0,Ti|0);UI(b,pu|0,Fo|0,Rt|0,Ti|0);UI(b,rt|0,Fo|0,Ps|0,Ti|0)}),0,(function(){var b,d=GI(ut|0);b=d>>2;t[b+1]=Zy|0;t[b+2]=8;t[b+3]=Yy|0;t[b+7]=142;t[b+5]=266;return d}),0,(function(){}),0,(function(){var b=j;j+=8;for(var d=P(),c=0;;){var e=P();t[Yb+(c<<4)+12>>2]=e;c=c+1|0;if(256==(c|0)){break}}t[Xb>>2]=0;mG();c=P();t[Nb>>2]=c;c=P();t[Dc>>2]=c;c=P();t[Ec>>2]=c;c=P();t[Jb>>2]=c;V(c,fr|0);c=b|0;t[c>>2]=P();t[b+4>>2]=eC();t[z>>2]=122;var e=rG(b),f=48==(e|0);a:do{if(!f){for(var g=e;;){if(ab[t[z>>2]](t[c>>2],g),g=rG(b),48==(g|0)){break a}}}}while(0);Q(d);Q(t[Jb>>2]);Q(t[Nb>>2]);Q(t[Dc>>2]);Q(t[Ec>>2]);for(d=0;!(Q(t[Yb+(d<<4)+12>>2]),d=d+1|0,256==(d|0));){}j=b}),0,(function(b,d){38==(d|0)?(t[rd>>2]=86,t[z>>2]=228):32==(d|0)?(t[rd>>2]=86,t[Ib>>2]=33,t[z>>2]=114):31==(d|0)?(nG(b,4),BG(0,0,122,b),l[yc]=1,t[Ib>>2]=40,t[rd>>2]=168,t[z>>2]=154):oG(0,d)}),0,(function(b,d){32==(d|0)||18==(d|0)||28==(d|0)||21==(d|0)||(31==(d|0)?(nG(b,1),BG(0,5,122,b),t[z>>2]=110):6==(d|0)?zG():t[z>>2]=122)}),0,(function(){var b,d=GI($t|0);b=d>>2;t[b+1]=zy|0;t[b+2]=1;t[b+3]=yy|0;t[b+6]=140;return d}),0,(function(b){t[Ey>>2]=b;for(var d=0;!(vC(t[E+(d<<3)>>2],b,t[E+(d<<3)+4>>2]),d=d+1|0,95==(d|0));){}}),0,VH,0,(function(){var b,d=GI(ep|0);b=d>>2;t[b+1]=Sx|0;t[b+2]=7;t[b+3]=Rx|0;t[b+6]=158;return d}),0,(function(){var b,d=GI(vs|0);b=d>>2;t[b+1]=Xz|0;t[b+2]=4;t[b+3]=Wz|0;t[b+6]=148;return d}),0,(function(b){t[Uy>>2]=b;for(b=0;!(vC(t[sc+(b<<3)>>2],t[Uy>>2],t[sc+(b<<3)+4>>2]),b=b+1|0,21==(b|0));){}}),0,dC,0,FG,0,(function(){var b,d=GI(Xh|0);b=d>>2;t[b+1]=By|0;t[b+2]=1;t[b+3]=Ay|0;t[b+6]=180;return d}),0,(function(){var b;b=2;for(var d={},c={2:(function(c){b=12;h=c}),g:0};;){try{switch(b){case 2:var e,f,g=P();e=1;f=0;var h=(k=Da++,d[k]=1,Ea[k]=b,t[vz>>2]=k,0);b=12;break;case 12:b=0==(h|0)?3:11;break;case 3:b=-1==(f|0)?11:4;break;case 4:var i=f=iI();b=32==(i|0)||9==(i|0)?5:59==(i|0)||10==(i|0)?6:7;break;case 5:b=-1==(f|0)?11:4;break;case 6:e=1;b=5;break;case 7:b=0==(e|0)?10:8;break;case 8:b=0==(gI(g,f)|0)?10:9;break;case 9:a:{var i=g,m=ba,n=i+8|0,q=mC(t[n>>2],t[Fy>>2]);if(0==(q|0)){m=1967}else{if(-1==(q|0)){break a}}do{if(1967==m&&96==l[t[n>>2]]<<24>>24){gI(i,jI(iI()));for(jC(i,Ex|0,0);10!=(iI()|0);){}fI(10);break a}}while(0);var p=jI(iI()),s=40==(p|0)?kI(40,41):p,r=jI(s),u=91==(r|0)?kI(91,93):r,v=jI(u);if(35==(v|0)){var w=iI(),C=40!=(w|0)?w:kI(40,41)}else{C=v}var A=jI(C);if(0!=(hI(A)|0)){var i=q,n=A,m=ba,I=P();b:for(;;){if(0==(hI(n)|0)){var M=n,m=2007;break}gI(I,n);jC(I,Ex|0,i);var B=jI(iI()),G=91==(B|0)?kI(91,93):B,Z=jI(G),X=61==(Z|0);c:do{if(X){if(123==(jI(iI())|0)){m=2001;break b}for(;;){var ga=iI();if(59==(ga|0)||44==(ga|0)){var ra=ga;break c}}}else{ra=Z}}while(0);if(44!=(ra|0)){M=ra;m=2008;break}n=jI(iI())}2001==m?(kI(123,125),M=123,Q(I),fI(M)):2007==m?(Q(I),fI(M)):2008==m&&(Q(I),fI(M))}}b=10;break;case 10:e=0;b=5;break;case 11:Q(g);return;default:ua(0,"bad label: "+b)}}catch(ka){(!ka.f||!(ka.id in d))&&aa(ka),c[Ea[ka.id]](ka.value)}}}),0,yG,0,(function(){var b,d=GI(Mv|0);b=d>>2;t[b+1]=Cz|0;t[b+2]=3;t[b+3]=Bz|0;t[b+6]=130;t[b+5]=176;return d}),0,(function(b,d){(t[Ib>>2]|0)==(d|0)?t[z>>2]=t[rd>>2]:6==(d|0)&&(zG(),t[z>>2]=122)}),0,(function(b){t[My>>2]=b;vC(Gi|0,b,0);vC(Yv|0,b,1);vC(El|0,b,2);vC(wf|0,b,3);vC(Wj|0,b,4);vC(Mg|0,b,5);vC(uq|0,b,6);vC(cq|0,b,7);vC(ys|0,b,8);vC(kw|0,b,9)}),0,(function(){var b;b=2;for(var d={},c={2:(function(c){b=5;h=c}),g:0};;){try{switch(b){case 2:var e=cE(),f=bH();t[Rz>>2]=f;var g=bH();t[fz>>2]=g;var h=(k=Da++,d[k]=1,Ea[k]=b,t[sz>>2]=k,0);b=5;break;case 5:b=0==(h|0)?3:4;break;case 3:var i=e,m=ba,m=(i|0)>>2,n=i+4|0;a:for(;;){Y(i);var q=t[m];if(22==(q|0)){Y(i);if(24==(t[m]|0)){for(Y(i);;){var p=24==(t[m]|0);Y(i);if(p){continue a}}}if(-1==(t[n>>2]|0)&&(Y(i),23!=(t[m]|0))){for(;;){if(Y(i),23==(t[m]|0)){continue a}}}}else{19==(q|0)?eE(i):fE(i)}};case 4:fH(t[Rz>>2]);fH(t[fz>>2]);t[Rz>>2]=0;t[fz>>2]=0;dE(e);return;default:ua(0,"bad label: "+b)}}catch(s){(!s.f||!(s.id in d))&&aa(s),c[Ea[s.id]](s.value)}}}),0,oC,0,oG,0,(function(b,d){if(22==(d|0)){var c=b+8|0;iG(t[c>>2],0);aG(t[c>>2],0)}t[z>>2]=74}),0,LG,0,(function(b,d){31==(d|0)?nG(b,8):oG(0,d);t[z>>2]=122}),0,(function(){var b;b=2;for(var d={},c={2:(function(c){b=5;f=c}),g:0};;){try{switch(b){case 2:var e=ED(),f=(k=Da++,d[k]=1,Ea[k]=b,t[tz>>2]=k,0);b=5;break;case 5:b=0==(f|0)?3:4;break;case 3:FD(e,7);var g=e,h=ba;GD(g);var i=g|0,m=t[i>>2];if(11==(m|0)){var n=g,q=j;j+=80;var p=n+12|0;0!=(t[Cz>>2]|0)&&(sC(q,t[t[p>>2]+8>>2]),t[q+36>>2]=t[Cz+8>>2],l[q+40|0]=t[Cz+4>>2]&255,tC(q));V(t[n+16>>2],t[t[p>>2]+8>>2]);j=q;GD(g);h=1608}else{var s=m}for(;;){1608==h&&(s=t[i>>2]);if(15==(s|0)){ID(g)}else{if(12==(s|0)){var r=t[g+4>>2];if(31==(r|0)){if(n=g,p=q=ba,GD(n),q=(n|0)>>2,11==(t[q]|0)){for(var u=n+4|0;;){JD(n);var v=t[q];if(12==(v|0)){var w=t[u>>2];if(45==(w|0)){for(var C=n,A=C|0,I=C+4|0;!(GD(C),0!=(LD(C)|0)&&(GD(C),3==(t[I>>2]|0)&&(GD(C),0!=(LD(C)|0)&&(MD(C),GD(C)))),7!=(t[A>>2]|0));){}p=1635}else{if(18==(w|0)){GD(n)}else{if(21==(w|0)||55==(w|0)||44==(w|0)||50==(w|0)){p=1635}}}1635==p&&(p=0,FD(n,18),GD(n));var M=t[q]}else{M=v}if(20==(M|0)){GD(n);var B=t[q]}else{B=M}if(11!=(B|0)){break}}}}else{if(24==(r|0)){for(var n=g,q=ba,q=(n+4|0)>>2,G=t[q];;){if(24==(G|0)){p=n;u=ba;u=(p+8|0)>>2;t[u]=1;GD(p);C=p|0;if(14==(t[C>>2]|0)){t[u]=0;for(A=14;;){if(11==(A|0)){var Z;if(11!=(t[p>>2]|0)){var X=0,ga=X&1}else{X=0==(sA(t[t[p+12>>2]+8>>2],qu|0,Aa)|0),ga=X&1}Z=ga;t[u]|=0==(Z|0)&1}else{if(3==(A|0)){break}}GD(p);A=t[C>>2]}GD(p)}var ra=t[q]}else{ra=G}!(24==(ra|0)||33==(ra|0)||29==(ra|0))&&0==(KD(n)|0)&&GD(n);var ka=t[q];if(18==(ka|0)||33==(ka|0)||29==(ka|0)){break}else{G=ka}}}else{GD(g)}}}else{GD(g)}}if(18==(t[g+4>>2]|0)){break}else{h=1608}}b=3;break;case 4:HD(e);return;default:ua(0,"bad label: "+b)}}catch(ia){(!ia.f||!(ia.id in d))&&aa(ia),c[Ea[ia.id]](ia.value)}}}),0,(function(){for(;0!=(eC()|0);){}}),0,qJ,0,(function(){var b,d=GI(Cu|0);b=d>>2;t[b+1]=dz|0;t[b+2]=5;t[b+3]=cz|0;t[b+6]=230;t[b+5]=116;return d}),0,(function(){var b,d=GI(iq|0);b=d>>2;t[b+1]=uy|0;t[b+2]=13;t[b+3]=ty|0;t[b+6]=22;t[b+5]=100;return d}),0,(function(){var b=P(),d=eC();if(0!=(d|0)){for(;;){for(var c=ba,e=d;;){var f=e+1|0;if(0==(L(l[e]&255)|0)){break}else{e=f}}e=l[e];if(45==e<<24>>24){if(45==l[f]<<24>>24){var g=0}else{c=3733}}else{0==e<<24>>24?g=0:c=3733}3733==c&&(g=1);0!=(g|0)&&(c=tA(d,Cf|0),0!=(c|0)&&(e=mA(d,61),0==(e|0)?(d=c+9|0,TF(d,mA(d,40),b)):TF(d,e,b)));d=eC();if(0==(d|0)){break}}}Q(b)}),0,(function(b){var d=j,c;c=2;for(var e={},f={2:(function(b){c=7;n=b}),g:0};;){try{switch(c){case 2:var g=(t[Py>>2]|0)==(t[K+56>>2]|0)&1;t[Vz>>2]=1<b>>>0&1;t[Lz>>2]=0;t[Lz+4>>2]=0;t[Lz+8>>2]=0;t[Lz+12>>2]=g;t[Lz+16>>2]=0;t[Lz+20>>2]=1;t[Lz+28>>2]=0;t[Lz+32>>2]=0;t[Lz+36>>2]=0;t[Lz+40>>2]=0;t[Lz+44>>2]=0;var h=t[Lz+24>>2];if(0==(h|0)){var i=P();t[Lz+24>>2]=i}else{S(h)}var m=P();t[Vx>>2]=m;var n=(k=Da++,e[k]=1,Ea[k]=c,t[yz>>2]=k,0);c=7;break;case 7:c=0==(n|0)?3:4;break;case 3:yC(0,0);var q=0;c=6;break;case 4:if(0!=(t[Fz>>2]|0)){for(;!(wC(),0==(t[Fz>>2]|0));){}}3==(n|0)&1==(b|0)?c=5:(q=0,c=6);break;case 5:var p=t[(t[K+40>>2]+8|0)>>2];KC(ku|0,(k=j,j+=4,t[k>>2]=p,k));q=1;c=6;break;case 6:Q(t[Vx>>2]);var s=t[Lz+24>>2];0!=(s|0)&&(Q(s),t[Lz+24>>2]=0);j=d;return q;default:ua(0,"bad label: "+c)}}catch(r){(!r.f||!(r.id in e))&&aa(r),f[Ea[r.id]](r.value)}}}),0,(function(b,d){if(31==(d|0)){l[md]||(l[md]=1,0==(t[ic>>2]|0)&&(t[z>>2]=110))}else{if(33==(d|0)){var c=t[ic>>2]-1|0;t[ic>>2]=c;0==(c|0)&&(t[z>>2]=110)}else{32==(d|0)&&(t[ic>>2]=t[ic>>2]+1|0)}}}),0,(function(){var b,d=GI(ej|0);b=d>>2;t[b+1]=fy|0;t[b+2]=5;t[b+3]=ey|0;t[b+6]=126;return d}),0,qC,0,(function(b,d){t[z>>2]=22!=(d|0)?304:0==(qA(t[b+8>>2],zr|0)|0)?298:304}),0,(function(){var b,d=GI(Pr|0);b=d>>2;t[b+1]=Hx|0;t[b+2]=13;t[b+3]=Gx|0;t[b+7]=142;t[b+5]=44;return d}),0,(function(b,d){(t[Ib>>2]|0)==(d|0)?t[z>>2]=t[rd>>2]:oG(0,d)}),0,(function(){var b=KI(t[t[K>>2]+8>>2]),d=0==(qA(b,eq|0)|0)?sd|0:0==(qA(b,wn|0)|0)?dc|0:Xc|0,c=eC();if(0!=(c|0)){for(;;){if(0!=(L(l[c]<<24>>24)|0)){c=c+1|0}else{do{if(0!=l[c]<<24>>24){for(var e=d;0!=(t[e>>2]|0);){var f;f=c;for(var g=e,h=ba,i=g|0,m=0,n=t[i>>2];m>>>0<tb(n)>>>0;){if(n=t[i>>2],(rA(l[f+m|0]<<24>>24)|0)==(l[n+m|0]<<24>>24|0)){m=m+1|0}else{var q=0,h=341;break}}if(341!=h){q=P();h=g+8|0;i=0<(t[h>>2]+1|0);b:do{if(i){for(var n=0,p=f+m|0;;){if(p=pC(p,q),n=n+1|0,(n|0)>=(t[h>>2]+1|0)){break b}}}}while(0);jC(q,Zz|0,t[g+4>>2]);Q(q);q=1}f=q;if(0==(f|0)){e=e+12|0}else{break}}if(0==(qA(b,eq|0)|0)){e=c,46==l[e]<<24>>24&&(f=P(),pC(e+1|0,f),jC(f,Zz|0,2),Q(f))}else{e=c;for(f=e+(tb(e)-1)|0;0!=(L(l[f]<<24>>24)|0);){f=f-1|0}58==l[f]<<24>>24&&(g=P(),gD(g,e,f-e|0),jC(g,Zz|0,2),Q(g))}}}while(0);c=eC();if(0==(c|0)){break}}}}}),0,lH,0,(function(b,d){34==(d|0)?t[Bc>>2]=t[Bc>>2]+1|0:12==(d|0)?GG():14==(d|0)?(GG(),oG(0,14)):45==(d|0)&&(EG(160),t[z>>2]=20)}),0,(function(b){var d=j,c;c=2;for(var e={},f={2:(function(b){c=7;i=b}),g:0};;){try{switch(c){case 2:var g=CE();t[my>>2]=g;var h=CE();t[gz>>2]=1<b>>>0&1;t[Nz>>2]=0;var i=(k=Da++,e[k]=1,Ea[k]=c,t[rz>>2]=k,0);c=7;break;case 7:c=1==(i|0)?6:3;break;case 3:c=2!=(i|0)|0!=(t[gz>>2]|0)?5:4;break;case 4:var m=t[(t[K+40>>2]+8|0)>>2];KC(Hg|0,(k=j,j+=4,t[k>>2]=m,k));var n=1;c=6;break;case 5:var q=h;JE(q);for(var p=q|0,s=q+4|0;;){if(11==(t[p>>2]|0)){JE(q)}else{var r=t[s>>2];if(23==(r|0)){XE(q,3)}else{if(57==(r|0)){XE(q,11)}else{if(3==(r|0)){var u=q,v=ba;JE(u);v=(u+4|0)>>2;11==(t[v]|0)&&(JE(u),3==(t[u>>2]|0)&&TE(u,0));WE(u);HE(u);KE(u);if(18!=(t[v]|0)){for(;!(HE(u),18==(t[v]|0));){}}SE(u);HE(u);EE()}else{if(45==(r|0)){XE(q,10)}else{if(18==(r|0)){HE(q)}else{if(34==(r|0)){u=q;v=ba;JE(u);3==(t[u>>2]|0)&&TE(u,8);WE(u);HE(u);KE(u);var w=u+4|0,C=t[w>>2];if(10==(C|0)){lF(u),v=2626}else{var A=C}for(;;){2626==v&&(A=t[w>>2]);if(18==(A|0)){break}HE(u);v=2626}SE(u);HE(u);EE()}else{0!=(FE(r)|0)?JE(q):0==(KE(q)|RE(q)|0)&&JE(q)}}}}}}}};case 6:var I=0==(t[lA>>2]|0);a:do{if(!I){for(;;){if(EE(),0==(t[lA>>2]|0)){break a}}}}while(0);var M=t[jA>>2];0!=(M|0)&&vB(M);t[jA>>2]=0;t[lA>>2]=0;t[kA>>2]=0;DE(h);DE(t[my>>2]);j=d;return n;default:ua(0,"bad label: "+c)}}catch(B){(!B.f||!(B.id in e))&&aa(B),f[Ea[B.id]](B.value)}}}),0,(function(b){UI(b,Nn|0,du|0,Ej|0,Ti|0);UI(b,Ig|0,Fo|0,ue|0,0)}),0,(function(b,d){var c=t[gc>>2];0!=(c|0)&&(t[rd>>2]=c,t[gc>>2]=0);32==(d|0)?(iG(t[t[Mb>>2]+8>>2],6),S(t[Mb>>2])):22==(d|0)?V(t[Mb>>2],t[b+8>>2]):28==(d|0)||26==(d|0)||30==(d|0)?(t[z>>2]=250,t[gc>>2]=t[rd>>2],t[rd>>2]=166,hG(0,d)):29==(d|0)&&(t[z>>2]=t[rd>>2])}),0,(function(b,d){if(31==(d|0)){var c=t[b+8>>2];0==(26>(l[c]-65&255)&1|0)?(t[z>>2]=154,t[rd>>2]=168,t[Ib>>2]=39):(V(t[Nb>>2],c),AG(Lb,t[t[Nb>>2]+8>>2],6),t[z>>2]=234)}else{36==(d|0)?t[z>>2]=18:0==(d|0)&&(t[z>>2]=86)}}),0,(function(){var b;b=2;for(var d={},c={2:(function(c){b=5;f=c}),g:0};;){try{switch(b){case 2:var e=lI(),f=(k=Da++,d[k]=1,Ea[k]=b,t[uz>>2]=k,0);b=5;break;case 5:b=0==(f|0)?3:4;break;case 3:for(var g=e,h=g+4|0;!(qI(g),nI(g,0),23==(t[h>>2]|0));){}b=3;break;case 4:mI(e);return;default:ua(0,"bad label: "+b)}}catch(i){(!i.f||!(i.id in d))&&aa(i),c[Ea[i.id]](i.value)}}}),0,(function(b,d){if(31==(d|0)){l[md]||(l[md]=1)}else{if(32==(d|0)){t[jc>>2]=t[jc>>2]+1|0}else{if(42==(d|0)){58==l[t[b+8>>2]]<<24>>24?(t[z>>2]=228,t[rd>>2]=110):0==(t[jc>>2]|0)&l[md]&&(t[z>>2]=110,yG(b,42))}else{if(33==(d|0)){var c=t[jc>>2]-1|0;t[jc>>2]=c;0==(c|0)&&(t[z>>2]=110)}else{0==(t[jc>>2]|0)&l[md]&&(t[z>>2]=110,yG(b,d))}}}}}),0,(function(b,d){if(22==(d|0)){var c=b+8|0;iG(t[c>>2],1);aG(t[c>>2],1)}t[z>>2]=26}),0,(function(b){t[Oy>>2]=b;for(b=0;!(vC(t[Dz+(b<<3)>>2],t[Oy>>2],t[Dz+(b<<3)+4>>2]),b=b+1|0,61==(b|0));){}}),0,(function(){var b,d=GI(Fn|0);b=d>>2;t[b+1]=aA|0;t[b+2]=1;t[b+3]=$z|0;t[b+6]=120;return d}),0,RF,0,(function(){var b,d=GI(ww|0);b=d>>2;t[b+3]=Kx|0;t[b+1]=Lx|0;t[b+2]=8;t[b+6]=246;t[b+5]=236;return d}),0,(function(){var b,d=GI(pv|0);b=d>>2;t[b+1]=Tz|0;t[b+2]=14;t[b+3]=Kz|0;t[b+7]=142;t[b+5]=36;return d}),0,(function(b,d){return 0==(sA(b,t[d+8>>2],Aa)|0)&1}),0,(function(b,d){32==(d|0)||21==(d|0)||(42==(d|0)?(BG(1,4,20,b),t[z>>2]=110):6==(d|0)?zG():41==(d|0)?(BG(1,3,20,b),t[z>>2]=110):31==(d|0)?(BG(1,3,20,b),t[z>>2]=110):t[z>>2]=12)}),0,jH,0,(function(b,d){if((t[Ib>>2]|0)==(d|0)){t[z>>2]=t[rd>>2]}else{if(((l[Zc]?29:0)|0)==(d|0)){t[z>>2]=t[Yc>>2]}}}),0,(function(b){UI(b,gp|0,Fo|0,Ek|0,Ti|0);UI(b,xh|0,Fo|0,ig|0,0)}),0,(function(){var b,d=GI(Fw|0);b=d>>2;t[b+1]=Tz|0;t[b+2]=14;t[b+3]=Sz|0;t[b+7]=142;t[b+5]=64;return d}),0,(function(b,d){if(22==(d|0)){if(l[fc]){l[fc]=0;bG();var c=t[rd>>2];t[z>>2]=c;ab[c](b,22)}else{c=b+8|0,iG(t[c>>2],10),aG(t[c>>2],10),l[fc]=1}}else{28==(d|0)?t[z>>2]=166:32==(d|0)&&(l[fc]&&bG(),c=t[rd>>2],t[z>>2]=c,ab[c](b,32))}}),0,(function(){var b,d=GI(ul|0);b=d>>2;t[b+1]=xy|0;t[b+2]=1;t[b+4]=vy|0;t[b+3]=wy|0;t[b+6]=270;return d}),0,(function(){var b;b=2;for(var d={},c={2:(function(c){b=5;h=c}),g:0};;){try{switch(b){case 2:var e=yF(),f=bH();t[Qz>>2]=f;var g=bH();t[ez>>2]=g;var h=(k=Da++,d[k]=1,Ea[k]=b,t[pz>>2]=k,0);b=5;break;case 5:b=0==(h|0)?3:4;break;case 3:for(var i=e,m=i|0,n=i+4|0;;){BF(i),6!=(t[m>>2]|0)?JF(i,0):0==(t[n>>2]|0)?AF(i):JF(i,0)};case 4:fH(t[Qz>>2]);fH(t[ez>>2]);t[Qz>>2]=0;t[ez>>2]=0;zF(e);return;default:ua(0,"bad label: "+b)}}catch(q){(!q.f||!(q.id in d))&&aa(q),c[Ea[q.id]](q.value)}}}),0,sJ,0,(function(){var b,d=GI(qw|0);b=d>>2;t[b+1]=Ax|0;t[b+2]=5;t[b+3]=zx|0;t[b+6]=210;return d}),0,(function(b,d){(t[Ib>>2]|0)==(d|0)?t[z>>2]=t[rd>>2]:((l[Kb]?37:0)|0)==(d|0)?t[z>>2]=122:oG(0,d)}),0,(function(){var b=xI();a:for(;;){for(var d=0==(b|0);;){if(d){break a}var c;c=b;var e=0==(N(c,Hr|0,4)|0)?1:0==(N(c,Go|0,4)|0)?1:0!=(N(c,om|0,3)|0)?1:yI(c);0!=(zI(c)|0)&&AI(c);0==(N(c,hk|0,2)|0)&&BI(c);0==(N(c,yi|0,3)|0)&&DI(c);0==(N(c,fh|0,3)|0)&&EI(c);c=e;if(0!=(c|0)){break}}b=xI()}}),0,(function(b){t[Sy>>2]=b;for(b=0;!(vC(t[gA+(b<<3)>>2],t[Sy>>2],t[gA+(b<<3)+4>>2]),b=b+1|0,16==(b|0));){}}),0,(function(){var b,d=GI(rr|0);b=d>>2;t[b+3]=Ez|0;t[b+5]=306;t[b+8]=1;return d}),0,(function(b){t[Ny>>2]=b;for(b=0;!(vC(t[J+(b<<3)>>2],t[Ny>>2],t[J+(b<<3)+4>>2]),b=b+1|0,68==(b|0));){}}),0,(function(){var b,d=GI($m|0);b=d>>2;t[b+3]=dy|0;t[b+5]=296;t[b+8]=1;return d}),0,(function(){var b,d=GI(vw|0);b=d>>2;t[b+1]=Ex|0;t[b+2]=8;t[b+3]=Dx|0;t[b+6]=108;t[b+5]=4;return d}),0,(function(){var b,d=GI(rs|0);b=d>>2;t[b+3]=Ux|0;t[b+5]=194;t[b+8]=1;return d}),0,hH,0,(function(){var b,d=GI(Jr|0);b=d>>2;t[b+1]=Cx|0;t[b+2]=11;t[b+3]=Bx|0;t[b+6]=170;t[b+5]=92;return d}),0,(function(){t[z>>2]=t[rd>>2]}),0,(function(){var b;b=2;for(var d={},c={2:(function(c){b=5;f=c}),g:0};;){try{switch(b){case 2:var e=qF(),f=(k=Da++,d[k]=1,Ea[k]=b,t[qz>>2]=k,0);b=5;break;case 5:b=0==(f|0)?3:4;break;case 3:for(var g=e,h=g|0,i=g+4|0;;){if(tF(g),2==(t[h>>2]|0)){var m=t[i>>2];if(4==(m|0)){sF(g,4)}else{if(5==(m|0)){var n=g,q=qF();tF(q);5==(t[q>>2]|0)&&wF(q);tF(n);wF(n);vF(n);7==(t[n>>2]|0)&&wF(n);uF(q,1);rF(q)}else{if(2==(m|0)){sF(g,2)}else{if(0==(m|0)){var p=qF();tF(p);uF(p,0);if(0==(t[Zb>>2]|0)&0!=(t[oy+4>>2]|0)){var s=P();t[Zb>>2]=s;V(s,t[t[p+8>>2]+8>>2])}rF(p)}else{3==(m|0)&&sF(g,3)}}}}}};case 4:rF(e);Q(t[Zb>>2]);t[Zb>>2]=0;return;default:ua(0,"bad label: "+b)}}catch(r){(!r.f||!(r.id in d))&&aa(r),c[Ea[r.id]](r.value)}}}),0,HG,0,(function(b,d){20==(d|0)?(tC(Lb),S(t[Nb>>2]),t[z>>2]=154,t[rd>>2]=168,t[Ib>>2]=39):42==(d|0)?(t[z>>2]=122,zG(),l[yc]=0):39==(d|0)?(tC(Lb),S(t[Nb>>2]),t[z>>2]=168):(tC(Lb),S(t[Nb>>2]),t[z>>2]=154,t[rd>>2]=168,t[Ib>>2]=39,zG(),oG(0,d))}),0,(function(b){t[Jy>>2]=b;vC(Nr|0,t[Jy>>2],0);vC(Mo|0,t[Jy>>2],1);vC(sm|0,t[Jy>>2],2);vC(mk|0,t[Jy>>2],3);vC(Ci|0,t[Jy>>2],4);vC(ih|0,t[Jy>>2],5);vC(Wf|0,t[Jy>>2],6);vC(Ue|0,t[Jy>>2],7)}),0,(function(b,d){if(28==(d|0)||32==(d|0)){var c=t[Wc>>2];0==(t[c>>2]|0)?iG(t[t[ec>>2]+8>>2],t[Ac>>2]):(iG(t[c+8>>2],t[Ac>>2]),S(t[Wc>>2]));t[z>>2]=26;jG(0,d);S(t[ec>>2])}else{33==(d|0)?(U(t[Wc>>2],t[t[ec>>2]+8>>2]),U(t[Wc>>2],Gq|0),S(t[ec>>2])):22==(d|0)?V(t[ec>>2],t[b+8>>2]):26==(d|0)&&(t[z>>2]=48,t[rd>>2]=238,t[Ib>>2]=27)}}),0,(function(){var b,d=GI(wx|0);b=d>>2;t[b+3]=hA|0;t[b+5]=60;t[b+8]=1;return d}),0,(function(){var b,d=GI(gg|0);b=d>>2;t[b+1]=fA|0;t[b+2]=4;t[b+3]=eA|0;t[b+4]=dA|0;t[b+6]=102;t[b+5]=212;return d}),0,(function(){var b,d=GI(mw|0);b=d>>2;t[b+3]=yx|0;t[b+5]=2;t[b+8]=1;return d}),0,(function(){var b;b=2;for(var d={},c={2:(function(c){b=5;f=c}),g:0};;){try{switch(b){case 2:var e=YH(),f=(k=Da++,d[k]=1,Ea[k]=b,t[wz>>2]=k,0);b=5;break;case 5:b=0==(f|0)?3:4;break;case 3:for(var g=e,h=g|0,i=g+4|0;;){if(aI(g),4==(t[h>>2]|0)){var m=t[i>>2];3==(m|0)?$H(g,3):4==(m|0)?$H(g,4):5==(m|0)?$H(g,5):1==(m|0)?$H(g,1):7==(m|0)?$H(g,7):0==(m|0)?$H(g,0):2==(m|0)?$H(g,2):6==(m|0)&&$H(g,6)}};case 4:ZH(e);return;default:ua(0,"bad label: "+b)}}catch(n){(!n.f||!(n.id in d))&&aa(n),c[Ea[n.id]](n.value)}}}),0,(function(b,d){6==(d|0)?zG():31==(d|0)?(nG(b,3),BG(0,3,122,b),l[yc]=1,t[z>>2]=110):42==(d|0)?(nG(b,5),BG(0,4,122,b),t[z>>2]=110):32==(d|0)||18==(d|0)||28==(d|0)||21==(d|0)||(t[z>>2]=122)}),0,hG,0,(function(){var b,d=GI(tp|0);b=d>>2;t[b+1]=cy|0;t[b+2]=6;t[b+3]=by|0;t[b+6]=278;return d}),0,(function(b){t[Py>>2]=b;uC(b,2)}),0,(function(b,d){22==(d|0)?V(t[Mb>>2],t[b+8>>2]):32==(d|0)?(iG(t[t[Mb>>2]+8>>2],6),S(t[Mb>>2])):30==(d|0)||26==(d|0)?(t[z>>2]=250,t[rd>>2]=256):29==(d|0)&&(t[z>>2]=74)}),0,(function(){var b,d=GI(Qq|0);b=d>>2;t[b+1]=cA|0;t[b+2]=5;t[b+3]=bA|0;t[b+6]=70;return d}),0,(function(b,d){2==(d|0)?(t[z>>2]=294,t[rd>>2]=260):32==(d|0)?(iG(t[t[Mb>>2]+8>>2],9),S(t[Mb>>2]),t[z>>2]=16):1==(d|0)?(t[z>>2]=198,t[rd>>2]=260):22==(d|0)&&V(t[Mb>>2],t[b+8>>2])}),0,(function(){var b,d=GI(Hw|0);b=d>>2;t[b+1]=Qx|0;t[b+2]=23;t[b+3]=Px|0;t[b+6]=50;t[b+5]=10;return d}),0,(function(){var b,d=GI(Wq|0);b=d>>2;t[b+3]=jz|0;t[b+1]=kz|0;t[b+2]=6;t[b+6]=118;t[b+5]=300;return d}),0,(function(b){t[Ly>>2]=b;uC(b,3)}),0,(function(b,d){var c=t[Ec>>2];19==(d|0)?BG(0,2,122,c):S(c);t[z>>2]=122}),0,UF,0,(function(b){UI(b,Zk|0,kj|0,Jh|0,0);UI(b,qg|0,Fo|0,Ud|0,0);UI(b,Ow|0,Fo|0,$v|0,0);UI(b,zv|0,kj|0,Ek|0,0);UI(b,Eu|0,du|0,Et|0,0);UI(b,dt|0,kj|0,Et|0,0);UI(b,Fs|0,du|0,ns|0,0);UI(b,Yr|0,yr|0,ns|0,0);UI(b,Yr|0,kj|0,ns|0,0)}),0,(function(b,d){var c=t[pc>>2];0!=(c|0)&&(t[rd>>2]=c,t[pc>>2]=0);29==(d|0)?(t[z>>2]=t[rd>>2],bG()):22==(d|0)&&(iG(t[b+8>>2],11),c=t[rd>>2],t[pc>>2]=c,t[Ib>>2]=23,l[Zc]=1,t[Yc>>2]=c,t[rd>>2]=274,t[z>>2]=192)}),0,$D,0,aH,0,(function(b,d){23==(d|0)||22==(d|0)?(BG(0,1,122,t[Dc>>2]),t[z>>2]=122):9==(d|0)?(t[z>>2]=104,t[Ib>>2]=45,t[rd>>2]=280):32==(d|0)?(t[z>>2]=104,t[rd>>2]=122,t[Ib>>2]=33,FG(0,32)):(S(t[Dc>>2]),t[z>>2]=122)}),0,(function(){for(var b=0;;){var d=eC();if(0==(d|0)){break}b=AD(d,b);if(10==(b|0)){break}}}),0,(function(b,d){if(22==(d|0)){V(t[ec>>2],t[b+8>>2])}else{if(28==(d|0)||32==(d|0)){var c=t[Wc>>2];0==(t[c>>2]|0)?iG(t[t[ec>>2]+8>>2],t[Ac>>2]):(iG(t[c+8>>2],t[Ac>>2]),S(t[Wc>>2]));t[z>>2]=74;jG(0,d);S(t[ec>>2])}else{33==(d|0)?(U(t[Wc>>2],t[t[ec>>2]+8>>2]),U(t[Wc>>2],Gq|0),S(t[ec>>2])):26==(d|0)&&(t[z>>2]=48,t[rd>>2]=284,t[Ib>>2]=27)}}}),0,(function(){var b=P(),d=eC();if(0!=(d|0)){for(;;){var c=l[d];if(45==c<<24>>24){for(var e=d+1|0,c=b,d=P(),f=t[d+8>>2],e=YD(e,d);0!=(L(l[e]&255)|0);){e=e+1|0}e=40==l[e]<<24>>24?e+1|0:e;0==(qA(f,Hh|0)|0)?ZD(e,3):0==(qA(f,zr|0)|0)?ZD(e,0):0==(qA(f,Uf|0)|0)&&(f=e,e=P(),YD(f,e),jC(e,Az|0,2),V(c,t[e+8>>2]),Q(e));Q(d)}else{if(!(37==c<<24>>24||34==c<<24>>24)&&0!=(pA(c&255)|0)){c=d;f=b;d=P();YD(c,d);var c=d,e=ba,g=j;j+=80;e=g>>2;0!=(t[Az+16>>2]|0)&&0!=(t[c>>2]|0)&&(sC(g,t[c+8>>2]),t[e+9]=t[Az+24>>2],l[g+40|0]=t[Az+20>>2]&255,0!=(f|0)&&0!=(t[f>>2]|0)&&(t[e+15]=Uf|0,t[e+16]=t[f+8>>2]),tC(g));j=g;Q(d)}}d=eC();if(0==(d|0)){break}}}Q(b)}),0,(function(b){t[Iy>>2]=b;for(b=0;!(vC(t[Wy+(b<<3)>>2],t[Iy>>2],t[Wy+(b<<3)+4>>2]),b=b+1|0,17==(b|0));){}}),0,(function(){var b,d=GI(Vv|0);b=d>>2;t[b+1]=Hz|0;t[b+2]=3;t[b+3]=Gz|0;t[b+6]=282;return d}),0,(function(){var b,d=GI(bq|0);b=d>>2;t[b+1]=ry|0;t[b+2]=9;t[b+3]=qy|0;t[b+6]=84;t[b+5]=14;return d}),0,(function(b,d){if(22==(d|0)){if(l[oc]){l[oc]=0;bG();var c=t[rd>>2];t[z>>2]=c;ab[c](b,22)}else{c=b+8|0,iG(t[c>>2],11),aG(t[c>>2],11),l[oc]=1}}else{28==(d|0)?(t[z>>2]=274,l[oc]=0):32==(d|0)&&(l[oc]&&bG(),c=t[rd>>2],t[z>>2]=c,ab[c](b,32))}}),0,(function(b){UI(b,Pk|0,Fo|0,Eh|0,0)}),0,(function(b,d){22==(d|0)&&iG(t[b+8>>2],12);t[z>>2]=304}),0,(function(b){t[Ky>>2]=b;for(b=0;!(vC(t[lz+(b<<3)>>2],t[Ky>>2],t[lz+(b<<3)+4>>2]),b=b+1|0,28==(b|0));){}}),0,(function(){var b,d=GI(nl|0);b=d>>2;t[b+1]=Zz|0;t[b+2]=6;t[b+3]=Yz|0;t[b+6]=156;return d}),0,(function(b,d){35==(d|0)?l[Jc]=1:36==(d|0)?l[Jc]?l[Jc]=0:t[z>>2]=16:l[Jc]=0}),0,(function(b){UI(b,vo|0,Fo|0,mm|0,0);UI(b,ni|0,Fo|0,Et|0,0)}),0];a.FUNCTION_TABLE=ab;function Hb(b){function d(){var c=0;Ab=ca;a._main&&(nb(qb),c=a.H(b),a.noExitRuntime||nb(rb));if(a.postRun){for("function"==typeof a.postRun&&(a.postRun=[a.postRun]);0<a.postRun.length;){a.postRun.pop()()}}return c}b=b||a.arguments;if(0<xb){return a.h("run() called, but dependencies remain, so not running"),0}if(a.preRun){"function"==typeof a.preRun&&(a.preRun=[a.preRun]);var c=a.preRun;a.preRun=[];for(var e=c.length-1;0<=e;e--){c[e]()}if(0<xb){return 0}}return a.setStatus?(a.setStatus("Running..."),setTimeout((function(){setTimeout((function(){a.setStatus("")}),1);d()}),1),0):d()}a.run=a.T=Hb;if(a.preInit){for("function"==typeof a.preInit&&(a.preInit=[a.preInit]);0<a.preInit.length;){a.preInit.pop()()}}nb(pb);var CJ=ca;a.noInitialRun&&(CJ=fa);CJ&&Hb()

Module = this.Module;

})();

define("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags.min",[], function(require, exports, module) {

	module.exports = Module;
	module.exports.CTags_parseTempFile = function(filename, contents) {
		filename = "file." + filename.match(/[^.]*$/)[0];
		this.FS_createDataFile("/", filename, contents, true, true);
		logged = "";
		this.CTags_parseFile("/" + filename);
	};
	var logged = "";
	module.exports.getLog = function() {
		return logged.replace(/\n$/, "");
	};
	Module.print = function() {
		arguments = Array.prototype.slice.call(arguments);
		logged += arguments.map(function(a) {
			return typeof a === "object" ? JSON.stringify(a) : a;
		}).join(" ") + "\n";
		console.log.apply(sysConsole, arguments)
	};
	Module.printErr = function() {
		arguments = Array.prototype.slice.call(arguments);
		logged += arguments.map(function(a) {
			return typeof a === "object" ? JSON.stringify(a) : a;
		}).join(" ") + "\n";
		console.err.apply(sysConsole, arguments)
	};

	
});
})();

define("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_ex",[], function(require, exports, module) {
var ctags = require("./ctags.min");

var util = require("./ctags_util");

var MAX_DOCHEAD_LENGTH = 80;

var CTAGS_OPTIONS = [
    '--langdef=js',
    '--langmap=js:.js',
    '--regex-js=/([A-Za-z0-9._$]+)[ \\t]*[:=][ \\t]*\\{/\\1/,object/',
    '--regex-js=/([A-Za-z0-9._$()]+)[ \\t]*[:=][ \\t]*function[ \\t]*\\(/\\1/,function/',
    '--regex-js=/function[ \\t]+([A-Za-z0-9._$]+)[ \\t]*\\(([^)])\\)/\\1/,function/',
    '--regex-js=/([A-Za-z0-9._$]+)[ \\t]*[:=][ \\t]*\\[/\\1/,array/',
    '--regex-js=/([^= ]+)[ \\t]*=[ \\t]*[^"]\'[^\']*/\\1/,string/',
    '--regex-js=/([^= ]+)[ \\t]*=[ \\t]*[^\']"[^"]*/\\1/,string/',
    
    '--langdef=rust',
    '--langmap=rust:.rs',
    '--regex-rust=/[ \\t]*fn[ \\t]+([a-zA-Z0-9_]+)/\\1/f,function/',
    '--regex-rust=/[ \\t]*type[ \\t]+([a-zA-Z0-9_]+)/\\1/T,types/',
    '--regex-rust=/[ \\t]*enum[ \\t]+([a-zA-Z0-9_]+)/\\1/T,types/',
    '--regex-rust=/[ \\t]*struct[ \\t]+([a-zA-Z0-9_]+)/\\1/m,types/',
    '--regex-rust=/[ \\t]*class[ \\t]+([a-zA-Z0-9_]+)/\\1/m,types/',
    '--regex-rust=/[ \\t]*mod[ \\t]+([a-zA-Z0-9_]+)/\\1/m,modules/',
    '--regex-rust=/[ \\t]*const[ \\t]+([a-zA-Z0-9_]+)/\\1/m,consts/',
    '--regex-rust=/[ \\t]*trait[ \\t]+([a-zA-Z0-9_]+)/\\1/m,traits/',
    '--regex-rust=/[ \\t]*impl[ \\t]+([a-zA-Z0-9_]+)/\\1/m,impls/',
    '--regex-rust=/[ \\t]*impl[ \\t]+of[ \\t]([a-zA-Z0-9_]+)/\\1/m,impls/',
    
    '--langmap=PHP:+.inc',
    '--PHP-kinds=+cf',
    '--regex-PHP=/abstract class ([^ ]*)/\\1/c/',
    '--regex-PHP=/interface ([^ ]*)/\\1/c/',
    '--regex-PHP=/(public |static |abstract |protected |private )+function ([^ (]*)/\\2/f/',

    '--regex-make=/-D([^ =]+).+$/\\1/d,definition/',
    
    '--langdef=markdown',
    '--langmap=markdown:.markdown',
    '--regex-markdown=/^#[ \\t]+(.*)/\\1/h,heading1/',
    '--regex-markdown=/^##[ \\t]+(.*)/\\1/h,heading2/',
    '--regex-markdown=/^###[ \\t]+(.*)/\\1/h,heading3/',
    
    '--langdef=ActionScript',
    '--langmap=ActionScript:.as',
    '--regex-ActionScript=/^[ \\t]*[(private|public|static)( \\t)]*function[ \\t]+([A-Za-z0-9_]+)[ \\t]*\\(/\\1/f,function/',
    '--regex-ActionScript=/^[ \\t]*[(public)( \\t)]*function[ \\t]+(set|get)[ \\t]+([A-Za-z0-9_]+)[ \\t]*\\(/\\2/p,property/',
    '--regex-ActionScript=/.*\\.prototype\\.([A-Za-z0-9 ]+)=([ \\t]?)function([ \\t]?)*\\(/\\1/f,function/',
];
var LANGUAGES = module.exports.LANGUAGES = [
    { guessFargs: true, extensions: ["as"], name: "actionscript" },
    { guessFargs: false, extensions: ["asm", "a"], name: "assembly_x86" },
    { guessFargs: true, extensions: ["sh"], name: "sh" },
    { guessFargs: true, extensions: ["js"], name: "javascript" },
    { guessFargs: true, extensions: ["html"], name: "html" },
    { guessFargs: true, extensions: ["coffee"], name: "coffee" },
    { guessFargs: true, extensions: ["bas"]},
    { guessFargs: true, extensions: ["asp"]},
    { guessFargs: true, extensions: ["cpp", "c", "cc", "cxx", "h", "hh", "hpp"], name: "c_cpp" },
    { guessFargs: true, extensions: ["cs"], name: "csharp" },
    { guessFargs: false, extensions: ["e", "ge"], extractDocs: false, name: "eiffel" },
    { guessFargs: true, extensions: ["erl", "hrl"], name: "erlang" },
    { guessFargs: false, extensions: ["f", "for", "ftn", "f77", "f90", "f95"]}, // Fortran
    { guessFargs: true, extensions: ["lisp", "cl", "lsp"]},
    { guessFargs: true, extensions: ["lua"], name: "lua" },
    { guessFargs: false, extensions: ["cob"], name: "cobol" },
    { guessFargs: true, extensions: ["pas", "p"], name: "pascal" },
    { guessFargs: true, extensions: ["scm", "sm", "scheme", "oak"], name: "scheme" },
    { guessFargs: true, extensions: ["pl", "pm"], name: "perl" },
    { guessFargs: false, extensions: ["prolog"], name: "prolog" },
    { guessFargs: false, extensions: ["ltx", "tex", "bib", "sty", "cls", "clo"], name: "latex" },
    { guessFargs: true, extensions: ["php", "php3", "phtml", "inc"], name: "php" },
    { guessFargs: true, extensions: ["py"], name: "python" },
    { guessFargs: false, extensions: ["y", "ym"]},
    { guessFargs: true, extensions: ["java"], name: "java" },
    { guessFargs: true, extensions: ["rb", "ru"], name: "ruby" },
    { guessFargs: true, extensions: ["ss"]}
];

module.exports.languages = LANGUAGES.map(function(l) { return l.name; }).filter(Boolean);
module.exports.extensions = [].concat.apply([], LANGUAGES.map(function(l) { return l.extensions; }));
util.init(module.exports);

module.exports.pathForLanguage = function(language, path) {
    var ext = path.match(/[^./]*$/)[0];
    LANGUAGES.some(function(r) {
        if (r.name == language) {
            if (r.extensions.indexOf(ext) == -1)
                path = "tmp." + r.extensions[0];
            return true;
        }
    });
    return path;
};

module.exports.analyze = function(path, doc, options, callback) {
    if (!doc)
        return callback("No contents");
    
    var lines;
    if (doc.getAllLines) {
        lines = doc.getAllLines();
        doc = doc.getValue();
    }
    else {
        if (doc.getValue)
            doc = doc.getValue();
        lines = doc.split(/\n/);
    }
    
    var result = {
        doc: doc ? util.extractDocumentationAtRow(lines, 0) : undefined,
        properties: {}
    };
    
    var isDone = false;
    var language = getLanguage(path);
    var guessFargs = language && language.guessFargs;
    ctags.CTags_setOnTagEntry(function(name, kind, row, sourceFile, language) {
        analyzeTag(lines, name, kind, row, sourceFile, guessFargs, result.properties);
    });
    
    ctags.CTags_setOnParsingCompleted(function() {
        isDone = true;
        callback(null, result);
    });
    
    var filename = path.match(/[^\/]*$/)[0];
    ctags.FS_createPath("/", "data", true, true);
    try {
        ctags.CTags_parseTempFile(filename, doc);
    } catch (err) {
        if (isDone)
            throw err;
        return callback("Internal error in CTags: " + err);
    }
    if (!isDone) {
        callback(ctags.getLog() || "ctags analysis failed");
        callback = function() {
            throw new Error("Callback called too late");
        };
    }
};

function getLanguage(path) {
    var ext = path.substr(path.lastIndexOf(".") + 1);
    return ext && LANGUAGES.filter(function(l) {
        return l.extensions.indexOf(ext) > -1;
    })[0];
}
    
function analyzeTag(lines, name, kind, row, sourceFile, guessFargs, results) {
    var line = lines[row - 1] || "";
    var doc = util.extractDocumentationAtRow(lines, row - 1);

    var docHead = line.length > MAX_DOCHEAD_LENGTH
        ? line.substr(MAX_DOCHEAD_LENGTH) + "..."
        : line;
    if (docHead.indexOf(name) === -1) // sanity check
        docHead = null;
    var icon = getIconForKind(kind);
    
    var result = {
        row: row - 1,
        doc: doc,
        docHead: docHead,
        kind: kind,
        icon: icon
    };
    if (icon === "method" || icon === "method2") {
        result.guessFargs = guessFargs;
        result.properties = {
            _return: []
        };
    }
    
    results["_" + name] = results["_" + name] || [];
    results["_" + name].push(result);
}

function getIconForKind(kind) {
    switch (kind) {
        case "member": 
            return "property";
        case "function":
            return "method";
        case "prototype":
            return "method2";
        case "class": case "module": case "typedef":
            return "package";
        default:
            return "property2";
    }
}

});

define("plugins/c9.ide.language.jsonalyzer/worker/handler_registry",[], function(require, exports, module) {

var assert = require("c9/assert");

module.exports.HandlerRegistry = function() {
    var handlers = [];
    var supportedLanguages = "";
    var supportedExtensions = "";
    
    return {
        registerHandler: function(handler, options) {
            options = options || {};
            var existing = handlers.filter(function(h) { return h.$source && handler.$source === h.$source; });
            if (existing.length || handlers.indexOf(handler) > -1)
                return;
            
            handler.sender = options.sender;
            if (handler.init)
                handler.init(options, function(err) {
                    if (err)
                        console.error("Error initializing " + handler.$source, err.stack || err);
                });
        
            var languages = handler.languages;
            var extensions = handler.extensions;
            handler.guidName = languages.join("");
            assert(languages && extensions, "Handlers must have a languages and extensions property");
            
            handler.supportedLanguages = "$.";
            handler.supportedExtensions = "$.";
            handlers.push(handler);
            languages.forEach(function(e) {
                supportedLanguages += (supportedLanguages ? "|^" : "^") + e;
                handler.supportedLanguages += "|^" + e + "$";
            });
            extensions.forEach(function(e) {
                supportedExtensions += (supportedExtensions ? "|^" : "^") + e + "$";
                handler.supportedExtensions += "|^" + e + "$";
            });
        },
        
        unregisterHandler: function(source) {
            handlers = handlers.filter(function(h) { return !(h.$source && source === h.$source); });
        },
        
        getHandlerFor: function(path, language) {
            var match = path && path.match(/\.([^/.]*)$/);
            var extension = match && match[1] || "";
            if (!extension.match(supportedExtensions) && !(language || "").match(supportedLanguages))
                return null;
            
            var results = handlers.filter(function(p) {
                if (p.disabled) return false;
                if (language && language.match(p.supportedLanguages)) return true;
                if (p.supportedExtensions && extension.match(p.supportedExtensions)) return true;
                if (p.supportedPaths && path && path.match(p.supportedPaths)) return true;
                return false;
            });
            if (results.length > 1)
                results = results.filter(function(r) { return !r.isGeneric; });
            
            return results[0];
        },
        
        getAllHandlers: function() {
            return handlers;
        }
    
    };
};

});

define("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_base_handler",[], function(require, exports, module) {

var asyncForEach = require("plugins/c9.ide.language.core/worker").asyncForEach;
var workerUtil = require("plugins/c9.ide.language/worker_util");
var child_process = typeof process === "undefined" || !process.version
    ? null
    : arguments[0]("child_process");
module.exports = {
    languages: [],
    extensions: [],
    maxCallInterval: 2000,
    CALL_INTERVAL_MIN: 500,
    
    CALL_INTERVAL_BASIC: 1200,
    init: function(options, callback) {
        callback();
    },
    findImports: function(path, value, ast, options, callback) {
        callback();
    },
    analyzeCurrent: function(path, value, ast, options, callback) {
        callback();
    },
    analyzeOthers: function(paths, options, callback) {
        callback();
    },
    analyzeWorkspaceRoot: function(callback) {
        callback();
    },
    analyzeCurrentAll: function(paths, options, callback) {
        var errs = [];
        var results = [];
        var _self = this;
        asyncForEach(
            paths,
            function(path, next) {
                workerUtil.readFile(path, { unsaved: true }, function(err, doc) {
                    if (err) {
                        errs.push(err);
                        results.push(null);
                        return next();
                    }
                    
                    _self.analyzeCurrent(path, doc, null, options, function(err, result) {
                        errs.push(err);
                        results.push(result);
                        next();
                    });
                });
            },
            function() {
                callback(errs, results);
            }
        );
    },
    $lint: function(linter, args, stdin, options, callback) {
        var a = arguments;
        callback = a[4] || a[3] || a[2];
        options = typeof a[3] == "object" && a[3]
            || typeof a[2] == "object" && !(a[2] instanceof Buffer) && a[2];
        stdin = (typeof a[2] == "string" || a[2] instanceof Buffer) && a[2];

        if (!child_process)
            return callback(new Error("Only implemented for server-side plugins"));
        
        options = options || {};
        options.maxBuffer = options.maxBuffer || 200 * 1024;
        options.env = options.env || {};
        var PATH = options.env.PATH || this.defaultEnv && this.defaultEnv.PATH || process.env.PATH;
        options.env.PATH = process.platform === "linux"
            ? PATH + ":/mnt/shared/bin"
            : PATH;
        for (var key in process.env) {
            options.env[key] = options.env[key] != null ? options.env[key] : process.env[key];
        }
        
        try {
            var child = child_process.execFile(
                linter, args, options,
                function(err, stdout, stderr) {
                    if (err && ["ENOENT", "EACCES"].indexOf(err.code) > -1) {
                        err = new Error(err.code + ": No " + (linter === "bash" ? "linter" : linter) + " installation found");
                        err.code = "EFATAL";
                        return callback(err, stdout, stderr);
                    }
                    
                    callback(null, stdout, stderr, err);
                }
            );

            child.stdin.on("error", function(e) {
            });
    
            if (stdin)
                child.stdin.end(stdin);
        }
        catch (err) {
            err.code = "EFATAL";
            callback(err);
        }
    }
};

});

define("plugins/c9.ide.language.jsonalyzer/worker/server_handler_wrapper",[], function(require, exports, module) {
    
    var lastId = 0;
    module.exports.ServerHandlerWrapper = function(descriptor, worker) {
        var PluginBase = require("./jsonalyzer_base_handler");
        var handler = Object.create(PluginBase);
        handler.$source = descriptor.path;
        handler.languages = descriptor.properties.languages;
        handler.extensions = descriptor.properties.extensions;
        handler.maxCallInterval = descriptor.properties.maxCallInterval;
        
        if (descriptor.functions.analyzeCurrent)
            handler.analyzeCurrent = function(path, value, ast, options, callback) {
                callServer({
                    handlerPath: descriptor.path,
                    maxCallInterval: descriptor.properties.maxCallInterval,
                    semaphore: handler.$source,
                    filePath: path,
                    method: "analyzeCurrent",
                    args: [path, null, null, options]
                }, callback);
            };
        if (descriptor.functions.findImports)
            handler.findImports = function(path, value, ast, options, callback) {
                callServer({
                    handlerPath: descriptor.path,
                    maxCallInterval: descriptor.properties.maxCallInterval,
                    filePath: path,
                    method: "findImports",
                    args: [path, null, null, options]
                }, callback);
            };
        if (descriptor.functions.analyzeOthers)
            handler.analyzeOthers = function(paths, options, callback) {
                callServer({
                    handlerPath: descriptor.path,
                    maxCallInterval: descriptor.properties.maxCallInterval,
                    filePath: null, // we're not using collab for these so we don't care
                    method: "analyzeOthers",
                    args: [paths, options]
                }, callback);
            };
        return handler;
    
        function callServer(options, callback) {
            options.id = ++lastId;
            worker.sender.on("jsonalyzerCallServerResult", function onResult(e) {
                if (e.data.id !== options.id)
                    return;
                
                worker.sender.off("jsonalyzerCallServerResult", onResult);

                var err = e.data.result[0];
                if (err && err.code === "EFATAL") {
                    console.error("Fatal error in " + descriptor.path, err);
                    handler.disabled = err;
                }

                callback.apply(null, e.data.result);
            });
            worker.sender.emit("jsonalyzerCallServer", options);
        }
    };
    
});

define("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_worker",[], function(require, exports, module) {

var baseLanguageHandler = require("plugins/c9.ide.language/base_handler");
var languageWorker = require("plugins/c9.ide.language.core/worker");
var index = require("./semantic_index");
var jumptodef = require("./jumptodef");
var complete = require("./complete");
var outline = require("./outline");
var refactor = require("./refactor");
var highlight = require("./highlight_occurrences");
var scopeAnalyzer = require('plugins/c9.ide.language.javascript/scope_analyzer');
var directoryIndexer = require("./directory_indexer");
var fileIndexer = require("./file_indexer");
var ctagsUtil = require("./ctags/ctags_util");
var ctagsEx = require("./ctags/ctags_ex");
var HandlerRegistry = require("./handler_registry").HandlerRegistry;
var ServerHandlerWrapper = require("./server_handler_wrapper").ServerHandlerWrapper;
require("treehugger/traverse"); // add traversal methods

var worker = module.exports = Object.create(baseLanguageHandler);
var isOnline = false;
var isInWebWorker = typeof window == "undefined" || !window.location || !window.document;
var handlers = new HandlerRegistry();
var handlersServer = new HandlerRegistry();

worker.$isInited = false;
worker.DEBUG = true;
worker.KIND_DEFAULT = scopeAnalyzer.KIND_DEFAULT;
worker.KIND_PACKAGE = scopeAnalyzer.KIND_PACKAGE;

worker.init = function(callback) {
    worker.sender.on("onlinechange", function(event) {
        worker.onOnlineChange(event);
    });
    worker.sender.on("filechange", function(event) {
        worker.onFileChange(event);
    });
    worker.sender.on("dirchange", function(event) {
        worker.onDirChange(event);
    });
    worker.sender.on("jsonalyzerRegister", function(event) {
        worker.loadPlugin(event.data.modulePath, event.data.contents, function(err, plugin) {
            if (err) return console.error(err);
            plugin.$source = event.data.modulePath;
            
            var oldHandler = worker.getHandlerFor(worker.path, worker.language);
            var options = event.data.options || {};
            
            options.sender = worker.sender;
            handlers.registerHandler(plugin, worker, options);
            if (oldHandler !== worker.getHandlerFor(worker.path, worker.language)) {
                index.markStale(oldHandler);
                languageWorker.$lastWorker.onUpdate();
            }
                
            worker.sender.emit("jsonalyzerRegistered",
                { modulePath: event.data.modulePath, err: err });
        });
    });
    worker.sender.on("jsonalyzerRegisterServer", function(event) {
        var oldHandler = worker.getServerHandlerFor(worker.path, worker.language);
        handlersServer.registerHandler(
            new ServerHandlerWrapper(event.data, worker), worker);
        if (oldHandler !== worker.getServerHandlerFor(worker.path, worker.language)) {
            index.markStale(oldHandler);
            var clientHandler = worker.getHandlerFor(worker.path, worker.language);
            if (oldHandler !== clientHandler)
                index.markStale(clientHandler);
            languageWorker.$lastWorker.onUpdate();
        }
    });
    worker.sender.on("jsonalyzerUnregister", function(event) {
        if (window.require)
            window.require.modules[event.data.modulePath] = null;
        handlers.unregisterHandler(event.data.modulePath);
        worker.sender.emit("jsonalyzerUnregistered", { modulePath: event.data.modulePath });
    });
    worker.sender.on("jsonalyzerUnregisterServer", function(event) {
        handlersServer.unregisterHandler(event.data.modulePath);
        worker.sender.emit("jsonalyzerUnregisteredServer", { modulePath: event.data.modulePath });
    });
    
    directoryIndexer.init(this);
    fileIndexer.init(this);
    index.init(this);
    jumptodef.init(this);
    complete.init(this);
    outline.init(this);
    refactor.init(this);
    highlight.init(this);
    ctagsUtil.init(ctagsEx, this);
    callback();
};

worker.loadPlugin = function(modulePath, contents, callback) {
    if (contents) {
        contents = contents.replace(/^(define\()(function|["'])/m, function(_, def, arg1) {
            if (arg1 == "function")
                return def + "'" + modulePath + "',[]," + arg1;
            return _;
        });
        try {
            eval.call(null, contents + "\n//@ sourceURL=" + modulePath);
        } catch (e) {
            return callback("Could not load language handler " + modulePath + ": " + e);
        }
    }
    
    require([modulePath], function(handler) {
        if (!handler)
            return callback("Could not load language handler " + modulePath);
        callback(null, handler);
    }, function(err) {
        callback(err);
    });
};

worker.handlesLanguage = function(language, part) {
    return (!part || !part.index) && this.getHandlerFor(this.path, language);
};

worker.onDocumentOpen = function(path, doc, oldPath, callback) {
    if (this.$isInited && !this.getHandlerFor(path, null))
        return callback();
    fileIndexer.analyzeOthers([path]);
    callback();
};

worker.analyze = function(doc, ast, options, callback) {
    if (options.minimalAnalysis && index.get(worker.path) || !worker.path)
        return callback();
    var fullDoc = this.doc.getValue();
    this.language = this.doc.$language;
        
    fileIndexer.analyzeCurrent(worker.path, fullDoc, ast, options, function(err, result, imports, markers) {
        if (err)
            console.error("[jsonalyzer] Warning: could not analyze " + worker.path + ": " + (err.stack || err));
        if (imports && imports.length)
            fileIndexer.analyzeOthers(imports, true);
        
        callback(markers);
    });
};

worker.complete = complete.complete.bind(complete);

worker.outline = outline.outline.bind(outline);

worker.jumpToDefinition = jumptodef.jumpToDefinition.bind(jumptodef);

worker.getRefactorings = refactor.getRefactorings.bind(refactor);

worker.getRenamePositions = refactor.getRenamePositions.bind(refactor);

worker.commitRename = refactor.commitRename.bind(refactor);

worker.highlightOccurrences = highlight.highlightOccurrences.bind(highlight);

worker.onOnlineChange = function(event) {
    isOnline = event.data.isOnline;
},

worker.onFileChange = function(event) {
    if (worker.disabled)
        return;
    var path = event.data.path.replace(/^\/((?!workspace)[^\/]+\/[^\/]+\/)?workspace\//, "");
    
    if (!this.getHandlerFor(path, null))
        return;
    
    if (event.data.isSave && path === this.path)
        return fileIndexer.analyzeCurrent(path, event.data.value, null, { isSave: true }, function() {});

    index.removeByPath(path);
    fileIndexer.analyzeOthers([path]);
};

worker.onDirChange = function(event) {
    directoryIndexer.enqueue(event.data.path);
};

worker.getHandlerFor = function(path, language) {
    language = language || (worker.path === path && worker.language);
    
    return handlers.getHandlerFor(path, language)
        || this.getServerHandlerFor(path, language);
};

worker.getServerHandlerFor = function(path, language) {
    language = language || (worker.path === path && worker.language);
    
    return handlersServer.getHandlerFor(path, language);
};

worker.getAllHandlers = function() {
    return handlers.getAllHandlers();
};

worker.getHandlerRegistry = function() {
    return handlers;
};

});

define("plugins/c9.ide.language.jsonalyzer/worker/handlers/jsonalyzer_html",[], function(require, exports, module) {

var jsonalyzer = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_worker");
var BaseHandler = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_base_handler");
var ctagsUtil = require("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_util");

var handler = module.exports = Object.create(BaseHandler);

handler.extensions = ["htm", "html"];
handler.languages = ["html"];
handler.maxCallInterval = handler.CALL_INTERVAL_BASIC;

var TAGS = [
    { regex: /(?:^|\n)\s*<(xml|html)\b/g, kind: "package" },
    { regex: /(?:^|\n)\s*<(form|h1|body|head)\b/g, kind: "method", indent: 1 },
    { regex: /\sng-app=["']([A-Za-z0-9$_\.]+)/g, kind: "property", indent: 1 },
    { regex: /\sng-controller=["']([A-Za-z0-9$_\.]+)/g, kind: "property", indent: 1 },
    { regex: /\sng-repeat="[^\"]+ in ([^\"]+)/g, kind: "property2", indent: 1 },
    { regex: /\sng-repeat='[^\']+ in ([^\']+)/g, kind: "property2", indent: 1 },
    { regex: /\sng-click=["']([A-Za-z0-9$_\.]+)/g, kind: "property2", indent: 1 },
    { regex: /\sng-model=["']([A-Za-z0-9$_\.]+)/g, kind: "property2", indent: 1 },
    { regex: /\sdata-bind="[^"]*\b(?:foreach|click|value|checked):\s*(?:\$root\.)?([A-Za-z0-9$_\.]+)/g, kind: "property2", indent: 1 },
    { regex: /\sdata-bind='[^']*\b(?:foreach|click|value|checked):\s*(?:\$root\.)?([A-Za-z0-9$_\.]+)/g, kind: "property2", indent: 1 },
];
var GUESS_FARGS = false;
var EXTRACT_DOCS = false;

handler.init = function(options, callback) {
    callback();
};

handler.analyzeCurrent = function(path, doc, ast, options, callback) {
    if (doc === "" || doc.length > jsonalyzer.getMaxFileSizeSupported())
        return callback(null, {});
    
    var results = {};
    TAGS.forEach(function(tag) {
        if (tag.kind === "import")
            return;
        ctagsUtil.findMatchingTags(path, doc, tag, GUESS_FARGS, EXTRACT_DOCS, results);
    });
    for (var id in results) {
        results[id].forEach(function(r) {
            r.noComplete = true;
        });
    }
    
    callback(null, { properties: results });
};

});

define("plugins/c9.ide.language.jsonalyzer/worker/handlers/jsonalyzer_make",[], function(require, exports, module) {

var jsonalyzer = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_worker");
var PluginBase = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_base_handler");
var ctagsUtil = require("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_util");

var TAGS = [
    { regex: /(?:^|\n)([A-Za-z0-9 \.].*?)\s*:(?!=)/g, kind: "property" },
    { regex: /(?:^|\n)([A-Za-z0-9].*?)\s*:=/g, kind: "property2" }
];
var GUESS_FARGS = false;
var EXTRACT_DOCS = false;

var handler = module.exports = Object.create(PluginBase);

handler.languages = ["makefile"];

handler.extensions = [];

handler.supportedPaths = "(^|\/)Makefile.*";

handler.analyzeCurrent = function(path, doc, ast, options, callback) {
    if (doc === "")
        return callback(null, {});
        
    if (doc.length > jsonalyzer.getMaxFileSizeSupported())
        return callback(null, {});
    
    var results = {};
    TAGS.forEach(function(tag) {
        if (tag.kind === "import")
            return;
        ctagsUtil.findMatchingTags(
            path, doc, tag, GUESS_FARGS, EXTRACT_DOCS, results);
    });
    callback(null, { properties: results });
};

handler.analyzeOthers = handler.analyzeCurrentAll;

handler.findImports = function(path, doc, ast, options, callback) {
    callback(null, ctagsUtil.findMatchingOpenFiles(path));
};


});

define("plugins/c9.ide.language.jsonalyzer/worker/handlers/jsonalyzer_go",[], function(require, exports, module) {

var jsonalyzer = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_worker");
var PluginBase = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_base_handler");
var ctagsUtil = require("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_util");

var TAGS = [
    { regex: /(?:^|\n)\s*package\s+([^\s\(]+)/g, kind: "package" },
    { regex: /(?:^|\n)\s*type\s+([^\s\(]+)/g, kind: "method2", indent: 1 },
    { regex: /(?:^|\n)\s*func\s+([^\s\r\(]+)/g, kind: "method", indent: 1 },
    {
        regex: new RegExp(
            "(?:^|\\n)\\s*import\\s+([^ \\(]+)"
        ),
        kind: "import"
    }
];
var GUESS_FARGS = true;
var EXTRACT_DOCS = true;

var handler = module.exports = Object.create(PluginBase);

handler.languages = ["golang"];

handler.extensions = ["go"];

handler.analyzeCurrent = function(path, doc, ast, options, callback) {
    if (doc === "")
        return callback(null, {});
        
    if (doc.length > jsonalyzer.getMaxFileSizeSupported())
        return callback(null, {});
    
    var results = {};
    TAGS.forEach(function(tag) {
        if (tag.kind === "import")
            return;
        ctagsUtil.findMatchingTags(path, doc, tag, GUESS_FARGS, EXTRACT_DOCS, results);
    });

    var serverHandler = jsonalyzer.getServerHandlerFor(path, "go");
    if (options.service || !serverHandler)
        return callback(null, { properties: results });
    
    serverHandler.analyzeCurrent(path, doc, ast, options, function(err, summary, markers) {
        if (err && err.code === "ESUPERSEDED")
            return callback(err);
        if (err)
            console.error(err.stack || err);
        return callback(null, { properties: results }, markers);
    });
};

handler.analyzeOthers = handler.analyzeCurrentAll;

handler.findImports = function(path, doc, ast, options, callback) {
    callback(null, ctagsUtil.findMatchingOpenFiles(path));
};


});

define("plugins/c9.ide.language.jsonalyzer/worker/handlers/jsonalyzer_ctags",[], function(require, exports, module) {

var index = require("plugins/c9.ide.language.jsonalyzer/worker/semantic_index");
var PluginBase = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_base_handler");
var jsonalyzer = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_worker");
var ctags = require("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_ex");
var ctagsUtil = require("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_util");
var asyncForEach = require("plugins/c9.ide.language.core/worker").asyncForEach;
var workerUtil = require("plugins/c9.ide.language/worker_util");

var handler = module.exports = Object.create(PluginBase);

var IDLE_TIME = 50;

handler.languages = ctags.languages;

handler.extensions = ctags.extensions;

handler.isGeneric = true;

handler.findImports = function(path, doc, ast, options, callback) {
    callback(null, ctagsUtil.findMatchingOpenFiles(path));
};

handler.analyzeCurrent = function(path, doc, ast, options, callback) {
    if (doc === "")
        return callback(null, {});
        
    if (doc.length > jsonalyzer.getMaxFileSizeSupported())
        return callback();
    if ((options.service === "complete" || options.isSave) && index.get(path))
        return callback(null, index.get(path));
    if (options.language)
        path = ctags.pathForLanguage(options.language, path);
    ctags.analyze(path, doc, options, callback);
};

handler.analyzeOthers = function(paths, options, callback) {
    var errs = [];
    var results = [];
    var _self = this;
    asyncForEach(
        paths,
        function(path, next) {
            workerUtil.readFile(path, { unsaved: true }, function(err, doc) {
                if (err) {
                    errs.push(err);
                    results.push(null);
                    return next();
                }
                
                _self.analyzeCurrent(path, doc, null, {}, function(err, result) {
                    errs.push(err);
                    results.push(result);
                    next();
                });
            });
        },
        function() {
            callback(errs, results);
        }
    );
};

});

define("plugins/c9.ide.language.jsonalyzer/worker/handlers/jsonalyzer_rb",[], function(require, exports, module) {

var jsonalyzer = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_worker");
var PluginBase = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_base_handler");
var ctagsUtil = require("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_util");

var TAGS = [
    { regex: /(?:^|\n)\s*module\s+([^ \(]+)/g, kind: "package" },
    { regex: /(?:^|\n)\s*class\s+([^ \(]+)/g, kind: "package" },
    { regex: /(?:^|\n)\s*def\s+([^ \(]+)/g, kind: "method" },
    {
        regex: new RegExp(
            "(?:^|\\n)\\s*include\\s+([^ \\(]+)"
        ),
        kind: "import"
    }
];
var GUESS_FARGS = true;
var EXTRACT_DOCS = true;

var handler = module.exports = Object.create(PluginBase);

handler.languages = ["ruby"];

handler.extensions = ["rb"];

handler.analyzeCurrent = function(path, doc, ast, options, callback) {
    if (doc === "")
        return callback(null, {});
        
    if (doc.length > jsonalyzer.getMaxFileSizeSupported())
        return callback(null, {});
    
    var results = {};
    TAGS.forEach(function(tag) {
        if (tag.kind === "import")
            return;
        ctagsUtil.findMatchingTags(path, doc, tag, GUESS_FARGS, EXTRACT_DOCS, results);
    });

    var serverHandler = jsonalyzer.getServerHandlerFor(path, "ruby");
    if (options.service || !serverHandler)
        return callback(null, { properties: results });
    
    serverHandler.analyzeCurrent(path, doc, ast, options, function(err, summary, markers) {
        if (err && err.code === "ESUPERSEDED")
            return callback(err);
        if (err)
            console.error(err.stack || err);
        return callback(null, { properties: results }, markers);
    });
};

handler.analyzeOthers = handler.analyzeCurrentAll;

handler.findImports = function(path, doc, ast, options, callback) {
    callback(null, ctagsUtil.findMatchingOpenFiles(path));
};


});

define("plugins/c9.ide.language.jsonalyzer/worker/handlers/jsonalyzer_sh",[], function(require, exports, module) {

var jsonalyzer = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_worker");
var PluginBase = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_base_handler");
var ctagsUtil = require("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_util");

var TAGS = [
    { regex: /(?:^|\n)\s*([A-Za-z0-9_]+)\(\)/g, kind: "method" },
    { regex: /(?:^|\n)\s*(\.|source)\s+([A-Za-z0-9_]+)/g, kind: "import" }
];
var GUESS_FARGS = false;
var EXTRACT_DOCS = true;

var handler = module.exports = Object.create(PluginBase);

handler.languages = ["sh"];

handler.extensions = ["sh"];

handler.analyzeCurrent = function(path, doc, ast, options, callback) {
    if (doc === "")
        return callback(null, {});
        
    if (doc.length > jsonalyzer.getMaxFileSizeSupported())
        return callback(null, {});
    
    var results = {};
    TAGS.forEach(function(tag) {
        if (tag.kind === "import")
            return;
        ctagsUtil.findMatchingTags(
            path, doc, tag, GUESS_FARGS, EXTRACT_DOCS, results);
    });

    var serverHandler = jsonalyzer.getServerHandlerFor(path, "sh");
    if (options.service || !serverHandler)
        return callback(null, { properties: results });
    
    serverHandler.analyzeCurrent(path, doc, ast, options, function(err, summary, markers) {
        if (err && err.code === "ESUPERSEDED")
            return callback(err);
        if (err)
            console.error(err.stack || err);
        return callback(null, { properties: results }, markers);
    });
};

handler.analyzeOthers = handler.analyzeCurrentAll;

handler.findImports = function(path, doc, ast, options, callback) {
    callback(null, ctagsUtil.findMatchingOpenFiles(path));
};


});

define("plugins/c9.ide.language.jsonalyzer/worker/handlers/jsonalyzer_php",[], function(require, exports, module) {

var jsonalyzer = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_worker");
var PluginBase = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_base_handler");
var ctagsUtil = require("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_util");

var TAGS = [
    { regex: /(?:^|\n)\s*(?:abstract\s+)?class ([^ ]*)/g, kind: "package" },
    { regex: /(?:^|\n)\s*interface ([^ ]*)/g, kind: "package" },
    {
        regex: /(?:^|\n)\s*(?:public\s+|static\s+|abstract\s+|protected\s+|private\s+|final\s+)*function ([^ (]*)/g,
        kind: "method"
    },
    {
        regex: new RegExp(
            "(?:^|\n)\s*include\\("
            + "(?:\\$\\w+(?:\\[[\\w']+\\])?)?"
            + "(?:\\s*\\.\\s*)?",
            "g"
        ),
        kind: "import"
    }
];
var GUESS_FARGS = true;
var EXTRACT_DOCS = true;

var handler = module.exports = Object.create(PluginBase);

handler.languages = ["php"];

handler.extensions = ["php"];

handler.analyzeCurrent = function(path, doc, ast, options, callback) {
    if (doc === "")
        return callback(null, {});
        
    if (doc.length > jsonalyzer.getMaxFileSizeSupported())
        return callback(null, {});
    
    var results = {};
    TAGS.forEach(function(tag) {
        if (tag.kind === "import")
            return;
        ctagsUtil.findMatchingTags(path, doc, tag, GUESS_FARGS, EXTRACT_DOCS, results);
    });

    var serverHandler = jsonalyzer.getServerHandlerFor(path, "php");
    if (options.service || !serverHandler)
        return callback(null, { properties: results });
    
    serverHandler.analyzeCurrent(path, doc, ast, options, function(err, summary, markers) {
        if (err && err.code === "ESUPERSEDED")
            return callback(err);
        if (err)
            console.error(err.stack || err);
        return callback(null, { properties: results }, markers);
    });
};

handler.analyzeOthers = handler.analyzeCurrentAll;

handler.findImports = function(path, doc, ast, options, callback) {
    callback(null, ctagsUtil.findMatchingOpenFiles(path));
};


});

define("plugins/c9.ide.language.jsonalyzer/worker/handlers/jsonalyzer_md",[], function(require, exports, module) {

var jsonalyzer = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_worker");
var PluginBase = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_base_handler");
var ctagsUtil = require("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_util");

var TAGS = [
    { regex: /^# (.*?)[#\s]*$/gm, kind: "property" },
    { regex: /^([A-Za-z0-9].*?)[ \t]*\n={2,}$/gm, kind: "property" },
    { regex: /^#{3,} (.*?)[# \t]*$/gm, kind: "property2", indent: 2 },
    { regex: /^([A-Za-z0-9].*?)[ \t]*\n-{3,}$/gm, kind: "property2", indent: 2 },
    { regex: /^#{2} (.*?)[# \t]*$/gm, kind: "property2", indent: 1 },
    { regex: /^([A-Za-z0-9].*?)[ \t]*\n-{2}$/gm, kind: "property2", indent: 1 },
];
var GUESS_FARGS = false;
var EXTRACT_DOCS = false;

var handler = module.exports = Object.create(PluginBase);

handler.languages = ["markdown"];

handler.extensions = ["md", "markdown"];

handler.analyzeCurrent = function(path, doc, ast, options, callback) {
    if (doc === "")
        return callback(null, {});
        
    if (doc.length > jsonalyzer.getMaxFileSizeSupported())
        return callback(null, {});
    
    var results = {};
    TAGS.forEach(function(tag) {
        if (tag.kind === "import")
            return;
        ctagsUtil.findMatchingTags(
            path, doc, tag, GUESS_FARGS, EXTRACT_DOCS, results);
    });
    callback(null, { properties: results });
};

handler.analyzeOthers = handler.analyzeCurrentAll;

handler.findImports = function(path, doc, ast, options, callback) {
    callback(null, ctagsUtil.findMatchingOpenFiles(path));
};


});

define("plugins/c9.ide.language.javascript.infer/path",[], function(require, exports, module) {

function getBasePath(file, workspaceDir) {
    if (file.substr(0, workspaceDir.length) === workspaceDir)
        file = file.substr(workspaceDir.length + 1);
    return file.replace(/\/?[^\/]*$/, "");
}

function canonicalizePath(path, basePath) {
    if (basePath && isRelativePath(path))
        path = basePath + "/" + path;
    return normalizePath(path).replace(/^\.\//, "");
}

function isRelativePath(path) {
    return !!path.match(/^\.\.\/|^\.\//);
}

function isAbsolutePath(path) {
    return !!path.match(/^\//);
}

function uncanonicalizePath(path, basePath) {
    if (basePath === "")
        return "./" + path;
    var pathParts = path.split("/");
    var basePathParts = basePath.split("/");
    for (var common = 0; common < basePathParts.length; common++)
        if (basePathParts[common] !== pathParts[common])
            break;
    var dirsUp = pathParts.length - 1 - common;
    var resultParts = [];
    for (var i = 0; i < dirsUp; i++)
        resultParts.push("..");
    if (!dirsUp)
        resultParts.push(".");
    for (var j = common; j < pathParts.length; j++)
        resultParts.push(pathParts[j]);
    return resultParts.join("/");
}

function normalizePath(path) {
    var isAbsolute = path.charAt(0) === '/',
        trailingSlash = path.substr(-1) === '/';

    path = normalizePathArray(path.split('/').filter(function(p) {
        return !!p;
    }), !isAbsolute).join('/');

    if (!path && !isAbsolute) {
        path = '.';
    }
    if (path && trailingSlash) {
        path += '/';
    }

    return (isAbsolute ? '/' : '') + path;
}

function normalizePathArray(parts, allowAboveRoot) {
    var up = 0;
    for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === '.') {
            parts.splice(i, 1);
        }
        else if (last === '..') {
            parts.splice(i, 1);
            up++;
        }
        else if (up) {
            parts.splice(i, 1);
            up--;
        }
    }
    if (allowAboveRoot) {
        for (; up--; up) {
            parts.unshift('..');
        }
    }

    return parts;
}

exports.canonicalizePath = canonicalizePath;
exports.uncanonicalizePath = uncanonicalizePath;
exports.getBasePath = getBasePath;
exports.isRelativePath = isRelativePath;
exports.isAbsolutePath = isAbsolutePath;
exports.normalizePath = normalizePath;

});

define("plugins/c9.ide.language.jsonalyzer/worker/handlers/jsonalyzer_js",[], function(require, exports, module) {

var jsonalyzer = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_worker");
var PluginBase = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_base_handler");
var ctagsUtil = require("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_util");
var pathUtil = require("plugins/c9.ide.language.javascript.infer/path");

var TAGS = [
    {
        regex: /function\s*([A-Za-z0-9$_]+)\s*\(/g,
        kind: "unknown2"
    },
    {
        regex: /exports\.([A-Za-z0-9$_]+)\s*=\s*function\b/g,
        kind: "unknown2"
    },
    {
        regex: /\s(\w+)\s*:\s*\w+(?:\s|,)/g,
        kind: "unknown2",
        docOnly: true
    }
];
var GUESS_FARGS = true;
var EXTRACT_DOCS = true;

var handler = module.exports = Object.create(PluginBase);

handler.extensions = ["js", "jsx"];

handler.languages = ["javascript", "jsx"];

handler.analyzeCurrent = function(path, doc, ast, options, callback) {
    if (doc === "")
        return callback(null, {});
        
    if (doc.length > jsonalyzer.getMaxFileSizeSupported())
        return callback(null, {});
    
    var results = {};
    TAGS.forEach(function(tag) {
        if (tag.kind === "import")
            return;
        ctagsUtil.findMatchingTags(path, doc, tag, EXTRACT_DOCS, GUESS_FARGS, results);
    });
    for (var p in results) {
        if (results[p][0])
            results[p][0].kind = null;
    }
    callback(null, { properties: results });
};

handler.analyzeOthers = handler.analyzeCurrentAll;

handler.findImports = function(path, doc, ast, options, callback) {
    var openFiles = ctagsUtil.findMatchingOpenFiles(path);
    var astImports = findImportsInAST(path, ast);

    callback(null, openFiles.concat(astImports));
};

function findImportsInAST(path, ast) {
    if (!ast)
        return [];
    
    return []; // Don't import anything now that tern does this for us
    
    var basePath = path.match(/^(.*?)(\/[^\/]+)?$/)[1];
    return ast.collectTopDown(
        'Call(Var("require"), [String(required)])', function(b) {
            var name = b.required.value;
            if (name.match(/^text!/))
                return;
            var isFilePath = pathUtil.isAbsolutePath(name) || pathUtil.isRelativePath(name);
            if (!isFilePath)
                name = guessFilePath(basePath, name);
            if (!name)
                return;
            
            var result = isFilePath ? pathUtil.canonicalizePath(name, basePath) : "js_p:" + name;
            if (isFilePath && !result.match(/\.js$/))
                result += ".js";
            return result;
        }
    ).toArray();
}

function guessFilePath(basePath, importPath) {
    var baseDir = importPath.match(/[^\/]+/);
    if (!baseDir)
        return;
    var i = basePath.indexOf(baseDir[0]);
    if (i === -1)
        return;
    return basePath.substr(0, i) + importPath;
}

});

define("plugins/c9.ide.language.javascript.eslint/worker/js-yaml",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.jsyaml=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';


var loader = require('./js-yaml/loader');
var dumper = require('./js-yaml/dumper');


function deprecated(name) {
  return function () {
    throw new Error('Function ' + name + ' is deprecated and cannot be used.');
  };
}


module.exports.Type                = require('./js-yaml/type');
module.exports.Schema              = require('./js-yaml/schema');
module.exports.FAILSAFE_SCHEMA     = require('./js-yaml/schema/failsafe');
module.exports.JSON_SCHEMA         = require('./js-yaml/schema/json');
module.exports.CORE_SCHEMA         = require('./js-yaml/schema/core');
module.exports.DEFAULT_SAFE_SCHEMA = require('./js-yaml/schema/default_safe');
module.exports.DEFAULT_FULL_SCHEMA = require('./js-yaml/schema/default_full');
module.exports.load                = loader.load;
module.exports.loadAll             = loader.loadAll;
module.exports.safeLoad            = loader.safeLoad;
module.exports.safeLoadAll         = loader.safeLoadAll;
module.exports.dump                = dumper.dump;
module.exports.safeDump            = dumper.safeDump;
module.exports.YAMLException       = require('./js-yaml/exception');
module.exports.MINIMAL_SCHEMA = require('./js-yaml/schema/failsafe');
module.exports.SAFE_SCHEMA    = require('./js-yaml/schema/default_safe');
module.exports.DEFAULT_SCHEMA = require('./js-yaml/schema/default_full');
module.exports.scan           = deprecated('scan');
module.exports.parse          = deprecated('parse');
module.exports.compose        = deprecated('compose');
module.exports.addConstructor = deprecated('addConstructor');

},{"./js-yaml/dumper":3,"./js-yaml/exception":4,"./js-yaml/loader":5,"./js-yaml/schema":7,"./js-yaml/schema/core":8,"./js-yaml/schema/default_full":9,"./js-yaml/schema/default_safe":10,"./js-yaml/schema/failsafe":11,"./js-yaml/schema/json":12,"./js-yaml/type":13}],2:[function(require,module,exports){
'use strict';


function isNothing(subject) {
  return (undefined === subject) || (null === subject);
}


function isObject(subject) {
  return ('object' === typeof subject) && (null !== subject);
}


function toArray(sequence) {
  if (Array.isArray(sequence)) {
    return sequence;
  } else if (isNothing(sequence)) {
    return [];
  } else {
    return [ sequence ];
  }
}


function extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}


function repeat(string, count) {
  var result = '', cycle;

  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }

  return result;
}


function isNegativeZero(number) {
  return (0 === number) && (Number.NEGATIVE_INFINITY === 1 / number);
}


module.exports.isNothing      = isNothing;
module.exports.isObject       = isObject;
module.exports.toArray        = toArray;
module.exports.repeat         = repeat;
module.exports.isNegativeZero = isNegativeZero;
module.exports.extend         = extend;

},{}],3:[function(require,module,exports){
'use strict';


var common              = require('./common');
var YAMLException       = require('./exception');
var DEFAULT_FULL_SCHEMA = require('./schema/default_full');
var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');


var _toString       = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;


var CHAR_TAB                  = 0x09; /* Tab */
var CHAR_LINE_FEED            = 0x0A; /* LF */
var CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */
var CHAR_SPACE                = 0x20; /* Space */
var CHAR_EXCLAMATION          = 0x21; /* ! */
var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
var CHAR_SHARP                = 0x23; /* # */
var CHAR_PERCENT              = 0x25; /* % */
var CHAR_AMPERSAND            = 0x26; /* & */
var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
var CHAR_ASTERISK             = 0x2A; /* * */
var CHAR_COMMA                = 0x2C; /* , */
var CHAR_MINUS                = 0x2D; /* - */
var CHAR_COLON                = 0x3A; /* : */
var CHAR_GREATER_THAN         = 0x3E; /* > */
var CHAR_QUESTION             = 0x3F; /* ? */
var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
var CHAR_VERTICAL_LINE        = 0x7C; /* | */
var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */


var ESCAPE_SEQUENCES = {};

ESCAPE_SEQUENCES[0x00]   = '\\0';
ESCAPE_SEQUENCES[0x07]   = '\\a';
ESCAPE_SEQUENCES[0x08]   = '\\b';
ESCAPE_SEQUENCES[0x09]   = '\\t';
ESCAPE_SEQUENCES[0x0A]   = '\\n';
ESCAPE_SEQUENCES[0x0B]   = '\\v';
ESCAPE_SEQUENCES[0x0C]   = '\\f';
ESCAPE_SEQUENCES[0x0D]   = '\\r';
ESCAPE_SEQUENCES[0x1B]   = '\\e';
ESCAPE_SEQUENCES[0x22]   = '\\"';
ESCAPE_SEQUENCES[0x5C]   = '\\\\';
ESCAPE_SEQUENCES[0x85]   = '\\N';
ESCAPE_SEQUENCES[0xA0]   = '\\_';
ESCAPE_SEQUENCES[0x2028] = '\\L';
ESCAPE_SEQUENCES[0x2029] = '\\P';


var DEPRECATED_BOOLEANS_SYNTAX = [
  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
];


function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;

  if (null === map) {
    return {};
  }

  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if ('!!' === tag.slice(0, 2)) {
      tag = 'tag:yaml.org,2002:' + tag.slice(2);
    }

    type = schema.compiledTypeMap[tag];

    if (type && _hasOwnProperty.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }

    result[tag] = style;
  }

  return result;
}


function encodeHex(character) {
  var string, handle, length;

  string = character.toString(16).toUpperCase();

  if (character <= 0xFF) {
    handle = 'x';
    length = 2;
  } else if (character <= 0xFFFF) {
    handle = 'u';
    length = 4;
  } else if (character <= 0xFFFFFFFF) {
    handle = 'U';
    length = 8;
  } else {
    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
  }

  return '\\' + handle + common.repeat('0', length - string.length) + string;
}


function State(options) {
  this.schema      = options['schema'] || DEFAULT_FULL_SCHEMA;
  this.indent      = Math.max(1, (options['indent'] || 2));
  this.skipInvalid = options['skipInvalid'] || false;
  this.flowLevel   = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
  this.styleMap    = compileStyleMap(this.schema, options['styles'] || null);

  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;

  this.tag = null;
  this.result = '';

  this.duplicates = [];
  this.usedDuplicates = null;
}


function generateNextLine(state, level) {
  return '\n' + common.repeat(' ', state.indent * level);
}

function testImplicitResolving(state, str) {
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type = state.implicitTypes[index];

    if (type.resolve(str)) {
      return true;
    }
  }

  return false;
}

function writeScalar(state, object) {
  var isQuoted, checkpoint, position, length, character, first;

  state.dump = '';
  isQuoted = false;
  checkpoint = 0;
  first = object.charCodeAt(0) || 0;

  if (-1 !== DEPRECATED_BOOLEANS_SYNTAX.indexOf(object)) {
    isQuoted = true;
  } else if (0 === object.length) {
    isQuoted = true;
  } else if (CHAR_SPACE    === first ||
             CHAR_SPACE    === object.charCodeAt(object.length - 1)) {
    isQuoted = true;
  } else if (CHAR_MINUS    === first ||
             CHAR_QUESTION === first) {
    isQuoted = true;
  }

  for (position = 0, length = object.length; position < length; position += 1) {
    character = object.charCodeAt(position);

    if (!isQuoted) {
      if (CHAR_TAB                  === character ||
          CHAR_LINE_FEED            === character ||
          CHAR_CARRIAGE_RETURN      === character ||
          CHAR_COMMA                === character ||
          CHAR_LEFT_SQUARE_BRACKET  === character ||
          CHAR_RIGHT_SQUARE_BRACKET === character ||
          CHAR_LEFT_CURLY_BRACKET   === character ||
          CHAR_RIGHT_CURLY_BRACKET  === character ||
          CHAR_SHARP                === character ||
          CHAR_AMPERSAND            === character ||
          CHAR_ASTERISK             === character ||
          CHAR_EXCLAMATION          === character ||
          CHAR_VERTICAL_LINE        === character ||
          CHAR_GREATER_THAN         === character ||
          CHAR_SINGLE_QUOTE         === character ||
          CHAR_DOUBLE_QUOTE         === character ||
          CHAR_PERCENT              === character ||
          CHAR_COMMERCIAL_AT        === character ||
          CHAR_COLON                === character ||
          CHAR_GRAVE_ACCENT         === character) {
        isQuoted = true;
      }
    }

    if (ESCAPE_SEQUENCES[character] ||
        !((0x00020 <= character && character <= 0x00007E) ||
          (0x00085 === character)                         ||
          (0x000A0 <= character && character <= 0x00D7FF) ||
          (0x0E000 <= character && character <= 0x00FFFD) ||
          (0x10000 <= character && character <= 0x10FFFF))) {
      state.dump += object.slice(checkpoint, position);
      state.dump += ESCAPE_SEQUENCES[character] || encodeHex(character);
      checkpoint = position + 1;
      isQuoted = true;
    }
  }

  if (checkpoint < position) {
    state.dump += object.slice(checkpoint, position);
  }

  if (!isQuoted && testImplicitResolving(state, state.dump)) {
    isQuoted = true;
  }

  if (isQuoted) {
    state.dump = '"' + state.dump + '"';
  }
}

function writeFlowSequence(state, level, object) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    if (writeNode(state, level, object[index], false, false)) {
      if (0 !== index) {
        _result += ', ';
      }
      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = '[' + _result + ']';
}

function writeBlockSequence(state, level, object, compact) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    if (writeNode(state, level + 1, object[index], true, true)) {
      if (!compact || 0 !== index) {
        _result += generateNextLine(state, level);
      }
      _result += '- ' + state.dump;
    }
  }

  state.tag = _tag;
  state.dump = _result || '[]'; // Empty sequence if no valid values.
}

function writeFlowMapping(state, level, object) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (0 !== index) {
      pairBuffer += ', ';
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level, objectKey, false, false)) {
      continue; // Skip this pair because of invalid key;
    }

    if (state.dump.length > 1024) {
      pairBuffer += '? ';
    }

    pairBuffer += state.dump + ': ';

    if (!writeNode(state, level, objectValue, false, false)) {
      continue; // Skip this pair because of invalid value.
    }

    pairBuffer += state.dump;
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = '{' + _result + '}';
}

function writeBlockMapping(state, level, object, compact) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (!compact || 0 !== index) {
      pairBuffer += generateNextLine(state, level);
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level + 1, objectKey, true, true)) {
      continue; // Skip this pair because of invalid key.
    }

    explicitPair = (null !== state.tag && '?' !== state.tag) ||
                   (state.dump && state.dump.length > 1024);

    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += '?';
      } else {
        pairBuffer += '? ';
      }
    }

    pairBuffer += state.dump;

    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }

    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue; // Skip this pair because of invalid value.
    }

    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ':';
    } else {
      pairBuffer += ': ';
    }

    pairBuffer += state.dump;
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
}

function detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index < length; index += 1) {
    type = typeList[index];

    if ((type.instanceOf  || type.predicate) &&
        (!type.instanceOf || (('object' === typeof object) && (object instanceof type.instanceOf))) &&
        (!type.predicate  || type.predicate(object))) {

      state.tag = explicit ? type.tag : '?';

      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;

        if ('[object Function]' === _toString.call(type.represent)) {
          _result = type.represent(object, style);
        } else if (_hasOwnProperty.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
        }

        state.dump = _result;
      }

      return true;
    }
  }

  return false;
}
//
function writeNode(state, level, object, block, compact) {
  state.tag = null;
  state.dump = object;

  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }

  var type = _toString.call(state.dump);

  if (block) {
    block = (0 > state.flowLevel || state.flowLevel > level);
  }

  if ((null !== state.tag && '?' !== state.tag) || (2 !== state.indent && level > 0)) {
    compact = false;
  }

  var objectOrArray = '[object Object]' === type || '[object Array]' === type,
      duplicateIndex,
      duplicate;

  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }

  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = '*ref_' + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if ('[object Object]' === type) {
      if (block && (0 !== Object.keys(state.dump).length)) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + (0 === level ? '\n' : '') + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if ('[object Array]' === type) {
      if (block && (0 !== state.dump.length)) {
        writeBlockSequence(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + (0 === level ? '\n' : '') + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if ('[object String]' === type) {
      if ('?' !== state.tag) {
        writeScalar(state, state.dump);
      }
    } else if (state.skipInvalid) {
      return false;
    } else {
      throw new YAMLException('unacceptable kind of an object to dump ' + type);
    }

    if (null !== state.tag && '?' !== state.tag) {
      state.dump = '!<' + state.tag + '> ' + state.dump;
    }
  }

  return true;
}

function getDuplicateReferences(object, state) {
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;

  inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}

function inspectNode(object, objects, duplicatesIndexes) {
  var type = _toString.call(object),
      objectKeyList,
      index,
      length;

  if (null !== object && 'object' === typeof object) {
    index = objects.indexOf(object);
    if (-1 !== index) {
      if (-1 === duplicatesIndexes.indexOf(index)) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);
    
      if(Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}

function dump(input, options) {
  options = options || {};

  var state = new State(options);

  getDuplicateReferences(input, state);

  if (writeNode(state, 0, input, true, true)) {
    return state.dump + '\n';
  } else {
    return '';
  }
}


function safeDump(input, options) {
  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


module.exports.dump     = dump;
module.exports.safeDump = safeDump;

},{"./common":2,"./exception":4,"./schema/default_full":9,"./schema/default_safe":10}],4:[function(require,module,exports){
'use strict';


function YAMLException(reason, mark) {
  this.name    = 'YAMLException';
  this.reason  = reason;
  this.mark    = mark;
  this.message = this.toString(false);
}


YAMLException.prototype.toString = function toString(compact) {
  var result;

  result = 'JS-YAML: ' + (this.reason || '(unknown reason)');

  if (!compact && this.mark) {
    result += ' ' + this.mark.toString();
  }

  return result;
};


module.exports = YAMLException;

},{}],5:[function(require,module,exports){
'use strict';


var common              = require('./common');
var YAMLException       = require('./exception');
var Mark                = require('./mark');
var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');
var DEFAULT_FULL_SCHEMA = require('./schema/default_full');


var _hasOwnProperty = Object.prototype.hasOwnProperty;


var CONTEXT_FLOW_IN   = 1;
var CONTEXT_FLOW_OUT  = 2;
var CONTEXT_BLOCK_IN  = 3;
var CONTEXT_BLOCK_OUT = 4;


var CHOMPING_CLIP  = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP  = 3;


var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uD800-\uDFFF\uFFFE\uFFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;


function is_EOL(c) {
  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
}

function is_WHITE_SPACE(c) {
  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
}

function is_WS_OR_EOL(c) {
  return (c === 0x09/* Tab */) ||
         (c === 0x20/* Space */) ||
         (c === 0x0A/* LF */) ||
         (c === 0x0D/* CR */);
}

function is_FLOW_INDICATOR(c) {
  return 0x2C/* , */ === c ||
         0x5B/* [ */ === c ||
         0x5D/* ] */ === c ||
         0x7B/* { */ === c ||
         0x7D/* } */ === c;
}

function fromHexCode(c) {
  var lc;

  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  lc = c | 0x20;
  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
    return lc - 0x61 + 10;
  }

  return -1;
}

function escapedHexLen(c) {
  if (c === 0x78/* x */) { return 2; }
  if (c === 0x75/* u */) { return 4; }
  if (c === 0x55/* U */) { return 8; }
  return 0;
}

function fromDecimalCode(c) {
  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  return -1;
}

function simpleEscapeSequence(c) {
 return (c === 0x30/* 0 */) ? '\x00' :
        (c === 0x61/* a */) ? '\x07' :
        (c === 0x62/* b */) ? '\x08' :
        (c === 0x74/* t */) ? '\x09' :
        (c === 0x09/* Tab */) ? '\x09' :
        (c === 0x6E/* n */) ? '\x0A' :
        (c === 0x76/* v */) ? '\x0B' :
        (c === 0x66/* f */) ? '\x0C' :
        (c === 0x72/* r */) ? '\x0D' :
        (c === 0x65/* e */) ? '\x1B' :
        (c === 0x20/* Space */) ? ' ' :
        (c === 0x22/* " */) ? '\x22' :
        (c === 0x2F/* / */) ? '/' :
        (c === 0x5C/* \ */) ? '\x5C' :
        (c === 0x4E/* N */) ? '\x85' :
        (c === 0x5F/* _ */) ? '\xA0' :
        (c === 0x4C/* L */) ? '\u2028' :
        (c === 0x50/* P */) ? '\u2029' : '';
}

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}


function State(input, options) {
  this.input = input;

  this.filename  = options['filename']  || null;
  this.schema    = options['schema']    || DEFAULT_FULL_SCHEMA;
  this.onWarning = options['onWarning'] || null;
  this.legacy    = options['legacy']    || false;

  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap       = this.schema.compiledTypeMap;

  this.length     = input.length;
  this.position   = 0;
  this.line       = 0;
  this.lineStart  = 0;
  this.lineIndent = 0;

  this.documents = [];

}


function generateError(state, message) {
  return new YAMLException(
    message,
    new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  var error = generateError(state, message);

  if (state.onWarning) {
    state.onWarning.call(null, error);
  } else {
    throw error;
  }
}


var directiveHandlers = {

  'YAML': function handleYamlDirective(state, name, args) {

      var match, major, minor;

      if (null !== state.version) {
        throwError(state, 'duplication of %YAML directive');
      }

      if (1 !== args.length) {
        throwError(state, 'YAML directive accepts exactly one argument');
      }

      match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

      if (null === match) {
        throwError(state, 'ill-formed argument of the YAML directive');
      }

      major = parseInt(match[1], 10);
      minor = parseInt(match[2], 10);

      if (1 !== major) {
        throwError(state, 'unacceptable YAML version of the document');
      }

      state.version = args[0];
      state.checkLineBreaks = (minor < 2);

      if (1 !== minor && 2 !== minor) {
        throwWarning(state, 'unsupported YAML version of the document');
      }
    },

  'TAG': function handleTagDirective(state, name, args) {

      var handle, prefix;

      if (2 !== args.length) {
        throwError(state, 'TAG directive accepts exactly two arguments');
      }

      handle = args[0];
      prefix = args[1];

      if (!PATTERN_TAG_HANDLE.test(handle)) {
        throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
      }

      if (_hasOwnProperty.call(state.tagMap, handle)) {
        throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
      }

      if (!PATTERN_TAG_URI.test(prefix)) {
        throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
      }

      state.tagMap[handle] = prefix;
    }
};


function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start < end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length;
           _position < _length;
           _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(0x09 === _character ||
              0x20 <= _character && _character <= 0x10FFFF)) {
          throwError(state, 'expected valid JSON character');
        }
      }
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source) {
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) {
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty.call(destination, key)) {
      destination[key] = source[key];
    }
  }
}

function storeMappingPair(state, _result, keyTag, keyNode, valueNode) {
  var index, quantity;

  keyNode = String(keyNode);

  if (null === _result) {
    _result = {};
  }

  if ('tag:yaml.org,2002:merge' === keyTag) {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index]);
      }
    } else {
      mergeMappings(state, _result, valueNode);
    }
  } else {
    _result[keyNode] = valueNode;
  }

  return _result;
}

function readLineBreak(state) {
  var ch;

  ch = state.input.charCodeAt(state.position);

  if (0x0A/* LF */ === ch) {
    state.position++;
  } else if (0x0D/* CR */ === ch) {
    state.position++;
    if (0x0A/* LF */ === state.input.charCodeAt(state.position)) {
      state.position++;
    }
  } else {
    throwError(state, 'a line break is expected');
  }

  state.line += 1;
  state.lineStart = state.position;
}

function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (0 !== ch) {
    while (is_WHITE_SPACE(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (allowComments && 0x23/* # */ === ch) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && 0 !== ch);
    }

    if (is_EOL(ch)) {
      readLineBreak(state);

      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (0x20/* Space */ === ch) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }

      if (state.lineIndent < checkIndent) {
        throwWarning(state, 'deficient indentation');
      }
    } else {
      break;
    }
  }

  return lineBreaks;
}

function testDocumentSeparator(state) {
  var _position = state.position,
      ch;

  ch = state.input.charCodeAt(_position);
  if ((0x2D/* - */ === ch || 0x2E/* . */ === ch) &&
      state.input.charCodeAt(_position + 1) === ch &&
      state.input.charCodeAt(_position+ 2) === ch) {

    _position += 3;

    ch = state.input.charCodeAt(_position);

    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }

  return false;
}

function writeFoldedLines(state, count) {
  if (1 === count) {
    state.result += ' ';
  } else if (count > 1) {
    state.result += common.repeat('\n', count - 1);
  }
}


function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (is_WS_OR_EOL(ch)             ||
      is_FLOW_INDICATOR(ch)        ||
      0x23/* # */           === ch ||
      0x26/* & */           === ch ||
      0x2A/* * */           === ch ||
      0x21/* ! */           === ch ||
      0x7C/* | */           === ch ||
      0x3E/* > */           === ch ||
      0x27/* ' */           === ch ||
      0x22/* " */           === ch ||
      0x25/* % */           === ch ||
      0x40/* @ */           === ch ||
      0x60/* ` */           === ch) {
    return false;
  }

  if (0x3F/* ? */ === ch || 0x2D/* - */ === ch) {
    following = state.input.charCodeAt(state.position + 1);

    if (is_WS_OR_EOL(following) ||
        withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }

  state.kind = 'scalar';
  state.result = '';
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (0 !== ch) {
    if (0x3A/* : */ === ch) {
      following = state.input.charCodeAt(state.position+1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }

    } else if (0x23/* # */ === ch) {
      preceding = state.input.charCodeAt(state.position - 1);

      if (is_WS_OR_EOL(preceding)) {
        break;
      }

    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
               withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;

    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);

      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }

    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }

    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }

    ch = state.input.charCodeAt(++state.position);
  }

  captureSegment(state, captureStart, captureEnd, false);

  if (state.result) {
    return true;
  } else {
    state.kind = _kind;
    state.result = _result;
    return false;
  }
}

function readSingleQuotedScalar(state, nodeIndent) {
  var ch,
      captureStart, captureEnd;

  ch = state.input.charCodeAt(state.position);

  if (0x27/* ' */ !== ch) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while (0 !== (ch = state.input.charCodeAt(state.position))) {
    if (0x27/* ' */ === ch) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (0x27/* ' */ === ch) {
        captureStart = captureEnd = state.position;
        state.position++;
      } else {
        return true;
      }

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a single quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a single quoted scalar');
}

function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart,
      captureEnd,
      hexLength,
      hexResult,
      tmp, tmpEsc,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (0x22/* " */ !== ch) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while (0 !== (ch = state.input.charCodeAt(state.position))) {
    if (0x22/* " */ === ch) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;

    } else if (0x5C/* \ */ === ch) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;

      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;

        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);

          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;

          } else {
            throwError(state, 'expected hexadecimal character');
          }
        }

        state.result += String.fromCharCode(hexResult);
        state.position++;

      } else {
        throwError(state, 'unknown escape sequence');
      }

      captureStart = captureEnd = state.position;

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a double quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a double quoted scalar');
}

function readFlowCollection(state, nodeIndent) {
  var readNext = true,
      _line,
      _tag     = state.tag,
      _result,
      _anchor  = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B/* [ */) {
    terminator = 0x5D/* ] */;
    isMapping = false;
    _result = [];
  } else if (ch === 0x7B/* { */) {
    terminator = 0x7D/* } */;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }

  if (null !== state.anchor) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(++state.position);

  while (0 !== ch) {
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? 'mapping' : 'sequence';
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, 'missed comma between flow collection entries');
    }

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (0x3F/* ? */ === ch) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) && 0x3A/* : */ === ch) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }

    if (isMapping) {
      storeMappingPair(state, _result, keyTag, keyNode, valueNode);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, keyTag, keyNode, valueNode));
    } else {
      _result.push(keyNode);
    }

    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (0x2C/* , */ === ch) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }

  throwError(state, 'unexpected end of the stream within a flow collection');
}

function readBlockScalar(state, nodeIndent) {
  var captureStart,
      folding,
      chomping       = CHOMPING_CLIP,
      detectedIndent = false,
      textIndent     = nodeIndent,
      emptyLines     = 0,
      atMoreIndented = false,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C/* | */) {
    folding = false;
  } else if (ch === 0x3E/* > */) {
    folding = true;
  } else {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';

  while (0 !== ch) {
    ch = state.input.charCodeAt(++state.position);

    if (0x2B/* + */ === ch || 0x2D/* - */ === ch) {
      if (CHOMPING_CLIP === chomping) {
        chomping = (0x2B/* + */ === ch) ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, 'repeat of a chomping mode identifier');
      }

    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, 'repeat of an indentation width identifier');
      }

    } else {
      break;
    }
  }

  if (is_WHITE_SPACE(ch)) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (is_WHITE_SPACE(ch));

    if (0x23/* # */ === ch) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (!is_EOL(ch) && (0 !== ch));
    }
  }

  while (0 !== ch) {
    readLineBreak(state);
    state.lineIndent = 0;

    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent < textIndent) &&
           (0x20/* Space */ === ch)) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }

    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }

    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat('\n', emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (detectedIndent) { // i.e. only if the scalar is not empty.
          state.result += '\n';
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat('\n', emptyLines + 1);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat('\n', emptyLines + 1);
      } else if (0 === emptyLines) {
        if (detectedIndent) { // i.e. only if we have already read some scalar content.
          state.result += ' ';
        }
      } else {
        state.result += common.repeat('\n', emptyLines);
      }
    } else {
      if (detectedIndent) {
        state.result += common.repeat('\n', emptyLines + 1);
      } else {
        state.result += common.repeat('\n', emptyLines);
      }
    }

    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!is_EOL(ch) && (0 !== ch))
    { ch = state.input.charCodeAt(++state.position); }

    captureSegment(state, captureStart, state.position, false);
  }

  return true;
}

function readBlockSequence(state, nodeIndent) {
  var _line,
      _tag      = state.tag,
      _anchor   = state.anchor,
      _result   = [],
      following,
      detected  = false,
      ch;

  if (null !== state.anchor) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (0 !== ch) {

    if (0x2D/* - */ !== ch) {
      break;
    }

    following = state.input.charCodeAt(state.position + 1);

    if (!is_WS_OR_EOL(following)) {
      break;
    }

    detected = true;
    state.position++;

    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent > nodeIndent) && (0 !== ch)) {
      throwError(state, 'bad indentation of a sequence entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'sequence';
    state.result = _result;
    return true;
  } else {
    return false;
  }
}

function readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
      allowCompact,
      _line,
      _tag          = state.tag,
      _anchor       = state.anchor,
      _result       = {},
      keyTag        = null,
      keyNode       = null,
      valueNode     = null,
      atExplicitKey = false,
      detected      = false,
      ch;

  if (null !== state.anchor) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (0 !== ch) {
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.

    //
    //
    if ((0x3F/* ? */ === ch || 0x3A/* : */  === ch) && is_WS_OR_EOL(following)) {

      if (0x3F/* ? */ === ch) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, keyTag, keyNode, null);
          keyTag = keyNode = valueNode = null;
        }

        detected = true;
        atExplicitKey = true;
        allowCompact = true;

      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;

      } else {
        throwError(state, 'incomplete explicit mapping pair; a key node is missed');
      }

      state.position += 1;
      ch = following;

    //
    //
    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {

      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);

        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (0x3A/* : */ === ch) {
          ch = state.input.charCodeAt(++state.position);

          if (!is_WS_OR_EOL(ch)) {
            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
          }

          if (atExplicitKey) {
            storeMappingPair(state, _result, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;

        } else if (detected) {
          throwError(state, 'can not read an implicit mapping pair; a colon is missed');

        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }

      } else if (detected) {
        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of `composeNode`.
      }

    } else {
      break; // Reading is done. Go to the epilogue.
    }

    //
    //
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }

      if (!atExplicitKey) {
        storeMappingPair(state, _result, keyTag, keyNode, valueNode);
        keyTag = keyNode = valueNode = null;
      }

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }

    if (state.lineIndent > nodeIndent && (0 !== ch)) {
      throwError(state, 'bad indentation of a mapping entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  //
  //
  if (atExplicitKey) {
    storeMappingPair(state, _result, keyTag, keyNode, null);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'mapping';
    state.result = _result;
  }

  return detected;
}

function readTagProperty(state) {
  var _position,
      isVerbatim = false,
      isNamed    = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (0x21/* ! */ !== ch) {
    return false;
  }

  if (null !== state.tag) {
    throwError(state, 'duplication of a tag property');
  }

  ch = state.input.charCodeAt(++state.position);

  if (0x3C/* < */ === ch) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);

  } else if (0x21/* ! */ === ch) {
    isNamed = true;
    tagHandle = '!!';
    ch = state.input.charCodeAt(++state.position);

  } else {
    tagHandle = '!';
  }

  _position = state.position;

  if (isVerbatim) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (0 !== ch && 0x3E/* > */ !== ch);

    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, 'unexpected end of the stream within a verbatim tag');
    }
  } else {
    while (0 !== ch && !is_WS_OR_EOL(ch)) {

      if (0x21/* ! */ === ch) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);

          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, 'named tag handle cannot contain such characters');
          }

          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, 'tag suffix cannot contain exclamation marks');
        }
      }

      ch = state.input.charCodeAt(++state.position);
    }

    tagName = state.input.slice(_position, state.position);

    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, 'tag suffix cannot contain flow indicator characters');
    }
  }

  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, 'tag name cannot contain such characters: ' + tagName);
  }

  if (isVerbatim) {
    state.tag = tagName;

  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;

  } else if ('!' === tagHandle) {
    state.tag = '!' + tagName;

  } else if ('!!' === tagHandle) {
    state.tag = 'tag:yaml.org,2002:' + tagName;

  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }

  return true;
}

function readAnchorProperty(state) {
  var _position,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (0x26/* & */ !== ch) {
    return false;
  }

  if (null !== state.anchor) {
    throwError(state, 'duplication of an anchor property');
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an anchor node must contain at least one character');
  }

  state.anchor = state.input.slice(_position, state.position);
  return true;
}

function readAlias(state) {
  var _position, alias,
      len = state.length,
      input = state.input,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (0x2A/* * */ !== ch) {
    return false;
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an alias node must contain at least one character');
  }

  alias = state.input.slice(_position, state.position);

  if (!state.anchorMap.hasOwnProperty(alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }

  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}

function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      atNewLine  = false,
      isIndented = true,
      hasContent = false,
      typeIndex,
      typeQuantity,
      type,
      flowIndent,
      blockIndent,
      _result;

  state.tag    = null;
  state.anchor = null;
  state.kind   = null;
  state.result = null;

  allowBlockStyles = allowBlockScalars = allowBlockCollections =
    CONTEXT_BLOCK_OUT === nodeContext ||
    CONTEXT_BLOCK_IN  === nodeContext;

  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;

      if (state.lineIndent === parentIndent) {
        isIndented = false;

      } else if (state.lineIndent > parentIndent) {
        isIndented = true;

      } else {
        return false;
      }
    }
  }

  if (isIndented) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;

        if (state.lineIndent > parentIndent) {
          isIndented = true;
          allowBlockCollections = allowBlockStyles;

        } else if (state.lineIndent === parentIndent) {
          isIndented = false;
          allowBlockCollections = allowBlockStyles;

        } else {
          return true;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }

  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }

  if (isIndented || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }

    blockIndent = state.position - state.lineStart;

    if (isIndented) {
      if (allowBlockCollections &&
          (readBlockSequence(state, blockIndent) ||
           readBlockMapping(state, blockIndent, flowIndent)) ||
          readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
            readSingleQuotedScalar(state, flowIndent) ||
            readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;

        } else if (readAlias(state)) {
          hasContent = true;

          if (null !== state.tag || null !== state.anchor) {
            throwError(state, 'alias node should not have any properties');
          }

        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;

          if (null === state.tag) {
            state.tag = '?';
          }
        }

        if (null !== state.anchor) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }

  if (null !== state.tag && '!' !== state.tag) {
    if ('?' === state.tag) {
      for (typeIndex = 0, typeQuantity = state.implicitTypes.length;
           typeIndex < typeQuantity;
           typeIndex += 1) {
        type = state.implicitTypes[typeIndex];
        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
          state.result = type.construct(state.result);
          state.tag = type.tag;
          if (null !== state.anchor) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (_hasOwnProperty.call(state.typeMap, state.tag)) {
      type = state.typeMap[state.tag];

      if (null !== state.result && type.kind !== state.kind) {
        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
      }

      if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched
        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
      } else {
        state.result = type.construct(state.result);
        if (null !== state.anchor) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      throwWarning(state, 'unknown tag !<' + state.tag + '>');
    }
  }

  return null !== state.tag || null !== state.anchor || hasContent;
}

function readDocument(state) {
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = {};
  state.anchorMap = {};

  while (0 !== (ch = state.input.charCodeAt(state.position))) {
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent > 0 || 0x25/* % */ !== ch) {
      break;
    }

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (0 !== ch && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length < 1) {
      throwError(state, 'directive name must not be less than one character in length');
    }

    while (0 !== ch) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (0x23/* # */ === ch) {
        do { ch = state.input.charCodeAt(++state.position); }
        while (0 !== ch && !is_EOL(ch));
        break;
      }

      if (is_EOL(ch)) {
        break;
      }

      _position = state.position;

      while (0 !== ch && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveArgs.push(state.input.slice(_position, state.position));
    }

    if (0 !== ch) {
      readLineBreak(state);
    }

    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }

  skipSeparationSpace(state, true, -1);

  if (0 === state.lineIndent &&
      0x2D/* - */ === state.input.charCodeAt(state.position) &&
      0x2D/* - */ === state.input.charCodeAt(state.position + 1) &&
      0x2D/* - */ === state.input.charCodeAt(state.position + 2)) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);

  } else if (hasDirectives) {
    throwError(state, 'directives end mark is expected');
  }

  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks &&
      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
  }

  state.documents.push(state.result);

  if (state.position === state.lineStart && testDocumentSeparator(state)) {

    if (0x2E/* . */ === state.input.charCodeAt(state.position)) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }

  if (state.position < (state.length - 1)) {
    throwError(state, 'end of the stream or a document separator is expected');
  } else {
    return;
  }
}


function loadDocuments(input, options) {
  input = String(input);
  options = options || {};

  if (0 !== input.length &&
      0x0A/* LF */ !== input.charCodeAt(input.length - 1) &&
      0x0D/* CR */ !== input.charCodeAt(input.length - 1)) {
    input += '\n';
  }

  var state = new State(input, options);

  if (PATTERN_NON_PRINTABLE.test(state.input)) {
    throwError(state, 'the stream contains non-printable characters');
  }
  state.input += '\0';

  while (0x20/* Space */ === state.input.charCodeAt(state.position)) {
    state.lineIndent += 1;
    state.position += 1;
  }

  while (state.position < (state.length - 1)) {
    readDocument(state);
  }

  return state.documents;
}


function loadAll(input, iterator, options) {
  var documents = loadDocuments(input, options), index, length;

  for (index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}


function load(input, options) {
  var documents = loadDocuments(input, options), index, length;

  if (0 === documents.length) {
    return undefined;
  } else if (1 === documents.length) {
    return documents[0];
  } else {
    throw new YAMLException('expected a single document in the stream, but found more');
  }
}


function safeLoadAll(input, output, options) {
  loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


function safeLoad(input, options) {
  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


module.exports.loadAll     = loadAll;
module.exports.load        = load;
module.exports.safeLoadAll = safeLoadAll;
module.exports.safeLoad    = safeLoad;

},{"./common":2,"./exception":4,"./mark":6,"./schema/default_full":9,"./schema/default_safe":10}],6:[function(require,module,exports){
'use strict';


var common = require('./common');


function Mark(name, buffer, position, line, column) {
  this.name     = name;
  this.buffer   = buffer;
  this.position = position;
  this.line     = line;
  this.column   = column;
}


Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
  var head, start, tail, end, snippet;

  if (!this.buffer) {
    return null;
  }

  indent = indent || 4;
  maxLength = maxLength || 75;

  head = '';
  start = this.position;

  while (start > 0 && -1 === '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1))) {
    start -= 1;
    if (this.position - start > (maxLength / 2 - 1)) {
      head = ' ... ';
      start += 5;
      break;
    }
  }

  tail = '';
  end = this.position;

  while (end < this.buffer.length && -1 === '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end))) {
    end += 1;
    if (end - this.position > (maxLength / 2 - 1)) {
      tail = ' ... ';
      end -= 5;
      break;
    }
  }

  snippet = this.buffer.slice(start, end);

  return common.repeat(' ', indent) + head + snippet + tail + '\n' +
         common.repeat(' ', indent + this.position - start + head.length) + '^';
};


Mark.prototype.toString = function toString(compact) {
  var snippet, where = '';

  if (this.name) {
    where += 'in "' + this.name + '" ';
  }

  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);

  if (!compact) {
    snippet = this.getSnippet();

    if (snippet) {
      where += ':\n' + snippet;
    }
  }

  return where;
};


module.exports = Mark;

},{"./common":2}],7:[function(require,module,exports){
'use strict';


var common        = require('./common');
var YAMLException = require('./exception');
var Type          = require('./type');


function compileList(schema, name, result) {
  var exclude = [];

  schema.include.forEach(function (includedSchema) {
    result = compileList(includedSchema, name, result);
  });

  schema[name].forEach(function (currentType) {
    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag) {
        exclude.push(previousIndex);
      }
    });

    result.push(currentType);
  });

  return result.filter(function (type, index) {
    return -1 === exclude.indexOf(index);
  });
}


function compileMap(/* lists... */) {
  var result = {}, index, length;

  function collectType(type) {
    result[type.tag] = type;
  }

  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }

  return result;
}


function Schema(definition) {
  this.include  = definition.include  || [];
  this.implicit = definition.implicit || [];
  this.explicit = definition.explicit || [];

  this.implicit.forEach(function (type) {
    if (type.loadKind && 'scalar' !== type.loadKind) {
      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }
  });

  this.compiledImplicit = compileList(this, 'implicit', []);
  this.compiledExplicit = compileList(this, 'explicit', []);
  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);
}


Schema.DEFAULT = null;


Schema.create = function createSchema() {
  var schemas, types;

  switch (arguments.length) {
  case 1:
    schemas = Schema.DEFAULT;
    types = arguments[0];
    break;

  case 2:
    schemas = arguments[0];
    types = arguments[1];
    break;

  default:
    throw new YAMLException('Wrong number of arguments for Schema.create function');
  }

  schemas = common.toArray(schemas);
  types = common.toArray(types);

  if (!schemas.every(function (schema) { return schema instanceof Schema; })) {
    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
  }

  if (!types.every(function (type) { return type instanceof Type; })) {
    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
  }

  return new Schema({
    include: schemas,
    explicit: types
  });
};


module.exports = Schema;

},{"./common":2,"./exception":4,"./type":13}],8:[function(require,module,exports){
//

'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  include: [
    require('./json')
  ]
});

},{"../schema":7,"./json":12}],9:[function(require,module,exports){
//
//

'use strict';


var Schema = require('../schema');


module.exports = Schema.DEFAULT = new Schema({
  include: [
    require('./default_safe')
  ],
  explicit: [
    require('../type/js/undefined'),
    require('../type/js/regexp'),
    require('../type/js/function')
  ]
});

},{"../schema":7,"../type/js/function":18,"../type/js/regexp":19,"../type/js/undefined":20,"./default_safe":10}],10:[function(require,module,exports){
//

'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  include: [
    require('./core')
  ],
  implicit: [
    require('../type/timestamp'),
    require('../type/merge')
  ],
  explicit: [
    require('../type/binary'),
    require('../type/omap'),
    require('../type/pairs'),
    require('../type/set')
  ]
});

},{"../schema":7,"../type/binary":14,"../type/merge":22,"../type/omap":24,"../type/pairs":25,"../type/set":27,"../type/timestamp":29,"./core":8}],11:[function(require,module,exports){

'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  explicit: [
    require('../type/str'),
    require('../type/seq'),
    require('../type/map')
  ]
});

},{"../schema":7,"../type/map":21,"../type/seq":26,"../type/str":28}],12:[function(require,module,exports){
//

'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  include: [
    require('./failsafe')
  ],
  implicit: [
    require('../type/null'),
    require('../type/bool'),
    require('../type/int'),
    require('../type/float')
  ]
});

},{"../schema":7,"../type/bool":15,"../type/float":16,"../type/int":17,"../type/null":23,"./failsafe":11}],13:[function(require,module,exports){
'use strict';

var YAMLException = require('./exception');

var TYPE_CONSTRUCTOR_OPTIONS = [
  'kind',
  'resolve',
  'construct',
  'instanceOf',
  'predicate',
  'represent',
  'defaultStyle',
  'styleAliases'
];

var YAML_NODE_KINDS = [
  'scalar',
  'sequence',
  'mapping'
];

function compileStyleAliases(map) {
  var result = {};

  if (null !== map) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function Type(tag, options) {
  options = options || {};

  Object.keys(options).forEach(function (name) {
    if (-1 === TYPE_CONSTRUCTOR_OPTIONS.indexOf(name)) {
      throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.tag          = tag;
  this.kind         = options['kind']         || null;
  this.resolve      = options['resolve']      || function () { return true; };
  this.construct    = options['construct']    || function (data) { return data; };
  this.instanceOf   = options['instanceOf']   || null;
  this.predicate    = options['predicate']    || null;
  this.represent    = options['represent']    || null;
  this.defaultStyle = options['defaultStyle'] || null;
  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);

  if (-1 === YAML_NODE_KINDS.indexOf(this.kind)) {
    throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}

module.exports = Type;

},{"./exception":4}],14:[function(require,module,exports){
'use strict';
var NodeBuffer = require('buffer').Buffer;
var Type       = require('../type');
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';


function resolveYamlBinary(data) {
  var code, idx, bitlen = 0, len = 0, max = data.length, map = BASE64_MAP;
  for (idx = 0; idx < max; idx ++) {
    code = map.indexOf(data.charAt(idx));
    if (code > 64) { continue; }
    if (code < 0) { return false; }

    bitlen += 6;
  }
  return (bitlen % 8) === 0;
}

function constructYamlBinary(data) {
  var code, idx, tailbits,
      input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
      max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = [];
  for (idx = 0; idx < max; idx++) {
    if ((idx % 4 === 0) && idx) {
      result.push((bits >> 16) & 0xFF);
      result.push((bits >> 8) & 0xFF);
      result.push(bits & 0xFF);
    }

    bits = (bits << 6) | map.indexOf(input.charAt(idx));
  }
  tailbits = (max % 4)*6;

  if (tailbits === 0) {
    result.push((bits >> 16) & 0xFF);
    result.push((bits >> 8) & 0xFF);
    result.push(bits & 0xFF);
  } else if (tailbits === 18) {
    result.push((bits >> 10) & 0xFF);
    result.push((bits >> 2) & 0xFF);
  } else if (tailbits === 12) {
    result.push((bits >> 4) & 0xFF);
  }
  if (NodeBuffer) {
    return new NodeBuffer(result);
  }

  return result;
}

function representYamlBinary(object /*, style*/) {
  var result = '', bits = 0, idx, tail,
      max = object.length,
      map = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if ((idx % 3 === 0) && idx) {
      result += map[(bits >> 18) & 0x3F];
      result += map[(bits >> 12) & 0x3F];
      result += map[(bits >> 6) & 0x3F];
      result += map[bits & 0x3F];
    }

    bits = (bits << 8) + object[idx];
  }
  tail = max % 3;

  if (tail === 0) {
    result += map[(bits >> 18) & 0x3F];
    result += map[(bits >> 12) & 0x3F];
    result += map[(bits >> 6) & 0x3F];
    result += map[bits & 0x3F];
  } else if (tail === 2) {
    result += map[(bits >> 10) & 0x3F];
    result += map[(bits >> 4) & 0x3F];
    result += map[(bits << 2) & 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[(bits >> 2) & 0x3F];
    result += map[(bits << 4) & 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function isBinary(object) {
  return NodeBuffer && NodeBuffer.isBuffer(object);
}

module.exports = new Type('tag:yaml.org,2002:binary', {
  kind: 'scalar',
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});

},{"../type":13,"buffer":30}],15:[function(require,module,exports){
'use strict';

var Type = require('../type');

function resolveYamlBoolean(data) {
  var max = data.length;

  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
}

function constructYamlBoolean(data) {
  return data === 'true' ||
         data === 'True' ||
         data === 'TRUE';
}

function isBoolean(object) {
  return '[object Boolean]' === Object.prototype.toString.call(object);
}

module.exports = new Type('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function (object) { return object ? 'true' : 'false'; },
    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
    camelcase: function (object) { return object ? 'True' : 'False'; }
  },
  defaultStyle: 'lowercase'
});

},{"../type":13}],16:[function(require,module,exports){
'use strict';

var common = require('../common');
var Type   = require('../type');

var YAML_FLOAT_PATTERN = new RegExp(
  '^(?:[-+]?(?:[0-9][0-9_]*)\\.[0-9_]*(?:[eE][-+][0-9]+)?' +
  '|\\.[0-9_]+(?:[eE][-+][0-9]+)?' +
  '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
  '|[-+]?\\.(?:inf|Inf|INF)' +
  '|\\.(?:nan|NaN|NAN))$');

function resolveYamlFloat(data) {
  var value, sign, base, digits;

  if (!YAML_FLOAT_PATTERN.test(data)) {
    return false;
  }
  return true;
}

function constructYamlFloat(data) {
  var value, sign, base, digits;

  value  = data.replace(/_/g, '').toLowerCase();
  sign   = '-' === value[0] ? -1 : 1;
  digits = [];

  if (0 <= '+-'.indexOf(value[0])) {
    value = value.slice(1);
  }

  if ('.inf' === value) {
    return (1 === sign) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

  } else if ('.nan' === value) {
    return NaN;

  } else if (0 <= value.indexOf(':')) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseFloat(v, 10));
    });

    value = 0.0;
    base = 1;

    digits.forEach(function (d) {
      value += d * base;
      base *= 60;
    });

    return sign * value;

  } else {
    return sign * parseFloat(value, 10);
  }
}

function representYamlFloat(object, style) {
  if (isNaN(object)) {
    switch (style) {
    case 'lowercase':
      return '.nan';
    case 'uppercase':
      return '.NAN';
    case 'camelcase':
      return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
    case 'lowercase':
      return '.inf';
    case 'uppercase':
      return '.INF';
    case 'camelcase':
      return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
    case 'lowercase':
      return '-.inf';
    case 'uppercase':
      return '-.INF';
    case 'camelcase':
      return '-.Inf';
    }
  } else if (common.isNegativeZero(object)) {
    return '-0.0';
  } else {
    return object.toString(10);
  }
}

function isFloat(object) {
  return ('[object Number]' === Object.prototype.toString.call(object)) &&
         (0 !== object % 1 || common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:float', {
  kind: 'scalar',
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: 'lowercase'
});

},{"../common":2,"../type":13}],17:[function(require,module,exports){
'use strict';

var common = require('../common');
var Type   = require('../type');

function isHexCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
         ((0x61/* a */ <= c) && (c <= 0x66/* f */));
}

function isOctCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
}

function isDecCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
}

function resolveYamlInteger(data) {
  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;

  if (!max) { return false; }

  ch = data[index];
  if (ch === '-' || ch === '+') {
    ch = data[++index];
  }

  if (ch === '0') {
    if (index+1 === max) { return true; }
    ch = data[++index];
    if (ch === 'b') {
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') { continue; }
        if (ch !== '0' && ch !== '1') {
          return false;
        }
        hasDigits = true;
      }
      return hasDigits;
    }


    if (ch === 'x') {
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') { continue; }
        if (!isHexCode(data.charCodeAt(index))) {
          return false;
        }
        hasDigits = true;
      }
      return hasDigits;
    }
    for (; index < max; index++) {
      ch = data[index];
      if (ch === '_') { continue; }
      if (!isOctCode(data.charCodeAt(index))) {
        return false;
      }
      hasDigits = true;
    }
    return hasDigits;
  }
  for (; index < max; index++) {
    ch = data[index];
    if (ch === '_') { continue; }
    if (ch === ':') { break; }
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }

  if (!hasDigits) { return false; }
  if (ch !== ':') { return true; }
  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}

function constructYamlInteger(data) {
  var value = data, sign = 1, ch, base, digits = [];

  if (value.indexOf('_') !== -1) {
    value = value.replace(/_/g, '');
  }

  ch = value[0];

  if (ch === '-' || ch === '+') {
    if (ch === '-') { sign = -1; }
    value = value.slice(1);
    ch = value[0];
  }

  if ('0' === value) {
    return 0;
  }

  if (ch === '0') {
    if (value[1] === 'b') {
      return sign * parseInt(value.slice(2), 2);
    }
    if (value[1] === 'x') {
      return sign * parseInt(value, 16);
    }
    return sign * parseInt(value, 8);

  }

  if (value.indexOf(':') !== -1) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseInt(v, 10));
    });

    value = 0;
    base = 1;

    digits.forEach(function (d) {
      value += (d * base);
      base *= 60;
    });

    return sign * value;

  }

  return sign * parseInt(value, 10);
}

function isInteger(object) {
  return ('[object Number]' === Object.prototype.toString.call(object)) &&
         (0 === object % 1 && !common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:int', {
  kind: 'scalar',
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary:      function (object) { return '0b' + object.toString(2); },
    octal:       function (object) { return '0'  + object.toString(8); },
    decimal:     function (object) { return        object.toString(10); },
    hexadecimal: function (object) { return '0x' + object.toString(16).toUpperCase(); }
  },
  defaultStyle: 'decimal',
  styleAliases: {
    binary:      [ 2,  'bin' ],
    octal:       [ 8,  'oct' ],
    decimal:     [ 10, 'dec' ],
    hexadecimal: [ 16, 'hex' ]
  }
});

},{"../common":2,"../type":13}],18:[function(require,module,exports){
'use strict';

var esprima;
//
//
var Type = require('../../type');

function resolveJavascriptFunction(data) {
  try {
    var source = '(' + data + ')',
        ast    = esprima.parse(source, { range: true }),
        params = [],
        body;

    if ('Program'             !== ast.type         ||
        1                     !== ast.body.length  ||
        'ExpressionStatement' !== ast.body[0].type ||
        'FunctionExpression'  !== ast.body[0].expression.type) {
      return false;
    }

    return true;
  } catch (err) {
    return false;
  }
}

function constructJavascriptFunction(data) {

  var source = '(' + data + ')',
      ast    = esprima.parse(source, { range: true }),
      params = [],
      body;

  if ('Program'             !== ast.type         ||
      1                     !== ast.body.length  ||
      'ExpressionStatement' !== ast.body[0].type ||
      'FunctionExpression'  !== ast.body[0].expression.type) {
    throw new Error('Failed to resolve function');
  }

  ast.body[0].expression.params.forEach(function (param) {
    params.push(param.name);
  });

  body = ast.body[0].expression.body.range;
  return new Function(params, source.slice(body[0]+1, body[1]-1));
}

function representJavascriptFunction(object /*, style*/) {
  return object.toString();
}

function isFunction(object) {
  return '[object Function]' === Object.prototype.toString.call(object);
}

module.exports = new Type('tag:yaml.org,2002:js/function', {
  kind: 'scalar',
  resolve: resolveJavascriptFunction,
  construct: constructJavascriptFunction,
  predicate: isFunction,
  represent: representJavascriptFunction
});

},{"../../type":13,"esprima":"esprima"}],19:[function(require,module,exports){
'use strict';

var Type = require('../../type');

function resolveJavascriptRegExp(data) {
  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';
  if ('/' === regexp[0]) {
    if (tail) {
      modifiers = tail[1];
    }

    if (modifiers.length > 3) { return false; }
    if (regexp[regexp.length - modifiers.length - 1] !== '/') { return false; }

    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  try {
    var dummy = new RegExp(regexp, modifiers);
    return true;
  } catch (error) {
    return false;
  }
}

function constructJavascriptRegExp(data) {
  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';
  if ('/' === regexp[0]) {
    if (tail) {
      modifiers = tail[1];
    }
    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  return new RegExp(regexp, modifiers);
}

function representJavascriptRegExp(object /*, style*/) {
  var result = '/' + object.source + '/';

  if (object.global) {
    result += 'g';
  }

  if (object.multiline) {
    result += 'm';
  }

  if (object.ignoreCase) {
    result += 'i';
  }

  return result;
}

function isRegExp(object) {
  return '[object RegExp]' === Object.prototype.toString.call(object);
}

module.exports = new Type('tag:yaml.org,2002:js/regexp', {
  kind: 'scalar',
  resolve: resolveJavascriptRegExp,
  construct: constructJavascriptRegExp,
  predicate: isRegExp,
  represent: representJavascriptRegExp
});

},{"../../type":13}],20:[function(require,module,exports){
'use strict';

var Type = require('../../type');

function resolveJavascriptUndefined() {
  return true;
}

function constructJavascriptUndefined() {
  return undefined;
}

function representJavascriptUndefined() {
  return '';
}

function isUndefined(object) {
  return 'undefined' === typeof object;
}

module.exports = new Type('tag:yaml.org,2002:js/undefined', {
  kind: 'scalar',
  resolve: resolveJavascriptUndefined,
  construct: constructJavascriptUndefined,
  predicate: isUndefined,
  represent: representJavascriptUndefined
});

},{"../../type":13}],21:[function(require,module,exports){
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:map', {
  kind: 'mapping'
});

},{"../type":13}],22:[function(require,module,exports){
'use strict';

var Type = require('../type');

function resolveYamlMerge(data) {
  return '<<' === data;
}

module.exports = new Type('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge,
});

},{"../type":13}],23:[function(require,module,exports){
'use strict';

var Type = require('../type');

function resolveYamlNull(data) {
  var max = data.length;

  return (max === 1 && data === '~') ||
         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return null === object;
}

module.exports = new Type('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () { return '~';    },
    lowercase: function () { return 'null'; },
    uppercase: function () { return 'NULL'; },
    camelcase: function () { return 'Null'; }
  },
  defaultStyle: 'lowercase'
});

},{"../type":13}],24:[function(require,module,exports){
'use strict';

var Type = require('../type');

var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _toString       = Object.prototype.toString;

function resolveYamlOmap(data) {
  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if ('[object Object]' !== _toString.call(pair)) {
      return false;
    }

    for (pairKey in pair) {
      if (_hasOwnProperty.call(pair, pairKey)) {
        if (!pairHasKey) {
          pairHasKey = true;
        } else {
          return false;
        }
      }
    }

    if (!pairHasKey) {
      return false;
    }

    if (-1 === objectKeys.indexOf(pairKey)) {
      objectKeys.push(pairKey);
    } else {
      return false;
    }
  }

  return true;
}

module.exports = new Type('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap
});

},{"../type":13}],25:[function(require,module,exports){
'use strict';

var Type = require('../type');

var _toString = Object.prototype.toString;

function resolveYamlPairs(data) {
  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    if ('[object Object]' !== _toString.call(pair)) {
      return false;
    }

    keys = Object.keys(pair);

    if (1 !== keys.length) {
      return false;
    }

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return true;
}

function constructYamlPairs(data) {
  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return result;
}

module.exports = new Type('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});

},{"../type":13}],26:[function(require,module,exports){
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:seq', {
  kind: 'sequence'
});

},{"../type":13}],27:[function(require,module,exports){
'use strict';

var Type = require('../type');

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  var key, object = data;

  for (key in object) {
    if (_hasOwnProperty.call(object, key)) {
      if (null !== object[key]) {
        return false;
      }
    }
  }

  return true;
}

module.exports = new Type('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: resolveYamlSet
});

},{"../type":13}],28:[function(require,module,exports){
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:str', {
  kind: 'scalar'
});

},{"../type":13}],29:[function(require,module,exports){
'use strict';

var Type = require('../type');

var YAML_TIMESTAMP_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9]?)'                   + // [2] month
  '-([0-9][0-9]?)'                   + // [3] day
  '(?:(?:[Tt]|[ \\t]+)'              + // ...
  '([0-9][0-9]?)'                    + // [4] hour
  ':([0-9][0-9])'                    + // [5] minute
  ':([0-9][0-9])'                    + // [6] second
  '(?:\\.([0-9]*))?'                 + // [7] fraction
  '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
  '(?::([0-9][0-9]))?))?)?$');         // [11] tz_minute

function resolveYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (null === match) {
    return false;
  }

  return true;
}

function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (null === match) {
    throw new Error('Date resolve error');
  }
  year = +(match[1]);
  month = +(match[2]) - 1; // JS month starts with 0
  day = +(match[3]);

  if (!match[4]) { // no hour
    return new Date(Date.UTC(year, month, day));
  }
  hour = +(match[4]);
  minute = +(match[5]);
  second = +(match[6]);

  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) { // milli-seconds
      fraction += '0';
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +(match[10]);
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if ('-' === match[9]) {
      delta = -delta;
    }
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) {
    date.setTime(date.getTime() - delta);
  }

  return date;
}

function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}

module.exports = new Type('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});

},{"../type":13}],30:[function(require,module,exports){

},{}],"/":[function(require,module,exports){
'use strict';


var yaml = require('./lib/js-yaml.js');


module.exports = yaml;

},{"./lib/js-yaml.js":1}]},{},[])("/")
});
});

define("plugins/c9.ide.language.javascript.eslint/worker/strip-json-comments",[], function(require, exports, module) {

	function stripJsonComments(str) {
		var currentChar;
		var nextChar;
		var insideString = false;
		var insideComment = false;
		var ret = '';

		for (var i = 0; i < str.length; i++) {
			currentChar = str[i];
			nextChar = str[i + 1];

			if (!insideComment && str[i - 1] !== '\\' && currentChar === '"') {
				insideString = !insideString;
			}

			if (insideString) {
				ret += currentChar;
				continue;
			}

			if (!insideComment && currentChar + nextChar === '//') {
				insideComment = 'single';
				i++;
			} else if (insideComment === 'single' && currentChar + nextChar === '\r\n') {
				insideComment = false;
				i++;
				ret += currentChar;
				ret += nextChar;
				continue;
			} else if (insideComment === 'single' && currentChar === '\n') {
				insideComment = false;
			} else if (!insideComment && currentChar + nextChar === '/*') {
				insideComment = 'multi';
				i++;
				continue;
			} else if (insideComment === 'multi' && currentChar + nextChar === '*/') {
				insideComment = false;
				i++;
				continue;
			}

			if (insideComment) {
				continue;
			}

			ret += currentChar;
		}

		return ret;
	}

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = stripJsonComments;
	} else {
		window.stripJsonComments = stripJsonComments;
	}
	
});

define("plugins/c9.ide.language.javascript.eslint/worker/eslint_worker",[], function(require, exports, module) {

var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');
var workerUtil = require('plugins/c9.ide.language/worker_util');
var linter;
var handler = module.exports = Object.create(baseLanguageHandler);
var util = require("plugins/c9.ide.language/worker_util");
var yaml = require("./js-yaml");
var stripJsonComments = require("./strip-json-comments");

function loadLinter(callback) {
    require(["./eslint_browserified"], function(Linter) {
        linter = new Linter();
        callback();
    });
}

var defaultRules;
var defaultEnv = {
    "browser": false,
    "amd": true,
    "builtin": true,
    "node": true,
    "jasmine": false,
    "mocha": true,
    "es6": true,
    "jquery": false,
    "meteor": false,
};
var defaultParserOptions = {
    ecmaFeatures: {
        globalReturn: true, // allow return statements in the global scope
        jsx: true, // enable JSX
        experimentalObjectRestSpread: true
    },
    ecmaVersion: 8,
};
var defaultGlobals = require("plugins/c9.ide.language.javascript/scope_analyzer").GLOBALS;
var userConfig;
var userConfigRaw;

handler.init = function(callback) {
    var rules = defaultRules = {};
    
    rules["handle-callback-err"] = 1;
    rules["no-debugger"] = 1;
    rules["no-undef"] = 1;
    rules["no-inner-declarations"] = [1, "functions"];
    rules["no-native-reassign"] = 1;
    rules["no-new-func"] = 1;
    rules["no-new-wrappers"] = 1;
    rules["no-cond-assign"] = [1, "except-parens"];
    rules["no-debugger"] = 3;
    rules["no-dupe-keys"] = 3;
    rules["no-eval"] = 1;
    rules["no-func-assign"] = 1;
    rules["no-extra-semi"] = 3;
    rules["no-invalid-regexp"] = 1;
    rules["no-irregular-whitespace"] = 3;
    rules["no-negated-in-lhs"] = 1;
    rules["no-regex-spaces"] = 3;
    rules["quote-props"] = 0;
    rules["no-unreachable"] = 1;
    rules["use-isnan"] = 2;
    rules["valid-typeof"] = 1;
    rules["no-redeclare"] = 3;
    rules["no-with"] = 1;
    rules["radix"] = 3;
    rules["no-delete-var"] = 2;
    rules["no-label-var"] = 3;
    rules["no-console"] = 0;
    rules["no-shadow-restricted-names"] = 2;
    rules["handle-callback-err"] = 1;
    rules["no-new-require"] = 2;

    loadConfigFile(true, function(err) {
        if (err) console.error(err);
        util.$watchDir("/", handler);
        util.$onWatchDirChange(onWorkspaceDirChange);
    });
    
    callback();
};

function onWorkspaceDirChange(e) {
    e.data.files.forEach(function(f) {
        if (f.name === ".eslintrc")
            loadConfigFile();
    });
}

function loadConfigFile(initialLoad, callback) {
    util.readFile("/.eslintrc", "utf-8", function onResult(err, data) {
        if (err) return loadConfig(err);
        
        if (data === userConfigRaw)
            return callback && callback();

        userConfigRaw = data;
        var result;
        try {
            result = yaml.safeLoad(stripJsonComments(data));
        }
        catch (e) {
            return loadConfig(e);
        }
        loadConfig(null, result);
    });
    
    function loadConfig(err, result) {
        if (err && !callback)
            util.showError(err);
        userConfig = result;
        if (userConfig && userConfig.rules && userConfig.rules["semi"] != undefined)
            userConfig.semi = true;
        if (!initialLoad)
            util.refreshAllMarkers();
        callback && callback();
    }
}

handler.handlesLanguage = function(language) {
    return language === "javascript" || language == "jsx";
};

handler.analyze = function(value, ast, options, callback) {
    if (options.minimalAnalysis)
        return callback();
    if (!linter) {
        return loadLinter(function() {
            callback(handler.analyzeSync(value, ast, options.path));
        });
    }
    callback(handler.analyzeSync(value, ast, options.path));
};

handler.getMaxFileSizeSupported = function() {
    return .5 * 10 * 1000 * 80;
};

handler.analyzeSync = function(value, ast, path) {
    var doc = this.doc;
    var markers = [];
    if (!workerUtil.isFeatureEnabled("hints"))
        return markers;

    var config = this.isFeatureEnabled("eslintrc") && userConfig || {};

    delete config.parser; // we only support espree

    config.rules = config.rules || defaultRules;
    config.env = config.env || defaultEnv;
    config.globals = config.globals || defaultGlobals;
    config.parserOptions = config.parserOptions || defaultParserOptions;
    if (config.parserOptions.ecmaVersion == null)
        config.parserOptions.ecmaVersion = 8;
    if (config.parserOptions.ecmaFeatures == null)
        config.parserOptions.ecmaFeatures = defaultParserOptions.ecmaFeatures;
    if (config.parserOptions.ecmaFeatures.experimentalObjectRestSpread == null)
        config.parserOptions.ecmaFeatures.experimentalObjectRestSpread = true;

    config.rules["no-unused-vars"] = [
        3,
        {
            vars: "all",
            args: handler.isFeatureEnabled("unusedFunctionArgs") ? "all" : "none"
        }
    ];
    config.rules["react/jsx-uses-vars"] = 2;
    config.rules["no-undef"] =
        handler.isFeatureEnabled("undeclaredVars") ? 1 : 0;
    
    if (!config.semi) {
        config.rules["semi"] =
            handler.isFeatureEnabled("semi") ? 3 : 0;
    }

    var isJson = this.path.match(/\.(json|run|settings|build)$/);
    if (isJson)
        value = "!" + value;

    try {
        var messages = linter.verify(value, config);
    }
    catch (e) {
        console.error(e.stack);
        if (e.message && e.message.match(/rule .* was not found/))
            workerUtil.showError("eslint: " + e.message);
        return [];
    }
    
    messages.forEach(function(m) {
        var level;
        if (m.severity === 2)
            level = "error";
        else if (m.severity === 1)
            level = "warning";
        else
            level = "info";
        
        if (isJson && level !== "error")
            return;
        m.column--;
        m.line--;
        m.endLine--;
        m.endColumn--;
        
        if (m.message.match(/but never used/)) {
            var line = doc.getLine(m.line);
            var target = line.slice(m.column, m.endColumn)
            if (target.toUpperCase() === target && target.toLowerCase() !== target)
                return; // ignore unused constants
            if (target === "h")
                return; // ignore 'h', used in preact
            if (m.severity === 1)
                level = "info";
        }
        if (m.ruleId && m.ruleId.match(/space|spacing/) && m.severity === 1)
            level = "info";
        
        var ec;
        if (m.message.match(/is not defined|was used before it was defined|is already declared|is already defined|unexpected identifier|but never used/i)) {
            var line = doc.getLine(m.line);
            var id = workerUtil.getFollowingIdentifier(line, m.column);
            if (m.message.match(/is already defined/) && line.match("for \\(var " + id))
                return;
            ec = m.column + id.length;
        }
        if (m.message.match(/'([^']*)' is not defined/)) {
            m.message = RegExp.$1 + " is not defined; please fix or add /*global " + RegExp.$1 + "*/";
        }
        if (m.message.match(/missing semicolon/i)) {
            var line = doc.getLine(m.line);
            if (line.substr(m.column).match(/\s*}/))
                return; // allow missing semi at end of block
            if ((m.line === doc.getLength() || m.line === doc.getLength() - 1)
                && line.match(/^\s*\}\)\s*$/))
                return;
            if (m.severity === 1)
                level = "info";
        }
            
        markers.push({
            pos: {
                sl: m.line,
                sc: m.column,
                ec: ec
            },
            type: level,
            level: level !== "info" && level,
            message: m.message
        });
    });
    return markers;
};
    
});

define("acorn/dist/walk",["require", "exports", "module", "./acorn"], function(require, exports, module) {

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.acorn || (g.acorn = {})).walk = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/src\\walk\\index.js":[function(_dereq_,module,exports){
//
//
//
"use strict";

exports.__esModule = true;
exports.simple = simple;
exports.ancestor = ancestor;
exports.recursive = recursive;
exports.findNodeAt = findNodeAt;
exports.findNodeAround = findNodeAround;
exports.findNodeAfter = findNodeAfter;
exports.findNodeBefore = findNodeBefore;
exports.make = make;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function simple(node, visitors, base, state, override) {
  if (!base) base = exports.base;(function c(node, st, override) {
    var type = override || node.type,
        found = visitors[type];
    base[type](node, st, c);
    if (found) found(node, st);
  })(node, state, override);
}
function ancestor(node, visitors, base, state) {
  if (!base) base = exports.base;
  if (!state) state = [];(function c(node, st, override) {
    var type = override || node.type,
        found = visitors[type];
    if (node != st[st.length - 1]) {
      st = st.slice();
      st.push(node);
    }
    base[type](node, st, c);
    if (found) found(node, st);
  })(node, state);
}
function recursive(node, state, funcs, base, override) {
  var visitor = funcs ? exports.make(funcs, base) : base;(function c(node, st, override) {
    visitor[override || node.type](node, st, c);
  })(node, state, override);
}

function makeTest(test) {
  if (typeof test == "string") return function (type) {
    return type == test;
  };else if (!test) return function () {
    return true;
  };else return test;
}

var Found = function Found(node, state) {


  this.node = node;this.state = state;
};
function findNodeAt(node, start, end, test, base, state) {
  test = makeTest(test);
  if (!base) base = exports.base;
  try {
    ;(function c(node, st, override) {
      var type = override || node.type;
      if ((start == null || node.start <= start) && (end == null || node.end >= end)) base[type](node, st, c);
      if ((start == null || node.start == start) && (end == null || node.end == end) && test(type, node)) throw new Found(node, st);
    })(node, state);
  } catch (e) {
    if (e instanceof Found) return e;
    throw e;
  }
}
function findNodeAround(node, pos, test, base, state) {
  test = makeTest(test);
  if (!base) base = exports.base;
  try {
    ;(function c(node, st, override) {
      var type = override || node.type;
      if (node.start > pos || node.end < pos) return;
      base[type](node, st, c);
      if (test(type, node)) throw new Found(node, st);
    })(node, state);
  } catch (e) {
    if (e instanceof Found) return e;
    throw e;
  }
}
function findNodeAfter(node, pos, test, base, state) {
  test = makeTest(test);
  if (!base) base = exports.base;
  try {
    ;(function c(node, st, override) {
      if (node.end < pos) return;
      var type = override || node.type;
      if (node.start >= pos && test(type, node)) throw new Found(node, st);
      base[type](node, st, c);
    })(node, state);
  } catch (e) {
    if (e instanceof Found) return e;
    throw e;
  }
}
function findNodeBefore(node, pos, test, base, state) {
  test = makeTest(test);
  if (!base) base = exports.base;
  var max = undefined;(function c(node, st, override) {
    if (node.start > pos) return;
    var type = override || node.type;
    if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node)) max = new Found(node, st);
    base[type](node, st, c);
  })(node, state);
  return max;
}
function make(funcs, base) {
  if (!base) base = exports.base;
  var visitor = {};
  for (var type in base) visitor[type] = base[type];
  for (var type in funcs) visitor[type] = funcs[type];
  return visitor;
}

function skipThrough(node, st, c) {
  c(node, st);
}
function ignore(_node, _st, _c) {}
var base = {};

exports.base = base;
base.Program = base.BlockStatement = function (node, st, c) {
  for (var i = 0; i < node.body.length; ++i) {
    c(node.body[i], st, "Statement");
  }
};
base.Statement = skipThrough;
base.EmptyStatement = ignore;
base.ExpressionStatement = base.ParenthesizedExpression = function (node, st, c) {
  return c(node.expression, st, "Expression");
};
base.IfStatement = function (node, st, c) {
  c(node.test, st, "Expression");
  c(node.consequent, st, "Statement");
  if (node.alternate) c(node.alternate, st, "Statement");
};
base.LabeledStatement = function (node, st, c) {
  return c(node.body, st, "Statement");
};
base.BreakStatement = base.ContinueStatement = ignore;
base.WithStatement = function (node, st, c) {
  c(node.object, st, "Expression");
  c(node.body, st, "Statement");
};
base.SwitchStatement = function (node, st, c) {
  c(node.discriminant, st, "Expression");
  for (var i = 0; i < node.cases.length; ++i) {
    var cs = node.cases[i];
    if (cs.test) c(cs.test, st, "Expression");
    for (var j = 0; j < cs.consequent.length; ++j) {
      c(cs.consequent[j], st, "Statement");
    }
  }
};
base.ReturnStatement = base.YieldExpression = function (node, st, c) {
  if (node.argument) c(node.argument, st, "Expression");
};
base.ThrowStatement = base.SpreadElement = function (node, st, c) {
  return c(node.argument, st, "Expression");
};
base.TryStatement = function (node, st, c) {
  c(node.block, st, "Statement");
  if (node.handler) {
    c(node.handler.param, st, "Pattern");
    c(node.handler.body, st, "ScopeBody");
  }
  if (node.finalizer) c(node.finalizer, st, "Statement");
};
base.WhileStatement = base.DoWhileStatement = function (node, st, c) {
  c(node.test, st, "Expression");
  c(node.body, st, "Statement");
};
base.ForStatement = function (node, st, c) {
  if (node.init) c(node.init, st, "ForInit");
  if (node.test) c(node.test, st, "Expression");
  if (node.update) c(node.update, st, "Expression");
  c(node.body, st, "Statement");
};
base.ForInStatement = base.ForOfStatement = function (node, st, c) {
  c(node.left, st, "ForInit");
  c(node.right, st, "Expression");
  c(node.body, st, "Statement");
};
base.ForInit = function (node, st, c) {
  if (node.type == "VariableDeclaration") c(node, st);else c(node, st, "Expression");
};
base.DebuggerStatement = ignore;

base.FunctionDeclaration = function (node, st, c) {
  return c(node, st, "Function");
};
base.VariableDeclaration = function (node, st, c) {
  for (var i = 0; i < node.declarations.length; ++i) {
    c(node.declarations[i], st);
  }
};
base.VariableDeclarator = function (node, st, c) {
  c(node.id, st, "Pattern");
  if (node.init) c(node.init, st, "Expression");
};

base.Function = function (node, st, c) {
  if (node.id) c(node.id, st, "Pattern");
  for (var i = 0; i < node.params.length; i++) {
    c(node.params[i], st, "Pattern");
  }c(node.body, st, node.expression ? "ScopeExpression" : "ScopeBody");
};
base.ScopeBody = function (node, st, c) {
  return c(node, st, "Statement");
};
base.ScopeExpression = function (node, st, c) {
  return c(node, st, "Expression");
};

base.Pattern = function (node, st, c) {
  if (node.type == "Identifier") c(node, st, "VariablePattern");else if (node.type == "MemberExpression") c(node, st, "MemberPattern");else c(node, st);
};
base.VariablePattern = ignore;
base.MemberPattern = skipThrough;
base.RestElement = function (node, st, c) {
  return c(node.argument, st, "Pattern");
};
base.ArrayPattern = function (node, st, c) {
  for (var i = 0; i < node.elements.length; ++i) {
    var elt = node.elements[i];
    if (elt) c(elt, st, "Pattern");
  }
};
base.ObjectPattern = function (node, st, c) {
  for (var i = 0; i < node.properties.length; ++i) {
    c(node.properties[i].value, st, "Pattern");
  }
};

base.Expression = skipThrough;
base.ThisExpression = base.Super = base.MetaProperty = ignore;
base.ArrayExpression = function (node, st, c) {
  for (var i = 0; i < node.elements.length; ++i) {
    var elt = node.elements[i];
    if (elt) c(elt, st, "Expression");
  }
};
base.ObjectExpression = function (node, st, c) {
  for (var i = 0; i < node.properties.length; ++i) {
    c(node.properties[i], st);
  }
};
base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;
base.SequenceExpression = base.TemplateLiteral = function (node, st, c) {
  for (var i = 0; i < node.expressions.length; ++i) {
    c(node.expressions[i], st, "Expression");
  }
};
base.UnaryExpression = base.UpdateExpression = function (node, st, c) {
  c(node.argument, st, "Expression");
};
base.BinaryExpression = base.LogicalExpression = function (node, st, c) {
  c(node.left, st, "Expression");
  c(node.right, st, "Expression");
};
base.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {
  c(node.left, st, "Pattern");
  c(node.right, st, "Expression");
};
base.ConditionalExpression = function (node, st, c) {
  c(node.test, st, "Expression");
  c(node.consequent, st, "Expression");
  c(node.alternate, st, "Expression");
};
base.NewExpression = base.CallExpression = function (node, st, c) {
  c(node.callee, st, "Expression");
  if (node.arguments) for (var i = 0; i < node.arguments.length; ++i) {
    c(node.arguments[i], st, "Expression");
  }
};
base.MemberExpression = function (node, st, c) {
  c(node.object, st, "Expression");
  if (node.computed) c(node.property, st, "Expression");
};
base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {
  if (node.declaration) c(node.declaration, st, node.type == "ExportNamedDeclaration" || node.declaration.id ? "Statement" : "Expression");
  if (node.source) c(node.source, st, "Expression");
};
base.ExportAllDeclaration = function (node, st, c) {
  c(node.source, st, "Expression");
};
base.ImportDeclaration = function (node, st, c) {
  for (var i = 0; i < node.specifiers.length; i++) {
    c(node.specifiers[i], st);
  }c(node.source, st, "Expression");
};
base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = ignore;

base.TaggedTemplateExpression = function (node, st, c) {
  c(node.tag, st, "Expression");
  c(node.quasi, st);
};
base.ClassDeclaration = base.ClassExpression = function (node, st, c) {
  return c(node, st, "Class");
};
base.Class = function (node, st, c) {
  if (node.id) c(node.id, st, "Pattern");
  if (node.superClass) c(node.superClass, st, "Expression");
  for (var i = 0; i < node.body.body.length; i++) {
    c(node.body.body[i], st);
  }
};
base.MethodDefinition = base.Property = function (node, st, c) {
  if (node.computed) c(node.key, st, "Expression");
  c(node.value, st, "Expression");
};

},{}]},{},["/src\\walk\\index.js"])("/src\\walk\\index.js")
});
});

define("tern/lib/def",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
//
//
//
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return exports.init = mod;
  if (typeof define == "function" && define.amd) // AMD
    return define({init: mod});
  tern.def = {init: mod};
})(function(exports, infer) {
  "use strict";

  function hop(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }

  var TypeParser = exports.TypeParser = function(spec, start, base, forceNew) {
    this.pos = start || 0;
    this.spec = spec;
    this.base = base;
    this.forceNew = forceNew;
  };

  function unwrapType(type, self, args) {
    return type.call ? type(self, args) : type;
  }

  function extractProp(type, prop) {
    if (prop == "!ret") {
      if (type.retval) return type.retval;
      var rv = new infer.AVal;
      type.propagate(new infer.IsCallee(infer.ANull, [], null, rv));
      return rv;
    } else {
      return type.getProp(prop);
    }
  }

  function computedFunc(name, args, retType, generator) {
    return function(self, cArgs) {
      var realArgs = [];
      for (var i = 0; i < args.length; i++) realArgs.push(unwrapType(args[i], self, cArgs));
      return new infer.Fn(name, infer.ANull, realArgs, unwrapType(retType, self, cArgs), generator);
    };
  }
  function computedUnion(types) {
    return function(self, args) {
      var union = new infer.AVal;
      for (var i = 0; i < types.length; i++) unwrapType(types[i], self, args).propagate(union);
      union.maxWeight = 1e5;
      return union;
    };
  }
  function computedArray(inner) {
    return function(self, args) {
      return new infer.Arr(inner(self, args));
    };
  }
  function computedTuple(types) {
    return function(self, args) {
      return new infer.Arr(types.map(function(tp) { return unwrapType(tp, self, args) }))
    }
  }

  TypeParser.prototype = {
    eat: function(str) {
      if (str.length == 1 ? this.spec.charAt(this.pos) == str : this.spec.indexOf(str, this.pos) == this.pos) {
        this.pos += str.length;
        return true;
      }
    },
    word: function(re) {
      var word = "", ch, re = re || /[\w$]/;
      while ((ch = this.spec.charAt(this.pos)) && re.test(ch)) { word += ch; ++this.pos; }
      return word;
    },
    error: function() {
      throw new Error("Unrecognized type spec: " + this.spec + " (at " + this.pos + ")");
    },
    parseFnType: function(comp, name, top, generator) {
      var args = [], names = [], computed = false;
      if (!this.eat(")")) for (var i = 0; ; ++i) {
        var colon = this.spec.indexOf(": ", this.pos), argname;
        if (colon != -1) {
          argname = this.spec.slice(this.pos, colon);
          if (/^[$\w?]+$/.test(argname))
            this.pos = colon + 2;
          else
            argname = null;
        }
        names.push(argname);
        var argType = this.parseType(comp);
        if (argType.call) computed = true;
        args.push(argType);
        if (!this.eat(", ")) {
          this.eat(")") || this.error();
          break;
        }
      }
      var retType, computeRet, computeRetStart, fn;
      if (this.eat(" -> ")) {
        var retStart = this.pos;
        retType = this.parseType(true);
        if (retType.call && !computed) {
          computeRet = retType;
          retType = infer.ANull;
          computeRetStart = retStart;
        }
      } else {
        retType = infer.ANull;
      }
      if (computed) return computedFunc(name, args, retType, generator);

      if (top && (fn = this.base))
        infer.Fn.call(this.base, name, infer.ANull, args, names, retType, generator);
      else
        fn = new infer.Fn(name, infer.ANull, args, names, retType, generator);
      if (computeRet) fn.computeRet = computeRet;
      if (computeRetStart != null) fn.computeRetSource = this.spec.slice(computeRetStart, this.pos);
      return fn;
    },
    parseType: function(comp, name, top) {
      var main = this.parseTypeMaybeProp(comp, name, top);
      if (!this.eat("|")) return main;
      var types = [main], computed = main.call;
      for (;;) {
        var next = this.parseTypeMaybeProp(comp, name, top);
        types.push(next);
        if (next.call) computed = true;
        if (!this.eat("|")) break;
      }
      if (computed) return computedUnion(types);
      var union = new infer.AVal;
      for (var i = 0; i < types.length; i++) types[i].propagate(union);
      union.maxWeight = 1e5;
      return union;
    },
    parseTypeMaybeProp: function(comp, name, top) {
      var result = this.parseTypeInner(comp, name, top);
      while (comp && this.eat(".")) result = this.extendWithProp(result);
      return result;
    },
    extendWithProp: function(base) {
      var propName = this.word(/[\w<>$!:]/) || this.error();
      if (base.apply) return function(self, args) {
        return extractProp(base(self, args), propName);
      };
      return extractProp(base, propName);
    },
    parseTypeInner: function(comp, name, top) {
      var gen
      if (this.eat("fn(") || (gen = this.eat("fn*("))) {
        return this.parseFnType(comp, name, top, gen);
      } else if (this.eat("[")) {
        var inner = this.parseType(comp), types, computed = inner.call
        while (this.eat(", ")) {
          if (!types) types = [inner]
          var next = this.parseType(comp)
          types.push(next)
          computed = computed || next.call
        }
        this.eat("]") || this.error()
        if (computed) return types ? computedTuple(types) : computedArray(inner)
        if (top && this.base) {
          infer.Arr.call(this.base, types || inner)
          return this.base
        }
        return new infer.Arr(types || inner)
      } else if (this.eat("+")) {
        var path = this.word(/[\w$<>\.:!]/)
        var base = infer.cx().localDefs[path + ".prototype"]
        if (!base) {
          var base = parsePath(path);
          if (!(base instanceof infer.Obj)) return base;
          var proto = descendProps(base, ["prototype"])
          if (proto && (proto = proto.getObjType()))
            base = proto
        }
        if (comp && this.eat("[")) return this.parsePoly(base);
        if (top && this.forceNew) return new infer.Obj(base);
        return infer.getInstance(base);
      } else if (this.eat(":")) {
        var name = this.word(/[\w$\.]/)
        return infer.getSymbol(name)
      } else if (comp && this.eat("!")) {
        var arg = this.word(/\d/);
        if (arg) {
          arg = Number(arg);
          return function(_self, args) {return args[arg] || infer.ANull;};
        } else if (this.eat("this")) {
          return function(self) {return self;};
        } else if (this.eat("custom:")) {
          var fname = this.word(/[\w$]/);
          return customFunctions[fname] || function() { return infer.ANull; };
        } else {
          return this.fromWord("!" + this.word(/[\w$<>\.!:]/));
        }
      } else if (this.eat("?")) {
        return infer.ANull;
      } else {
        return this.fromWord(this.word(/[\w$<>\.!:`]/));
      }
    },
    fromWord: function(spec) {
      var cx = infer.cx();
      switch (spec) {
      case "number": return cx.num;
      case "string": return cx.str;
      case "bool": return cx.bool;
      case "<top>": return cx.topScope;
      }
      if (cx.localDefs && spec in cx.localDefs) return cx.localDefs[spec];
      return parsePath(spec);
    },
    parsePoly: function(base) {
      var propName = "<i>", match;
      if (match = this.spec.slice(this.pos).match(/^\s*([\w$:]+)\s*=\s*/)) {
        propName = match[1];
        this.pos += match[0].length;
      }
      var value = this.parseType(true);
      if (!this.eat("]")) this.error();
      if (value.call) return function(self, args) {
        var instance = new infer.Obj(base);
        value(self, args).propagate(instance.defProp(propName));
        return instance;
      };
      var instance = new infer.Obj(base);
      value.propagate(instance.defProp(propName));
      return instance;
    }
  };

  function parseType(spec, name, base, forceNew) {
    var type = new TypeParser(spec, null, base, forceNew).parseType(false, name, true);
    if (/^fn\(/.test(spec)) for (var i = 0; i < type.args.length; ++i) (function(i) {
      var arg = type.args[i];
      if (arg instanceof infer.Fn && arg.args && arg.args.length) addEffect(type, function(_self, fArgs) {
        var fArg = fArgs[i];
        if (fArg) fArg.propagate(new infer.IsCallee(infer.cx().topScope, arg.args, null, infer.ANull));
      });
    })(i);
    return type;
  }

  function addEffect(fn, handler, replaceRet) {
    var oldCmp = fn.computeRet, rv = fn.retval;
    fn.computeRet = function(self, args, argNodes) {
      var handled = handler(self, args, argNodes);
      var old = oldCmp ? oldCmp(self, args, argNodes) : rv;
      return replaceRet ? handled : old;
    };
  }

  var parseEffect = exports.parseEffect = function(effect, fn) {
    var m;
    if (effect.indexOf("propagate ") == 0) {
      var p = new TypeParser(effect, 10);
      var origin = p.parseType(true);
      if (!p.eat(" ")) p.error();
      var target = p.parseType(true);
      addEffect(fn, function(self, args) {
        unwrapType(origin, self, args).propagate(unwrapType(target, self, args));
      });
    } else if (effect.indexOf("call ") == 0) {
      var andRet = effect.indexOf("and return ", 5) == 5;
      var p = new TypeParser(effect, andRet ? 16 : 5);
      var getCallee = p.parseType(true), getSelf = null, getArgs = [];
      if (p.eat(" this=")) getSelf = p.parseType(true);
      while (p.eat(" ")) getArgs.push(p.parseType(true));
      addEffect(fn, function(self, args) {
        var callee = unwrapType(getCallee, self, args);
        var slf = getSelf ? unwrapType(getSelf, self, args) : infer.ANull, as = [];
        for (var i = 0; i < getArgs.length; ++i) as.push(unwrapType(getArgs[i], self, args));
        var result = andRet ? new infer.AVal : infer.ANull;
        callee.propagate(new infer.IsCallee(slf, as, null, result));
        return result;
      }, andRet);
    } else if (m = effect.match(/^custom (\S+)\s*(.*)/)) {
      var customFunc = customFunctions[m[1]];
      if (customFunc) addEffect(fn, m[2] ? customFunc(m[2]) : customFunc);
    } else if (effect.indexOf("copy ") == 0) {
      var p = new TypeParser(effect, 5);
      var getFrom = p.parseType(true);
      p.eat(" ");
      var getTo = p.parseType(true);
      addEffect(fn, function(self, args) {
        var from = unwrapType(getFrom, self, args), to = unwrapType(getTo, self, args);
        from.forAllProps(function(prop, val, local) {
          if (local && prop != "<i>")
            to.propagate(new infer.DefProp(prop, val));
        });
      });
    } else {
      throw new Error("Unknown effect type: " + effect);
    }
  };

  var currentTopScope;

  var parsePath = exports.parsePath = function(path, scope) {
    var cx = infer.cx(), cached = cx.paths[path], origPath = path;
    if (cached != null) return cached;
    cx.paths[path] = infer.ANull;

    var base = scope || currentTopScope || cx.topScope;

    if (cx.localDefs) for (var name in cx.localDefs) {
      if (path.indexOf(name) == 0) {
        if (path == name) return cx.paths[path] = cx.localDefs[path];
        if (path.charAt(name.length) == ".") {
          base = cx.localDefs[name];
          path = path.slice(name.length + 1);
          break;
        }
      }
    }

    var result = descendProps(base, path.split("."))
    cx.paths[origPath] = result == infer.ANull ? null : result
    return result
  }

  function descendProps(base, parts) {
    for (var i = 0; i < parts.length && base != infer.ANull; ++i) {
      var prop = parts[i];
      if (prop.charAt(0) == "!") {
        if (prop == "!proto") {
          base = (base instanceof infer.Obj && base.proto) || infer.ANull;
        } else {
          var fn = base.getFunctionType();
          if (!fn) {
            base = infer.ANull;
          } else if (prop == "!ret") {
            base = fn.retval && fn.retval.getType(false) || infer.ANull;
          } else {
            var arg = fn.args && fn.args[Number(prop.slice(1))];
            base = (arg && arg.getType(false)) || infer.ANull;
          }
        }
      } else if (base instanceof infer.Obj &&
                 (prop == "prototype" && base instanceof infer.Fn || base.hasProp(prop))) {
        var propVal = base.getProp(prop);
        if (!propVal || propVal.isEmpty())
          base = infer.ANull;
        else
          base = propVal.types[0];
      } else {
        base = infer.ANull;
      }
    }
    return base;
  }

  function emptyObj(ctor) {
    var empty = Object.create(ctor.prototype);
    empty.props = Object.create(null);
    empty.isShell = true;
    return empty;
  }

  function isSimpleAnnotation(spec) {
    if (!spec["!type"] || /^(fn\(|\[)/.test(spec["!type"])) return false;
    for (var prop in spec)
      if (prop != "!type" && prop != "!doc" && prop != "!url" && prop != "!span" && prop != "!data")
        return false;
    return true;
  }

  function passOne(base, spec, path) {
    if (!base) {
      var tp = spec["!type"];
      if (tp) {
        if (/^fn\(/.test(tp)) base = emptyObj(infer.Fn);
        else if (tp.charAt(0) == "[") base = emptyObj(infer.Arr);
        else throw new Error("Invalid !type spec: " + tp);
      } else if (spec["!stdProto"]) {
        base = infer.cx().protos[spec["!stdProto"]];
      } else {
        base = emptyObj(infer.Obj);
      }
      base.name = path;
    }

    for (var name in spec) if (hop(spec, name) && name.charCodeAt(0) != 33) {
      var inner = spec[name];
      if (typeof inner == "string" || isSimpleAnnotation(inner)) continue;
      var prop = base.defProp(name);
      passOne(prop.getObjType(), inner, path ? path + "." + name : name).propagate(prop);
    }
    return base;
  }

  function passTwo(base, spec, path) {
    if (base.isShell) {
      delete base.isShell;
      var tp = spec["!type"];
      if (tp) {
        parseType(tp, path, base);
      } else {
        var proto = spec["!proto"] && parseType(spec["!proto"]);
        infer.Obj.call(base, proto instanceof infer.Obj ? proto : true, path);
      }
    }

    var effects = spec["!effects"];
    if (effects && base instanceof infer.Fn) for (var i = 0; i < effects.length; ++i)
      parseEffect(effects[i], base);
    copyInfo(spec, base);

    for (var name in spec) if (hop(spec, name) && name.charCodeAt(0) != 33) {
      var inner = spec[name], known = base.defProp(name), innerPath = path ? path + "." + name : name;
      if (typeof inner == "string") {
        if (known.isEmpty()) parseType(inner, innerPath).propagate(known);
      } else {
        if (!isSimpleAnnotation(inner))
          passTwo(known.getObjType(), inner, innerPath);
        else if (known.isEmpty())
          parseType(inner["!type"], innerPath, null, true).propagate(known);
        else
          continue;
        if (inner["!doc"]) known.doc = inner["!doc"];
        if (inner["!url"]) known.url = inner["!url"];
        if (inner["!span"]) known.span = inner["!span"];
      }
    }
    return base;
  }

  function copyInfo(spec, type) {
    if (spec["!doc"]) type.doc = spec["!doc"];
    if (spec["!url"]) type.url = spec["!url"];
    if (spec["!span"]) type.span = spec["!span"];
    if (spec["!data"]) type.metaData = spec["!data"];
  }

  function doLoadEnvironment(data, scope) {
    var cx = infer.cx(), server = cx.parent

    infer.addOrigin(cx.curOrigin = data["!name"] || "env#" + cx.origins.length);
    cx.localDefs = cx.definitions[cx.curOrigin] = Object.create(null);

    if (server) server.signal("preLoadDef", data)

    passOne(scope, data);

    var def = data["!define"];
    if (def) {
      for (var name in def) {
        var spec = def[name];
        cx.localDefs[name] = typeof spec == "string" ? parsePath(spec) : passOne(null, spec, name);
      }
      for (var name in def) {
        var spec = def[name];
        if (typeof spec != "string") passTwo(cx.localDefs[name], def[name], name);
      }
    }

    passTwo(scope, data);

    if (server) server.signal("postLoadDef", data)

    cx.curOrigin = cx.localDefs = null;
  }

  exports.load = function(data, scope) {
    if (!scope) scope = infer.cx().topScope;
    var oldScope = currentTopScope;
    currentTopScope = scope;
    try {
      doLoadEnvironment(data, scope);
    } finally {
      currentTopScope = oldScope;
    }
  };

  exports.parse = function(data, origin, path) {
    var cx = infer.cx();
    if (origin) {
      cx.origin = origin;
      cx.localDefs = cx.definitions[origin];
    }

    try {
      if (typeof data == "string")
        return parseType(data, path);
      else
        return passTwo(passOne(null, data, path), data, path);
    } finally {
      if (origin) cx.origin = cx.localDefs = null;
    }
  };
  var customFunctions = Object.create(null);
  infer.registerFunction = function(name, f) { customFunctions[name] = f; };

  var IsCreated = infer.constraint({
    construct: function(created, target, spec) {
      this.created = created;
      this.target = target;
      this.spec = spec;
    },
    addType: function(tp) {
      if (tp instanceof infer.Obj && this.created++ < 5) {
        var derived = new infer.Obj(tp), spec = this.spec;
        if (spec instanceof infer.AVal) spec = spec.getObjType(false);
        if (spec instanceof infer.Obj) for (var prop in spec.props) {
          var cur = spec.props[prop].types[0];
          var p = derived.defProp(prop);
          if (cur && cur instanceof infer.Obj && cur.props.value) {
            var vtp = cur.props.value.getType(false);
            if (vtp) p.addType(vtp);
          }
        }
        this.target.addType(derived);
      }
    }
  });

  infer.registerFunction("Object_create", function(_self, args, argNodes) {
    if (argNodes && argNodes.length && argNodes[0].type == "Literal" && argNodes[0].value == null)
      return new infer.Obj();

    var result = new infer.AVal;
    if (args[0]) args[0].propagate(new IsCreated(0, result, args[1]));
    return result;
  });

  var PropSpec = infer.constraint({
    construct: function(target) { this.target = target; },
    addType: function(tp) {
      if (!(tp instanceof infer.Obj)) return;
      if (tp.hasProp("value"))
        tp.getProp("value").propagate(this.target);
      else if (tp.hasProp("get"))
        tp.getProp("get").propagate(new infer.IsCallee(infer.ANull, [], null, this.target));
    }
  });

  infer.registerFunction("Object_defineProperty", function(_self, args, argNodes) {
    if (argNodes && argNodes.length >= 3 && argNodes[1].type == "Literal" &&
        typeof argNodes[1].value == "string") {
      var obj = args[0], connect = new infer.AVal;
      obj.propagate(new infer.DefProp(argNodes[1].value, connect, argNodes[1]));
      args[2].propagate(new PropSpec(connect));
    }
    return infer.ANull;
  });

  infer.registerFunction("Object_defineProperties", function(_self, args, argNodes) {
    if (args.length >= 2) {
      var obj = args[0];
      args[1].forAllProps(function(prop, val, local) {
        if (!local) return;
        var connect = new infer.AVal;
        obj.propagate(new infer.DefProp(prop, connect, argNodes && argNodes[1]));
        val.propagate(new PropSpec(connect));
      });
    }
    return infer.ANull;
  });

  var IsBound = infer.constraint({
    construct: function(self, args, target) {
      this.self = self; this.args = args; this.target = target;
    },
    addType: function(tp) {
      if (!(tp instanceof infer.Fn)) return;
      this.target.addType(new infer.Fn(tp.name, infer.ANull, tp.args.slice(this.args.length),
                                       tp.argNames.slice(this.args.length), tp.retval, tp.generator));
      this.self.propagate(tp.self);
      for (var i = 0; i < Math.min(tp.args.length, this.args.length); ++i)
        this.args[i].propagate(tp.args[i]);
    }
  });

  infer.registerFunction("Function_bind", function(self, args) {
    if (!args.length) return infer.ANull;
    var result = new infer.AVal;
    self.propagate(new IsBound(args[0], args.slice(1), result));
    return result;
  });

  infer.registerFunction("Array_ctor", function(_self, args) {
    var arr = new infer.Arr;
    if (args.length != 1 || !args[0].hasType(infer.cx().num)) {
      var content = arr.getProp("<i>");
      for (var i = 0; i < args.length; ++i) args[i].propagate(content);
    }
    return arr;
  });

  infer.registerFunction("Promise_ctor", function(_self, args, argNodes) {
    var defs6 = infer.cx().definitions.ecma6
    if (!defs6 || args.length < 1) return infer.ANull;
    var self = new infer.Obj(defs6["Promise.prototype"]);
    var valProp = self.defProp(":t", argNodes && argNodes[0]);
    var valArg = new infer.AVal;
    valArg.propagate(valProp);
    var exec = new infer.Fn("execute", infer.ANull, [valArg], ["value"], infer.ANull);
    var reject = defs6.Promise_reject;
    args[0].propagate(new infer.IsCallee(infer.ANull, [exec, reject], null, infer.ANull));
    return self;
  });

  var PromiseResolvesTo = infer.constraint({
    construct: function(output) { this.output = output; },
    addType: function(tp) {
      if (tp.constructor == infer.Obj && tp.name == "Promise" && tp.hasProp(":t"))
        tp.getProp(":t").propagate(this.output);
      else
        tp.propagate(this.output);
    }
  });

  var WG_PROMISE_KEEP_VALUE = 50;

  infer.registerFunction("Promise_then", function(self, args, argNodes) {
    var fn = args.length && args[0].getFunctionType();
    var defs6 = infer.cx().definitions.ecma6
    if (!fn || !defs6) return self;

    var result = new infer.Obj(defs6["Promise.prototype"]);
    var value = result.defProp(":t", argNodes && argNodes[0]), ty;
    if (fn.retval.isEmpty() && (ty = self.getType()) instanceof infer.Obj && ty.hasProp(":t"))
      ty.getProp(":t").propagate(value, WG_PROMISE_KEEP_VALUE);
    fn.retval.propagate(new PromiseResolvesTo(value));
    return result;
  });

  infer.registerFunction("getOwnPropertySymbols", function(_self, args) {
    if (!args.length) return infer.ANull
    var result = new infer.AVal
    args[0].forAllProps(function(prop, _val, local) {
      if (local && prop.charAt(0) == ":") result.addType(infer.getSymbol(prop.slice(1)))
    })
    return result
  })

  infer.registerFunction("getSymbol", function(_self, _args, argNodes) {
    if (argNodes.length && argNodes[0].type == "Literal" && typeof argNodes[0].value == "string")
      return infer.getSymbol(argNodes[0].value)
    else
      return infer.ANull
  })

  return exports;
});

});

define("tern/lib/signal",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function(root, mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(exports);
  if (typeof define == "function" && define.amd) // AMD
    return define(["exports"], mod);
  mod((root.tern || (root.tern = {})).signal = {}); // Plain browser env
})(this, function(exports) {

  function on(type, f) {
    var handlers = this._handlers || (this._handlers = Object.create(null));
    (handlers[type] || (handlers[type] = [])).push(f);
  }

  function off(type, f) {
    var arr = this._handlers && this._handlers[type];
    if (arr) for (var i = 0; i < arr.length; ++i)
      if (arr[i] == f) { arr.splice(i, 1); break; }
  }

  var noHandlers = []
  function getHandlers(emitter, type) {
    var arr = emitter._handlers && emitter._handlers[type];
    return arr && arr.length ? arr.slice() : noHandlers
  }

  function signal(type, a1, a2, a3, a4) {
    var arr = getHandlers(this, type)
    for (var i = 0; i < arr.length; ++i) arr[i].call(this, a1, a2, a3, a4)
  }

  function signalReturnFirst(type, a1, a2, a3, a4) {
    var arr = getHandlers(this, type)
    for (var i = 0; i < arr.length; ++i) {
      var result = arr[i].call(this, a1, a2, a3, a4)
      if (result) return result
    }
  }

  function hasHandler(type) {
    var arr = this._handlers && this._handlers[type]
    return arr && arr.length > 0 && arr
  }

  exports.mixin = function(obj) {
    obj.on = on; obj.off = off;
    obj.signal = signal;
    obj.signalReturnFirst = signalReturnFirst;
    obj.hasHandler = hasHandler;
    return obj;
  };
});

});

define("tern/lib/infer",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function(root, mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(exports, require("acorn"), require("acorn/dist/acorn_loose"), require("acorn/dist/walk"),
               require("./def"), require("./signal"));
  if (typeof define == "function" && define.amd) // AMD
    return define(["exports", "acorn/dist/acorn", "acorn/dist/acorn_loose", "acorn/dist/walk", "./def", "./signal"], mod);
  mod(root.tern || (root.tern = {}), acorn, acorn, acorn.walk, tern.def, tern.signal); // Plain browser env
})(this, function(exports, acorn, acorn_loose, walk, def, signal) {
  "use strict";

  var toString = exports.toString = function(type, maxDepth, parent) {
    if (!type || type == parent || maxDepth && maxDepth < -3) return "?";
    return type.toString(maxDepth, parent);
  };
  var ANull = exports.ANull = signal.mixin({
    addType: function() {},
    propagate: function() {},
    getProp: function() { return ANull; },
    forAllProps: function() {},
    hasType: function() { return false; },
    isEmpty: function() { return true; },
    getFunctionType: function() {},
    getObjType: function() {},
    getSymbolType: function() {},
    getType: function() {},
    gatherProperties: function() {},
    propagatesTo: function() {},
    typeHint: function() {},
    propHint: function() {},
    toString: function() { return "?"; }
  });

  function extend(proto, props) {
    var obj = Object.create(proto);
    if (props) for (var prop in props) obj[prop] = props[prop];
    return obj;
  }
  var WG_DEFAULT = 100, WG_NEW_INSTANCE = 90, WG_MADEUP_PROTO = 10,
      WG_MULTI_MEMBER = 6, WG_CATCH_ERROR = 6,
      WG_PHANTOM_OBJ = 1,
      WG_GLOBAL_THIS = 90, WG_SPECULATIVE_THIS = 2, WG_SPECULATIVE_PROTO_THIS = 4;

  var AVal = exports.AVal = function() {
    this.types = [];
    this.forward = null;
    this.maxWeight = 0;
  };
  AVal.prototype = extend(ANull, {
    addType: function(type, weight) {
      weight = weight || WG_DEFAULT;
      if (this.maxWeight < weight) {
        this.maxWeight = weight;
        if (this.types.length == 1 && this.types[0] == type) return;
        this.types.length = 0;
      } else if (this.maxWeight > weight || this.types.indexOf(type) > -1) {
        return;
      }
      if (this.types.length > 5) {
        return;
      }
      this.signal("addType", type);
      this.types.push(type);
      var forward = this.forward;
      if (forward) withWorklist(function(add) {
        for (var i = 0; i < forward.length; ++i) add(type, forward[i], weight);
      });
    },

    propagate: function(target, weight) {
      if (target == ANull || (target instanceof Type && this.forward && this.forward.length > 2)) return;
      if (weight && weight != WG_DEFAULT) target = new Muffle(target, weight);
      (this.forward || (this.forward = [])).push(target);
      var types = this.types;
      if (types.length) withWorklist(function(add) {
        for (var i = 0; i < types.length; ++i) add(types[i], target, weight);
      });
    },

    getProp: function(prop) {
      if (prop == "__proto__" || prop == "✖") return ANull;
      var found = (this.props || (this.props = Object.create(null)))[prop];
      if (!found) {
        found = this.props[prop] = new AVal;
        this.propagate(new GetProp(prop, found));
      }
      return found;
    },

    forAllProps: function(c) {
      this.propagate(new ForAllProps(c));
    },

    hasType: function(type) {
      return this.types.indexOf(type) > -1;
    },
    isEmpty: function() { return this.types.length === 0; },
    getFunctionType: function() {
      for (var i = this.types.length - 1; i >= 0; --i)
        if (this.types[i] instanceof Fn) return this.types[i];
    },
    getObjType: function() {
      var seen = null;
      for (var i = this.types.length - 1; i >= 0; --i) {
        var type = this.types[i];
        if (!(type instanceof Obj)) continue;
        if (type.name) return type;
        if (!seen) seen = type;
      }
      return seen;
    },

    getSymbolType: function() {
      for (var i = this.types.length - 1; i >= 0; --i)
        if (this.types[i] instanceof Sym) return this.types[i]
    },

    getType: function(guess) {
      if (this.types.length === 0 && guess !== false) return this.makeupType();
      if (this.types.length === 1) return this.types[0];
      return canonicalType(this.types);
    },

    toString: function(maxDepth, parent) {
      if (this.types.length == 1) return toString(this.types[0], maxDepth, parent);
      var simplified = simplifyTypes(this.types);
      if (simplified.length > 2) return "?";
      return simplified.map(function(tp) { return toString(tp, maxDepth, parent); }).join("|");
    },

    makeupPropType: function(obj) {
      var propName = this.propertyName;

      var protoProp = obj.proto && obj.proto.hasProp(propName);
      if (protoProp) {
        var fromProto = protoProp.getType();
        if (fromProto) return fromProto;
      }

      if (propName != "<i>") {
        var computedProp = obj.hasProp("<i>");
        if (computedProp) return computedProp.getType();
      } else if (obj.props["<i>"] != this) {
        for (var prop in obj.props) {
          var val = obj.props[prop];
          if (!val.isEmpty()) return val.getType();
        }
      }
    },

    makeupType: function() {
      var computed = this.propertyOf && this.makeupPropType(this.propertyOf);
      if (computed) return computed;

      if (!this.forward) return null;
      for (var i = this.forward.length - 1; i >= 0; --i) {
        var hint = this.forward[i].typeHint();
        if (hint && !hint.isEmpty()) {guessing = true; return hint;}
      }

      var props = Object.create(null), foundProp = null;
      for (var i = 0; i < this.forward.length; ++i) {
        var prop = this.forward[i].propHint();
        if (prop && prop != "length" && prop != "<i>" && prop != "✖" && prop != cx.completingProperty) {
          props[prop] = true;
          foundProp = prop;
        }
      }
      if (!foundProp) return null;

      var objs = objsWithProp(foundProp);
      if (objs) {
        var matches = [];
        search: for (var i = 0; i < objs.length; ++i) {
          var obj = objs[i];
          for (var prop in props) if (!obj.hasProp(prop)) continue search;
          if (obj.hasCtor) obj = getInstance(obj);
          matches.push(obj);
        }
        var canon = canonicalType(matches);
        if (canon) {guessing = true; return canon;}
      }
    },

    typeHint: function() { return this.types.length ? this.getType() : null; },
    propagatesTo: function() { return this; },

    gatherProperties: function(f, depth) {
      for (var i = 0; i < this.types.length; ++i)
        this.types[i].gatherProperties(f, depth);
    },

    guessProperties: function(f) {
      var forward = this.forward;
      if (forward) for (var i = 0; i < forward.length; ++i) {
        var prop = forward[i].propHint();
        if (prop) f(prop, null, 0, function(rec) { if (forward[i].args) rec.type = "fn()?"; });
      }
      var guessed = this.makeupType();
      if (guessed) guessed.gatherProperties(f);
    }
  });

  function similarAVal(a, b, depth) {
    var typeA = a.getType(false), typeB = b.getType(false);
    if (!typeA || !typeB) return true;
    return similarType(typeA, typeB, depth);
  }

  function similarType(a, b, depth) {
    if (!a || depth >= 5) return b;
    if (!a || a == b) return a;
    if (!b) return a;
    if (a.constructor != b.constructor) return false;
    if (a.constructor == Arr) {
      var innerA = a.getProp("<i>").getType(false);
      if (!innerA) return b;
      var innerB = b.getProp("<i>").getType(false);
      if (!innerB || similarType(innerA, innerB, depth + 1)) return b;
    } else if (a.constructor == Obj) {
      var propsA = 0, propsB = 0, same = 0;
      for (var prop in a.props) {
        propsA++;
        if (prop in b.props && similarAVal(a.props[prop], b.props[prop], depth + 1))
          same++;
      }
      for (var prop in b.props) propsB++;
      if (propsA && propsB && same < Math.max(propsA, propsB) / 2) return false;
      return propsA > propsB ? a : b;
    } else if (a.constructor == Fn) {
      if (a.args.length != b.args.length ||
          !a.args.every(function(tp, i) { return similarAVal(tp, b.args[i], depth + 1); }) ||
          !similarAVal(a.retval, b.retval, depth + 1) || !similarAVal(a.self, b.self, depth + 1))
        return false;
      return a;
    } else {
      return false;
    }
  }

  var simplifyTypes = exports.simplifyTypes = function(types) {
    var found = [];
    outer: for (var i = 0; i < types.length; ++i) {
      var tp = types[i];
      for (var j = 0; j < found.length; j++) {
        var similar = similarType(tp, found[j], 0);
        if (similar) {
          found[j] = similar;
          continue outer;
        }
      }
      found.push(tp);
    }
    return found;
  };

  function canonicalType(types) {
    var arrays = 0, fns = 0, objs = 0, prim = null;
    for (var i = 0; i < types.length; ++i) {
      var tp = types[i];
      if (tp instanceof Arr) ++arrays;
      else if (tp instanceof Fn) ++fns;
      else if (tp instanceof Obj) ++objs;
      else if (tp instanceof Prim) {
        if (prim && tp.name != prim.name) return null;
        prim = tp;
      }
    }
    var kinds = (arrays && 1) + (fns && 1) + (objs && 1) + (prim && 1);
    if (kinds > 1) return null;
    if (prim) return prim;

    var maxScore = 0, maxTp = null;
    for (var i = 0; i < types.length; ++i) {
      var tp = types[i], score = 0;
      if (arrays) {
        score = tp.getProp("<i>").isEmpty() ? 1 : 2;
      } else if (fns) {
        score = 1;
        for (var j = 0; j < tp.args.length; ++j) if (!tp.args[j].isEmpty()) ++score;
        if (!tp.retval.isEmpty()) ++score;
      } else if (objs) {
        score = tp.name ? 100 : 2;
      }
      if (score >= maxScore) { maxScore = score; maxTp = tp; }
    }
    return maxTp;
  }
  var constraint = exports.constraint = function(methods) {
    var ctor = function() {
      this.origin = cx.curOrigin;
      this.construct.apply(this, arguments);
    };
    ctor.prototype = Object.create(ANull);
    for (var m in methods) if (methods.hasOwnProperty(m)) ctor.prototype[m] = methods[m];
    return ctor;
  };

  var GetProp = constraint({
    construct: function(prop, target) {
      this.prop = prop; this.target = target;
    },
    addType: function(type, weight) {
      if (type.getProp)
        type.getProp(this.prop).propagate(this.target, weight);
    },
    propHint: function() { return this.prop; },
    propagatesTo: function() {
      if (this.prop == "<i>" || !/[^\w_]/.test(this.prop))
        return {target: this.target, pathExt: "." + this.prop};
    }
  });

  var DefProp = exports.PropHasSubset = exports.DefProp = constraint({
    construct: function(prop, type, originNode) {
      this.prop = prop; this.type = type; this.originNode = originNode;
    },
    addType: function(type, weight) {
      if (!(type instanceof Obj)) return;
      var prop = type.defProp(this.prop, this.originNode);
      if (!prop.origin) prop.origin = this.origin;
      this.type.propagate(prop, weight);
    },
    propHint: function() { return this.prop; }
  });

  var ForAllProps = constraint({
    construct: function(c) { this.c = c; },
    addType: function(type) {
      if (!(type instanceof Obj)) return;
      type.forAllProps(this.c);
    }
  });

  function withDisabledComputing(fn, body) {
    cx.disabledComputing = {fn: fn, prev: cx.disabledComputing};
    var result = body();
    cx.disabledComputing = cx.disabledComputing.prev;
    return result;
  }
  var IsCallee = exports.IsCallee = constraint({
    construct: function(self, args, argNodes, retval) {
      this.self = self; this.args = args; this.argNodes = argNodes; this.retval = retval;
      this.disabled = cx.disabledComputing;
    },
    addType: function(fn, weight) {
      if (!(fn instanceof Fn)) return;
      for (var i = 0; i < this.args.length; ++i) {
        if (i < fn.args.length) this.args[i].propagate(fn.args[i], weight);
        if (fn.arguments) this.args[i].propagate(fn.arguments, weight);
      }
      this.self.propagate(fn.self, this.self == cx.topScope ? WG_GLOBAL_THIS : weight);
      var compute = fn.computeRet, result = fn.retval
      if (compute) for (var d = this.disabled; d; d = d.prev)
        if (d.fn == fn || fn.originNode && d.fn.originNode == fn.originNode) compute = null;
      if (compute) {
        var old = cx.disabledComputing;
        cx.disabledComputing = this.disabled;
        result = compute(this.self, this.args, this.argNodes)
        cx.disabledComputing = old;
      }
      maybeIterator(fn, result).propagate(this.retval, weight)
    },
    typeHint: function() {
      var names = [];
      for (var i = 0; i < this.args.length; ++i) names.push("?");
      return new Fn(null, this.self, this.args, names, ANull);
    },
    propagatesTo: function() {
      return {target: this.retval, pathExt: ".!ret"};
    }
  });

  var HasMethodCall = constraint({
    construct: function(propName, args, argNodes, retval) {
      this.propName = propName; this.args = args; this.argNodes = argNodes; this.retval = retval;
      this.disabled = cx.disabledComputing;
    },
    addType: function(obj, weight) {
      var callee = new IsCallee(obj, this.args, this.argNodes, this.retval);
      callee.disabled = this.disabled;
      obj.getProp(this.propName).propagate(callee, weight);
    },
    propHint: function() { return this.propName; }
  });

  var IsCtor = exports.IsCtor = constraint({
    construct: function(target, noReuse) {
      this.target = target; this.noReuse = noReuse;
    },
    addType: function(f, weight) {
      if (!(f instanceof Fn)) return;
      if (cx.parent && !cx.parent.options.reuseInstances) this.noReuse = true;
      f.getProp("prototype").propagate(new IsProto(this.noReuse ? false : f, this.target), weight);
    }
  });

  var getInstance = exports.getInstance = function(obj, ctor) {
    if (ctor === false) return new Obj(obj);

    if (!ctor) ctor = obj.hasCtor;
    if (!obj.instances) obj.instances = [];
    for (var i = 0; i < obj.instances.length; ++i) {
      var cur = obj.instances[i];
      if (cur.ctor == ctor) return cur.instance;
    }
    var instance = new Obj(obj, ctor && ctor.name);
    instance.origin = obj.origin;
    obj.instances.push({ctor: ctor, instance: instance});
    return instance;
  };

  var IsProto = exports.IsProto = constraint({
    construct: function(ctor, target) {
      this.ctor = ctor; this.target = target;
    },
    addType: function(o, _weight) {
      if (!(o instanceof Obj)) return;
      if ((this.count = (this.count || 0) + 1) > 8) return;
      if (o == cx.protos.Array)
        this.target.addType(new Arr);
      else
        this.target.addType(getInstance(o, this.ctor));
    }
  });

  var FnPrototype = constraint({
    construct: function(fn) { this.fn = fn; },
    addType: function(o, _weight) {
      if (o instanceof Obj && !o.hasCtor) {
        o.hasCtor = this.fn;
        var adder = new SpeculativeThis(o, this.fn);
        adder.addType(this.fn);
        o.forAllProps(function(_prop, val, local) {
          if (local) val.propagate(adder);
        });
      }
    }
  });

  var IsAdded = constraint({
    construct: function(other, target) {
      this.other = other; this.target = target;
    },
    addType: function(type, weight) {
      if (type == cx.str)
        this.target.addType(cx.str, weight);
      else if (type == cx.num && this.other.hasType(cx.num))
        this.target.addType(cx.num, weight);
    },
    typeHint: function() { return this.other; }
  });

  var IfObj = exports.IfObj = constraint({
    construct: function(target) { this.target = target; },
    addType: function(t, weight) {
      if (t instanceof Obj) this.target.addType(t, weight);
    },
    propagatesTo: function() { return this.target; }
  });

  var SpeculativeThis = constraint({
    construct: function(obj, ctor) { this.obj = obj; this.ctor = ctor; },
    addType: function(tp) {
      if (tp instanceof Fn && tp.self)
        tp.self.addType(getInstance(this.obj, this.ctor), WG_SPECULATIVE_PROTO_THIS);
    }
  });

  var HasProto = constraint({
    construct: function(obj) { this.obj = obj },
    addType: function(tp) {
      if (tp instanceof Obj && this.obj.proto == cx.protos.Object)
        this.obj.replaceProto(tp)
    }
  });

  var Muffle = constraint({
    construct: function(inner, weight) {
      this.inner = inner; this.weight = weight;
    },
    addType: function(tp, weight) {
      this.inner.addType(tp, Math.min(weight, this.weight));
    },
    propagatesTo: function() { return this.inner.propagatesTo(); },
    typeHint: function() { return this.inner.typeHint(); },
    propHint: function() { return this.inner.propHint(); }
  });
  var Type = exports.Type = function() {};
  Type.prototype = extend(ANull, {
    constructor: Type,
    propagate: function(c, w) { c.addType(this, w); },
    hasType: function(other) { return other == this; },
    isEmpty: function() { return false; },
    typeHint: function() { return this; },
    getType: function() { return this; }
  });

  var Prim = exports.Prim = function(proto, name) { this.name = name; this.proto = proto; };
  Prim.prototype = extend(Type.prototype, {
    constructor: Prim,
    toString: function() { return this.name; },
    getProp: function(prop) {return this.proto.hasProp(prop) || ANull;},
    gatherProperties: function(f, depth) {
      if (this.proto) this.proto.gatherProperties(f, depth);
    }
  });

  function isInteger(str) {
    var c0 = str.charCodeAt(0)
    if (c0 >= 48 && c0 <= 57) return !/\D/.test(str)
    else return false
  }

  var Obj = exports.Obj = function(proto, name) {
    if (!this.props) this.props = Object.create(null);
    this.proto = proto === true ? cx.protos.Object : proto;
    if (this.proto && !(this.proto instanceof Obj)) {
      throw new Error("bad " + Object.keys(this.proto).join())
    }
    if (proto && !name && proto.name && !(this instanceof Fn)) {
      var match = /^(.*)\.prototype$/.exec(this.proto.name);
      if (match) name = match[1];
    }
    this.name = name;
    this.maybeProps = null;
    this.origin = cx.curOrigin;
  };
  Obj.prototype = extend(Type.prototype, {
    constructor: Obj,
    toString: function(maxDepth) {
      if (maxDepth == null) maxDepth = 0;
      if (maxDepth <= 0 && this.name) return this.name;
      var props = [], etc = false;
      for (var prop in this.props) if (prop != "<i>") {
        if (props.length > 5) { etc = true; break; }
        if (maxDepth)
          props.push(prop + ": " + toString(this.props[prop], maxDepth - 1, this));
        else
          props.push(prop);
      }
      props.sort();
      if (etc) props.push("...");
      return "{" + props.join(", ") + "}";
    },
    hasProp: function(prop, searchProto) {
      if (isInteger(prop)) prop = this.normalizeIntegerProp(prop)
      var found = this.props[prop];
      if (searchProto !== false)
        for (var p = this.proto; p && !found; p = p.proto) found = p.props[prop];
      return found;
    },
    defProp: function(prop, originNode) {
      var found = this.hasProp(prop, false);
      if (found) {
        if (originNode && !found.originNode) found.originNode = originNode;
        return found;
      }
      if (prop == "__proto__" || prop == "✖") return ANull;
      if (isInteger(prop)) prop = this.normalizeIntegerProp(prop)

      var av = this.maybeProps && this.maybeProps[prop];
      if (av) {
        delete this.maybeProps[prop];
        this.maybeUnregProtoPropHandler();
      } else {
        av = new AVal;
        av.propertyOf = this;
        av.propertyName = prop;
      }

      this.props[prop] = av;
      av.originNode = originNode;
      av.origin = cx.curOrigin;
      this.broadcastProp(prop, av, true);
      return av;
    },
    getProp: function(prop) {
      var found = this.hasProp(prop, true) || (this.maybeProps && this.maybeProps[prop]);
      if (found) return found;
      if (prop == "__proto__" || prop == "✖") return ANull;
      if (isInteger(prop)) prop = this.normalizeIntegerProp(prop)
      var av = this.ensureMaybeProps()[prop] = new AVal;
      av.propertyOf = this;
      av.propertyName = prop;
      return av;
    },
    normalizeIntegerProp: function(_) { return "<i>" },
    broadcastProp: function(prop, val, local) {
      if (local) {
        this.signal("addProp", prop, val);
        if (!(this instanceof Scope)) registerProp(prop, this);
      }

      if (this.onNewProp) for (var i = 0; i < this.onNewProp.length; ++i) {
        var h = this.onNewProp[i];
        h.onProtoProp ? h.onProtoProp(prop, val, local) : h(prop, val, local);
      }
    },
    onProtoProp: function(prop, val, _local) {
      var maybe = this.maybeProps && this.maybeProps[prop];
      if (maybe) {
        delete this.maybeProps[prop];
        this.maybeUnregProtoPropHandler();
        this.proto.getProp(prop).propagate(maybe);
      }
      this.broadcastProp(prop, val, false);
    },
    replaceProto: function(proto) {
      if (this.proto && this.maybeProps)
        this.proto.unregPropHandler(this)
      this.proto = proto
      if (this.maybeProps)
        this.proto.forAllProps(this)
    },
    ensureMaybeProps: function() {
      if (!this.maybeProps) {
        if (this.proto) this.proto.forAllProps(this);
        this.maybeProps = Object.create(null);
      }
      return this.maybeProps;
    },
    removeProp: function(prop) {
      var av = this.props[prop];
      delete this.props[prop];
      this.ensureMaybeProps()[prop] = av;
      av.types.length = 0;
    },
    forAllProps: function(c) {
      if (!this.onNewProp) {
        this.onNewProp = [];
        if (this.proto) this.proto.forAllProps(this);
      }
      this.onNewProp.push(c);
      for (var o = this; o; o = o.proto) for (var prop in o.props) {
        if (c.onProtoProp)
          c.onProtoProp(prop, o.props[prop], o == this);
        else
          c(prop, o.props[prop], o == this);
      }
    },
    maybeUnregProtoPropHandler: function() {
      if (this.maybeProps) {
        for (var _n in this.maybeProps) return;
        this.maybeProps = null;
      }
      if (!this.proto || this.onNewProp && this.onNewProp.length) return;
      this.proto.unregPropHandler(this);
    },
    unregPropHandler: function(handler) {
      for (var i = 0; i < this.onNewProp.length; ++i)
        if (this.onNewProp[i] == handler) { this.onNewProp.splice(i, 1); break; }
      this.maybeUnregProtoPropHandler();
    },
    gatherProperties: function(f, depth) {
      for (var prop in this.props) if (prop != "<i>" && prop.charAt(0) != ":")
        f(prop, this, depth);
      if (this.proto) this.proto.gatherProperties(f, depth + 1);
    },
    getObjType: function() { return this; }
  });

  var Fn = exports.Fn = function(name, self, args, argNames, retval, generator) {
    Obj.call(this, cx.protos.Function, name);
    this.self = self;
    this.args = args;
    this.argNames = argNames;
    this.retval = retval;
    this.generator = generator
  };
  Fn.prototype = extend(Obj.prototype, {
    constructor: Fn,
    toString: function(maxDepth) {
      if (maxDepth == null) maxDepth = 0;
      var str = this.generator ? "fn*(" : "fn(";
      for (var i = 0; i < this.args.length; ++i) {
        if (i) str += ", ";
        var name = this.argNames[i];
        if (name && name != "?") str += name + ": ";
        str += maxDepth > -3 ? toString(this.args[i], maxDepth - 1, this) : "?";
      }
      str += ")";
      if (!this.retval.isEmpty())
        str += " -> " + (maxDepth > -3 ? toString(this.retval, maxDepth - 1, this) : "?");
      return str;
    },
    getProp: function(prop) {
      if (prop == "prototype") {
        var known = this.hasProp(prop, false);
        if (!known) {
          known = this.defProp(prop);
          var proto = new Obj(true, this.name && this.name + ".prototype");
          proto.origin = this.origin;
          known.addType(proto, WG_MADEUP_PROTO);
        }
        return known;
      }
      return Obj.prototype.getProp.call(this, prop);
    },
    defProp: function(prop, originNode) {
      if (prop == "prototype") {
        var found = this.hasProp(prop, false);
        if (found) return found;
        found = Obj.prototype.defProp.call(this, prop, originNode);
        found.origin = this.origin;
        found.propagate(new FnPrototype(this));
        return found;
      }
      return Obj.prototype.defProp.call(this, prop, originNode);
    },
    getFunctionType: function() { return this; }
  });

  var Arr = exports.Arr = function(contentType) {
    Obj.call(this, cx.protos.Array)
    var content = this.defProp("<i>")
    if (Array.isArray(contentType)) {
      this.tuple = contentType.length
      for (var i = 0; i < contentType.length; i++) {
        var prop = this.defProp(String(i))
        contentType[i].propagate(prop)
        prop.propagate(content)
      }
    } else if (contentType) {
      this.tuple = 0
      contentType.propagate(content)
    }
  };
  Arr.prototype = extend(Obj.prototype, {
    constructor: Arr,
    toString: function(maxDepth) {
      if (maxDepth == null) maxDepth = 0
      if (maxDepth <= -3) return "[?]"
      var content = ""
      if (this.tuple) {
        var similar
        for (var i = 0; i in this.props; i++) {
          var type = toString(this.getProp(String(i)), maxDepth - 1, this)
          if (similar == null)
            similar = type
          else if (similar != type)
            similar = false
          else
            similar = type
          content += (content ? ", " : "") + type
        }
        if (similar) content = similar
      } else {
        content = toString(this.getProp("<i>"), maxDepth - 1, this)
      }
      return "[" + content + "]"
    },
    normalizeIntegerProp: function(prop) {
      if (+prop < this.tuple) return prop
      else return "<i>"
    }
  });

  var Sym = exports.Sym = function(name, originNode) {
    Prim.call(this, cx.protos.Symbol, "Symbol")
    this.symName = name
    this.originNode = originNode
  }
  Sym.prototype = extend(Prim.prototype, {
    constructor: Sym,
    asPropName: function() { return ":" + this.symName },
    getSymbolType: function() { return this }
  })

  exports.getSymbol = function(name, originNode) {
    var cleanName = name.replace(/[^\w$\.]/g, "_")
    var known = cx.symbols[cleanName]
    if (known) {
      if (originNode && !known.originNode) known.originNode = originNode
      return known
    }
    return cx.symbols[cleanName] = new Sym(cleanName, originNode)
  }
  function registerProp(prop, obj) {
    var data = cx.props[prop] || (cx.props[prop] = []);
    data.push(obj);
  }

  function objsWithProp(prop) {
    return cx.props[prop];
  }
  exports.Context = function(defs, parent) {
    this.parent = parent;
    this.props = Object.create(null);
    this.protos = Object.create(null);
    this.origins = [];
    this.curOrigin = "ecma5";
    this.paths = Object.create(null);
    this.definitions = Object.create(null);
    this.purgeGen = 0;
    this.workList = null;
    this.disabledComputing = null;
    this.curSuperCtor = this.curSuper = null;
    this.symbols = Object.create(null)

    exports.withContext(this, function() {
      cx.protos.Object = new Obj(null, "Object.prototype");
      cx.topScope = new Scope();
      cx.topScope.name = "<top>";
      cx.protos.Array = new Obj(true, "Array.prototype");
      cx.protos.Function = new Fn("Function.prototype", ANull, [], [], ANull);
      cx.protos.Function.proto = cx.protos.Object;
      cx.protos.RegExp = new Obj(true, "RegExp.prototype");
      cx.protos.String = new Obj(true, "String.prototype");
      cx.protos.Number = new Obj(true, "Number.prototype");
      cx.protos.Boolean = new Obj(true, "Boolean.prototype");
      cx.protos.Symbol = new Obj(true, "Symbol.prototype");
      cx.str = new Prim(cx.protos.String, "string");
      cx.bool = new Prim(cx.protos.Boolean, "bool");
      cx.num = new Prim(cx.protos.Number, "number");
      cx.curOrigin = null;

      if (defs) for (var i = 0; i < defs.length; ++i)
        def.load(defs[i]);
    });
  };

  exports.Context.prototype.startAnalysis = function() {
    this.disabledComputing = this.workList = this.curSuperCtor = this.curSuper = null;
  };

  var cx = null;
  exports.cx = function() { return cx; };

  exports.withContext = function(context, f) {
    var old = cx;
    cx = context;
    try { return f(); }
    finally { cx = old; }
  };

  exports.TimedOut = function() {
    this.message = "Timed out";
    this.stack = (new Error()).stack;
  };
  exports.TimedOut.prototype = Object.create(Error.prototype);
  exports.TimedOut.prototype.name = "infer.TimedOut";

  var timeout;
  exports.withTimeout = function(ms, f) {
    var end = +new Date + ms;
    var oldEnd = timeout;
    if (oldEnd && oldEnd < end) return f();
    timeout = end;
    try { return f(); }
    finally { timeout = oldEnd; }
  };

  exports.addOrigin = function(origin) {
    if (cx.origins.indexOf(origin) < 0) cx.origins.push(origin);
  };

  var baseMaxWorkDepth = 20, reduceMaxWorkDepth = 0.0001;
  function withWorklist(f) {
    if (cx.workList) return f(cx.workList);

    var list = [], depth = 0;
    var add = cx.workList = function(type, target, weight) {
      if (depth < baseMaxWorkDepth - reduceMaxWorkDepth * list.length)
        list.push(type, target, weight, depth);
    };
    var ret = f(add);
    for (var i = 0; i < list.length; i += 4) {
      if (timeout && +new Date >= timeout)
        throw new exports.TimedOut();
      depth = list[i + 3] + 1;
      list[i + 1].addType(list[i], list[i + 2]);
    }
    cx.workList = null;
    return ret;
  }

  function withSuper(ctor, obj, f) {
    var oldCtor = cx.curSuperCtor, oldObj = cx.curSuper
    cx.curSuperCtor = ctor; cx.curSuper = obj
    var result = f()
    cx.curSuperCtor = oldCtor; cx.curSuper = oldObj
    return result
  }
  var Scope = exports.Scope = function(prev, originNode, isBlock) {
    Obj.call(this, prev || true);
    this.prev = prev;
    this.originNode = originNode
    this.isBlock = !!isBlock
  };
  Scope.prototype = extend(Obj.prototype, {
    constructor: Scope,
    defVar: function(name, originNode) {
      for (var s = this; ; s = s.proto) {
        var found = s.props[name];
        if (found) return found;
        if (!s.prev) return s.defProp(name, originNode);
      }
    }
  });

  function functionScope(scope) {
    while (scope.isBlock) scope = scope.prev
    return scope
  }
  function maybeInstantiate(scope, score) {
    var fn = functionScope(scope).fnType
    if (fn) fn.instantiateScore = (fn.instantiateScore || 0) + score;
  }

  var NotSmaller = {};
  function nodeSmallerThan(node, n) {
    try {
      walk.simple(node, {Expression: function() { if (--n <= 0) throw NotSmaller; }});
      return true;
    } catch(e) {
      if (e == NotSmaller) return false;
      throw e;
    }
  }

  function maybeTagAsInstantiated(node, fn) {
    var score = fn.instantiateScore;
    if (!cx.disabledComputing && score && fn.args.length && nodeSmallerThan(node, score * 5)) {
      maybeInstantiate(functionScope(fn.originNode.scope.prev), score / 2);
      setFunctionInstantiated(node, fn);
      return true;
    } else {
      fn.instantiateScore = null;
    }
  }

  function setFunctionInstantiated(node, fn) {
    for (var i = 0; i < fn.args.length; ++i) fn.args[i] = new AVal;
    fn.self = new AVal;
    fn.computeRet = function(self, args) {
      return withDisabledComputing(fn, function() {
        var oldOrigin = cx.curOrigin;
        cx.curOrigin = fn.origin;
        var scope = node.scope
        var scopeCopy = new Scope(scope.prev, scope.originNode);
        for (var v in scope.props) {
          var local = scopeCopy.defProp(v, scope.props[v].originNode);
          for (var i = 0; i < args.length; ++i) if (fn.argNames[i] == v && i < args.length)
            args[i].propagate(local);
        }
        var argNames = fn.argNames.length != args.length ? fn.argNames.slice(0, args.length) : fn.argNames;
        while (argNames.length < args.length) argNames.push("?");
        scopeCopy.fnType = new Fn(fn.name, self, args, argNames, ANull, fn.generator);
        scopeCopy.fnType.originNode = fn.originNode;
        if (fn.arguments) {
          var argset = scopeCopy.fnType.arguments = new AVal;
          scopeCopy.defProp("arguments").addType(new Arr(argset));
          for (var i = 0; i < args.length; ++i) args[i].propagate(argset);
        }
        node.scope = scopeCopy;
        walk.recursive(node.body, scopeCopy, null, scopeGatherer);
        walk.recursive(node.body, scopeCopy, null, inferWrapper);
        cx.curOrigin = oldOrigin;
        return scopeCopy.fnType.retval;
      });
    };
  }

  function maybeTagAsGeneric(fn) {
    var target = fn.retval;
    if (target == ANull) return;
    var targetInner, asArray;
    if (!target.isEmpty() && (targetInner = target.getType()) instanceof Arr)
      target = asArray = targetInner.getProp("<i>");

    function explore(aval, path, depth) {
      if (depth > 3 || !aval.forward) return;
      for (var i = 0; i < aval.forward.length; ++i) {
        var prop = aval.forward[i].propagatesTo();
        if (!prop) continue;
        var newPath = path, dest;
        if (prop instanceof AVal) {
          dest = prop;
        } else if (prop.target instanceof AVal) {
          newPath += prop.pathExt;
          dest = prop.target;
        } else continue;
        if (dest == target) return newPath;
        var found = explore(dest, newPath, depth + 1);
        if (found) return found;
      }
    }

    var foundPath = explore(fn.self, "!this", 0);
    for (var i = 0; !foundPath && i < fn.args.length; ++i)
      foundPath = explore(fn.args[i], "!" + i, 0);

    if (foundPath) {
      if (asArray) foundPath = "[" + foundPath + "]";
      var p = new def.TypeParser(foundPath);
      var parsed = p.parseType(true);
      fn.computeRet = parsed.apply ? parsed : function() { return parsed; };
      fn.computeRetSource = foundPath;
      return true;
    }
  }
  function addVar(scope, nameNode) {
    return scope.defProp(nameNode.name, nameNode);
  }
  function patternName(node) {
    if (node.type == "Identifier") return node.name
    if (node.type == "AssignmentPattern") return patternName(node.left)
    if (node.type == "ObjectPattern") return "{" + node.properties.map(function(e) { return patternName(e.value) }).join(", ") + "}"
    if (node.type == "ArrayPattern") return "[" + node.elements.map(patternName).join(", ") + "]"
    if (node.type == "RestElement") return "..." + patternName(node.argument)
    return "_"
  }

  function isBlockScopedDecl(node) {
    return node.type == "VariableDeclaration" && node.kind != "var" ||
      node.type == "FunctionDeclaration" ||
      node.type == "ClassDeclaration";
  }

  function patternScopes(inner, outer) {
    return {inner: inner, outer: outer || inner}
  }

  var scopeGatherer = exports.scopeGatherer = walk.make({
    VariablePattern: function(node, scopes) {
      if (scopes.inner) addVar(scopes.inner, node)
    },
    AssignmentPattern: function(node, scopes, c) {
      c(node.left, scopes, "Pattern")
      c(node.right, scopes.outer, "Expression")
    },
    AssignmentExpression: function(node, scope, c) {
      if (node.left.type == "MemberExpression")
        c(node.left, scope, "Expression")
      else
        c(node.left, patternScopes(false, scope), "Pattern")
      c(node.right, scope, "Expression")
    },
    Function: function(node, scope, c) {
      if (scope.inner) throw new Error("problem at " + node.start + " " + node.type)
      var inner = node.scope = new Scope(scope, node)
      var argVals = [], argNames = []
      for (var i = 0; i < node.params.length; ++i) {
        var param = node.params[i]
        argNames.push(patternName(param))
        if (param.type == "Identifier") {
          argVals.push(addVar(inner, param))
        } else {
          var arg = new AVal
          argVals.push(arg)
          arg.originNode = param
          c(param, patternScopes(inner), "Pattern")
        }
      }
      inner.fnType = new Fn(node.id && node.id.name, new AVal, argVals, argNames, ANull, node.generator)
      inner.fnType.originNode = node;
      if (node.id) {
        var decl = node.type == "FunctionDeclaration";
        addVar(decl ? scope : inner, node.id);
      }
      c(node.body, inner, node.expression ? "Expression" : "Statement");
    },
    BlockStatement: function(node, scope, c) {
      if (!node.scope && node.body.some(isBlockScopedDecl))
        scope = node.scope = new Scope(scope, node, true)
      walk.base.BlockStatement(node, scope, c)
    },
    TryStatement: function(node, scope, c) {
      c(node.block, scope, "Statement");
      if (node.handler) {
        if (node.handler.param.type == "Identifier") {
          var v = addVar(scope, node.handler.param);
          c(node.handler.body, scope, "Statement");
          var e5 = cx.definitions.ecma5;
          if (e5 && v.isEmpty()) getInstance(e5["Error.prototype"]).propagate(v, WG_CATCH_ERROR);
        } else {
          c(node.handler.param, patternScopes(scope), "Pattern")
        }
      }
      if (node.finalizer) c(node.finalizer, scope, "Statement");
    },
    VariableDeclaration: function(node, scope, c) {
      var targetScope = node.kind == "var" ? functionScope(scope) : scope
      for (var i = 0; i < node.declarations.length; ++i) {
        var decl = node.declarations[i];
        c(decl.id, patternScopes(targetScope, scope), "Pattern")
        if (decl.init) c(decl.init, scope, "Expression");
      }
    },
    ClassDeclaration: function(node, scope, c) {
      addVar(scope, node.id)
      if (node.superClass) c(node.superClass, scope, "Expression")
      for (var i = 0; i < node.body.body.length; i++)
        c(node.body.body[i], scope)
    },
    ForInStatement: function(node, scope, c) {
      if (!node.scope && isBlockScopedDecl(node.left))
        scope = node.scope = new Scope(scope, node, true)
      walk.base.ForInStatement(node, scope, c)
    },
    ForStatement: function(node, scope, c) {
      if (!node.scope && node.init && isBlockScopedDecl(node.init))
        scope = node.scope = new Scope(scope, node, true)
      walk.base.ForStatement(node, scope, c)
    },
    ImportDeclaration: function(node, scope) {
      for (var i = 0; i < node.specifiers.length; i++)
        addVar(scope, node.specifiers[i].local)
    }
  });
  scopeGatherer.ForOfStatement = scopeGatherer.ForInStatement
  var propName = exports.propName = function(node, inferInScope) {
    var key = node.property || node.key;
    if (!node.computed && key.type == "Identifier") return key.name;
    if (key.type == "Literal") {
      if (typeof key.value == "string") return key.value
      if (typeof key.value == "number") return String(key.value)
    }
    if (inferInScope) {
      var symName = symbolName(infer(key, inferInScope))
      if (symName) return node.propName = symName
    } else if (node.propName) {
      return node.propName
    }
    return "<i>";
  }
  function symbolName(val) {
    var sym = val.getSymbolType()
    if (sym) return sym.asPropName()
  }

  function unopResultType(op) {
    switch (op) {
    case "+": case "-": case "~": return cx.num;
    case "!": return cx.bool;
    case "typeof": return cx.str;
    case "void": case "delete": return ANull;
    }
  }
  function binopIsBoolean(op) {
    switch (op) {
    case "==": case "!=": case "===": case "!==": case "<": case ">": case ">=": case "<=":
    case "in": case "instanceof": return true;
    }
  }
  function literalType(node) {
    if (node.regex) return getInstance(cx.protos.RegExp);
    switch (typeof node.value) {
    case "boolean": return cx.bool;
    case "number": return cx.num;
    case "string": return cx.str;
    case "object":
    case "function":
      if (!node.value) return ANull;
      return getInstance(cx.protos.RegExp);
    }
  }

  function join(a, b) {
    if (a == b || b == ANull) return a
    if (a == ANull) return b
    var joined = new AVal
    a.propagate(joined)
    b.propagate(joined)
    return joined
  }

  function connectParams(node, scope) {
    for (var i = 0; i < node.params.length; i++) {
      var param = node.params[i]
      if (param.type == "Identifier") continue
      connectPattern(param, scope, node.scope.fnType.args[i])
    }
  }

  function ensureVar(node, scope) {
    return scope.hasProp(node.name) || cx.topScope.defProp(node.name, node)
  }

  var inferPatternVisitor = exports.inferPatternVisitor = {
    Identifier: function(node, scope, source) {
      source.propagate(ensureVar(node, scope))
    },
    MemberExpression: function(node, scope, source) {
      var obj = infer(node.object, scope)
      var pName = propName(node, scope)
      obj.propagate(new DefProp(pName, source, node.property))
    },
    RestElement: function(node, scope, source) {
      connectPattern(node.argument, scope, new Arr(source))
    },
    ObjectPattern: function(node, scope, source) {
      for (var i = 0; i < node.properties.length; ++i) {
        var prop = node.properties[i]
        connectPattern(prop.value, scope, source.getProp(prop.key.name))
      }
    },
    ArrayPattern: function(node, scope, source) {
      for (var i = 0; i < node.elements.length; i++)
        if (node.elements[i])
          connectPattern(node.elements[i], scope, source.getProp(String(i)))
    },
    AssignmentPattern: function(node, scope, source) {
      connectPattern(node.left, scope, join(source, infer(node.right, scope)))
    }
  }

  function connectPattern(node, scope, source) {
    var connecter = inferPatternVisitor[node.type]
    if (connecter) connecter(node, scope, source)
  }

  function getThis(scope) {
    var fnScope = functionScope(scope)
    return fnScope.fnType ? fnScope.fnType.self : fnScope
  }

  function maybeAddPhantomObj(obj) {
    if (!obj.isEmpty() || !obj.propertyOf) return
    obj.propertyOf.getProp(obj.propertyName).addType(new Obj, WG_PHANTOM_OBJ)
    maybeAddPhantomObj(obj.propertyOf)
  }

  function inferClass(node, scope, name) {
    if (!name && node.id) name = node.id.name

    var sup = cx.protos.Object, supCtor, delayed
    if (node.superClass) {
      if (node.superClass.type == "Literal" && node.superClass.value == null) {
        sup = null
      } else {
        var supVal = infer(node.superClass, scope), supProto
        supCtor = supVal.getFunctionType()
        if (supCtor && (supProto = supCtor.getProp("prototype").getObjType())) {
          sup = supProto
        } else {
          supCtor = supVal
          delayed = supVal.getProp("prototype")
        }
      }
    }
    var proto = new Obj(sup, name && name + ".prototype")
    if (delayed) delayed.propagate(new HasProto(proto))

    return withSuper(supCtor, delayed || sup, function() {
      var ctor, body = node.body.body
      for (var i = 0; i < body.length; i++)
        if (body[i].kind == "constructor") ctor = body[i].value
      var fn = node.objType = ctor ? infer(ctor, scope) : new Fn(name, ANull, [], null, ANull)
      fn.originNode = node.id || ctor || node

      var inst = getInstance(proto, fn)
      fn.self.addType(inst)
      fn.defProp("prototype", node).addType(proto)
      for (var i = 0; i < body.length; i++) {
        var method = body[i], target
        if (method.kind == "constructor") continue
        var pName = propName(method, scope)
        if (pName == "<i>" || method.kind == "set") {
          target = ANull
        } else {
          target = (method.static ? fn : proto).defProp(pName, method.key)
          target.initializer = true
          if (method.kind == "get") target = new IsCallee(inst, [], null, target)
        }
        infer(method.value, scope, target)
        var methodFn = target.getFunctionType()
        if (methodFn) methodFn.self.addType(inst)
      }
      return fn
    })
  }

  function arrayLiteralType(elements, scope, inner) {
    var tuple = elements.length > 1 && elements.length < 6
    if (tuple) {
      var homogenous = true, litType
      for (var i = 0; i < elements.length; i++) {
        var elt = elements[i]
        if (!elt)
          tuple = false
        else if (elt.type != "Literal" || (litType && litType != typeof elt.value))
          homogenous = false
        else
          litType = typeof elt.value
      }
      if (homogenous) tuple = false
    }

    if (tuple) {
      var types = []
      for (var i = 0; i < elements.length; ++i)
        types.push(inner(elements[i], scope))
      return new Arr(types)
    } else if (elements.length < 2) {
      return new Arr(elements[0] && inner(elements[0], scope))
    } else {
      var eltVal = new AVal
      for (var i = 0; i < elements.length; i++)
        if (elements[i]) inner(elements[i], scope).propagate(eltVal)
      return new Arr(eltVal)
    }
  }

  function ret(f) {
    return function(node, scope, out, name) {
      var r = f(node, scope, name);
      if (out) r.propagate(out);
      return r;
    };
  }
  function fill(f) {
    return function(node, scope, out, name) {
      if (!out) out = new AVal;
      f(node, scope, out, name);
      return out;
    };
  }

  var inferExprVisitor = exports.inferExprVisitor = {
    ArrayExpression: ret(function(node, scope) {
      return arrayLiteralType(node.elements, scope, infer)
    }),
    ObjectExpression: ret(function(node, scope, name) {
      var proto = true, waitForProto
      for (var i = 0; i < node.properties.length; ++i) {
        var prop = node.properties[i]
        if (prop.key.name == "__proto__") {
          if (prop.value.type == "Literal" && prop.value.value == null) {
            proto = null
          } else {
            var protoVal = infer(prop.value, scope), known = protoVal.getObjType()
            if (known) proto = known
            else waitForProto = protoVal
          }
        }
      }

      var obj = node.objType = new Obj(proto, name);
      if (waitForProto) waitForProto.propagate(new HasProto(obj))
      obj.originNode = node;

      withSuper(null, waitForProto || proto, function() {
        for (var i = 0; i < node.properties.length; ++i) {
          var prop = node.properties[i], key = prop.key;
          if (prop.value.name == "✖" || prop.key.name == "__proto__") continue;

          var name = propName(prop, scope), target
          if (name == "<i>" || prop.kind == "set") {
            target = ANull;
          } else {
            var val = target = obj.defProp(name, key);
            val.initializer = true;
            if (prop.kind == "get")
              target = new IsCallee(obj, [], null, val);
          }
          infer(prop.value, scope, target, name);
          if (prop.value.type == "FunctionExpression")
            prop.value.scope.fnType.self.addType(obj, WG_SPECULATIVE_THIS);
        }
      })
      return obj;
    }),
    FunctionExpression: ret(function(node, scope, name) {
      var inner = node.scope, fn = inner.fnType;
      if (name && !fn.name) fn.name = name;
      connectParams(node, inner)
      if (node.expression)
        infer(node.body, inner, inner.fnType.retval = new AVal)
      else
        walk.recursive(node.body, inner, null, inferWrapper, "Statement")
      if (node.type == "ArrowFunctionExpression") {
        getThis(scope).propagate(fn.self)
        fn.self = ANull
      }
      maybeTagAsInstantiated(node, fn) || maybeTagAsGeneric(fn);
      if (node.id) inner.getProp(node.id.name).addType(fn);
      return fn;
    }),
    ClassExpression: ret(inferClass),
    SequenceExpression: ret(function(node, scope) {
      for (var i = 0, l = node.expressions.length - 1; i < l; ++i)
        infer(node.expressions[i], scope, ANull);
      return infer(node.expressions[l], scope);
    }),
    UnaryExpression: ret(function(node, scope) {
      infer(node.argument, scope, ANull);
      return unopResultType(node.operator);
    }),
    SpreadExpression: ret(function(node, scope) {
      return infer(node.argument, scope, ANull); // TODO: fixme
    }),
    SpreadElement: ret(function(node, scope) {
      return infer(node.argument, scope, ANull); // TODO: fixme
    }),
    UpdateExpression: ret(function(node, scope) {
      infer(node.argument, scope, ANull);
      return cx.num;
    }),
    BinaryExpression: ret(function(node, scope) {
      if (node.operator == "+") {
        var lhs = infer(node.left, scope);
        var rhs = infer(node.right, scope);
        if (lhs.hasType(cx.str) || rhs.hasType(cx.str)) return cx.str;
        if (lhs.hasType(cx.num) && rhs.hasType(cx.num)) return cx.num;
        var result = new AVal;
        lhs.propagate(new IsAdded(rhs, result));
        rhs.propagate(new IsAdded(lhs, result));
        return result;
      } else {
        infer(node.left, scope, ANull);
        infer(node.right, scope, ANull);
        return binopIsBoolean(node.operator) ? cx.bool : cx.num;
      }
    }),
    AssignmentExpression: ret(function(node, scope, name) {
      var rhs, pName;
      if (node.left.type == "MemberExpression") {
        pName = propName(node.left, scope)
        if (!name)
          name = node.left.object.type == "Identifier" ? node.left.object.name + "." + pName : pName
      } else if (!name && node.left.type == "Identifier") {
        name = node.left.name
      }

      if (node.operator && node.operator != "=" && node.operator != "+=") {
        infer(node.right, scope, ANull);
        rhs = cx.num;
      } else {
        rhs = infer(node.right, scope, null, name);
      }

      if (node.left.type == "MemberExpression") {
        var obj = infer(node.left.object, scope);
        if (pName == "prototype") maybeInstantiate(scope, 20);
        if (pName == "<i>") {
          var v = node.left.property.name, local = scope.props[v], over = local && local.iteratesOver;
          if (over) {
            maybeInstantiate(scope, 20);
            var fromRight = node.right.type == "MemberExpression" && node.right.computed && node.right.property.name == v;
            over.forAllProps(function(prop, val, local) {
              if (local && prop != "prototype" && prop != "<i>")
                obj.propagate(new DefProp(prop, fromRight ? val : ANull));
            });
            return rhs;
          }
        }

        obj.propagate(new DefProp(pName, rhs, node.left.property));
        maybeAddPhantomObj(obj)
        if (node.right.type == "FunctionExpression")
          obj.propagate(node.right.scope.fnType.self, WG_SPECULATIVE_THIS);
      } else {
        connectPattern(node.left, scope, rhs)
      }
      return rhs;
    }),
    LogicalExpression: fill(function(node, scope, out) {
      infer(node.left, scope, out);
      infer(node.right, scope, out);
    }),
    ConditionalExpression: fill(function(node, scope, out) {
      infer(node.test, scope, ANull);
      infer(node.consequent, scope, out);
      infer(node.alternate, scope, out);
    }),
    NewExpression: fill(function(node, scope, out, name) {
      if (node.callee.type == "Identifier" && node.callee.name in scope.props)
        maybeInstantiate(scope, 20);

      for (var i = 0, args = []; i < node.arguments.length; ++i)
        args.push(infer(node.arguments[i], scope));
      var callee = infer(node.callee, scope);
      var self = new AVal;
      callee.propagate(new IsCtor(self, name && /\.prototype$/.test(name)));
      self.propagate(out, WG_NEW_INSTANCE);
      callee.propagate(new IsCallee(self, args, node.arguments, new IfObj(out)));
    }),
    CallExpression: fill(function(node, scope, out) {
      for (var i = 0, args = []; i < node.arguments.length; ++i)
        args.push(infer(node.arguments[i], scope));
      var outerFn = functionScope(scope).fnType
      if (node.callee.type == "MemberExpression") {
        var self = infer(node.callee.object, scope);
        var pName = propName(node.callee, scope)
        if (outerFn && (pName == "call" || pName == "apply") &&
            outerFn.args.indexOf(self) > -1)
          maybeInstantiate(scope, 30);
        self.propagate(new HasMethodCall(pName, args, node.arguments, out));
      } else if (node.callee.type == "Super" && cx.curSuperCtor) {
        cx.curSuperCtor.propagate(new IsCallee(getThis(scope), args, node.arguments, out))
      } else {
        var callee = infer(node.callee, scope);
        if (outerFn && outerFn.args.indexOf(callee) > -1)
          maybeInstantiate(scope, 30);
        var knownFn = callee.getFunctionType();
        if (knownFn && knownFn.instantiateScore && outerFn)
          maybeInstantiate(scope, knownFn.instantiateScore / 5);
        callee.propagate(new IsCallee(cx.topScope, args, node.arguments, out));
      }
    }),
    MemberExpression: fill(function(node, scope, out) {
      var name = propName(node), wg;
      if (name == "<i>") {
        var propType = infer(node.property, scope)
        var symName = symbolName(propType)
        if (symName)
          name = node.propName = symName
        else if (!propType.hasType(cx.num))
          wg = WG_MULTI_MEMBER
      }
      infer(node.object, scope).getProp(name).propagate(out, wg)
    }),
    Identifier: ret(function(node, scope) {
      if (node.name == "arguments") {
        var fnScope = functionScope(scope)
        if (fnScope.fnType && !(node.name in fnScope.props))
          scope.defProp(node.name, fnScope.fnType.originNode)
            .addType(new Arr(fnScope.fnType.arguments = new AVal));
      }
      return scope.getProp(node.name);
    }),
    ThisExpression: ret(function(_node, scope) {
      return getThis(scope)
    }),
    Super: ret(function(node) {
      return node.superType = cx.curSuper || ANull
    }),
    Literal: ret(function(node) {
      return literalType(node);
    }),
    TemplateLiteral: ret(function(node, scope) {
      for (var i = 0; i < node.expressions.length; ++i)
        infer(node.expressions[i], scope, ANull)
      return cx.str
    }),
    TaggedTemplateExpression: fill(function(node, scope, out) {
      var args = [new Arr(cx.str)]
      for (var i = 0; i < node.quasi.expressions.length; ++i)
        args.push(infer(node.quasi.expressions[i], scope))
      infer(node.tag, scope, new IsCallee(cx.topScope, args, node.quasi.expressions, out))
    }),
    YieldExpression: ret(function(node, scope) {
      var output = ANull, fn = functionScope(scope).fnType
      if (fn) {
        if (fn.retval == ANull) fn.retval = new AVal
        if (!fn.yieldval) fn.yieldval = new AVal
        output = fn.retval
      }
      if (node.argument) {
        if (node.delegate) {
          infer(node.argument, scope, new HasMethodCall("next", [], null,
                                                        new GetProp("value", output)))
        } else {
          infer(node.argument, scope, output)
        }
      }
      return fn ? fn.yieldval : ANull
    })
  };
  inferExprVisitor.ArrowFunctionExpression = inferExprVisitor.FunctionExpression

  function infer(node, scope, out, name) {
    var handler = inferExprVisitor[node.type];
    return handler ? handler(node, scope, out, name) : ANull;
  }

  function loopPattern(init) {
    return init.type == "VariableDeclaration" ? init.declarations[0].id : init
  }

  var inferWrapper = exports.inferWrapper = walk.make({
    Expression: function(node, scope) {
      infer(node, node.scope || scope, ANull);
    },

    FunctionDeclaration: function(node, scope, c) {
      var inner = node.scope, fn = inner.fnType;
      connectParams(node, inner)
      c(node.body, inner, "Statement");
      maybeTagAsInstantiated(node, fn) || maybeTagAsGeneric(fn);
      scope.getProp(node.id.name).addType(fn)
    },

    Statement: function(node, scope, c) {
      c(node, node.scope || scope)
    },

    VariableDeclaration: function(node, scope) {
      for (var i = 0; i < node.declarations.length; ++i) {
        var decl = node.declarations[i];
        if (decl.id.type == "Identifier") {
          var prop = scope.getProp(decl.id.name);
          if (decl.init)
            infer(decl.init, scope, prop, decl.id.name);
        } else if (decl.init) {
          connectPattern(decl.id, scope, infer(decl.init, scope))
        }
      }
    },

    ClassDeclaration: function(node, scope) {
      scope.getProp(node.id.name).addType(inferClass(node, scope, node.id.name))
    },

    ReturnStatement: function(node, scope) {
      if (!node.argument) return;
      var output = ANull, fn = functionScope(scope).fnType
      if (fn) {
        if (fn.retval == ANull) fn.retval = new AVal;
        output = fn.retval;
      }
      infer(node.argument, scope, output);
    },

    ForInStatement: function(node, scope, c) {
      var source = infer(node.right, scope);
      if ((node.right.type == "Identifier" && node.right.name in scope.props) ||
          (node.right.type == "MemberExpression" && node.right.property.name == "prototype")) {
        maybeInstantiate(scope, 5);
        var pattern = loopPattern(node.left)
        if (pattern.type == "Identifier") {
          if (pattern.name in scope.props)
            scope.getProp(pattern.name).iteratesOver = source
          source.getProp("<i>").propagate(ensureVar(pattern, scope))
        } else {
          connectPattern(pattern, scope, source.getProp("<i>"))
        }
      }
      c(node.body, scope, "Statement");
    },

    ForOfStatement: function(node, scope, c) {
      var pattern = loopPattern(node.left), target
      if (pattern.type == "Identifier")
        target = ensureVar(pattern, scope)
      else
        connectPattern(pattern, scope, target = new AVal)
      infer(node.right, scope, new HasMethodCall(":Symbol.iterator", [], null,
                                                 new HasMethodCall("next", [], null,
                                                                   new GetProp("value", target))))
      c(node.body, scope, "Statement")
    }
  });
  var parse = exports.parse = function(text, options, thirdArg) {
    if (!options || Array.isArray(options)) options = thirdArg
    var ast;
    try { ast = acorn.parse(text, options); }
    catch(e) { ast = acorn_loose.parse_dammit(text, options); }
    return ast;
  };
  exports.analyze = function(ast, name, scope) {
    if (typeof ast == "string") ast = parse(ast);

    if (!name) name = "file#" + cx.origins.length;
    exports.addOrigin(cx.curOrigin = name);

    if (!scope) scope = cx.topScope;
    cx.startAnalysis();

    walk.recursive(ast, scope, null, scopeGatherer);
    if (cx.parent) cx.parent.signal("preInfer", ast, scope)
    walk.recursive(ast, scope, null, inferWrapper);
    if (cx.parent) cx.parent.signal("postInfer", ast, scope)

    cx.curOrigin = null;
  };
  exports.purge = function(origins, start, end) {
    var test = makePredicate(origins, start, end);
    ++cx.purgeGen;
    cx.topScope.purge(test);
    for (var prop in cx.props) {
      var list = cx.props[prop];
      for (var i = 0; i < list.length; ++i) {
        var obj = list[i], av = obj.props[prop];
        if (!av || test(av, av.originNode)) list.splice(i--, 1);
      }
      if (!list.length) delete cx.props[prop];
    }
  };

  function makePredicate(origins, start, end) {
    var arr = Array.isArray(origins);
    if (arr && origins.length == 1) { origins = origins[0]; arr = false; }
    if (arr) {
      if (end == null) return function(n) { return origins.indexOf(n.origin) > -1; };
      return function(n, pos) { return pos && pos.start >= start && pos.end <= end && origins.indexOf(n.origin) > -1; };
    } else {
      if (end == null) return function(n) { return n.origin == origins; };
      return function(n, pos) { return pos && pos.start >= start && pos.end <= end && n.origin == origins; };
    }
  }

  AVal.prototype.purge = function(test) {
    if (this.purgeGen == cx.purgeGen) return;
    this.purgeGen = cx.purgeGen;
    for (var i = 0; i < this.types.length; ++i) {
      var type = this.types[i];
      if (test(type, type.originNode))
        this.types.splice(i--, 1);
      else
        type.purge(test);
    }
    if (!this.types.length) this.maxWeight = 0;

    if (this.forward) for (var i = 0; i < this.forward.length; ++i) {
      var f = this.forward[i];
      if (test(f)) {
        this.forward.splice(i--, 1);
        if (this.props) this.props = null;
      } else if (f.purge) {
        f.purge(test);
      }
    }
  };
  ANull.purge = function() {};
  Obj.prototype.purge = function(test) {
    if (this.purgeGen == cx.purgeGen) return true;
    this.purgeGen = cx.purgeGen;
    for (var p in this.props) {
      var av = this.props[p];
      if (test(av, av.originNode))
        this.removeProp(p);
      av.purge(test);
    }
  };
  Fn.prototype.purge = function(test) {
    if (Obj.prototype.purge.call(this, test)) return;
    this.self.purge(test);
    this.retval.purge(test);
    for (var i = 0; i < this.args.length; ++i) this.args[i].purge(test);
  };
  function findByPropertyName(name) {
    guessing = true;
    var found = objsWithProp(name);
    if (found) for (var i = 0; i < found.length; ++i) {
      var val = found[i].getProp(name);
      if (!val.isEmpty()) return val;
    }
    return ANull;
  }

  function generatorResult(input, output) {
    var retObj = new Obj(true)
    retObj.defProp("done").addType(cx.bool)
    output.propagate(retObj.defProp("value"))
    var method = new Fn(null, ANull, input ? [input] : [], input ? ["?"] : [], retObj)
    var result = new Obj(cx.definitions.ecma6 && cx.definitions.ecma6.generator_prototype || true)
    result.defProp("next").addType(method)
    return result
  }

  function maybeIterator(fn, output) {
    if (!fn.generator) return output
    if (!fn.computeRet) { // Reuse iterator objects for non-computed return types
      if (fn.generator === true) fn.generator = generatorResult(fn.yieldval, output)
      return fn.generator
    }
    return generatorResult(fn.yieldval, output)
  }

  function computeReturnType(funcNode, argNodes, scope) {
    var fn = findType(funcNode, scope).getFunctionType()
    if (!fn) return ANull
    var result = fn.retval
    if (fn.computeRet) {
      for (var i = 0, args = []; i < argNodes.length; ++i)
        args.push(findType(argNodes[i], scope))
      var self = ANull
      if (funcNode.type == "MemberExpression")
        self = findType(funcNode.object, scope)
      result = fn.computeRet(self, args, argNodes);
    }
    return maybeIterator(fn, result)
  }

  var typeFinder = exports.typeFinder = {
    ArrayExpression: function(node, scope) {
      return arrayLiteralType(node.elements, scope, findType)
    },
    ObjectExpression: function(node) {
      return node.objType;
    },
    ClassExpression: function(node) {
      return node.objType;
    },
    FunctionExpression: function(node) {
      return node.scope.fnType;
    },
    ArrowFunctionExpression: function(node) {
      return node.scope.fnType;
    },
    SequenceExpression: function(node, scope) {
      return findType(node.expressions[node.expressions.length-1], scope);
    },
    UnaryExpression: function(node) {
      return unopResultType(node.operator);
    },
    UpdateExpression: function() {
      return cx.num;
    },
    BinaryExpression: function(node, scope) {
      if (binopIsBoolean(node.operator)) return cx.bool;
      if (node.operator == "+") {
        var lhs = findType(node.left, scope);
        var rhs = findType(node.right, scope);
        if (lhs.hasType(cx.str) || rhs.hasType(cx.str)) return cx.str;
      }
      return cx.num;
    },
    AssignmentExpression: function(node, scope) {
      return findType(node.right, scope);
    },
    LogicalExpression: function(node, scope) {
      var lhs = findType(node.left, scope);
      return lhs.isEmpty() ? findType(node.right, scope) : lhs;
    },
    ConditionalExpression: function(node, scope) {
      var lhs = findType(node.consequent, scope);
      return lhs.isEmpty() ? findType(node.alternate, scope) : lhs;
    },
    NewExpression: function(node, scope) {
      var f = findType(node.callee, scope).getFunctionType();
      var proto = f && f.getProp("prototype").getObjType();
      if (!proto) return ANull;
      return getInstance(proto, f);
    },
    CallExpression: function(node, scope) {
      return computeReturnType(node.callee, node.arguments, scope)
    },
    MemberExpression: function(node, scope) {
      var propN = propName(node), obj = findType(node.object, scope).getType();
      if (obj) return obj.getProp(propN);
      if (propN == "<i>") return ANull;
      return findByPropertyName(propN);
    },
    Identifier: function(node, scope) {
      return scope.hasProp(node.name) || ANull;
    },
    ThisExpression: function(_node, scope) {
      return getThis(scope)
    },
    Literal: function(node) {
      return literalType(node);
    },
    Super: ret(function(node) {
      return node.superType
    }),
    TemplateLiteral: function() {
      return cx.str
    },
    TaggedTemplateExpression: function(node, scope) {
      return computeReturnType(node.tag, node.quasi.expressions, scope)
    },
    YieldExpression: function(_node, scope) {
      var fn = functionScope(scope).fnType
      return fn ? fn.yieldval : ANull
    }
  };

  function findType(node, scope) {
    var finder = typeFinder[node.type];
    return finder ? finder(node, scope) : ANull;
  }

  var searchVisitor = exports.searchVisitor = walk.make({
    Function: function(node, _st, c) {
      walk.base.Function(node, node.scope, c)
    },
    Property: function(node, st, c) {
      if (node.computed) c(node.key, st, "Expression");
      if (node.key != node.value) c(node.value, st, "Expression");
    },
    Statement: function(node, st, c) {
      c(node, node.scope || st)
    },
    ImportSpecifier: function(node, st, c) {
      c(node.local, st)
    },
    ImportDefaultSpecifier: function(node, st, c) {
      c(node.local, st)
    },
    ImportNamespaceSpecifier: function(node, st, c) {
      c(node.local, st)
    }
  });
  exports.fullVisitor = walk.make({
    MemberExpression: function(node, st, c) {
      c(node.object, st, "Expression");
      c(node.property, st, node.computed ? "Expression" : null);
    },
    ObjectExpression: function(node, st, c) {
      for (var i = 0; i < node.properties.length; ++i) {
        c(node.properties[i].value, st, "Expression");
        c(node.properties[i].key, st);
      }
    }
  }, searchVisitor);

  exports.findExpressionAt = function(ast, start, end, defaultScope, filter) {
    var test = filter || function(_t, node) {
      if (node.type == "Identifier" && node.name == "✖") return false;
      return typeFinder.hasOwnProperty(node.type);
    };
    return walk.findNodeAt(ast, start, end, test, searchVisitor, defaultScope || cx.topScope);
  };

  exports.findExpressionAround = function(ast, start, end, defaultScope, filter) {
    var test = filter || function(_t, node) {
      if (start != null && node.start > start) return false;
      if (node.type == "Identifier" && node.name == "✖") return false;
      return typeFinder.hasOwnProperty(node.type);
    };
    return walk.findNodeAround(ast, end, test, searchVisitor, defaultScope || cx.topScope);
  };

  exports.expressionType = function(found) {
    return findType(found.node, found.state);
  };
  exports.parentNode = function(child, ast) {
    var stack = [];
    function c(node, st, override) {
      if (node.start <= child.start && node.end >= child.end) {
        var top = stack[stack.length - 1];
        if (node == child) throw {found: top};
        if (top != node) stack.push(node);
        walk.base[override || node.type](node, st, c);
        if (top != node) stack.pop();
      }
    }
    try {
      c(ast, null);
    } catch (e) {
      if (e.found) return e.found;
      throw e;
    }
  };

  var findTypeFromContext = exports.findTypeFromContext = {
    ArrayExpression: function(parent, _, get) { return get(parent, true).getProp("<i>"); },
    ObjectExpression: function(parent, node, get) {
      for (var i = 0; i < parent.properties.length; ++i) {
        var prop = node.properties[i];
        if (prop.value == node)
          return get(parent, true).getProp(prop.key.name);
      }
    },
    UnaryExpression: function(parent) { return unopResultType(parent.operator); },
    UpdateExpression: function() { return cx.num; },
    BinaryExpression: function(parent) { return binopIsBoolean(parent.operator) ? cx.bool : cx.num; },
    AssignmentExpression: function(parent, _, get) { return get(parent.left); },
    LogicalExpression: function(parent, _, get) { return get(parent, true); },
    ConditionalExpression: function(parent, node, get) {
      if (parent.consequent == node || parent.alternate == node) return get(parent, true);
    },
    CallExpression: function(parent, node, get) {
      for (var i = 0; i < parent.arguments.length; i++) {
        var arg = parent.arguments[i];
        if (arg == node) {
          var calleeType = get(parent.callee).getFunctionType();
          if (calleeType instanceof Fn)
            return calleeType.args[i];
          break;
        }
      }
    },
    ReturnStatement: function(_parent, node, get) {
      var fnNode = walk.findNodeAround(node.sourceFile.ast, node.start, "Function");
      if (fnNode) {
        var fnType = fnNode.node.type != "FunctionDeclaration"
          ? get(fnNode.node, true).getFunctionType()
          : fnNode.node.scope.fnType;
        if (fnType) return fnType.retval.getType();
      }
    },
    VariableDeclarator: function(parent, node, get) {
      if (parent.init == node) return get(parent.id)
    }
  };
  findTypeFromContext.NewExpression = findTypeFromContext.CallExpression

  exports.typeFromContext = function(ast, found) {
    var parent = exports.parentNode(found.node, ast);
    var type = null;
    if (findTypeFromContext.hasOwnProperty(parent.type)) {
      var finder = findTypeFromContext[parent.type];
      type = finder && finder(parent, found.node, function(node, fromContext) {
        var obj = {node: node, state: found.state};
        var tp = fromContext ? exports.typeFromContext(ast, obj) : exports.expressionType(obj);
        return tp || ANull;
      });
    }
    return type || exports.expressionType(found);
  };
  var guessing = false;

  exports.resetGuessing = function(val) { guessing = val; };
  exports.didGuess = function() { return guessing; };

  exports.forAllPropertiesOf = function(type, f) {
    type.gatherProperties(f, 0);
  };

  var refFindWalker = walk.make({}, searchVisitor);

  exports.findRefs = function(ast, baseScope, name, refScope, f) {
    refFindWalker.Identifier = refFindWalker.VariablePattern = function(node, scope) {
      if (node.name != name) return;
      for (var s = scope; s; s = s.prev) {
        if (s == refScope) f(node, scope);
        if (name in s.props) return;
      }
    };
    walk.recursive(ast, baseScope, null, refFindWalker);
  };

  var simpleWalker = walk.make({
    Function: function(node, _scope, c) {
      c(node.body, node.scope, node.expression ? "Expression" : "Statement")
    },
    Statement: function(node, scope, c) {
      c(node, node.scope || scope)
    }
  });

  exports.findPropRefs = function(ast, scope, objType, propName, f) {
    walk.simple(ast, {
      MemberExpression: function(node, scope) {
        if (node.computed || node.property.name != propName) return;
        if (findType(node.object, scope).getType() == objType) f(node.property);
      },
      ObjectExpression: function(node, scope) {
        if (findType(node, scope).getType() != objType) return;
        for (var i = 0; i < node.properties.length; ++i)
          if (node.properties[i].key.name == propName) f(node.properties[i].key);
      }
    }, simpleWalker, scope);
  };
  var scopeAt = exports.scopeAt = function(ast, pos, defaultScope) {
    var found = walk.findNodeAround(ast, pos, function(_, node) {
      return node.scope;
    });
    if (found) return found.node.scope;
    else return defaultScope || cx.topScope;
  };

  exports.forAllLocalsAt = function(ast, pos, defaultScope, f) {
    var scope = scopeAt(ast, pos, defaultScope);
    scope.gatherProperties(f, 0);
  };
  def = exports.def = def.init({}, exports);
});

});

define("tern/lib/tern",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function(root, mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(exports, require("./infer"), require("./signal"),
               require("acorn"), require("acorn/dist/walk"));
  if (typeof define == "function" && define.amd) // AMD
    return define(["exports", "./infer", "./signal", "acorn/dist/acorn", "acorn/dist/walk"], mod);
  mod(root.tern || (root.tern = {}), tern, tern.signal, acorn, acorn.walk); // Plain browser env
})(this, function(exports, infer, signal, acorn, walk) {
  "use strict";

  var plugins = Object.create(null);
  exports.registerPlugin = function(name, init) { plugins[name] = init; };

  var defaultOptions = exports.defaultOptions = {
    debug: false,
    async: false,
    getFile: function(_f, c) { if (this.async) c(null, null); },
    normalizeFilename: function(name) { return name },
    defs: [],
    plugins: {},
    fetchTimeout: 1000,
    dependencyBudget: 20000,
    reuseInstances: true,
    stripCRs: false,
    ecmaVersion: 6,
    projectDir: "/",
    parent: null
  };

  var queryTypes = {
    completions: {
      takesFile: true,
      run: findCompletions
    },
    properties: {
      run: findProperties
    },
    type: {
      takesFile: true,
      run: findTypeAt
    },
    documentation: {
      takesFile: true,
      run: findDocs
    },
    definition: {
      takesFile: true,
      run: findDef
    },
    refs: {
      takesFile: true,
      fullFile: true,
      run: findRefs
    },
    rename: {
      takesFile: true,
      fullFile: true,
      run: buildRename
    },
    files: {
      run: listFiles
    }
  };

  exports.defineQueryType = function(name, desc) { queryTypes[name] = desc; };

  function File(name, parent) {
    this.name = name;
    this.parent = parent;
    this.scope = this.text = this.ast = this.lineOffsets = null;
  }
  File.prototype.asLineChar = function(pos) { return asLineChar(this, pos); };
  
  exports.File = File;

  function parseFile(srv, file) {
    var options = {
      directSourceFile: file,
      allowReturnOutsideFunction: true,
      allowImportExportEverywhere: true,
      ecmaVersion: srv.options.ecmaVersion
    }
    var text = srv.signalReturnFirst("preParse", file.text, options) || file.text
    var ast = infer.parse(text, options)
    srv.signal("postParse", ast, text)
    return ast
  }

  function updateText(file, text, srv) {
    file.text = srv.options.stripCRs ? text.replace(/\r\n/g, "\n") : text;
    infer.withContext(srv.cx, function() {
      file.ast = parseFile(srv, file)
    });
    file.lineOffsets = null;
  }

  var Server = exports.Server = function(options) {
    this.cx = null;
    this.options = options || {};
    for (var o in defaultOptions) if (!options.hasOwnProperty(o))
      options[o] = defaultOptions[o];

    this.projectDir = options.projectDir.replace(/\\/g, "/")
    if (!/\/$/.test(this.projectDir)) this.projectDir += "/"

    this.parent = options.parent;
    this.handlers = Object.create(null);
    this.files = [];
    this.fileMap = Object.create(null);
    this.needsPurge = [];
    this.budgets = Object.create(null);
    this.uses = 0;
    this.pending = 0;
    this.asyncError = null;
    this.mod = {}

    this.defs = options.defs.slice(0)
    this.plugins = Object.create(null)
    for (var plugin in options.plugins) if (options.plugins.hasOwnProperty(plugin))
      this.loadPlugin(plugin, options.plugins[plugin])

    this.reset();
  };
  Server.prototype = signal.mixin({
    addFile: function(name, /*optional*/ text, parent) {
      if (parent && !(parent in this.fileMap)) parent = null;
      if (!(name in this.fileMap))
        name = this.normalizeFilename(name)
      ensureFile(this, name, parent, text);
    },
    delFile: function(name) {
      var file = this.findFile(name);
      if (file) {
        this.needsPurge.push(file.name);
        this.files.splice(this.files.indexOf(file), 1);
        delete this.fileMap[name];
      }
    },
    reset: function() {
      this.signal("reset");
      this.cx = new infer.Context(this.defs, this);
      this.uses = 0;
      this.budgets = Object.create(null);
      for (var i = 0; i < this.files.length; ++i) {
        var file = this.files[i];
        file.scope = null;
      }
      this.signal("postReset");
    },

    request: function(doc, c) {
      var inv = invalidDoc(doc);
      if (inv) return c(inv);

      var self = this;
      doRequest(this, doc, function(err, data) {
        c(err, data);
        if (self.uses > 40) {
          self.reset();
          analyzeAll(self, null, function(){});
        }
      });
    },

    findFile: function(name) {
      return this.fileMap[name];
    },

    flush: function(c) {
      var cx = this.cx;
      analyzeAll(this, null, function(err) {
        if (err) return c(err);
        infer.withContext(cx, c);
      });
    },

    startAsyncAction: function() {
      ++this.pending;
    },
    finishAsyncAction: function(err) {
      if (err) this.asyncError = err;
      if (--this.pending === 0) this.signal("everythingFetched");
    },

    addDefs: function(defs, toFront) {
      if (toFront) this.defs.unshift(defs)
      else this.defs.push(defs)

      if (this.cx) this.reset()
    },

    deleteDefs: function(name) {
      for (var i = 0; i < this.defs.length; i++) if (this.defs[i]["!name"] == name) {
        this.defs.splice(i, 1);
        if (this.cx) this.reset();
        return;
      }
    },

    loadPlugin: function(name, options) {
      if (arguments.length == 1) options = this.options.plugins[name] || true
      if (name in this.plugins || !(name in plugins) || !options) return
      this.plugins[name] = true
      var init = plugins[name](this, options)
      if (!init) return
      if (init.defs) this.addDefs(init.defs, init.loadFirst)
      if (init.passes) for (var type in init.passes) if (init.passes.hasOwnProperty(type))
        this.on(type, init.passes[type])
    },

    normalizeFilename: function(name) {
      var norm = this.options.normalizeFilename(name).replace(/\\/g, "/")
      if (norm.indexOf(this.projectDir) == 0) norm = norm.slice(this.projectDir.length)
      return norm
    }
  });

  function doRequest(srv, doc, c) {
    if (doc.query && !queryTypes.hasOwnProperty(doc.query.type))
      return c("No query type '" + doc.query.type + "' defined");

    var query = doc.query;
    if (!query) c(null, {});

    var files = doc.files || [];
    if (files.length) ++srv.uses;
    for (var i = 0; i < files.length; ++i) {
      var file = files[i];
      if (file.type == "delete")
        srv.delFile(file.name);
      else
        ensureFile(srv, file.name, null, file.type == "full" ? file.text : null);
    }

    var timeBudget = typeof doc.timeout == "number" ? [doc.timeout] : null;
    if (!query) {
      analyzeAll(srv, timeBudget, function(){});
      return;
    }

    var queryType = queryTypes[query.type];
    if (queryType.takesFile) {
      if (typeof query.file != "string") return c(".query.file must be a string");
      if (!/^#/.test(query.file)) ensureFile(srv, query.file, null);
    }

    analyzeAll(srv, timeBudget, function(err) {
      if (err) return c(err);
      var file = queryType.takesFile && resolveFile(srv, files, query.file);
      if (queryType.fullFile && file.type == "part")
        return c("Can't run a " + query.type + " query on a file fragment");

      function run() {
        var result;
        try {
          result = queryType.run(srv, query, file);
        } catch (e) {
          if (srv.options.debug && e.name != "TernError") console.error(e.stack);
          return c(e);
        }
        c(null, result);
      }
      infer.resetGuessing()
      infer.withContext(srv.cx, timeBudget ? function() { infer.withTimeout(timeBudget[0], run); } : run);
    });
  }

  function analyzeFile(srv, file) {
    infer.withContext(srv.cx, function() {
      file.scope = srv.cx.topScope;
      srv.signal("beforeLoad", file);
      infer.analyze(file.ast, file.name, file.scope);
      srv.signal("afterLoad", file);
    });
    return file;
  }

  function ensureFile(srv, name, parent, text) {
    var known = srv.findFile(name);
    if (known) {
      if (text != null) {
        if (known.scope) {
          srv.needsPurge.push(name);
          known.scope = null;
        }
        updateText(known, text, srv);
      }
      if (parentDepth(srv, known.parent) > parentDepth(srv, parent)) {
        known.parent = parent;
        if (known.excluded) known.excluded = null;
      }
      return;
    }

    var file = new File(name, parent);
    srv.files.push(file);
    srv.fileMap[name] = file;
    if (text != null) {
      updateText(file, text, srv);
    } else if (srv.options.async) {
      srv.startAsyncAction();
      srv.options.getFile(name, function(err, text) {
        updateText(file, text || "", srv);
        srv.finishAsyncAction(err);
      });
    } else {
      updateText(file, srv.options.getFile(name) || "", srv);
    }
  }

  function fetchAll(srv, c) {
    var done = true, returned = false;
    srv.files.forEach(function(file) {
      if (file.text != null) return;
      if (srv.options.async) {
        done = false;
        srv.options.getFile(file.name, function(err, text) {
          if (err && !returned) { returned = true; return c(err); }
          updateText(file, text || "", srv);
          fetchAll(srv, c);
        });
      } else {
        try {
          updateText(file, srv.options.getFile(file.name) || "", srv);
        } catch (e) { return c(e); }
      }
    });
    if (done) c();
  }

  function waitOnFetch(srv, timeBudget, c) {
    var done = function() {
      srv.off("everythingFetched", done);
      clearTimeout(timeout);
      analyzeAll(srv, timeBudget, c);
    };
    srv.on("everythingFetched", done);
    var timeout = setTimeout(done, srv.options.fetchTimeout);
  }

  function analyzeAll(srv, timeBudget, c) {
    if (srv.pending) return waitOnFetch(srv, timeBudget, c);

    var e = srv.fetchError;
    if (e) { srv.fetchError = null; return c(e); }

    if (srv.needsPurge.length > 0) infer.withContext(srv.cx, function() {
      infer.purge(srv.needsPurge);
      srv.needsPurge.length = 0;
    });

    var done = true;
    for (var i = 0; i < srv.files.length;) {
      var toAnalyze = [];
      for (; i < srv.files.length; ++i) {
        var file = srv.files[i];
        if (file.text == null) done = false;
        else if (file.scope == null && !file.excluded) toAnalyze.push(file);
      }
      toAnalyze.sort(function(a, b) {
        return parentDepth(srv, a.parent) - parentDepth(srv, b.parent);
      });
      for (var j = 0; j < toAnalyze.length; j++) {
        var file = toAnalyze[j];
        if (file.parent && !chargeOnBudget(srv, file)) {
          file.excluded = true;
        } else if (timeBudget) {
          var startTime = +new Date;
          infer.withTimeout(timeBudget[0], function() { analyzeFile(srv, file); });
          timeBudget[0] -= +new Date - startTime;
        } else {
          analyzeFile(srv, file);
        }
      }
    }
    if (done) c();
    else waitOnFetch(srv, timeBudget, c);
  }

  function firstLine(str) {
    var end = str.indexOf("\n");
    if (end < 0) return str;
    return str.slice(0, end);
  }

  function findMatchingPosition(line, file, near) {
    var pos = Math.max(0, near - 500), closest = null;
    if (!/^\s*$/.test(line)) for (;;) {
      var found = file.indexOf(line, pos);
      if (found < 0 || found > near + 500) break;
      if (closest == null || Math.abs(closest - near) > Math.abs(found - near))
        closest = found;
      pos = found + line.length;
    }
    return closest;
  }

  function scopeDepth(s) {
    for (var i = 0; s; ++i, s = s.prev) {}
    return i;
  }

  function ternError(msg) {
    var err = new Error(msg);
    err.name = "TernError";
    return err;
  }

  function resolveFile(srv, localFiles, name) {
    var isRef = name.match(/^#(\d+)$/);
    if (!isRef) return srv.findFile(name);

    var file = localFiles[isRef[1]];
    if (!file || file.type == "delete") throw ternError("Reference to unknown file " + name);
    if (file.type == "full") return srv.findFile(file.name);
    var realFile = file.backing = srv.findFile(file.name);
    var offset = file.offset;
    if (file.offsetLines) offset = {line: file.offsetLines, ch: 0};
    file.offset = offset = resolvePos(realFile, file.offsetLines == null ? file.offset : {line: file.offsetLines, ch: 0}, true);
    var line = firstLine(file.text);
    var foundPos = findMatchingPosition(line, realFile.text, offset);
    var pos = foundPos == null ? Math.max(0, realFile.text.lastIndexOf("\n", offset)) : foundPos;
    var inObject, atFunction;

    infer.withContext(srv.cx, function() {
      infer.purge(file.name, pos, pos + file.text.length);

      var text = file.text, m;
      if (m = text.match(/(?:"([^"]*)"|([\w$]+))\s*:\s*function\b/)) {
        var objNode = walk.findNodeAround(file.backing.ast, pos, "ObjectExpression");
        if (objNode && objNode.node.objType)
          inObject = {type: objNode.node.objType, prop: m[2] || m[1]};
      }
      if (foundPos && (m = line.match(/^(.*?)\bfunction\b/))) {
        var cut = m[1].length, white = "";
        for (var i = 0; i < cut; ++i) white += " ";
        file.text = white + text.slice(cut);
        atFunction = true;
      }

      var scopeStart = infer.scopeAt(realFile.ast, pos, realFile.scope);
      var scopeEnd = infer.scopeAt(realFile.ast, pos + text.length, realFile.scope);
      var scope = file.scope = scopeDepth(scopeStart) < scopeDepth(scopeEnd) ? scopeEnd : scopeStart;
      file.ast = parseFile(srv, file)
      infer.analyze(file.ast, file.name, scope);
      tieTogether: if (inObject || atFunction) {
        var newInner = infer.scopeAt(file.ast, line.length, scopeStart);
        if (!newInner.fnType) break tieTogether;
        if (inObject) {
          var prop = inObject.type.getProp(inObject.prop);
          prop.addType(newInner.fnType);
        } else if (atFunction) {
          var inner = infer.scopeAt(realFile.ast, pos + line.length, realFile.scope);
          if (inner == scopeStart || !inner.fnType) break tieTogether;
          var fOld = inner.fnType, fNew = newInner.fnType;
          if (!fNew || (fNew.name != fOld.name && fOld.name)) break tieTogether;
          for (var i = 0, e = Math.min(fOld.args.length, fNew.args.length); i < e; ++i)
            fOld.args[i].propagate(fNew.args[i]);
          fOld.self.propagate(fNew.self);
          fNew.retval.propagate(fOld.retval);
        }
      }
    });
    return file;
  }
  function astSize(node) {
    var size = 0;
    walk.simple(node, {Expression: function() { ++size; }});
    return size;
  }

  function parentDepth(srv, parent) {
    var depth = 0;
    while (parent) {
      ++depth;
      var file = srv.findFile(parent);
      if (!file)
        return;
      parent = file.parent;
    }
    return depth;
  }

  function budgetName(srv, file) {
    for (;;) {
      var parent = srv.findFile(file.parent);
      if (!parent || !parent.parent) break;
      file = parent;
    }
    return file.name;
  }

  function chargeOnBudget(srv, file) {
    var bName = budgetName(srv, file);
    var size = astSize(file.ast);
    var known = srv.budgets[bName];
    if (known == null)
      known = srv.budgets[bName] = srv.options.dependencyBudget;
    if (known < size) return false;
    srv.budgets[bName] = known - size;
    return true;
  }
  function isPosition(val) {
    return typeof val == "number" || typeof val == "object" &&
      typeof val.line == "number" && typeof val.ch == "number";
  }
  function invalidDoc(doc) {
    if (doc.query) {
      if (typeof doc.query.type != "string") return ".query.type must be a string";
      if (doc.query.start && !isPosition(doc.query.start)) return ".query.start must be a position";
      if (doc.query.end && !isPosition(doc.query.end)) return ".query.end must be a position";
    }
    if (doc.files) {
      if (!Array.isArray(doc.files)) return "Files property must be an array";
      for (var i = 0; i < doc.files.length; ++i) {
        var file = doc.files[i];
        if (typeof file != "object") return ".files[n] must be objects";
        else if (typeof file.name != "string") return ".files[n].name must be a string";
        else if (file.type == "delete") continue;
        else if (typeof file.text != "string") return ".files[n].text must be a string";
        else if (file.type == "part") {
          if (!isPosition(file.offset) && typeof file.offsetLines != "number")
            return ".files[n].offset must be a position";
        } else if (file.type != "full") return ".files[n].type must be \"full\" or \"part\"";
      }
    }
  }

  var offsetSkipLines = 25;

  function findLineStart(file, line) {
    var text = file.text, offsets = file.lineOffsets || (file.lineOffsets = [0]);
    var pos = 0, curLine = 0;
    var storePos = Math.min(Math.floor(line / offsetSkipLines), offsets.length - 1);
    var pos = offsets[storePos], curLine = storePos * offsetSkipLines;

    while (curLine < line) {
      ++curLine;
      pos = text.indexOf("\n", pos) + 1;
      if (pos === 0) return null;
      if (curLine % offsetSkipLines === 0) offsets.push(pos);
    }
    return pos;
  }

  var resolvePos = exports.resolvePos = function(file, pos, tolerant) {
    if (typeof pos != "number") {
      var lineStart = findLineStart(file, pos.line);
      if (lineStart == null) {
        if (tolerant) pos = file.text.length;
        else throw ternError("File doesn't contain a line " + pos.line);
      } else {
        pos = lineStart + pos.ch;
      }
    }
    if (pos > file.text.length) {
      if (tolerant) pos = file.text.length;
      else throw ternError("Position " + pos + " is outside of file.");
    }
    return pos;
  };

  function asLineChar(file, pos) {
    if (!file) return {line: 0, ch: 0};
    var offsets = file.lineOffsets || (file.lineOffsets = [0]);
    var text = file.text, line, lineStart;
    for (var i = offsets.length - 1; i >= 0; --i) if (offsets[i] <= pos) {
      line = i * offsetSkipLines;
      lineStart = offsets[i];
    }
    for (;;) {
      var eol = text.indexOf("\n", lineStart);
      if (eol >= pos || eol < 0) break;
      lineStart = eol + 1;
      ++line;
    }
    return {line: line, ch: pos - lineStart};
  }

  var outputPos = exports.outputPos = function(query, file, pos) {
    if (query.lineCharPositions) {
      var out = asLineChar(file, pos);
      if (file.type == "part")
        out.line += file.offsetLines != null ? file.offsetLines : asLineChar(file.backing, file.offset).line;
      return out;
    } else {
      return pos + (file.type == "part" ? file.offset : 0);
    }
  };
  function clean(obj) {
    for (var prop in obj) if (obj[prop] == null) delete obj[prop];
    return obj;
  }
  function maybeSet(obj, prop, val) {
    if (val != null) obj[prop] = val;
  }
  function compareCompletions(a, b) {
    if (typeof a != "string") { a = a.name; b = b.name; }
    var aUp = /^[A-Z]/.test(a), bUp = /^[A-Z]/.test(b);
    if (aUp == bUp) return a < b ? -1 : a == b ? 0 : 1;
    else return aUp ? 1 : -1;
  }

  function isStringAround(node, start, end) {
    return node.type == "Literal" && typeof node.value == "string" &&
      node.start == start - 1 && node.end <= end + 1;
  }

  function pointInProp(objNode, point) {
    for (var i = 0; i < objNode.properties.length; i++) {
      var curProp = objNode.properties[i];
      if (curProp.key.start <= point && curProp.key.end >= point)
        return curProp;
    }
  }

  var jsKeywords = ("break do instanceof typeof case else new var " +
    "catch finally return void continue for switch while debugger " +
    "function this with default if throw delete in try").split(" ");

  var addCompletion = exports.addCompletion = function(query, completions, name, aval, depth) {
    var typeInfo = query.types || query.docs || query.urls || query.origins;
    var wrapAsObjs = typeInfo || query.depths;

    for (var i = 0; i < completions.length; ++i) {
      var c = completions[i];
      if ((wrapAsObjs ? c.name : c) == name) return;
    }
    var rec = wrapAsObjs ? {name: name} : name;
    completions.push(rec);

    if (aval && typeInfo) {
      infer.resetGuessing();
      var type = aval.getType(false);
      rec.guess = infer.didGuess();
      if (query.types)
        rec.type = infer.toString(aval);
      if (query.docs)
        maybeSet(rec, "doc", parseDoc(query, aval.doc || type && type.doc));
      if (query.urls)
        maybeSet(rec, "url", aval.url || type && type.url);
      if (query.origins)
        maybeSet(rec, "origin", aval.origin || type && type.origin);
    }
    if (query.depths) rec.depth = depth || 0;
    return rec;
  };

  function findCompletions(srv, query, file) {
    if (query.end == null) throw ternError("missing .query.end field");
    var fromPlugin = srv.signalReturnFirst("completion", file, query)
    if (fromPlugin) return fromPlugin

    var wordStart = resolvePos(file, query.end), wordEnd = wordStart, text = file.text;
    while (wordStart && acorn.isIdentifierChar(text.charCodeAt(wordStart - 1))) --wordStart;
    if (query.expandWordForward !== false)
      while (wordEnd < text.length && acorn.isIdentifierChar(text.charCodeAt(wordEnd))) ++wordEnd;
    var word = text.slice(wordStart, wordEnd), completions = [], ignoreObj;
    if (query.caseInsensitive) word = word.toLowerCase();

    function gather(prop, obj, depth, addInfo) {
      if ((objLit || query.omitObjectPrototype !== false) && obj == srv.cx.protos.Object && !word) return;
      if (query.filter !== false && word &&
          (query.caseInsensitive ? prop.toLowerCase() : prop).indexOf(word) !== 0) return;
      if (ignoreObj && ignoreObj.props[prop]) return;
      var result = addCompletion(query, completions, prop, obj && obj.props[prop], depth);
      if (addInfo && result && typeof result != "string") addInfo(result);
    }

    var hookname, prop, objType, isKey;

    var exprAt = infer.findExpressionAround(file.ast, null, wordStart, file.scope);
    var memberExpr, objLit;
    if (exprAt) {
      var exprNode = exprAt.node;
      if (exprNode.type == "MemberExpression" && exprNode.object.end < wordStart) {
        memberExpr = exprAt;
      } else if (isStringAround(exprNode, wordStart, wordEnd)) {
        var parent = infer.parentNode(exprNode, file.ast);
        if (parent.type == "MemberExpression" && parent.property == exprNode)
          memberExpr = {node: parent, state: exprAt.state};
      } else if (exprNode.type == "ObjectExpression") {
        var objProp = pointInProp(exprNode, wordEnd);
        if (objProp) {
          objLit = exprAt;
          prop = isKey = objProp.key.name;
        } else if (!word && !/:\s*$/.test(file.text.slice(0, wordStart))) {
          objLit = exprAt;
          prop = isKey = true;
        }
      }
    }

    if (objLit) {
      objType = infer.typeFromContext(file.ast, objLit);
      ignoreObj = objLit.node.objType;
    } else if (memberExpr) {
      prop = memberExpr.node.property;
      prop = prop.type == "Literal" ? prop.value.slice(1) : prop.name;
      memberExpr.node = memberExpr.node.object;
      objType = infer.expressionType(memberExpr);
    } else if (text.charAt(wordStart - 1) == ".") {
      var pathStart = wordStart - 1;
      while (pathStart && (text.charAt(pathStart - 1) == "." || acorn.isIdentifierChar(text.charCodeAt(pathStart - 1)))) pathStart--;
      var path = text.slice(pathStart, wordStart - 1);
      if (path) {
        objType = infer.def.parsePath(path, file.scope).getObjType();
        prop = word;
      }
    }

    if (prop != null) {
      srv.cx.completingProperty = prop;

      if (objType) infer.forAllPropertiesOf(objType, gather);

      if (!completions.length && query.guess !== false && objType && objType.guessProperties)
        objType.guessProperties(function(p, o, d, a) {if (p != prop && p != "✖") gather(p, o, d, a);});
      if (!completions.length && word.length >= 2 && query.guess !== false)
        for (var prop in srv.cx.props) gather(prop, srv.cx.props[prop][0], 0, function(rec) { rec.guess = true; });
      hookname = "memberCompletion";
    } else {
      infer.forAllLocalsAt(file.ast, wordStart, file.scope, gather);
      if (query.includeKeywords) jsKeywords.forEach(function(kw) {
        gather(kw, null, 0, function(rec) { rec.isKeyword = true; });
      });
      hookname = "variableCompletion";
    }
    srv.signal(hookname, file, wordStart, wordEnd, gather)

    if (query.sort !== false) completions.sort(compareCompletions);
    srv.cx.completingProperty = null;

    return {start: outputPos(query, file, wordStart),
            end: outputPos(query, file, wordEnd),
            isProperty: !!prop,
            isObjectKey: !!isKey,
            completions: completions};
  }

  function findProperties(srv, query) {
    var prefix = query.prefix, found = [];
    for (var prop in srv.cx.props)
      if (prop != "<i>" && (!prefix || prop.indexOf(prefix) === 0)) found.push(prop);
    if (query.sort !== false) found.sort(compareCompletions);
    return {completions: found};
  }

  var findExpr = exports.findQueryExpr = function(file, query, wide) {
    if (query.end == null) throw ternError("missing .query.end field");

    if (query.variable) {
      var scope = infer.scopeAt(file.ast, resolvePos(file, query.end), file.scope);
      return {node: {type: "Identifier", name: query.variable, start: query.end, end: query.end + 1},
              state: scope};
    } else {
      var start = query.start && resolvePos(file, query.start), end = resolvePos(file, query.end);
      var expr = infer.findExpressionAt(file.ast, start, end, file.scope);
      if (expr) return expr;
      expr = infer.findExpressionAround(file.ast, start, end, file.scope);
      if (expr && (expr.node.type == "ObjectExpression" || wide ||
                   (start == null ? end : start) - expr.node.start < 20 || expr.node.end - end < 20))
        return expr;
      return null;
    }
  };

  function findExprOrThrow(file, query, wide) {
    var expr = findExpr(file, query, wide);
    if (expr) return expr;
    throw ternError("No expression at the given position.");
  }

  function ensureObj(tp) {
    if (!tp || !(tp = tp.getType()) || !(tp instanceof infer.Obj)) return null;
    return tp;
  }

  function findExprType(srv, query, file, expr) {
    var type;
    if (expr) {
      infer.resetGuessing();
      type = infer.expressionType(expr);
    }
    var typeHandlers = srv.hasHandler("typeAt")
    if (typeHandlers) {
      var pos = resolvePos(file, query.end)
      for (var i = 0; i < typeHandlers.length; i++)
        type = typeHandlers[i](file, pos, expr, type)
    }
    if (!type) throw ternError("No type found at the given position.");

    var objProp;
    if (expr.node.type == "ObjectExpression" && query.end != null &&
        (objProp = pointInProp(expr.node, resolvePos(file, query.end)))) {
      var name = objProp.key.name;
      var fromCx = ensureObj(infer.typeFromContext(file.ast, expr));
      if (fromCx && fromCx.hasProp(name)) {
        type = fromCx.hasProp(name);
      } else {
        var fromLocal = ensureObj(type);
        if (fromLocal && fromLocal.hasProp(name))
          type = fromLocal.hasProp(name);
      }
    }
    return type;
  };

  function findTypeAt(srv, query, file) {
    var expr = findExpr(file, query), exprName;
    var type = findExprType(srv, query, file, expr), exprType = type;
    if (query.preferFunction)
      type = type.getFunctionType() || type.getType(query.guess === true);
    else
      type = type.getType(query.guess === true);

    if (expr) {
      if (expr.node.type == "Identifier")
        exprName = expr.node.name;
      else if (expr.node.type == "MemberExpression" && !expr.node.computed)
        exprName = expr.node.property.name;
    }

    if (query.depth != null && typeof query.depth != "number")
      throw ternError(".query.depth must be a number");

    var result = {guess: infer.didGuess(),
                  type: infer.toString(exprType, query.depth),
                  name: type && type.name,
                  exprName: exprName,
                  doc: exprType.doc,
                  url: exprType.url};
    if (type) storeTypeDocs(query, type, result);

    return clean(result);
  }

  function parseDoc(query, doc) {
    if (!doc) return null;
 return doc;
    var parabreak = /.\n[\s@\n]/.exec(doc);
    if (parabreak) doc = doc.slice(0, parabreak.index + 1);
    doc = doc.replace(/\n\s*/g, " ");
    if (doc.length < 100) return doc;
    var sentenceEnd = /[\.!?] [A-Z]/g;
    sentenceEnd.lastIndex = 80;
    var found = sentenceEnd.exec(doc);
    if (found) doc = doc.slice(0, found.index + 1);
    return doc;
  }

  function findDocs(srv, query, file) {
    var expr = findExpr(file, query);
    var type = findExprType(srv, query, file, expr);
    var result = {url: type.url, doc: parseDoc(query, type.doc), type: infer.toString(type)};
    var inner = type.getType();
    if (inner) storeTypeDocs(query, inner, result);
    return clean(result);
  }

  function storeTypeDocs(query, type, out) {
    if (!out.url) out.url = type.url;
    if (!out.doc) out.doc = parseDoc(query, type.doc);
    if (!out.origin) out.origin = type.origin;
    var ctor, boring = infer.cx().protos;
    if (!out.url && !out.doc && type.proto && (ctor = type.proto.hasCtor) &&
        type.proto != boring.Object && type.proto != boring.Function && type.proto != boring.Array) {
      out.url = ctor.url;
      out.doc = parseDoc(query, ctor.doc);
    }
  }

  var getSpan = exports.getSpan = function(obj) {
    if (!obj.origin) return;
    if (obj.originNode) {
      var node = obj.originNode;
      if (/^Function/.test(node.type) && node.id) node = node.id;
      return {origin: obj.origin, node: node};
    }
    if (obj.span) return {origin: obj.origin, span: obj.span};
  };

  var storeSpan = exports.storeSpan = function(srv, query, span, target) {
    target.origin = span.origin;
    if (span.span) {
      var m = /^(\d+)\[(\d+):(\d+)\]-(\d+)\[(\d+):(\d+)\]$/.exec(span.span);
      target.start = query.lineCharPositions ? {line: Number(m[2]), ch: Number(m[3])} : Number(m[1]);
      target.end = query.lineCharPositions ? {line: Number(m[5]), ch: Number(m[6])} : Number(m[4]);
    } else {
      var file = srv.findFile(span.origin);
      target.start = outputPos(query, file, span.node.start);
      target.end = outputPos(query, file, span.node.end);
    }
  };

  function findDef(srv, query, file) {
    var expr = findExpr(file, query);
    var type = findExprType(srv, query, file, expr);
    if (infer.didGuess()) return {};

    var span = getSpan(type);
    var result = {url: type.url, doc: parseDoc(query, type.doc), origin: type.origin};

    if (type.types) for (var i = type.types.length - 1; i >= 0; --i) {
      var tp = type.types[i];
      storeTypeDocs(query, tp, result);
      if (!span) span = getSpan(tp);
    }

    if (span && span.node) { // refers to a loaded file
      var spanFile = span.node.sourceFile || srv.findFile(span.origin);
      var start = outputPos(query, spanFile, span.node.start), end = outputPos(query, spanFile, span.node.end);
      result.start = start; result.end = end;
      result.file = span.origin;
      var cxStart = Math.max(0, span.node.start - 50);
      result.contextOffset = span.node.start - cxStart;
      result.context = spanFile.text.slice(cxStart, cxStart + 50);
    } else if (span) { // external
      result.file = span.origin;
      storeSpan(srv, query, span, result);
    }
    return clean(result);
  }

  function findRefsToVariable(srv, query, file, expr, checkShadowing) {
    var name = expr.node.name;

    for (var scope = expr.state; scope && !(name in scope.props); scope = scope.prev) {}
    if (!scope) throw ternError("Could not find a definition for " + name);

    var type, refs = [];
    function storeRef(file) {
      return function(node, scopeHere) {
        if (checkShadowing) for (var s = scopeHere; s != scope; s = s.prev) {
          var exists = s.hasProp(checkShadowing);
          if (exists)
            throw ternError("Renaming `" + name + "` to `" + checkShadowing + "` would make a variable at line " +
                            (asLineChar(file, node.start).line + 1) + " point to the definition at line " +
                            (asLineChar(file, exists.name.start).line + 1));
        }
        refs.push({file: file.name,
                   start: outputPos(query, file, node.start),
                   end: outputPos(query, file, node.end)});
      };
    }

    if (scope.originNode) {
      type = "local";
      if (checkShadowing) {
        for (var prev = scope.prev; prev; prev = prev.prev)
          if (checkShadowing in prev.props) break;
        if (prev) infer.findRefs(scope.originNode, scope, checkShadowing, prev, function(node) {
          throw ternError("Renaming `" + name + "` to `" + checkShadowing + "` would shadow the definition used at line " +
                          (asLineChar(file, node.start).line + 1));
        });
      }
      infer.findRefs(scope.originNode, scope, name, scope, storeRef(file));
    } else {
      type = "global";
      for (var i = 0; i < srv.files.length; ++i) {
        var cur = srv.files[i];
        infer.findRefs(cur.ast, cur.scope, name, scope, storeRef(cur));
      }
    }

    return {refs: refs, type: type, name: name};
  }

  function findRefsToProperty(srv, query, expr, prop) {
    var objType = infer.expressionType(expr).getObjType();
    if (!objType) throw ternError("Couldn't determine type of base object.");

    var refs = [];
    function storeRef(file) {
      return function(node) {
        refs.push({file: file.name,
                   start: outputPos(query, file, node.start),
                   end: outputPos(query, file, node.end)});
      };
    }
    for (var i = 0; i < srv.files.length; ++i) {
      var cur = srv.files[i];
      infer.findPropRefs(cur.ast, cur.scope, objType, prop.name, storeRef(cur));
    }

    return {refs: refs, name: prop.name};
  }

  function findRefs(srv, query, file) {
    var expr = findExprOrThrow(file, query, true);
    if (expr && expr.node.type == "Identifier") {
      return findRefsToVariable(srv, query, file, expr);
    } else if (expr && expr.node.type == "MemberExpression" && !expr.node.computed) {
      var p = expr.node.property;
      expr.node = expr.node.object;
      return findRefsToProperty(srv, query, expr, p);
    } else if (expr && expr.node.type == "ObjectExpression") {
      var pos = resolvePos(file, query.end);
      for (var i = 0; i < expr.node.properties.length; ++i) {
        var k = expr.node.properties[i].key;
        if (k.start <= pos && k.end >= pos)
          return findRefsToProperty(srv, query, expr, k);
      }
    }
    throw ternError("Not at a variable or property name.");
  }

  function buildRename(srv, query, file) {
    if (typeof query.newName != "string") throw ternError(".query.newName should be a string");
    var expr = findExprOrThrow(file, query);
    if (!expr || expr.node.type != "Identifier") throw ternError("Not at a variable.");

    var data = findRefsToVariable(srv, query, file, expr, query.newName), refs = data.refs;
    delete data.refs;
    data.files = srv.files.map(function(f){return f.name;});

    var changes = data.changes = [];
    for (var i = 0; i < refs.length; ++i) {
      var use = refs[i];
      use.text = query.newName;
      changes.push(use);
    }

    return data;
  }

  function listFiles(srv) {
    return {files: srv.files.map(function(f){return f.name;})};
  }

  exports.version = "0.16.1";
});

});

define("tern/lib/comment",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(exports);
  if (typeof define == "function" && define.amd) // AMD
    return define(["exports"], mod);
  mod(tern.comment || (tern.comment = {}));
})(function(exports) {
  function isSpace(ch) {
    return (ch < 14 && ch > 8) || ch === 32 || ch === 160;
  }

  function onOwnLine(text, pos) {
    for (; pos > 0; --pos) {
      var ch = text.charCodeAt(pos - 1);
      if (ch == 10) break;
      if (!isSpace(ch)) return false;
    }
    return true;
  }
  exports.commentsBefore = function(text, pos) {
    var found = null, emptyLines = 0, topIsLineComment;
    out: while (pos > 0) {
      var prev = text.charCodeAt(pos - 1);
      if (prev == 10) {
        for (var scan = --pos, sawNonWS = false; scan > 0; --scan) {
          prev = text.charCodeAt(scan - 1);
          if (prev == 47 && text.charCodeAt(scan - 2) == 47) {
            if (!onOwnLine(text, scan - 2)) break out;
            var content = text.slice(scan, pos);
            if (!emptyLines && topIsLineComment) found[0] = content + "\n" + found[0];
            else (found || (found = [])).unshift(content);
            topIsLineComment = true;
            emptyLines = 0;
            pos = scan - 2;
            break;
          } else if (prev == 10) {
            if (!sawNonWS && ++emptyLines > 1) break out;
            break;
          } else if (!sawNonWS && !isSpace(prev)) {
            sawNonWS = true;
          }
        }
      } else if (prev == 47 && text.charCodeAt(pos - 2) == 42) {
        for (var scan = pos - 2; scan > 1; --scan) {
          if (text.charCodeAt(scan - 1) == 42 && text.charCodeAt(scan - 2) == 47) {
            if (!onOwnLine(text, scan - 2)) break out;
            (found || (found = [])).unshift(text.slice(scan, pos - 2));
            topIsLineComment = false;
            emptyLines = 0;
            break;
          }
        }
        pos = scan - 2;
      } else if (isSpace(prev)) {
        --pos;
      } else {
        break;
      }
    }
    return found;
  };

  exports.commentAfter = function(text, pos) {
    while (pos < text.length) {
      var next = text.charCodeAt(pos);
      if (next == 47) {
        var after = text.charCodeAt(pos + 1), end;
        if (after == 47) // line comment
          end = text.indexOf("\n", pos + 2);
        else if (after == 42) // block comment
          end = text.indexOf("*/", pos + 2);
        else
          return;
        return text.slice(pos + 2, end < 0 ? text.length : end);
      } else if (isSpace(next)) {
        ++pos;
      }
    }
  };

  exports.ensureCommentsBefore = function(text, node) {
    if (node.hasOwnProperty("commentsBefore")) return node.commentsBefore;
    return node.commentsBefore = exports.commentsBefore(text, node.start);
  };
});

});

define("plugins/c9.ide.language.javascript.tern/worker/architect_resolver_tern_plugin",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(
        require("../lib/infer"),
        require("../lib/tern"),
        require("../lib/comment"),
        require("acorn/util/walk"),
        require
    );
  if (typeof define == "function" && define.amd) // AMD
    return define([
        "tern/lib/infer",
        "tern/lib/tern",
        "tern/lib/comment",
        "acorn/dist/walk",
        "require",
        "exports"
    ], mod);
  mod(tern, tern);
})(function(infer, tern, comment, walk, require, exports) {

var architectPlugins;
var warnedPlugins = {};

if (exports)
    exports.setArchitectPlugins = function(value) {
        architectPlugins = value;
    };

tern.registerPlugin("architect_resolver", function(ternWorker, options) {
    ternWorker._architect = {
        modules: Object.create(null)
    };
    ternWorker.on("afterLoad", function(file) {
        var provides;
        walk.simple(file.ast, {
            AssignmentExpression: function(node) {
                if (!isDependencyAssign(node, "provides"))
                    return;
                provides = node.right.elements.map(function(e) {
                    return e.value;
                }).filter(function(e) {
                    return e;
                });
            },
            FunctionDeclaration: function(node) {
                if ((node.id.name !== "main" && node.id.name !== "plugin")
                    || node.params.length !== 3
                    || node.params[1].name !== "imports"
                    || node.params[2].name !== "register")
                    return;
                
                var seen = {};

                walk.simple(node, {
                    CallExpression: function(node) {
                        if (node.callee.name === "register"
                            && node.arguments.length >= 2
                            && node.arguments[1].type === "ObjectExpression") {
                            var arg = node.arguments[1];
                            arg.properties.forEach(function(prop) {
                                var name = prop.key.name;
                                var value = arg.objType.props[name] && arg.objType.props[name].types && arg.objType.props[name].types[0];
                                if (!value || seen["_" + name])
                                    return;
                                ternWorker._architect.modules["_" + name] = value;
                            });
                        }
                        if (node.callee.type === "MemberExpression"
                            && node.callee.property.name === "freezePublicAPI"
                            && node.arguments.length >= 1
                            && node.arguments[0].type === "ObjectExpression") {
                            var name = provides[0];
                            if (provides.length !== 1
                                && !(provides.length === 2 && name === "ext" && !seen["_" + name]))
                                return console.warn("[architect_resolver_worker] exporting multiple client-side plugins with freezePublicAPI() not supported: " + node.sourceFile.name);
                            var type = node.arguments[0].objType;
                            ternWorker._architect.modules["_" + name] = type;
                            seen["_" + name] = true;
                            delete type.props._events;
                            
                            comment.ensureCommentsBefore(node.sourceFile.text, node);
                            if (node.commentsBefore)
                                type.doc = type.doc || node.commentsBefore[node.commentsBefore.length - 1];
                        }
                    }
                });
            }
        });
    });
    function onPostInfer(ast, scope) {
        var path = ternWorker.cx.curOrigin;
        var baseDirMatch = path.match(/(.*\/)?plugins\//);
        if (!architectPlugins)
            return console.error("[architect_resolver_worker] architectPlugins not available");

        var consumes;
        walk.simple(ast, {
            AssignmentExpression: function(node) {
                if (!isDependencyAssign(node, "consumes"))
                    return;
                consumes = node.right.elements.map(function(e) {
                    return e.value;
                }).filter(function(e) {
                    return e;
                });
            },
            FunctionDeclaration: function(node) {
                if (node.id.name !== "main"
                    || node.params.length !== 3
                    || node.params[1].name !== "imports"
                    || node.params[2].name !== "register"
                    || !node.body.scope)
                    return;

                var importsVal = node.body.scope.prev.props.imports;
                var type = new infer.Obj();
                importsVal.addType(type);
                importsVal.gatherProperties = function(f) {
                    consumes.forEach(function(m) {
                        return f(m, importsVal, 0);
                    });
                };

                if (!consumes)
                    return console.warn("[architect_resolver_worker] main.consumes not defined");
                    
                if (!baseDirMatch) {
                    if (!warnedPlugins[path])
                        console.warn("[architect_resolver_worker] expected plugin to be in plugins/ dir: " + path);
                    warnedPlugins[path] = true;
                    return;
                }

                consumes.forEach(function(name) {
                    var path = getPath(name);
                    var def = ternWorker._architect.modules["_" + name];
                    if (!path && !def) {
                        if (!warnedPlugins[name])
                            console.warn("[architect_resolver_worker] could not resolve \"" + name + "\" plugin");
                        warnedPlugins[name] = true;
                        return;
                    }
                    if (path && baseDirMatch)
                        ternWorker.addFile(path, null, ternWorker.cx.curOrigin);
                    if (!def)
                        return;
                    
                    importsVal.getProp(name).addType(def);
                    type.getProp(name).addType(def);
                });
            }
        });

        function getPath(name) {
            var result = architectPlugins["_" + name];
            if (!result)
                return;
            return baseDirMatch[1] + result + ".js";
        }
    }

    function isDependencyAssign(node, kind) {
        return node.left.type === "MemberExpression"
            && (node.left.object.name === "main" || node.left.object.name === "plugin")
            && node.left.property.name === kind
            && node.right.type === "ArrayExpression";
    }

    return {
        passes: {
            postInfer: onPostInfer
        }
    };
});

});
});

define("plugins/c9.ide.language.javascript.tern/worker/architect_resolver_worker",[], function(require, exports, module) {

var plugin = require("./architect_resolver_tern_plugin");
var worker = require("plugins/c9.ide.language.core/worker");
var util = require("plugins/c9.ide.language/worker_util");
var completeUtil = require("plugins/c9.ide.language/complete_util");
var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');
var handler = module.exports = Object.create(baseLanguageHandler);

var ready;
var pluginNames;

worker.sender.emit("architectPlugins");
worker.sender.on("architectPluginsResult", function(e) {
    plugin.setArchitectPlugins(e.data);
    pluginNames = Object.keys(e.data).map(function(key) {
        return key.substr(1);
    });
    ready = true;
});

handler.handlesLanguage = function(language) {
    return language === "javascript" || language === "jsx";
};

handler.onceReady = function(callback) {
    if (ready)
        return callback();
    
    worker.sender.once("architectPluginsResult", function() {
        setTimeout(callback);
    });
};

handler.complete = function(doc, fullAst, pos, options, callback) {
    var node = options.node;
    if (!ready
        || !node
        || node.cons !== "String"
        || !node.parent
        || !node.parent.parent
        || node.parent.parent.cons !== "Array"
        || !node.parent.parent.parent
        || node.parent.parent.parent.cons !== "Assign"
        )
        return callback();
    
    var lhs = node.parent.parent.parent[0];
    if (lhs.cons !== "PropAccess"
        || lhs[1].value !== "consumes")
        return callback();
    
    var line = doc.getLine(pos.row);
    var id = util.getPrecedingIdentifier(line, pos.column);
    var completions = completeUtil.findCompletions(id, pluginNames);

    callback(completions.map(function(c) {
        return {
            name: c,
            icon: "package",
            identifierRegex: /[a-zA-Z_0-9\$\/\.]/,
            replaceText: c,
            priority: 5
        };
    }));
};

});

define("plugins/c9.ide.language.javascript.tern/worker/acorn_helper",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(require("acorn/acorn"), require("acorn/acorn_loose"), require);
  if (typeof define == "function" && define.amd) // AMD
    return define(["acorn/dist/acorn", "acorn/dist/acorn_loose", "require", "exports"], mod);
  mod(tern, tern);
})(function(acorn, acornLoose, require, exports) {
var File = function() {}; // TODO? use require("tern/lib/tern").File
var parse = acorn.parse;
var parse_dammit = acornLoose.parse_dammit;

var lastInput;
var lastOutput;
var lastInputLoose;
var lastOutputLoose;
var language;

if (exports)
    exports.setLanguage = function(value) {
        language = value;
    };

acorn.parse = function(input, options) {
    return acornLoose.parse_dammit(input, options);
};

acornLoose.parse_dammit = function(input, options) {
    if (language === "jsx") {
        input = input.replace(/\/>|<\//g, " -").replace(/[<>]/g, "-");
    }
    if (input === lastInputLoose) {
        if (options.directSourceFile && lastOutputLoose.sourceFile != options.directSourceFile) {
            for (var i in options.directSourceFile)
                lastOutputLoose.sourceFile[i] = options.directSourceFile[i];
            lastOutputLoose.sourceFile.ast = lastOutputLoose;
        }
        return lastOutputLoose;
    }
    if (!options.directSourceFile) {
        options.directSourceFile = new File();
        options.directSourceFile;
    }
    lastOutputLoose = filterDefine(parse_dammit(input, options));
    lastInputLoose = input;
    return lastOutputLoose;
};

function filterDefine(ast) {
    ast.body.forEach(function(statement) {
        if (statement.type === "ExpressionStatement"
            && statement.expression.type === "CallExpression"
            && statement.expression.callee.name === "define"
            && statement.expression.arguments.length
            && statement.expression.arguments[0].type === "FunctionExpression") {
            var func = statement.expression.arguments[0];
            func.params = func.params.filter(function(p) {
                return ["require", "exports", "module"].indexOf(p.name) === -1;
            });
        }
    });
    return ast;
}

});
});

define("plugins/c9.ide.language.javascript.infer/values",[], function(require, exports, module) {

var PROPER = require('plugins/c9.ide.language.javascript/scope_analyzer').PROPER;
var MAYBE_PROPER = require('plugins/c9.ide.language.javascript/scope_analyzer').MAYBE_PROPER;
var NOT_PROPER = require('plugins/c9.ide.language.javascript/scope_analyzer').NOT_PROPER;
var MAX_VALUES_LENGTH = 15;

var valueRegistry = {};

var contextStack = [];

function Property(values, confidence, path, row) {
    this.values = values;
    this.confidence = confidence;
    this.path = path;
    this.row = row;
}

function Value(name, node) {
    this.init(name, node);
}

Value.enterContext = function(name) {
    contextStack.push([name, 0]);
};

Value.leaveContext = function() {
    contextStack.pop();
};

Value.prototype.init = function(name, node) {
    var guid = '';
    for (var i = 0; i < contextStack.length; i++) {
        guid += contextStack[i][0] + '[' + contextStack[i][1] + ']/';
    }
    var top = contextStack[contextStack.length - 1];
    if (top) {
        top[1]++;
    }
    if (name) {
        guid += name;
    } else {
        guid = guid.substring(0, guid.length - 1);
    }
    this.guid = guid;
    this.properties = {};
    this.doc = null;
    this.docUrl = null;
    if (node) {
        this.pos = node.getPos();
    }
    valueRegistry[guid] = this;
};

Value.prototype.get = function(name) {
    var coll = new ValueCollection();
    if (this.properties['_' + name]) {
        coll.extend(this.properties['_' + name].values);
    }

    if (name !== '__proto__') {
        this.get('__proto__').forEach(function(p) {
            coll.extendPrototype(p.get(name).toArray());
        });
    }
    coll.deref();
    return coll;
};

Value.prototype.getPropertyNames = function() {
    var results = Object.keys(this.properties).map(function(s) {
        return s.substr(1);
    });
    this.get('__proto__').forEach(function(p) {
        return Object.keys(p.properties).forEach(function (s) {
            results.push(s.substr(1));
        });
    });
    return results;
};

Value.prototype.toJSON = function() {
    var fieldJSON = {};
    var properties = this.properties;
    for (var p in properties) {
        if (properties.hasOwnProperty(p)) {
            var prop = properties[p];
            return new Property(prop.values.map(function(v) { return v.guid; }), prop.confidence, prop.path, prop.row);
        }
    }
    return {
        guid: this.guid,
        doc: this.doc,
        properties: fieldJSON,
        pos: this.pos
    };
};

Value.prototype.markProperDeclaration = function(uname, confidence, path, row) {
    if (!this.properties[uname])
        return;    
    if (path)
        this.properties[uname].path = path;
    if (row)
        this.properties[uname].row = row;    
    if (confidence && this.properties[uname].confidence < PROPER)
        this.properties[uname].confidence += confidence;
};

Value.prototype.isProperDeclaration = function(name) {
    if (!this.properties['_' + name])
        return false;
    if (this.properties['_' + name].confidence > MAYBE_PROPER)
        return true;
    var result;
    if (name !== '__proto__') {
        this.get('__proto__').forEach(function(p) {
            if (p.isProperDeclaration(name))
                result = true;
        });
    }
    return result;
};

Value.prototype.hint = function(name, v, declarationConfidence, path, row) {
    if (!v)
        throw Error("Hinting an empty value!");
    if (!this.properties['_' + name]) {
        this.properties['_' + name] = new Property([v], declarationConfidence, path, row);
    }
    else {
        var currentValues = this.properties['_' + name].values;
        this.markProperDeclaration('_' + name, declarationConfidence, row);
        for (var i = 0; i < currentValues.length; i++) {
            if (currentValues[i].guid === v.guid) {
                return;
            }
        }
        currentValues.push(v);
    }
};

Value.prototype.hintMultiple = function(name, valueColl, declarationConfidence, path, row) {
    var _self = this;
    valueColl.forEach(function(v) {
        _self.hint(name, v, NOT_PROPER);
    });
    this.markProperDeclaration('_' + name, declarationConfidence, path, row);
};

function ValueCollection(values, prototypeValues) {
    this.values = values || [];
    this.prototypeValues = prototypeValues || [];
}

ValueCollection.prototype.extend = function(coll) {
    if (coll instanceof ValueCollection) {
        for (var i = 0; i < coll.values.length; i++) {
            this.add(coll.values[i]);
        }
        for (var i = 0; i < coll.prototypeValues.length; i++) {
            this.addFromPrototype(coll.prototypeValues[i]);
        }
    } else {
        for (var i = 0; i < coll.length; i++) {
            this.add(coll[i]);
        }
    }
};

ValueCollection.prototype.extendPrototype = function(coll) {
    this.prototypeValues = this.prototypeValues.concat(coll);
};

ValueCollection.prototype.toArray = function() {
    return this.values.concat(this.prototypeValues);
};

ValueCollection.prototype.add = function(value) {
    if (!value)
        throw Error("Adding empty value!");
    if (this.values.length > MAX_VALUES_LENGTH)
        return;
    this.values.push(value);
};

ValueCollection.prototype.addFromPrototype = function(value) {
    if (this.prototypeValues.length > MAX_VALUES_LENGTH)
        return;
    this.prototypeValues.push(value);
};

ValueCollection.prototype.forEach = function(fn) {
    this.values.forEach(fn);
    this.prototypeValues.forEach(fn);
};

ValueCollection.prototype.deref = function() {
    var values = this.values;
    for (var i = 0; i < values.length; i++)
        if (typeof values[i] === 'string')
            values[i] = valueRegistry[values[i]];
    values = this.prototypeValues;
    for (var i = 0; i < values.length; i++)
        if (typeof values[i] === 'string')
            values[i] = valueRegistry[values[i]];
};

ValueCollection.prototype.isEmpty = function() {
    return this.values.length === 0 && this.prototypeValues.length === 0;
};

function FunctionValue(name, node, callOnly) {
    this.init(name, node);
    this.node = node;
    this.callOnly = callOnly;
    if (name || node) {
        this.hintMultiple('__proto__', lookupValue("es5:Function").get('prototype'));
    }
}

FunctionValue.prototype = new Value('<ignore>');

FunctionValue.prototype.getFargs = function() {
    if (this.fargs)
        return this.fargs;
    else if (this.node) {
        var fargs = [];
        var fargsNode = this.node[1];
        for (var i = 0; i < fargsNode.length; i++) {
            fargs.push(fargsNode[i][0].value);
        }
        this.fargs = fargs;
        return fargs;
    }
    else
        return [];
};

FunctionValue.prototype.toJSON = function() {
    var json = Value.prototype.toJSON.call(this);
    json.fargs = this.getFargs();
    return json;
};

function SerializedFunctionValue(name) {
    this.init(name);
}

SerializedFunctionValue.prototype = new FunctionValue();

function instantiate(fn, initVal, node, name) {
    var value = initVal || new Value(name, node);
    value.hintMultiple('__proto__', fn.get('prototype'));
    value.hint('constructor', fn, PROPER);
    return value;
}

function lookupValue(guid) {
    if (!valueRegistry[guid])
        throw Error("Could not find " + guid);
    return valueRegistry[guid];
}

function fromJSON(json) {
    if (typeof json === "string")
        return json;
    
    var properties = json.properties || {};
    var value;

    if (properties._return !== undefined) {
        value = new SerializedFunctionValue();
        if (json.fargs) {
            value.fargs = json.fargs;
            for (var i = 0; i < value.fargs.length; i++) {
                if (!value.fargs[i].type)
                    value.fargs[i].type = ["es5:Object"];
            }
        }
    }
    else {
        value = new Value();
    }
    
    for (var p in properties) {
        var prop = properties[p];
        if (!prop.forEach) {
            (prop.values || []).forEach(function(v) {
                value.hint(p.substr(1), fromJSON(v), PROPER, v.path || json.path, v.row);
            });
        }
        else {
            prop.forEach(function(v) {
                value.hint(p.substr(1), fromJSON(v), PROPER, v.path || json.path, v.row);
            });
        }
    }

    if (json.guid) {
        valueRegistry[json.guid] = value;
    }
    value.guid = json.guid;
    value.doc = json.doc;
    value.docUrl = json.docUrl;
    value.path = json.path;
    value.row = json.row;
    
    return value;
}
    
exports.Value = Value;
exports.ValueCollection = ValueCollection;
exports.FunctionValue = FunctionValue;
exports.instantiate = instantiate;
exports.fromJSON = fromJSON;
exports.lookupValue = lookupValue;

exports.getRegistry = function() { return valueRegistry; };

exports.reset = function() {
    valueRegistry = {};
    contextStack = [];
};

});

define("plugins/c9.ide.language.javascript.infer/infer",[], function(require, exports, module) {

var values = require("./values");
var Value = values.Value;
var ValueCollection = values.ValueCollection;
var FunctionValue = values.FunctionValue;
var instantiate = values.instantiate;
var valueFromJSON = values.fromJSON;
var lookupValue = values.lookupValue;
var scopeAnalyzer = require("plugins/c9.ide.language.javascript/scope_analyzer");
var Scope = scopeAnalyzer.Scope;
var Variable = scopeAnalyzer.Variable;
var PROPER = scopeAnalyzer.PROPER;
var MAYBE_PROPER = scopeAnalyzer.MAYBE_PROPER;
var NOT_PROPER = scopeAnalyzer.NOT_PROPER;
var KIND_PACKAGE = scopeAnalyzer.KIND_PACKAGE;
var KIND_DEFAULT = scopeAnalyzer.KIND_DEFAULT;
var path = require("./path");
var completeUtil = require("plugins/c9.ide.language/complete_util");
require('treehugger/traverse');

var registeredSummaries = {};

if (typeof window !== "undefined") {
    completeUtil.fetchText("plugins/c9.ide.language.javascript.infer/builtin.jst", function(err, result) {
        if (err) return console.error(err);
        registeredSummaries.$builtin1$ = JSON.parse(result);
    });
}

var filePath;
var basePath;

function registerSummary(guid, summary) {
    if (!summary) {
        if (registeredSummaries[guid])
            delete registeredSummaries[guid];
        return;
    }
    
    registeredSummaries[guid] = summary;
}

Variable.prototype.addValue = function(value) {
    var values = this.values;
    for (var i = 0; i < values.length; i++) {
        if (values[i].guid === value.guid) {
            return;
        }
    }
    values.push(value);
};
Scope.prototype.hint = function(name, v, declarationConfidence, path, row, kind) {
    var variable = this.get(name, kind);
    if (!variable) {
        variable = this.declare(name);
    }
    for (var i = 0; i < variable.values.length; i++) {
        if (variable.values[i].guid === v.guid) {
            return;
        }
    }
    variable.addValue(v);
    return v;
};

Scope.prototype.hintMultiple = function(name, valueColl, declarationConfidence, path, row) {
    var variable = this.get(name);
    if (!variable) {
        variable = this.declare(name);
    }
    valueColl.forEach(function(v) {
        for (var i = 0; i < variable.values.length; i++) {
            if (variable.values[i].guid === v.guid) {
                return;
            }
        }
        variable.addValue(v);
    });
};
function evalFunction(scope, node, thisValues) {
    node.rewrite(
        'Function(name, fargs, body)', function(b, node) {
            var val = new FunctionValue(b.name.value, node);
            if (b.name.value)
                scope.hint(b.name.value, val, PROPER, filePath, tryGetRow(node));
            var proto = new Value("prototype", node);
            val.hint('prototype', proto);
            var localScope = this.getAnnotation("localScope");
            localScope.fn = val;
            localScope.declare("this", undefined, PROPER);
            localScope.hint("this", proto, PROPER, filePath, tryGetRow(node));
            if (thisValues)
                localScope.hintMultiple("this", thisValues, PROPER);
            b.fargs.forEach(function(farg, idx) {
                var fargName = farg[0].value;
                var fargVal;
                if (localScope.fnFargs && localScope.fnFargs[idx] && localScope.fnFargs[idx].type) {
                    fargVal = lookupValue(localScope.fnFargs[idx].type);
                }
                else {
                    fargVal = new Value(fargName);
                }
                val.hint("arg" + idx, fargVal, NOT_PROPER);
                localScope.declare(fargName);
                localScope.hint(fargName, fargVal, PROPER);
            });
            Value.enterContext(b.name.value || 'fn');
            staticEval(localScope, b.body);
            Value.leaveContext();
        }
    );
}

function hintValue(node, asV, declarationConfidence) {
    node.rewrite(
        'Var(x)', function(b) {
            var scope = this.getAnnotation("scope");
            scope.hint(b.x.value, asV, declarationConfidence);
        },
        'PropAccess(e, x)', function(b) {
            var vals = inferValues(b.e);
            vals.forEach(function(v) {
                v.hint(b.x.value, asV, declarationConfidence);
            });
        }
    );
}
function staticEval(scope, node, newFilePath, newBasePath) {
    if (newFilePath || newFilePath === "")
        filePath = newFilePath;
    if (newBasePath || newBasePath === "")
        basePath = newBasePath;
        
    node.traverseTopDown(
        "Function(_, _, _)", function() {
            evalFunction(scope, this);
            return this; // Stop traversal
        },
        "VarDeclInit(name, e)", "ConstDeclInit(name, e)", "LetDeclInit(name, e)", function(b, node) {
            staticEval(scope, b.e);
            scope.hintMultiple(b.name.value, inferValues(b.e), PROPER, filePath, tryGetRow(node));
            return this; // Stop traversal
        }, 
        'Assign(PropAccess(e1, prop), e2)', function(b, node) {
            staticEval(scope, b.e1);
            var vs = inferValues(b.e1);
            var isImportant = false;
            if (b.e2.cons === 'Function') {
                evalFunction(scope, b.e2, vs);
                isImportant = true;
            }
            else if (b.e2.cons === 'ObjectInit') {
                staticEval(scope, this[0]); // PropAccess(e1, prop)
                var vs2 = inferValues(this[0]);
                b.e2[0].filter(
                    'PropertyInit(_, Function(_, _, _))', function(b) {
                        evalFunction(scope, this[1], vs2);
                        return this;
                    },
                    function(b) {
                        staticEval(scope, this);
                    }
                );
                isImportant = true;
            }
            else {
                staticEval(scope, b.e2);
            }
            var vs3 = inferValues(b.e2);
            if (isImportant) {
                vs.values.forEach(function(v) {
                    v.hintMultiple(b.prop.value, vs3, MAYBE_PROPER, filePath, tryGetRow(node));
                });
            }
            else {
                vs.values.forEach(function(v) {
                    v.hintMultiple(b.prop.value, vs3, MAYBE_PROPER);
                });
            }
            return this;
        },
        "Assign(Var(name), e)", function(b) {
            staticEval(scope, this[0]);
            staticEval(scope, b.e);
            scope.hintMultiple(b.name.value, inferValues(b.e), MAYBE_PROPER);
            return this;
        },
        "ObjectInit(inits)", function(b) {
            var v = new Value("objLit");
            var vals = new ValueCollection([v]);
            b.inits.filter(
                'PropertyInit(prop, Function(_, _, _))', function(b) {
                    evalFunction(scope, this[1], vals);
                    v.hintMultiple(b.prop.value, inferValues(this[1]), PROPER, filePath, tryGetRow(this));
                },
                'PropertyInit(prop, e)', function(b) {
                    staticEval(scope, b.e);
                    v.hintMultiple(b.prop.value, inferValues(b.e), PROPER, filePath, tryGetRow(this));
                }
            );
            return this;
        },
        "OpAssign(op, Var(name), e)", function(b) {
            staticEval(scope, this[1]);
            staticEval(scope, b.e);
            scope.hintMultiple(b.name.value, inferValues(b.e), MAYBE_PROPER);
            if (b.op.value === '*' || b.op.value === '/' || b.op.value === '%' || b.op.value === '-') {
                scope.hint(b.name.value, lookupValue('es5:Number/prototype'));
            } else if (b.op.value === '+') {
                scope.hint(b.name.value, lookupValue('es5:Number/prototype'));
                scope.hint(b.name.value, lookupValue('es5:String/prototype'));
            }
            return this;
        },
        "PropAccess(e, prop)", function(b) {
            staticEval(scope, b.e);
            var vs = inferValues(this);
            if (!vs.isEmpty()) {
                return; // property is defined
            }
            vs = inferValues(b.e);
            vs.forEach(function(v) {
                v.hint(b.prop.value, new Value(b.prop.value), MAYBE_PROPER);
            });
            return this;
        },
        'Call(PropAccess(Function(name, fargs, body), "call"), args)', function(b) {
            var fnNode = this[0][0]; // Function(name, ...)
            staticEval(scope, b.args);
            var objectValues = inferValues(b.args[0]);
            var funScope = fnNode.getAnnotation("localScope");
            var fargs = b.fargs;
            evalFunction(scope, fnNode, objectValues);
            for (var i = 0; i < b.args.length - 1; i++) {
                inferValues(b.args[i + 1]).forEach(function(v) {
                    if (i < fargs.length)
                        funScope.hint(fargs[i].value, v, NOT_PROPER);
                    objectValues.forEach(function(objV) {
                        objV.hint('arg' + i, v, NOT_PROPER);
                    });
                });
            }
            return this;
        },
        "Call(Var(name), args)", function(b) {
            var variable = scope.get(b.name.value);
            if (!variable) {
                variable = scope.declare(b.name.value);
                scope.hint(b.name.value, new FunctionValue(b.name.value, null, true), MAYBE_PROPER);
            } 
            else {
                var foundFunction = false;
                variable.values.forEach(function(v) {
                    if (v instanceof FunctionValue)
                        foundFunction = true;
                });
                if (!foundFunction)
                    scope.hint(b.name.value, new FunctionValue(b.name.value, null, true), MAYBE_PROPER);
            }
            staticEval(scope, b.args);
            for (var i = 0; i < b.args.length; i++) {
                inferValues(b.args[i]).forEach(function(v) {
                    variable.values.forEach(function(fn) {
                        if (fn instanceof FunctionValue) {
                            fn.hint('arg' + i, v, NOT_PROPER);
                        }
                    });
                });
            }
            variable.values.forEach(function(fn) {
                if (fn instanceof FunctionValue && fn.get("return").isEmpty())
                    fn.hint('return', new Value("implReturn"), PROPER);
            });
            return this;
        },
        "Call(PropAccess(e, prop), args)", function(b) {
            staticEval(scope, b.e);
            var eValues = inferValues(b.e);
            var fnValues = inferValuesPropAccess(eValues, b.prop.value, new ValueCollection());
            fnValues.forEach(function(fn) {
                if (fn instanceof FunctionValue) {
                    for (var i = 0; i < b.args.length; i++) {
                        var fargFargs = fn.fargs && fn.fargs[i] && fn.fargs[i].fargs;
                        var localScope = b.args[i].getAnnotation("localScope");
                        if (localScope)
                            localScope.fnFargs = fargFargs;
                    }
                }
            });
            staticEval(scope, b.args);
            if (fnValues.isEmpty()) {
                eValues.forEach(function(v) {
                    v.hint(b.prop.value, new FunctionValue(b.prop.value, null, true), MAYBE_PROPER);
                });
            }
            fnValues.forEach(function(fn) {
                if (fn instanceof FunctionValue) {
                    for (var i = 0; i < b.args.length; i++) {
                        var vs = inferValues(b.args[i]);
                        vs.forEach(function(v) {
                            fn.hint('arg' + i, v, NOT_PROPER);
                        });
                    }
                    if (fn.get("return").isEmpty())
                        fn.hint('return', new Value("implReturn"), PROPER);
                }    
            });
            return this;
        },
        "Return(e)", function(b) {
            staticEval(scope, b.e);
            scope.fn && scope.fn.hintMultiple('return', inferValues(b.e), PROPER);
            return this;
        },
        "Var(name)", function(b) {
            var vs = scope.get(b.name.value);
            if (!vs) {
                scope.declare(b.name.value);
                scope.hint(b.name.value, new Value(b.name.value, this), MAYBE_PROPER);
            }
            return this;
        },
        "ForIn(iter, _, _)", function(b) {
            b.iter.rewrite(
                "Var(x)", function(b) {
                    scope.hint(b.x.value, lookupValue("es5:String"));
                },
                "VarDecls([VarDecl(x)])", function(b) {
                    scope.hint(b.x.value, lookupValue("es5:String"));
                }
            );
        },
        "Op(op, e1, e2)", function(b) {
            staticEval(scope, b.e1);
            staticEval(scope, b.e2);
            switch (b.op.value) {
                case '<':
                case '<=':
                case '>':
                case '>=':
                    hintValue(b.e1, lookupValue("es5:Number"), NOT_PROPER);
                    hintValue(b.e1, lookupValue("es5:String"), NOT_PROPER);
                    hintValue(b.e2, lookupValue("es5:Number"), NOT_PROPER);
                    hintValue(b.e2, lookupValue("es5:String"), NOT_PROPER);
                    break;
            }
            return this;
        }
    );
    return scope;
}
function inferValues(e) {
    var values = new ValueCollection();
    e.rewrite(
        "String(_)", function() {
            values.add(lookupValue("es5:String/prototype"));
            return this;
        },
        "RegExp(_,_)", function() {
            values.add(lookupValue("es5:RegExp/prototype"));
            return this;
        },
        "Num(_)", function() {
            values.add(lookupValue("es5:Number/prototype"));
            return this;
        },
        "Var(\"true\")", function() {
            values.add(lookupValue("es5:Boolean/prototype"));
            return this;
        },
        "Var(\"false\")", function() {
            values.add(lookupValue("es5:Boolean/prototype"));
            return this;
        },
        "Array(_)", function() {
            values.add(lookupValue("es5:Array/prototype"));
            return this;
        },
        "Var(nm)", function(b) {
            var scope = this.getAnnotation("scope");
            if (!scope) {
                for (var root = this; root.parent;) root = root.parent;
                console.error("[infer] Cannot find scope of " + b.nm + "; analysis "
                    + (root.getAnnotation("scope") ? "incomplete" : "may not have been performed yet"));
                return;
            }
            var v = scope.get(b.nm.value) || scope.declare(b.nm.value);
            if (v.kind === KIND_DEFAULT)
                values.extend(v.values);
            return this;
        },
        "ObjectInit(inits)", function(b) {
            var v = instantiate(lookupValue("es5:Object"), undefined, this);
            b.inits.filter('PropertyInit(prop, e)', function(b) {
                v.hintMultiple(b.prop.value, inferValues(b.e), PROPER, filePath, tryGetRow(this));
            });
            values.add(v);
            return this;
        },
        "New(e, args)", function(b) {
            var vs = inferValues(b.e);
            vs.forEach(function(fn) {
                var value = instantiate(fn, undefined, undefined, b.e.cons === 'Var' && b.e[0].value);
                values.add(value);
            });
            return this;
        },
        "Call(Var(\"require\"), [String(name)])", function(b) {
            var scope = this[0].getAnnotation("scope");
            if (!scope)
                return;
            var required = b.name.value;
            if (path.isRelativePath(required) || path.isRelativePath(required)) {
                required = path.canonicalizePath(required, basePath).replace(/^\//, "");
                if (!required.match(/\.js$/))
                    required += ".js";
            }
            var result = scope.get(required, KIND_PACKAGE);
            if (!result)
                return;
            values.extend(result.values);
            return this;
        },
        "Call(PropAccess(e, method), args)", function(b) {
            var objectValues = inferValues(b.e);
            objectValues.forEach(function(objectValue) {
                var methods = objectValue.get(b.method.value);
                methods.forEach(function(fn) {
                    if (fn instanceof FunctionValue) {
                        values.extend(fn.get('return'));
                    }
                });
            });
            if (values.isEmpty())
                values.add(new Value("implRet"));
            return this;
        },
        "Call(e, args)", function(b) {
            var vs = inferValues(b.e);
            vs.forEach(function(fn) {
                if (fn instanceof FunctionValue) {
                    values.extend(fn.get('return'));
                }
            });
            if (values.isEmpty())
                values.add(new Value("implRet"));
            return this;
        },
        "PropAccess(e, prop)", function(b) {
            inferValuesPropAccess(inferValues(b.e), b.prop.value, values);
            return this;
        },
        "Function(name, fargs, _)", function(b) {
            values.add(this.getAnnotation("localScope").fn);
            return this;
        },
        'Assign(e1, e2)', function(b) {
            values = inferValues(b.e2);
        },
        'Op(op, e1, e2)', function(b) {
            switch (b.op.value) {
                case '*':
                case '/':
                case '%':
                case '-':
                    values.add(lookupValue('es5:Number/prototype'));
                    break;
                case '+':
                    values.add(lookupValue('es5:String/prototype'));
                    values.add(lookupValue('es5:Number/prototype'));
                    break;
                case '==':
                case '===':
                case '!==':
                case '!=':
                case '>':
                case '>=':
                case '<':
                case '<=':
                    values.add(lookupValue('es5:Boolean/prototype'));
                    break;
                case '||':
                case '&&':
                    values.extend(inferValues(b.e1));
                    values.extend(inferValues(b.e2));
                    break;
                default:
                    return false;
            }
            return this;
        },
        'PrefixOp(op, e)', function(b) {
            switch (b.op.value) {
                case '+':
                case '-':
                case '~':
                    values.add(lookupValue('es5:Number/prototype'));
                    break;
                case '!':
                    values.add(lookupValue('es5:Boolean/prototype'));
                    break;
                default:
                    return false;
            }
            return this;
        }
    );
    return values;
}

function inferValuesPropAccess(values, propName, results) {
    values.forEach(function(val) {
        results.extend(val.get(propName));
    });
    return results;
}

function createRootScope(scope, summaries) {
    if (!summaries)
        summaries = registeredSummaries;
    for (var p in summaries) {
        if (!summaries.hasOwnProperty(p))
            continue;
        var summarySet = summaries[p];
        for (var uri in summarySet) {
            if (!summarySet.hasOwnProperty(uri))
                continue;
            var summary = summarySet[uri];
            var TypeName = uri.split(':')[1];
            if (summary.kind === "default")
                summary.kind = KIND_DEFAULT;
            scope.declare(TypeName, undefined, PROPER, summary.kind);
            var value = valueFromJSON(summary);
            scope.hint(TypeName, value, PROPER, summary.path, summary.row, summary.kind);
    
            for (var j = 0; summary.altGuids && j < summary.altGuids.length; j++) {
                var guid = summary.altGuids[j].split(':')[1];
                scope.declare(guid, undefined, PROPER, summary.kind);
                scope.hint(guid, value, PROPER, summary.path, summary.row, summary.kind);   
            }
            
            if (summary.path) {
                scope.declareAlias(summary.kind, TypeName, summary.path);   
            }
        }
    }
    return scope;
}

function analyze(doc, ast, filePath, basePath, callback) {
    scopeAnalyzer.analyze(doc.getValue(), ast, function() {
        Value.enterContext('es5:unnamed');
        var scope = ast.getAnnotation("scope");
        values.reset();
        createRootScope(scope);
        Value.leaveContext();
        Value.enterContext("local:");
        staticEval(scope, ast, filePath, basePath);
        callback();
    }, true);
}

function tryGetRow(node) {
    var pos = node.getPos();
    return pos ? pos.sl : undefined;
}

exports.registerSummary = registerSummary;
exports.staticEval = staticEval;
exports.inferValues = inferValues;
exports.Scope = Scope;
exports.createRootScope = createRootScope;
exports.analyze = analyze;

});

define("plugins/c9.ide.language.javascript.infer/infer_arguments",[], function(require, exports, module) {

var tree = require("treehugger/tree");
var FunctionValue = require('./values').FunctionValue;
var ValueCollection = require('./values').ValueCollection;
module.exports.getArgIndex = function(node, doc, cursorPos) {
    var cursorTreePos = { line: cursorPos.row, col: cursorPos.column };
    var result = -1;
    node.rewrite(
        'Call(e, args)', function(b) {
            result = -1;
            var line = doc.getLine(cursorPos.row);
            if (line[b.args.getPos().ec + 1] && line[b.args.getPos().ec + 1].match(/[ ,]/))
                b.args.getPos().ec++;

            if (b.args.length === 0 && this.getPos().ec - 1 === cursorPos.column) {
                result = 0;
            }
            else if (b.args.length === 0 && line.substr(cursorPos.column).match(/^\s*\)/)) {
                result = 0;
            }
            else if (!tree.inRange(this.getPos(), cursorTreePos, true)) {
                return this;
            }
            else if (cursorPos.row === this.getPos().sl && line.substr(0, cursorPos.column + 1).match(/,\s*\)$/)) {
                result = b.args.length;
                return this;
            }
            for (var i = 0; i < b.args.length; i++) {
                if (b.args[i].cons === "ERROR" && result === -1) {
                    result = i;
                    break;
                }
                b.args[i].traverseTopDown(function() {
                    var pos = this.getPos();
                    if (this === node) {
                        result = i;
                        return this;
                    }
                    else if (pos && pos.sl <= cursorPos.row && pos.sc <= cursorPos.column) {
                        if (pos.sl === cursorPos.row && pos.ec === cursorPos.column - 1 && line[pos.ec] === ")")
                            return result = -1;
                        result = i;
                    }
                });
            }
            return this;
        }
    );
    return result;
};

module.exports.extractArgumentNames = function(v, showOptionals) {
    var args = [];
    var argsCode = [];
    var inferredArguments = v.callOnly;
    var opt;
    var fargs = v instanceof FunctionValue ? v.getFargs() : [];
    var argColl = extractArgumentValues(v, fargs, 0);
    for (var idx = 0; fargs.length ? idx < fargs.length : !argColl.isEmpty(); idx++) {
        var argName;
        if (fargs[idx]) {
            argName = fargs[idx].id || fargs[idx];
            if (showOptionals && fargs[idx].opt) {
                argName = "[" + argName + "]";
                opt = opt || idx;
            }
        }
        else {
            argName = "arg" + idx;
            inferredArguments = true;
        }
        args.push(argName);
        argsCode.push(fargToClosure(fargs[idx]) || valueCollToClosure(argName, argColl));
        argColl = extractArgumentValues(v, fargs, idx + 1);
    }
    return {
        argNames: args,
        argValueCodes: argsCode,
        inferredNames: inferredArguments,
        opt: opt
    };
};

var extractArgumentValues = function(v, fargs, index) {
    var result;
    if (fargs[index] && fargs[index].id) {
        result = new ValueCollection();
        if (fargs[index].type)
            result.extend(fargs[index].type);
    }
    else {
        result = v.get("arg" + index);
    }
    return result;
};

function fargToClosure(farg) {
    if (!farg || !farg.fargs)
        return null;
    var args = [];
    for (var i = 0; i < farg.fargs.length; i++) {
        args.push(farg.fargs[i].id || farg.fargs[i]);
    }
    return "function(" + args.join(", ") + ") {\n    ^^\n}";
}

function valueCollToClosure(name, coll) {
    var result;
    coll.forEach(function(v) {
        if (result)
            return;
        if (v instanceof FunctionValue) {
            var args = [];
            var fargs = v.getFargs();
            var argColl = extractArgumentValues(v, fargs, idx);
            for (var idx = 0; !argColl.isEmpty() || idx < fargs.length; idx++) {
                var argName;
                if (fargs[idx])
                    argName = fargs[idx].id || fargs[idx];
                else
                    argName = "arg" + idx;
                args.push(argName);
                argColl = extractArgumentValues(v, fargs, idx + 1);
            }
            result = "function(" + args.join(", ") + ") {\n    ^^\n}";
        }
    });
    return result;
}

});

define("plugins/c9.ide.language.javascript.infer/ast_updater",[], function(require, exports, module) {

    var infer = require("./infer");
    var assert = require("c9/assert");
    var tree = require("treehugger/tree");
    var REGEX_SAFE_CHANGE = /^[\(\)\s\.\/\*+;,A-Za-z-0-9_$]*$/;
    
    var lastAST;
    var lastDocValue;
    module.exports.updateOrReanalyze = function(doc, ast, filePath, basePath, pos, callback) {
        var docValue = doc.getValue();
        var updatedAST = tryUpdateAST(doc, docValue, ast);
        if (updatedAST) {
            if (ast.getAnnotation("scope")) {
                lastDocValue = docValue;
                lastAST = updatedAST;
            }
            return callback(updatedAST, findNode(updatedAST, pos));
        }
        var start = new Date().getTime();
        return infer.analyze(doc, ast, filePath, basePath, function() {
            lastDocValue = docValue;
            lastAST = ast;
            callback(ast, findNode(ast, pos));
        }, true);
    };
   
    function tryUpdateAST(doc, docValue, ast) {
        if (lastAST && (!lastAST.annos || !lastAST.annos.scope)) {
            console.error("Warning: Source does not appear to be analyzed yet; restarting analysis");
            return false;
        }
        if (lastDocValue === docValue) {
            return lastAST;
        }
        if (!isUpdateableAST(doc, docValue, ast))
            return null;
        
        if (!copyAnnosTop(lastAST, ast, true))
            return null;
        copyAnnosTop(lastAST, ast);
        assert(ast.annos.scope, "Target is empty");
        return ast;
    }
    function isUpdateableAST(doc, docValue, ast) {
        if (!lastDocValue)
            return false;

        var diff = getDiff(lastDocValue, docValue) || getDiff(docValue, lastDocValue);
        
        return diff && diff.text.match(REGEX_SAFE_CHANGE);
    }
    
    function copyAnnosTop(oldAST, newAST, dryRun) {
        if (!dryRun) copyAnnos(oldAST, newAST);
            
        for (var i = 0, j = 0; j < newAST.length; i++, j++) {
            if (!oldAST[i]) {
                if (newAST[j].cons !== "Var")
                    return false;
                copyAnnos(findScopeNode(oldAST), newAST[j]);
                if (!newAST[j].annos)
                    return false;
                continue;
            }
            if (oldAST[i].cons !== newAST[j].cons) {
                if (oldAST[i].cons === "Var" && newAST[j].isMatch("PropAccess(Var(_),_)")) {
                    copyAnnos(oldAST[i], newAST[j][0]);
                    continue;
                }
                if (newAST[j].cons === "Var" && oldAST[i].isMatch("PropAccess(Var(_),_)")) {
                    copyAnnos(oldAST[i][0], newAST[j]);
                    continue;
                }
                if (oldAST[i].isMatch("PropAccess(Var(_),_)") && newAST[j].isMatch("Call(PropAccess(Var(_),_),_)")) {
                    copyAnnos(oldAST[i][0], newAST[j][0][0]);
                    var oldTemplate = new tree.ListNode([oldAST[i][0]]);
                    oldTemplate.parent = oldAST;
                    copyAnnosTop(oldTemplate, newAST[j][1], dryRun);
                    continue;
                }
                if (newAST[j].isMatch("PropAccess(Var(_),_)") && oldAST[i].isMatch("Call(PropAccess(Var(_),_),_)")) {
                    copyAnnos(oldAST[i][0][0], newAST[j][0]);
                    continue;
                }
                if (newAST[j].cons === "Var" && newAST[j + 1] && newAST[j + 1].cons === oldAST[i].cons) {
                    copyAnnos(findScopeNode(oldAST), newAST[j]);
                    if (!newAST[j].annos)
                        return false;
                    i--;
                    continue;
                }
                if (oldAST[i].cons === "None" && newAST[j].cons === "Var") {
                    copyAnnos(findScopeNode(oldAST), newAST[j]);
                    if (!newAST[j].annos)
                        return false;
                    i--;
                    continue;
                }
                if (oldAST[i].cons === "Var" && oldAST[i + 1] && oldAST[i + 1].cons === newAST[i].cons) {
                    j--;
                    continue;
                }
                if (["If", "Return", "Throw"].indexOf(newAST[j].cons) > -1 && (!newAST[j][1] || newAST[j][1].isMatch("Block([])"))) {
                    var cond = newAST[j][0].toString();
                    if (cond === oldAST[i].toString()) {
                        copyAnnos(oldAST[i], newAST[j][0]);
                        continue;
                    }
                    else if (!oldAST[i + 1]) {
                        continue;
                    }
                    else if (cond === oldAST[i + 1].toString()) {
                        i++;
                        copyAnnos(oldAST[i], newAST[j][0]);
                        continue;
                    }
                }
                if (oldAST.cons === "If" && newAST.cons === "If" && newAST[0].cons === "Var" && oldAST[1].isMatch("Block([])")) {
                    var oldCond = oldAST[0];
                    var newCond = newAST[0];
                    var newBody = newAST[1];
                    if (oldCond.toString() === newBody.toString()) {
                        copyAnnos(findScopeNode(oldAST), newCond);
                        if (!newCond.annos)
                            return false;
                        copyAnnos(oldCond, newBody);
                        continue;
                    }
                }
                return false;
            }
            if (newAST[j].length) {
                if (!copyAnnosTop(oldAST[i], newAST[j], dryRun))
                    return false;
            } else if (!dryRun && newAST[j].$pos) {
                copyAnnos(oldAST[i], newAST[j]);
            }
            
        }
        return true;
    }
    
    function copyAnnos(oldNode, newNode) {
        newNode.oldNode = oldNode.oldNode || oldNode;
        newNode.oldNode.$pos = newNode.$pos;
        
        if (!oldNode.annos)
            return;
        newNode.annos = oldNode.annos;
    }
    
    function findScopeNode(ast) {
        if (!ast)
            return null;
        if (ast.annos && ast.annos.scope)
            return ast;
        return findScopeNode(ast.parent);
    }
    
    function getDiff(oldDoc, newDoc) {
        if (oldDoc.length > newDoc.length)
            return null;
        
        var diffLeft = -1;
        var diffRight = 0;
        
        for (var i = 0; i < newDoc.length; i++) {
            if (oldDoc[i] !== newDoc[i]) {
                diffLeft = i;
                break;
            }
        }
        
        for (var i = newDoc.length, j = oldDoc.length; j >= 0; i--, j--) {
            if (oldDoc[j] !== newDoc[i]) {
                diffRight = i + 1;
                break;
            }
        }
        
        assert(diffLeft != -1, "Inputs can't be equal");
        
        return {
            start: diffLeft,
            end: diffRight,
            text: newDoc.substring(diffLeft, diffRight)
        };
    }
    
    function findNode(ast, pos) {
        var treePos = { line: pos.row, col: pos.column };
        return ast.findNode(treePos);
    }
    
    
});

define("plugins/c9.ide.language.javascript.infer/infer_completer",[], function(require, exports, module) {

var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');
var infer = require('./infer');
var path = require('./path');
var KIND_DEFAULT = require('plugins/c9.ide.language.javascript/scope_analyzer').KIND_DEFAULT;
var KIND_PACKAGE = require('plugins/c9.ide.language.javascript/scope_analyzer').KIND_PACKAGE;
var KIND_EVENT = require('plugins/c9.ide.language.javascript/scope_analyzer').KIND_EVENT;
var PROPER = require('plugins/c9.ide.language.javascript/scope_analyzer').PROPER;
var EXPAND_STRING = 1;
var EXPAND_REQUIRE = 2;
var EXPAND_REQUIRE_LIMIT = 5;
var REQUIRE_PROPOSALS_MAX = 80;
var REQUIRE_ID_REGEX = /(?!["'])./;
var FunctionValue = require('./values').FunctionValue;
var completeUtil = require("plugins/c9.ide.language/complete_util");
var traverse = require("treehugger/traverse");
var args = require("./infer_arguments");
var astUpdater = require("./ast_updater");
var PRIORITY_INFER_LOW = 3;
var PRIORITY_INFER = 4;
var PRIORITY_INFER_TERN = 5;
var PRIORITY_INFER_HIGH = 6;

var completer = module.exports = Object.create(baseLanguageHandler);
var extraModuleCompletions;
    
completer.handlesLanguage = function(language) {
    return language === "javascript" || language === "jsx";
};

completer.getIdentifierRegex = function() {
    return (/[a-zA-Z_0-9\$\/]/);
};

completer.getCompletionRegex = function() {
    return (/^[\.]$/);
};

completer.getCacheCompletionRegex = function() {
    return new RegExp(
        "(\\b(if|while|for|switch)\\s*\\("
        + "|\\b\\w+\\s+"
        + "|(===?|!==?|[-+]=|[-+*%<>?!|&{[])"
        + "|\\s)+"
    );
};

completer.getMaxFileSizeSupported = function() {
    return .25 * 10 * 1000 * 80;
};

completer.setExtraModules = function(extraModules) {
    extraModuleCompletions = extraModules;
};

function valueToMatch(container, v, name, isPackage, isContextual) {
    if (isPackage)
        name = name.replace(/\.js$/, "");
    if ((v instanceof FunctionValue || v.properties._return) && !isPackage) {
        var showArgs = args.extractArgumentNames(v, true);
        var insertArgs = "opt" in showArgs ? args.extractArgumentNames(v, false) : showArgs;
        return {
            id: name,
            guid: v.guid + "[0" + name + "]",
            name: name + "(" + showArgs.argNames.join(", ") + ")",
            replaceText: name + (insertArgs.argNames.length === 0 && v.guid && v.guid.indexOf("es5:") !== 0 ? "()" : "(^^)"),
            icon: "method",
            priority: PRIORITY_INFER,
            inferredNames: showArgs.inferredNames,
            doc: v.doc,
            docUrl: v.docUrl,
            isFunction: true,
            type: v.properties._return && getGuid(v.properties._return.values[0]),
            isContextual: isContextual
        };
    }
    else {
        var isHighConfidence = 
            container && container.properties && container.properties["_" + name]
            && container.properties["_" + name].confidence >= 1;
        return {
            id: name,
            guid: container ? container.guid + "/" + name : v.guid + "[0" + name + "]",
            name: name,
            replaceText: name,
            doc: v.doc,
            docUrl: v.docUrl,
            icon: "property",
            priority: name === "__proto__" ? PRIORITY_INFER_LOW : PRIORITY_INFER,
            type: !isPackage && getGuid(v.properties.___proto__ ? v.properties.___proto__.values[0] : v.guid),
            isContextual: isHighConfidence
        };
    }
}

function getGuid(valueOrGuid) {
    if (!valueOrGuid)
        return;
    var result = valueOrGuid.guid || valueOrGuid;
    return result.substr && result.substr(-11) !== "/implReturn" ? result : undefined;
}

completer.predictNextCompletion = function(doc, fullAst, pos, options, callback) {
    if (!options.matches.length) {
        if (options.line[pos.column - 1] && /(?![{;})\]\s"'\+\-\*])./.test(options.line[pos.column - 1]))
            return callback(null, { predicted: "" });
    }
    var predicted = options.matches.filter(function(m) {
        return m.priority >= PRIORITY_INFER;
    });
    if (predicted.length !== 1 || predicted[0].icon === "method")
        return callback();
    callback(null, {
        predicted: predicted[0].replaceText + ".",
        showEarly: predicted[0].icon === "property" && !/\./.test(options.line)
    });
};

completer.complete = function(doc, fullAst, pos, options, callback) {
    if (!options.node)
        return callback();
    var line = options.line;
    var identifier = options.identifierPrefix;
    var basePath = path.getBasePath(completer.path, completer.workspaceDir);
    var filePath = path.canonicalizePath(completer.path, basePath);
    if (fullAst.parent === undefined) {
        traverse.addParentPointers(fullAst);
        fullAst.parent = null;
    }
    astUpdater.updateOrReanalyze(doc, fullAst, filePath, basePath, pos, function(fullAst, currentNode) {
        var completions = {};
        var duplicates = {};
        currentNode.rewrite(
            'PropAccess(e, x)', function(b) {
                var allIdentifiers = [];
                var values = infer.inferValues(b.e);
                values.forEach(function(v) {
                    var propNames = v.getPropertyNames();
                    for (var i = 0; i < propNames.length; i++) {
                        if (propNames[i] !== b.x.value || v.isProperDeclaration(propNames[i]))
                            allIdentifiers.push(propNames[i]);
                    }
                });
                var matches = completeUtil.findCompletions(identifier, allIdentifiers);
                for (var i = 0; i < matches.length; i++) {
                    values.forEach(function(v) {
                        v.get(matches[i]).forEach(function(propVal) {
                            var match = valueToMatch(v, propVal, matches[i], false, true);
                            var duplicate = duplicates["_" + match.id];
                            if (duplicate && duplicate.inferredNames)
                                delete completions["_" + duplicate.guid];
                            if (duplicate && match.inferredNames)
                                return;
                            duplicates["_" + match.id] = completions["_" + match.guid] = match;
                        });
                    });
                }
                return this;
            },
            'FArg(_)', 'Function(_,_,_)', 'VarDeclInit(_,_)', 'VarDecl(_,_)',
            'ConstDeclInit(_,_)', 'ConstDecl(_,_)', function() { return this; },
            '_', function() {
                var me = this;
                if (this.traverseUp(
                    "Call(Var(\"require\"), args)",
                    function(b) {
                        if (b.args[0] !== me && this !== me)
                            return;
                        var scope = this[0].getAnnotation("scope");
                        var expand = b.args[0] && b.args[0].cons === "String" ? null : EXPAND_STRING;
                        identifier = completeUtil.retrievePrecedingIdentifier(line, pos.column, REQUIRE_ID_REGEX);

                        var useBasePath = path.isRelativePath(identifier) || path.isAbsolutePath(identifier) ? basePath : null;
                        completer.proposeRequire(identifier, expand, scope, completions, useBasePath);
                    }))
                    return this;
            },
            'ERROR()', 'PropertyInit(x,e)', 'ObjectInit(ps)', function(b, node) {
                if (b.ps) {
                    completer.proposeObjectProperty(node, identifier, completions);
                }
                else if (!b.x) {
                    if (currentNode.parent.cons !== "PropertyInit")
                        return; // Fallthrough
                    currentNode = currentNode.parent;
                    b.x = currentNode[0];
                    b.e = currentNode[1];
                }
                var objectInit = currentNode.parent.parent;
                if (!objectInit.parent || !objectInit.parent.parent || objectInit.parent.parent.cons !== "Call")
                    return node;
                completer.proposeObjectProperty(objectInit, identifier, completions);
                return node;
            },
            'Call(_, _)', function(b) {
                if ("function".indexOf(identifier) === 0)
                    completer.proposeClosure(this, doc, pos, completions);
            },
            'Var(_)', function(b) {
                if (this.parent.parent && this.parent.parent.isMatch('Call(_, _)') && "function".indexOf(identifier) === 0)
                    completer.proposeClosure(this.parent.parent, doc, pos, completions);
            },
            'Var(_)', function(b) {
                this.parent.rewrite('VarDeclInit(x, _)', 'ConstDeclInit(x, _)', function(b) {
                    if ("require".indexOf(identifier) !== 0)
                        return;
                    var scope = this.getAnnotation("scope");
                    completer.proposeRequire(b.x.value, EXPAND_REQUIRE, scope, completions);
                    completer.proposeRequire(b.x.value, EXPAND_REQUIRE, scope, completions, basePath);
                });
            },
            function() {
                var scope;
                this.traverseUp(function() {
                    if (!scope) scope = this.getAnnotation("scope");
                    if (this.rewrite("String(_)")) return this;
                });
                if (!scope)
                    return;
                var variableNames = scope.getVariableNames();
                if (this.cons === 'Var') { // Delete current var from proposals if not properly declared anywhere
                    var varName = this[0].value;
                    if (variableNames.indexOf(varName) !== -1 && (!scope.get(varName) || !scope.get(varName).isProperDeclaration()))
                        variableNames.splice(variableNames.indexOf(varName), 1);
                }
                var matches = completeUtil.findCompletions(identifier, variableNames);
                for (var i = 0; i < matches.length; i++) {
                    var v = scope.get(matches[i]);
                    if (!v)
                        continue;
                    if (!v.values.length && v.properDeclarationConfidence >= PROPER && currentNode.cons === "Var") {
                        completions[matches[i]] = {
                            id: matches[i],
                            name: matches[i],
                            replaceText: matches[i],
                            icon: "property",
                            priority: PRIORITY_INFER_TERN
                        };
                    }
                    v.values.forEach(function(propVal) {
                        var match = valueToMatch(null, propVal, matches[i]);
                        if (!match.name)
                            return;
                        var duplicate = duplicates["_" + match.id];
                        if (duplicate && duplicate.inferredNames)
                            delete completions["_" + duplicate.guid];
                        if (duplicate && match.inferredNames)
                            return;
                        duplicates["_" + match.id] = completions["_" + match.guid] = match;
                    });
                }
            }
        );
        var completionsArray = [];
        for (var id in completions) {
            completionsArray.push(completions[id]);
        }
        callback(completionsArray);
    });
};
completer.proposeRequire = function(identifier, expand, scope, completions, basePath) {
    var names = scope.getNamesByKind(KIND_PACKAGE);
    
    if (basePath || basePath === "")
        identifier = path.canonicalizePath(identifier, basePath).replace(/^\.$/, "");
    
    if (expand === EXPAND_REQUIRE && extraModuleCompletions)
        names = names.concat(Object.keys(extraModuleCompletions));

    var matches = expand === EXPAND_REQUIRE
        ? filterRequireSubstring(identifier, names)
        : completeUtil.findCompletions(identifier === "/" ? "" : identifier, names);
    
    if (basePath || basePath === "")
        matches = matches.filter(function(v) { return v.match(/\.js$/) && !v.match(/(\/|^)node_modules\//); });
    else
        matches = matches.filter(function(v) { return !v.match(/\.js$/); });
    
    if (expand === EXPAND_REQUIRE && matches.length > EXPAND_REQUIRE_LIMIT)
        return;

    matches = matches.slice(0, REQUIRE_PROPOSALS_MAX);

    for (var i = 0; i < matches.length; i++) {
        var match = matches[i];
        var v = scope.get(match, KIND_PACKAGE);
        if (!v && expand === EXPAND_REQUIRE) {
            return completions["_" + match] = {
                id: match,
                icon: "package",
                name: 'require("' + match + '")',
                replaceText: 'require("' + match + '")',
                doc: "Origin: node<br/>"
                    + (extraModuleCompletions[match].doc || ""),
                priority: PRIORITY_INFER_HIGH
            };
        }
        v.values.forEach(function(propVal) {
            var match = valueToMatch(null, propVal, matches[i], true, expand);
            match.icon = "package";
            if (identifier.match(/^\//))
                match.replaceText = match.name = "/" + match.replaceText;
            else if (basePath || basePath === "")
                match.replaceText = match.name = path.uncanonicalizePath(match.replaceText, basePath);
            completions["_" + match.guid] = match;
            if (expand === EXPAND_REQUIRE) {
                match.replaceText = 'require("' + match.replaceText + '")';
                match.name = 'require("' + match.name + '")';
            }
            if (expand === EXPAND_STRING)
                match.replaceText = '"' + match.replaceText + '"';
            if (expand !== EXPAND_REQUIRE)
                match.identifierRegex = REQUIRE_ID_REGEX;
        });
    }
};

completer.proposeClosure = function(node, doc, pos, completions) {
    node.rewrite('Call(f, args)', function(b) {
        var argIndex = args.getArgIndex(this, doc, pos);
        var id = 0;
        infer.inferValues(b.f).forEach(function(v) {
            var argNames = args.extractArgumentNames(v, false);
            var code = argNames.argValueCodes[argIndex];
            if (!code)
                return;
            var codeName = code.split(/\n/)[0] + "}";
            var guid = v.guid + "-argfun" + (id++);
            completions[guid] = {
                id: codeName,
                guid: guid,
                name: codeName,
                replaceText: code,
                doc: v.fargs && v.fargs.doc,
                docUrl: v.fargs && v.fargs.docUrl,
                icon: "method",
                priority: PRIORITY_INFER_HIGH
            };
        });
    });
};
completer.proposeObjectProperty = function(objectInit, identifier, completions) {
    var listIndex;
    for (var i = 0; i < objectInit.parent.length; i++)
        if (objectInit.parent[i] === objectInit) listIndex = i;
    var call = objectInit.parent.parent;
    infer.inferValues(call[0]).forEach(function(v) {
        if (!v.fargs || !v.fargs[listIndex] || !v.fargs[listIndex].properties)
            return;
        v.fargs[listIndex].properties.forEach(function(property) {
            completions["_$p$" + property.id] = {
                id: property.id,
                name: property.id,
                replaceText: property.id,
                doc: property.doc,
                docUrl: property.docUrl,
                icon: "property",
                priority: PRIORITY_INFER
            };
        });
    });
};

function filterRequireSubstring(name, names) {
    var nameClean = name.replace(/[^A-Za-z0-9_-]/g, ".");
    var nameRegex = new RegExp("^" + nameClean + "\\b|\\b" + nameClean + "$");
    return names.filter(function(n) {
        return nameRegex.test(n);
    });
}

});

define("tern/plugin/doc_comment",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(require("../lib/infer"), require("../lib/tern"), require("../lib/comment"),
               require("acorn"), require("acorn/dist/walk"));
  if (typeof define == "function" && define.amd) // AMD
    return define(["../lib/infer", "../lib/tern", "../lib/comment", "acorn/dist/acorn", "acorn/dist/walk"], mod);
  mod(tern, tern, tern.comment, acorn, acorn.walk);
})(function(infer, tern, comment, acorn, walk) {
  "use strict";

  var WG_MADEUP = 1, WG_STRONG = 101;

  tern.registerPlugin("doc_comment", function(server, options) {
    server.mod.jsdocTypedefs = Object.create(null);
    server.on("reset", function() {
      server.mod.jsdocTypedefs = Object.create(null);
    });
    server.mod.docComment = {
      weight: options && options.strong ? WG_STRONG : undefined,
      fullDocs: options && options.fullDocs
    };

    server.on("postParse", postParse)
    server.on("postInfer", postInfer)
    server.on("postLoadDef", postLoadDef)
  });

  function postParse(ast, text) {
    function attachComments(node) { comment.ensureCommentsBefore(text, node); }

    walk.simple(ast, {
      VariableDeclaration: attachComments,
      FunctionDeclaration: attachComments,
      MethodDefinition: attachComments,
      Property: attachComments,
      AssignmentExpression: function(node) {
        if (node.operator == "=") attachComments(node);
      },
      CallExpression: function(node) {
        if (isDefinePropertyCall(node)) attachComments(node);
      }
    });
  }

  function isDefinePropertyCall(node) {
    return node.callee.type == "MemberExpression" &&
      node.callee.object.name == "Object" &&
      node.callee.property.name == "defineProperty" &&
      node.arguments.length >= 3 &&
      typeof node.arguments[1].value == "string";
  }

  function postInfer(ast, scope) {
    jsdocParseTypedefs(ast.sourceFile.text, scope);

    walk.simple(ast, {
      VariableDeclaration: function(node, scope) {
        var decl = node.declarations[0].id
        if (node.commentsBefore && decl.type == "Identifier")
          interpretComments(node, node.commentsBefore, scope,
                            scope.getProp(node.declarations[0].id.name));
      },
      FunctionDeclaration: function(node, scope) {
        if (node.commentsBefore)
          interpretComments(node, node.commentsBefore, scope,
                            scope.getProp(node.id.name),
                            node.scope.fnType);
      },
      ClassDeclaration: function(node, scope) {
        if (node.commentsBefore)
          interpretComments(node, node.commentsBefore, scope,
                            scope.getProp(node.id.name),
                            node.objType);
      },
      AssignmentExpression: function(node, scope) {
        if (node.commentsBefore)
          interpretComments(node, node.commentsBefore, scope,
                            infer.expressionType({node: node.left, state: scope}));
      },
      ObjectExpression: function(node, scope) {
        for (var i = 0; i < node.properties.length; ++i) {
          var prop = node.properties[i], name = infer.propName(prop)
          if (name != "<i>" && prop.commentsBefore)
            interpretComments(prop, prop.commentsBefore, scope, node.objType.getProp(name))
        }
      },
      Class: function(node, scope) {
        var proto = node.objType.getProp("prototype").getObjType()
        if (!proto) return
        for (var i = 0; i < node.body.body.length; i++) {
          var method = node.body.body[i], name
          if (!method.commentsBefore) continue
          if (method.kind == "constructor")
            interpretComments(method, method.commentsBefore, scope, node.objType)
          else if ((name = infer.propName(method)) != "<i>")
            interpretComments(method, method.commentsBefore, scope, proto.getProp(name))
        }
      },
      CallExpression: function(node, scope) {
        if (node.commentsBefore && isDefinePropertyCall(node)) {
          var type = infer.expressionType({node: node.arguments[0], state: scope}).getObjType();
          if (type && type instanceof infer.Obj) {
            var prop = type.props[node.arguments[1].value];
            if (prop) interpretComments(node, node.commentsBefore, scope, prop);
          }
        }
      }
    }, infer.searchVisitor, scope);
  }

  function postLoadDef(data) {
    var defs = data["!typedef"];
    var cx = infer.cx(), orig = data["!name"];
    if (defs) for (var name in defs)
      cx.parent.mod.jsdocTypedefs[name] =
        maybeInstance(infer.def.parse(defs[name], orig, name), name);
  }
  function stripLeadingChars(lines) {
    for (var head, i = 1; i < lines.length; i++) {
      var line = lines[i], lineHead = line.match(/^[\s\*]*/)[0];
      if (lineHead != line) {
        if (head == null) {
          head = lineHead;
        } else {
          var same = 0;
          while (same < head.length && head.charCodeAt(same) == lineHead.charCodeAt(same)) ++same;
          if (same < head.length) head = head.slice(0, same)
        }
      }
    }
    lines = lines.map(function(line, i) {
      line = line.replace(/\s+$/, "");
      if (i == 0 && head != null) {
        for (var j = 0; j < head.length; j++) {
          var found = line.indexOf(head.slice(j));
          if (found == 0) return line.slice(head.length - j);
        }
      }
      if (head == null || i == 0) return line.replace(/^[\s\*]*/, "");
      if (line.length < head.length) return "";
      return line.slice(head.length);
    });
    while (lines.length && !lines[lines.length - 1]) lines.pop();
    while (lines.length && !lines[0]) lines.shift();
    return lines;
  }

  function interpretComments(node, comments, scope, aval, type) {
    jsdocInterpretComments(node, scope, aval, comments);
    var cx = infer.cx();

    if (!type && aval instanceof infer.AVal && aval.types.length) {
      type = aval.types[aval.types.length - 1];
      if (!(type instanceof infer.Obj) || type.origin != cx.curOrigin || type.doc)
        type = null;
    }

    for (var i = comments.length - 1; i >= 0; i--) {
      var text = stripLeadingChars(comments[i].split(/\r\n?|\n/)).join("\n");
      if (text) {
        if (aval instanceof infer.AVal) aval.doc = text;
        if (type) type.doc = text;
        break;
      }
    }
  }
  function skipSpace(str, pos) {
    while (/\s/.test(str.charAt(pos))) ++pos;
    return pos;
  }

  function isIdentifier(string) {
    if (!acorn.isIdentifierStart(string.charCodeAt(0))) return false;
    for (var i = 1; i < string.length; i++)
      if (!acorn.isIdentifierChar(string.charCodeAt(i))) return false;
    return true;
  }

  function parseLabelList(scope, str, pos, close) {
    var labels = [], types = [], madeUp = false;
    for (var first = true; ; first = false) {
      pos = skipSpace(str, pos);
      if (first && str.charAt(pos) == close) break;
      var colon = str.indexOf(":", pos);
      if (colon < 0) return null;
      var label = str.slice(pos, colon);
      if (!isIdentifier(label)) return null;
      labels.push(label);
      pos = colon + 1;
      var type = parseType(scope, str, pos);
      if (!type) return null;
      pos = type.end;
      madeUp = madeUp || type.madeUp;
      types.push(type.type);
      pos = skipSpace(str, pos);
      var next = str.charAt(pos);
      ++pos;
      if (next == close) break;
      if (next != ",") return null;
    }
    return {labels: labels, types: types, end: pos, madeUp: madeUp};
  }

  function parseTypeAtom(scope, str, pos) {
    var result = parseTypeInner(scope, str, pos)
    if (!result) return null
    if (str.slice(result.end, result.end + 2) == "[]")
      return {madeUp: result.madeUp, end: result.end + 2, type: new infer.Arr(result.type)}
    else return result
  }

  function parseType(scope, str, pos) {
    var type, union = false, madeUp = false;
    for (;;) {
      var inner = parseTypeAtom(scope, str, pos);
      if (!inner) return null;
      madeUp = madeUp || inner.madeUp;
      if (union) inner.type.propagate(union);
      else type = inner.type;
      pos = skipSpace(str, inner.end);
      if (str.charAt(pos) != "|") break;
      pos++;
      if (!union) {
        union = new infer.AVal;
        type.propagate(union);
        type = union;
      }
    }
    var isOptional = false;
    if (str.charAt(pos) == "=") {
      ++pos;
      isOptional = true;
    }
    return {type: type, end: pos, isOptional: isOptional, madeUp: madeUp};
  }

  function parseTypeInner(scope, str, pos) {
    pos = skipSpace(str, pos);
    var type, madeUp = false;

    if (str.indexOf("function(", pos) == pos) {
      var args = parseLabelList(scope, str, pos + 9, ")"), ret = infer.ANull;
      if (!args) return null;
      pos = skipSpace(str, args.end);
      if (str.charAt(pos) == ":") {
        ++pos;
        var retType = parseType(scope, str, pos + 1);
        if (!retType) return null;
        pos = retType.end;
        ret = retType.type;
        madeUp = retType.madeUp;
      }
      type = new infer.Fn(null, infer.ANull, args.types, args.labels, ret);
    } else if (str.charAt(pos) == "[") {
      var inner = parseType(scope, str, pos + 1);
      if (!inner) return null;
      pos = skipSpace(str, inner.end);
      madeUp = inner.madeUp;
      if (str.charAt(pos) != "]") return null;
      ++pos;
      type = new infer.Arr(inner.type);
    } else if (str.charAt(pos) == "{") {
      var fields = parseLabelList(scope, str, pos + 1, "}");
      if (!fields) return null;
      type = new infer.Obj(true);
      for (var i = 0; i < fields.types.length; ++i) {
        var field = type.defProp(fields.labels[i]);
        field.initializer = true;
        fields.types[i].propagate(field);
      }
      pos = fields.end;
      madeUp = fields.madeUp;
    } else if (str.charAt(pos) == "(") {
      var inner = parseType(scope, str, pos + 1);
      if (!inner) return null;
      pos = skipSpace(str, inner.end);
      if (str.charAt(pos) != ")") return null;
      ++pos;
      type = inner.type;
    } else {
      var start = pos;
      if (!acorn.isIdentifierStart(str.charCodeAt(pos))) return null;
      while (acorn.isIdentifierChar(str.charCodeAt(pos))) ++pos;
      if (start == pos) return null;
      var word = str.slice(start, pos);
      if (/^(number|integer)$/i.test(word)) type = infer.cx().num;
      else if (/^bool(ean)?$/i.test(word)) type = infer.cx().bool;
      else if (/^string$/i.test(word)) type = infer.cx().str;
      else if (/^(null|undefined)$/i.test(word)) type = infer.ANull;
      else if (/^array$/i.test(word)) {
        var inner = null;
        if (str.charAt(pos) == "." && str.charAt(pos + 1) == "<") {
          var inAngles = parseType(scope, str, pos + 2);
          if (!inAngles) return null;
          pos = skipSpace(str, inAngles.end);
          madeUp = inAngles.madeUp;
          if (str.charAt(pos++) != ">") return null;
          inner = inAngles.type;
        }
        type = new infer.Arr(inner);
      } else if (/^object$/i.test(word)) {
        type = new infer.Obj(true);
        if (str.charAt(pos) == "." && str.charAt(pos + 1) == "<") {
          var key = parseType(scope, str, pos + 2);
          if (!key) return null;
          pos = skipSpace(str, key.end);
          madeUp = madeUp || key.madeUp;
          if (str.charAt(pos++) != ",") return null;
          var val = parseType(scope, str, pos);
          if (!val) return null;
          pos = skipSpace(str, val.end);
          madeUp = key.madeUp || val.madeUp;
          if (str.charAt(pos++) != ">") return null;
          val.type.propagate(type.defProp("<i>"));
        }
      } else {
        while (str.charCodeAt(pos) == 46 ||
               acorn.isIdentifierChar(str.charCodeAt(pos))) ++pos;
        var path = str.slice(start, pos);
        var cx = infer.cx(), defs = cx.parent && cx.parent.mod.jsdocTypedefs, found;
        if (defs && (path in defs)) {
          type = defs[path];
        } else if (found = infer.def.parsePath(path, scope).getObjType()) {
          type = maybeInstance(found, path);
        } else {
          if (!cx.jsdocPlaceholders) cx.jsdocPlaceholders = Object.create(null);
          if (!(path in cx.jsdocPlaceholders))
            type = cx.jsdocPlaceholders[path] = new infer.Obj(null, path);
          else
            type = cx.jsdocPlaceholders[path];
          madeUp = true;
        }
      }
    }

    return {type: type, end: pos, madeUp: madeUp};
  }

  function maybeInstance(type, path) {
    if (type instanceof infer.Fn && /(?:^|\.)[A-Z][^\.]*$/.test(path)) {
      var proto = type.getProp("prototype").getObjType();
      if (proto instanceof infer.Obj) return infer.getInstance(proto);
    }
    return type;
  }

  function parseTypeOuter(scope, str, pos) {
    pos = skipSpace(str, pos || 0);
    if (str.charAt(pos) != "{") return null;
    var result = parseType(scope, str, pos + 1);
    if (!result) return null;
    var end = skipSpace(str, result.end);
    if (str.charAt(end) != "}") return null;
    result.end = end + 1;
    return result;
  }

  function jsdocInterpretComments(node, scope, aval, comments) {
    var type, args, ret, foundOne, self, parsed;

    for (var i = 0; i < comments.length; ++i) {
      var comment = comments[i];
      var decl = /(?:\n|$|\*)\s*@(type|param|arg(?:ument)?|returns?|this|class|constructor)\s+(.*)/g, m;
      while (m = decl.exec(comment)) {
        if (m[1] == "class" || m[1] == "constructor") {
          self = foundOne = true;
          continue;
        }

        if (m[1] == "this" && (parsed = parseType(scope, m[2], 0))) {
          self = parsed;
          foundOne = true;
          continue;
        }

        if (!(parsed = parseTypeOuter(scope, m[2]))) continue;
        foundOne = true;

        switch(m[1]) {
        case "returns": case "return":
          ret = parsed; break;
        case "type":
          type = parsed; break;
        case "param": case "arg": case "argument":
            var name = m[2].slice(parsed.end).match(/^\s*(\[?)\s*([^\]\s=]+)\s*(?:=[^\]]+\s*)?(\]?).*/);
            if (!name) continue;
            var argname = name[2] + (parsed.isOptional || (name[1] === '[' && name[3] === ']') ? "?" : "");
          (args || (args = Object.create(null)))[argname] = parsed;
          break;
        }
      }
    }

    if (foundOne) applyType(type, self, args, ret, node, aval);
  };

  function jsdocParseTypedefs(text, scope) {
    var cx = infer.cx();

    var re = /\s@typedef\s+(.*)/g, m;
    while (m = re.exec(text)) {
      var parsed = parseTypeOuter(scope, m[1]);
      var name = parsed && m[1].slice(parsed.end).match(/^\s*(\S+)/);
      if (name && parsed.type instanceof infer.Obj) {
        var rest = text.slice(m.index + m[0].length)
        while (m = /\s+@prop(?:erty)?\s+(.*)/.exec(rest)) {
          var propType = parseTypeOuter(scope, m[1]), propName
          if (propType && (propName = m[1].slice(propType.end).match(/^\s*(\S+)/)))
            propType.type.propagate(parsed.type.defProp(propName[1]))
          rest = rest.slice(m[0].length)
        }
        cx.parent.mod.jsdocTypedefs[name[1]] = parsed.type;
      }
    }
  }

  function propagateWithWeight(type, target) {
    var weight = infer.cx().parent.mod.docComment.weight;
    type.type.propagate(target, weight || (type.madeUp ? WG_MADEUP : undefined));
  }

  function isFunExpr(node) { return node.type == "FunctionExpression" || node.type == "ArrowFunctionExpression" }

  function applyType(type, self, args, ret, node, aval) {
    var fn;
    if (node.type == "VariableDeclaration") {
      var decl = node.declarations[0];
      if (decl.init && isFunExpr(decl.init)) fn = decl.init.scope.fnType;
    } else if (node.type == "FunctionDeclaration") {
      fn = node.scope.fnType;
    } else if (node.type == "AssignmentExpression") {
      if (isFunExpr(node.right))
        fn = node.right.scope.fnType;
    } else if (node.type == "CallExpression") {
    } else { // An object property
      if (isFunExpr(node.value)) fn = node.value.scope.fnType;
      else if (fn = aval.types && aval.types[0] && aval.types[0].args)
        fn = aval.types[0];
    }

    if (fn && (args || ret || self)) {
      if (args) for (var i = 0; i < fn.argNames.length; ++i) {
        var name = fn.argNames[i], known = args[name];
        if (!known && (known = args[name + "?"]))
          fn.argNames[i] += "?";
        if (known) propagateWithWeight(known, fn.args[i]);
      }
      if (ret) {
        if (fn.retval == infer.ANull) fn.retval = new infer.AVal;
        propagateWithWeight(ret, fn.retval);
      }
      if (self === true) {
        var proto = fn.getProp("prototype").getObjType();
        self = proto && {type: infer.getInstance(proto, fn)};
      }
      if (self) propagateWithWeight(self, fn.self);
    } else if (type) {
      propagateWithWeight(type, aval);
    }
  };
});

});

define("tern/plugin/modules",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(require("../lib/infer"), require("../lib/tern"), require("../lib/signal"), require)
  if (typeof define == "function" && define.amd) // AMD
    return define(["../lib/infer", "../lib/tern", "../lib/signal"], mod)
  mod(tern, tern, tern.signal)
})(function(infer, tern, signal, require) {
  "use strict"

  function Modules(server, options) {
    this.server = server
    this.options = options || {}
    this.modules = Object.create(null)
    this.nonRelative = Object.create(null)
    this.knownModules = Object.create(null)
    this.resolvers = []
    this.modNameTests = []
    this.importTests = []
  }

  Modules.prototype = signal.mixin({
    buildWrappingScope: function(parent, origin, node) {
      var scope = new infer.Scope(parent, node)
      scope.origin = origin
      this.signal("wrapScope", scope)
      return scope
    },

    maybeOverride: function(name) {
      if (!this.options.modules || !this.options.modules.hasOwnProperty(name))
        return false
      if (this.modules[name]) return this.modules[name]

      var override = this.options.modules[name]
      if (typeof(override) == "string" && override.charAt(0) == "=")
        return infer.def.parsePath(override.slice(1))

      var scope = this.buildWrappingScope(infer.cx().topScope, name)
      infer.def.load(override, scope)
      return this.modules[name] = scope.exports
    },

    resolveModule: function(name, parentFile) {
      var over = this.maybeOverride(name)
      if (over) return over
      var known = this.knownModules[name]
      if (known) return known
      if (this.options.dontLoad == true ||
          this.options.dontLoad && new RegExp(this.options.dontLoad).test(name) ||
          this.options.load && !new RegExp(this.options.load).test(name))
        return infer.ANull

      var resolved, relative = isRelative(name)
      for (var i = 0; !resolved && i < this.resolvers.length; i++)
        resolved = this.resolvers[i](name, parentFile)
      if (!resolved) resolved = defaultResolver(name, parentFile)
      if (!resolved) return infer.ANull
      if (typeof resolved != "string") {
        if (!relative) this.nonRelative[name] = true
        return resolved
      }

      var known = this.modules[resolved]
      if (known) return known

      if (/\.js$|(?:^\/)[^\.]+$/.test(resolved))
        this.server.addFile(resolved, null, parentFile)
      if (!relative) this.nonRelative[name] = resolved
      return this.modules[resolved] = new infer.AVal
    },

    findIn: function(array, node) {
      for (var i = 0; i < array.length; i++) {
        var name = array[i](node)
        if (name != null) return name
      }
    },

    isModName: function(node) { return this.findIn(this.modNameTests, node) },
    isImport: function(node) { return this.findIn(this.importTests, node) },

    get: function(name) {
      return this.modules[name] || (this.modules[name] = new infer.AVal)
    },

    completeModuleName: function(completions, query, word) {
      function fromObj(obj, useVal) {
        for (var name in obj)
          if (filter(word, name, query))
            tern.addCompletion(query, completions, name, useVal && obj[name])
      }

      fromObj(this.knownModules, true)
      if (this.options.modules) fromObj(this.options.modules, false)

      var pathsSeen = Object.create(null)
      for (var prop in this.nonRelative) {
        var val = this.nonRelative[prop]
        if (val == true || prop.indexOf("/") == -1) {
          if (filter(word, prop, query)) tern.addCompletion(query, completions, prop)
        } else if (prop.indexOf(word) == 0 && word.indexOf("/") > -1) {
          var afterSlash = /.*?\/(.*)/.exec(prop)[1]
          var found = val.indexOf(afterSlash)
          if (found > -1) {
            var dir = val.slice(0, found) + (/.*?\/(.*\/)?/.exec(word)[1] || "")
            if (dir in pathsSeen) continue
            pathsSeen[dir] = true
            this.completeFileName(completions, query, null, word, dir)
          }
        }
      }
    },

    completeFileName: function(completions, query, parentFile, word, _dir) {
      var path = parentFile ? resolvePath(dirName(parentFile), word) : baseName(word)
      for (var prop in this.modules) {
        if (prop != parentFile && filter(path, prop, query)) {
          if (/\.js$/.test(prop)) prop = prop.slice(0, prop.length - 3)
          var added = prop.slice(path.length)
          tern.addCompletion(query, completions, word + added, this.modules[prop])
        }
      }
    },

    getModType: function(node) {
      var modName = this.isModName(node), imp, prop
      if (modName == null && (imp = this.isImport(node))) {
        modName = imp.name
        prop = imp.prop
      }
      if (modName == null) return

      var modType = this.resolveModule(modName, node.sourceFile.name)
      return (prop ? modType.getProp(prop) : modType).getType()
    }
  })

  function resolvePath(parent, sub) {
    if (/^https?:|^\//.test(sub)) return sub
    if (parent && !/\/$/.test(parent)) parent = parent + "/"
    var m
    while (m = /^\.(\.)?\//.exec(sub)) {
      if (m[1] && parent.length > 1) {
        var lastSlash = parent.lastIndexOf("/", parent.length - 2)
        parent = lastSlash == -1 ? "" : parent.slice(0, lastSlash + 1)
      }
      sub = sub.slice(m[0].length)
    }
    return parent + sub
  }

  function dirName(path) {
    var lastSlash = path.lastIndexOf("/")
    if (lastSlash == -1) return ""
    return path.slice(0, lastSlash + 1)
  }
  function baseName(path) {
    var lastSlash = path.lastIndexOf("/")
    if (lastSlash == -1) return path
    else return path.slice(lastSlash + 1)
  }

  function defaultResolver(name, parentFile) {
    if (!/^\.\.?\//.test(name)) return
    var path = resolvePath(dirName(parentFile), name)
    var server = infer.cx().parent
    if (server.findFile(path)) return path
    if (server.findFile(path + ".js")) return path + ".js"
  }
  if (require) (function() {
    var fs = require("fs"), path = require("path")

    Modules.prototype.completeFileName = function(completions, query, parentFile, word, dir) {
      var pDir = this.server.projectDir
      var endSlash = /\/$/.test(word)
      if (parentFile) {
        var pt = path.resolve(pDir, path.dirname(parentFile), word)
        dir = endSlash ? pt : path.dirname(pt)
      }
      var base = endSlash ? word : path.dirname(word) + "/"
      var filePart = endSlash ? "" : path.basename(word)

      var me = this
      fs.readdirSync(dir).forEach(function(file) {
        if (/^\./.test(file)) return
        if (filter(filePart, file, query)) {
          var projectPath = me.server.normalizeFilename(path.relative(pDir, path.resolve(dir, file)))
          if (projectPath == parentFile) return
          var value = me.modules[projectPath]
          if (/\.js$/.test(file)) file = file.slice(0, file.length - 3)
          tern.addCompletion(query, completions, base + file, value)
        }
      })
    }
  }())

  function isRelative(path) {
    return /^\.\.?\//.test(path)
  }

  function filter(word, string, query) {
    return query.filter === false || !word ||
      (query.caseInsensitive ? string.toLowerCase() : string).indexOf(word) == 0
  }

  function preCondenseReach(state) {
    var mods = infer.cx().parent.mod.modules.modules
    var node = state.roots["!modules"] = new infer.Obj(null)
    for (var name in mods) {
      var mod = mods[name]
      var id = mod.origin || name
      var prop = node.defProp(id.replace(/\./g, "`"))
      prop.origin = mod.origin
      mod.propagate(prop)
    }
  }

  function postLoadDef(data) {
    var cx = infer.cx(), me = cx.parent.mod.modules
    var mods = cx.definitions[data["!name"]]["!modules"]
    if (mods) for (var name in mods.props) {
      var origin = name.replace(/`/g, ".")
      var mod = me.get(origin)
      mod.origin = origin
      mods.props[name].propagate(mod)
    }
    var known = cx.definitions[data["!name"]]["!known_modules"]
    if (known) for (var name in known.props)
      me.knownModules[name.replace(/`/g, ".")] = known.props[name]
  }

  function findTypeAt(_file, _pos, expr, type) {
    if (!expr) return type
    var me = infer.cx().parent.mod.modules
    var modType = me.getModType(expr.node)
    if (!modType) return type
    type = Object.create(type)
    type.origin = modType.origin
    type.originNode = modType.originNode
    if (modType.doc) type.doc = modType.doc
    if (modType.url) type.url = modType.url
    return type
  }
  function findCompletions(file, query) {
    var wordEnd = tern.resolvePos(file, query.end)
    var expr = infer.findExpressionAround(file.ast, null, wordEnd, file.scope)
    if (!expr) return null
    var me = infer.cx().parent.mod.modules

    if (me.isModName(expr.node) != null)
      return findModuleCompletions(me, file, query, expr.node, wordEnd)

    var imp = me.isImport(expr.node)
    if (imp && imp.name && imp.prop != null)
      return findImportCompletions(me, file, query, expr.node, imp, wordEnd)
  }

  function findImportCompletions(me, file, query, node, imp, wordEnd) {
    var completions = []
    var word = node.name.slice(0, wordEnd - node.start)
    if (query.caseInsensitive) word = word.toLowerCase()

    var modType = me.resolveModule(imp.name, node.sourceFile.name).getType()
    if (!modType) return null
    infer.forAllPropertiesOf(modType, function(prop, obj, depth) {
      if (obj == infer.cx().protos.Object) return
      if (query.filter !== false && word &&
          (query.caseInsensitive ? prop.toLowerCase() : prop).indexOf(word) !== 0) return
      tern.addCompletion(query, completions, prop, obj && obj.props[prop], depth)
    })
    return {
      start: tern.outputPos(query, file, node.start),
      end: tern.outputPos(query, file, wordEnd),
      completions: completions,
      isSpecifier: true
    }
  }

  function findModuleCompletions(me, file, query, argNode, wordEnd) {
    if (argNode.type != "Literal" || typeof argNode.value != "string" ||
        argNode.start > wordEnd || argNode.end < wordEnd) return

    var word = argNode.raw.slice(1, wordEnd - argNode.start), quote = argNode.raw.charAt(0)
    if (word && word.charAt(word.length - 1) == quote)
      word = word.slice(0, word.length - 1)
    if (query.caseInsensitive) word = word.toLowerCase()

    var completions = []
    if (isRelative(word)) me.completeFileName(completions, query, file.name, word)
    else me.completeModuleName(completions, query, word)

    if (argNode.end == wordEnd + 1 && file.text.charAt(wordEnd) == quote)
      ++wordEnd
    return {
      start: tern.outputPos(query, file, argNode.start),
      end: tern.outputPos(query, file, wordEnd),
      isProperty: false,
      completions: completions.map(function(rec) {
        var name = typeof rec == "string" ? rec : rec.name
        var string = JSON.stringify(name)
        if (quote == "'") string = quote + string.slice(1, string.length -1).replace(/'/g, "\\'") + quote
        if (typeof rec == "string") return string
        rec.displayName = name
        rec.name = string
        return rec
      })
    }
  }

  tern.registerPlugin("modules", function(server, options) {
    server.mod.modules = new Modules(server, options)

    server.on("beforeLoad", function(file) {
      file.scope = this.mod.modules.buildWrappingScope(file.scope, file.name, file.ast)
    })

    server.on("afterLoad", function(file) {
      var mod = this.mod.modules.get(file.name)
      mod.origin = file.name
      this.mod.modules.signal("getExports", file, mod)
    })

    server.on("reset", function() {
      this.mod.modules.modules = Object.create(null)
    })

    server.on("preCondenseReach", preCondenseReach)
    server.on("postLoadDef", postLoadDef)
    server.on("typeAt", findTypeAt)
    server.on("completion", findCompletions)
  })

  tern.defineQueryType("exports", {
    takesFile: true,
    run: function(server, query, file) {
      function describe(aval) {
        var target = {}, type = aval.getType(false)
        target.type = infer.toString(type, 3)
        var doc = aval.doc || (type && type.doc), url = aval.url || (type && type.url)
        if (doc) target.doc = doc
        if (url) target.url = url
        var span = tern.getSpan(aval) || (type && tern.getSpan(type))
        if (span) tern.storeSpan(server, query, span, target)
        return target
      }

      var mod = server.mod.modules, known = mod && mod.modules[file.name]
      if (!known) return {}
      var resp = describe(known);
      var type = known.getType(false)
      if (type instanceof infer.Obj) {
        var props = resp.props = {}
        for (var prop in type.props)
          props[prop] = describe(type.props[prop])
      }
      return resp
    }
  })
})

});

define("tern/plugin/es_modules",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(require("../lib/infer"), require("../lib/tern"), require("acorn/dist/walk"), require("./modules"))
  if (typeof define == "function" && define.amd) // AMD
    return define(["../lib/infer", "../lib/tern", "acorn/dist/walk", "./modules"], mod)
  mod(tern, tern, acorn.walk)
})(function(infer, tern, walk) {
  "use strict"

  var WG_IMPORT_DEFAULT_FALLBACK = 80

  function connectModule(file, out) {
    var modules = infer.cx().parent.mod.modules
    var outObj = null
    function exp(prop, type, originNode) {
      if (!outObj) {
        outObj = new infer.Obj(true)
        outObj.origin = file.name
        outObj.originNode = file.ast
        out.addType(outObj)
      }
      type.propagate(outObj.defProp(prop, originNode))
    }

    walk.simple(file.ast, {
      ImportDeclaration: function(node) {
        var input = modules.resolveModule(node.source.value, file.name)
        for (var i = 0; i < node.specifiers.length; i++) {
          var spec = node.specifiers[i]
          var aval = file.scope.getProp(spec.local.name)
          if (spec.type == "ImportNamespaceSpecifier") {
            input.propagate(aval)
          } else if (spec.type == "ImportDefaultSpecifier") {
            input.getProp("default").propagate(aval)
            input.propagate(aval, WG_IMPORT_DEFAULT_FALLBACK)
          } else {
            input.getProp(spec.imported.name).propagate(aval)
          }
        }
      },
      ExportAllDeclaration: function(node) {
        var input = modules.resolveModule(node.source.value, file.name)
        input.forAllProps(function(prop, val, local) {
          if (local) exp(prop, val, val.originNode)
        })
      },
      ExportDefaultDeclaration: function(node) {
        var decl = node.declaration.id || node.declaration
        exp("default", infer.expressionType({node: decl, state: file.scope}), decl)
      },
      ExportNamedDeclaration: function(node) {
        var decl = node.declaration
        if (decl) {
          if (decl.type == "VariableDeclaration") {
            for (var i = 0; i < decl.declarations.length; ++i) {
              var cur = decl.declarations[i]
              if (cur.id.type == "Identifier")
                exp(cur.id.name, file.scope.getProp(cur.id.name), cur.id)
            }
          } else {
            exp(decl.id.name, file.scope.getProp(decl.id.name), decl.id)
          }
        }
        if (node.specifiers.length) {
          var src = node.source ? modules.resolveModule(node.source.value, file.name) : file.scope
          for (var i = 0; i < node.specifiers.length; i++) {
            var spec = node.specifiers[i]
            exp(spec.exported.name, src.getProp(spec.local.name), spec.local)
          }
        }
      }
    })
  }

  function isModuleName(node) {
    if (node.type != "Literal" || typeof node.value != "string") return

    var decl = infer.findExpressionAround(node.sourceFile.ast, null, node.end, null, function(_, node) {
      return node.type == "ImportDeclaration" || /Export(All|Named)Declaration/.test(node.type)
    })
    if (!decl || decl.node.source != node) return
    return node.value
  }

  function isImport(node) {
    if (node.type != "Identifier") return
    var imp = infer.findExpressionAround(node.sourceFile.ast, null, node.end, null, "ImportDeclaration")
    if (!imp) return
    var specs = imp.node.specifiers
    for (var i = 0; i < specs.length; i++) {
      var spec = specs[i]
      if (spec.local != node) continue
      var result = {name: imp.node.source.value, prop: null}
      if (spec.type == "ImportDefaultSpecifier") result.prop = "default"
      else if (spec.type == "ImportSpecifier") result.prop = spec.imported.name
      return result
    }
  }

  tern.registerPlugin("es_modules", function(server) {
    server.loadPlugin("modules")
    server.mod.modules.on("getExports", connectModule)
    server.mod.modules.modNameTests.push(isModuleName)
    server.mod.modules.importTests.push(isImport)
  })
})

});

define("tern/plugin/commonjs",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(require("../lib/infer"), require("../lib/tern"), require("./modules"))
  if (typeof define == "function" && define.amd) // AMD
    return define(["../lib/infer", "../lib/tern", "./modules"], mod)
  mod(tern, tern)
})(function(infer, tern) {
  "use strict"

  var WG_DEFAULT_EXPORT = 95

  function initScope(scope) {
    var defs = infer.cx().definitions.commonjs
    defs.require.propagate(scope.defProp("require"))
    var module = new infer.Obj(defs.Module.getProp("prototype").getType())
    module.propagate(scope.defProp("module"))
    var exports = new infer.Obj(true)
    module.origin = exports.origin = scope.origin
    module.originNode = exports.originNode = scope.originNode
    exports.propagate(scope.defProp("exports"))
    var moduleExports = scope.exports = module.defProp("exports")
    exports.propagate(moduleExports, WG_DEFAULT_EXPORT)
  }

  infer.registerFunction("require", function(_self, _args, argNodes) {
    if (!argNodes || !argNodes.length || argNodes[0].type != "Literal" || typeof argNodes[0].value != "string")
      return infer.ANull
    var cx = infer.cx(), server = cx.parent
    var currentFile = argNodes[0].sourceFile.name

    var name = argNodes[0].value
    var resolved = server.mod.modules.resolveModule(name, currentFile)
    return resolved
  })

  function isStaticRequire(node) {
    if (node.type != "CallExpression" || node.callee.type != "Identifier" || node.callee.name != "require") return
    var arg = node.arguments[0]
    if (arg && arg.type == "Literal" && typeof arg.value == "string") return arg.value
  }

  function isModuleName(node) {
    if (node.type != "Literal" || typeof node.value != "string") return

    var call = infer.findExpressionAround(node.sourceFile.ast, null, node.end, null,
                                          function(_, n) { return isStaticRequire(n) != null })
    if (call && call.node.arguments[0] == node) return node.value
  }

  function isImport(node) {
    if (node.type != "Identifier") return
    var decl = infer.findExpressionAround(node.sourceFile.ast, null, node.end, null, "VariableDeclarator"), name
    if (!decl || decl.node.id != node) return
    var init = decl.node.init
    if (init && (name = isStaticRequire(init)) != null)
      return {name: name, prop: null}
    if (init && init.type == "MemberExpression" && !init.computed && (name = isStaticRequire(init.object)) != null)
      return {name: name, prop: init.property.name}
  }

  function hasProps(obj) {
    if (obj) for (var _prop in obj) return true
  }

  tern.registerPlugin("commonjs", function(server) {
    server.loadPlugin("modules")
    server.mod.modules.on("wrapScope", initScope)
    server.mod.modules.on("getExports", function(file, mod) {
      var exports = file.scope.exports
      if (exports.types.length > 1 || hasProps(exports.getObjType()))
        exports.propagate(mod)
    })

    server.mod.modules.modNameTests.push(isModuleName)
    server.mod.modules.importTests.push(isImport)

    server.addDefs(defs)
  })

  var defs = {
    "!name": "commonjs",
    "!define": {
      require: {
        "!type": "fn(id: string) -> !custom:require",
        resolve: {
          "!type": "fn() -> string",
          "!url": "https://nodejs.org/api/globals.html#globals_require_resolve",
          "!doc": "Use the internal require() machinery to look up the location of a module, but rather than loading the module, just return the resolved filename."
        },
        cache: {
          "!url": "https://nodejs.org/api/globals.html#globals_require_cache",
          "!doc": "Modules are cached in this object when they are required. By deleting a key value from this object, the next require will reload the module."
        },
        extensions: {
          "!url": "https://nodejs.org/api/globals.html#globals_require_extensions",
          "!doc": "Instruct require on how to handle certain file extensions."
        },
        "!url": "https://nodejs.org/api/globals.html#globals_require",
        "!doc": "To require modules."
      },
      Module: {
        "!type": "fn()",
        "!url": "https://nodejs.org/api/modules.html",
        "!doc": "Node has a simple module loading system. In Node, files and modules are in one-to-one correspondence.",
        prototype: {
          exports: {
            "!type": "?",
            "!url": "https://nodejs.org/api/modules.html#modules_module_exports",
            "!doc": "The exports object is created by the Module system. Sometimes this is not acceptable, many want their module to be an instance of some class. To do this assign the desired export object to module.exports. For example suppose we were making a module called a.js"
          },
          require: {
            "!type": "require",
            "!url": "https://nodejs.org/api/modules.html#modules_module_require_id",
            "!doc": "The module.require method provides a way to load a module as if require() was called from the original module."
          },
          id: {
            "!type": "string",
            "!url": "https://nodejs.org/api/modules.html#modules_module_id",
            "!doc": "The identifier for the module. Typically this is the fully resolved filename."
          },
          filename: {
            "!type": "string",
            "!url": "https://nodejs.org/api/modules.html#modules_module_filename",
            "!doc": "The fully resolved filename to the module."
          },
          loaded: {
            "!type": "bool",
            "!url": "https://nodejs.org/api/modules.html#modules_module_loaded",
            "!doc": "Whether or not the module is done loading, or is in the process of loading."
          },
          parent: {
            "!type": "+Module",
            "!url": "https://nodejs.org/api/modules.html#modules_module_parent",
            "!doc": "The module that required this one."
          },
          children: {
            "!type": "[+Module]",
            "!url": "https://nodejs.org/api/modules.html#modules_module_children",
            "!doc": "The module objects required by this one."
          }
        }
      },
      module: {}
    },
    module: {
      "!type": "+Module",
      "!url": "https://nodejs.org/api/globals.html#globals_module",
      "!doc": "A reference to the current module. In particular module.exports is the same as the exports object. module isn't actually a global but rather local to each module."
    }
  }
})

});

define("tern/plugin/node_resolve",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(require("../lib/infer"), require("../lib/tern"), require("./commonjs"), require)
  if (typeof define == "function" && define.amd) // AMD
    return define(["../lib/infer", "../lib/tern", "./commonjs"], mod)
  mod(tern, tern)
})(function(infer, tern, _, require) {
  "use strict"

  function resolve(name, parentFile) {
    var resolved = resolveToFile(name, parentFile)
    return resolved && infer.cx().parent.normalizeFilename(resolved)
  }

  function findDeclaredDeps() {}

  var resolveToFile
  if (require) (function() {
    var module_ = require("module"), path = require("path"), fs = require("fs")

    resolveToFile = function(name, parentFile) {
      var projectDir = infer.cx().parent.projectDir
      var fullParent = path.resolve(projectDir, parentFile)
      var parentDir = path.dirname(fullParent)
      if (/^\.\.?\//.test(name))
        name = path.resolve(projectDir, parentDir, name)

      var parentModule = {
        id: fullParent,
        paths: module_._nodeModulePaths(parentDir)
      }
      try {
        return module_._resolveFilename(name, parentModule)
      } catch(e) {
        return null
      }
    }

    function findPackageFile(dir) {
      for (;;) {
        try {
          return JSON.parse(fs.readFileSync(path.resolve(dir, "package.json")))
        } catch(e) {}
        var shorter = path.dirname(dir)
        if (shorter == dir) return null
        dir = shorter
      }
    }

    findDeclaredDeps = function(path, knownModules) {
      var packageFile = findPackageFile(path)
      if (!packageFile) return null

      function add(obj) {
        for (var name in obj) if (!(name in knownModules)) knownModules[name] = null
      }
      add(packageFile.dependencies)
      add(packageFile.devDependencies)
      add(packageFile.peerDependencies)
    }

  })(); else (function() {
    function resolvePath(base, path) {
      if (path[0] == "/") return path;
      var slash = base.lastIndexOf("/"), m;
      if (slash >= 0) path = base.slice(0, slash + 1) + path;
      while (m = /[^\/]*[^\/\.][^\/]*\/\.\.\//.exec(path))
        path = path.slice(0, m.index) + path.slice(m.index + m[0].length);
      return path.replace(/(^|[^\.])\.\//g, "$1");
    }

    resolveToFile = function(name, parentFile) {
      return /^\.\.?\//.test(name) ? resolvePath(parentFile, name) : name
    }
  })()

  tern.registerPlugin("node_resolve", function(server) {
    server.loadPlugin("commonjs")
    server.mod.modules.resolvers.push(resolve)
    findDeclaredDeps(server.projectDir, server.mod.modules.knownModules)
  })
})

});

define("events",[], function(require, exports, module) {

var EventEmitter = module.exports = function() {};
EventEmitter.EventEmitter = EventEmitter;

var toString = Object.prototype.toString;

var isArray = Array.isArray || function(obj) {
    return toString.call(obj) === '[object Array]';
};
//
var defaultMaxListeners = 10;
EventEmitter.prototype.setMaxListeners = function(n) {
    if (!this._events) this._events = {};
    this._events.maxListeners = n;
};
EventEmitter.prototype.emit = function(type) {
    if (!this._events) 
        return;

    var handler = this._events[type];
    if (!handler) 
        return;
    
    var returnValue;

    if (typeof handler == 'function') {
        switch (arguments.length) {
        case 1:
            return handler.call(this);
        case 2:
            return handler.call(this, arguments[1]);
        case 3:
            return handler.call(this, arguments[1], arguments[2]);
        default:
            var args = Array.prototype.slice.call(arguments, 1);
            returnValue = handler.apply(this, args);
        }
    }
    else if (isArray(handler)) {
        var args = Array.prototype.slice.call(arguments, 1);

        var listeners = handler.slice(), temp;
        for (var i = 0, l = listeners.length; i < l; i++) {
            temp = listeners[i].apply(this, args);
            if (temp !== undefined) 
                returnValue = temp;
        }
    }
    
    return returnValue;
};
EventEmitter.prototype.addListener = function(type, listener, plugin) {
    if ('function' !== typeof listener) {
        throw new Error('addListener only takes instances of Function');
    }

    if (!this._events) this._events = {};

    var eventList = this._events[type];

    if (!eventList) {
        this._events[type] = listener;
    }
    else if (isArray(eventList)) {
        if (!eventList.warned) {
            var m;
            if (this._events.maxListeners !== undefined) {
                m = this._events.maxListeners;
            }
            else {
                m = defaultMaxListeners;
            }

            if (m && m > 0 && eventList.length > m) {
                eventList.warned = true;
                console.error('warning: possible EventEmitter memory '
                    + 'leak detected. " + eventList.length + " listeners of type "' + type + '" added. '
                    + 'Use emitter.setMaxListeners() to increase limit.'
                );
                console.trace();
            }
        }
        eventList.push(listener);
    }
    else {
        this._events[type] = [eventList, listener];
    }
    
    if (type != "newListener") 
        this.emit('newListener', type, listener);
    
    plugin && plugin.addEvent(this, type, listener);

    return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener, plugin) {
    var self = this;
    
    var wrapped = function() {
        self.removeListener(type, listener);
        return listener.apply(self, arguments);
    };
    wrapped.listener = listener;
    
    self.on(type, wrapped, plugin);

    return this;
};

EventEmitter.prototype.removeListener = function(type, listener) {
    if ('function' !== typeof listener) {
        throw new Error('removeListener only takes instances of Function');
    }
    if (!this._events || !this._events[type]) return this;

    var list = this._events[type];

    if (isArray(list)) {
        if (!list.some(function(l, i) {
            if ((l.listener || l) == listener) {
                list.splice(i, 1);
                return true;
            }
        })) return this;
        
        if (list.length === 0) 
            delete this._events[type];
    }
    else if ((this._events[type].listener || this._events[type]) === listener) {
        delete this._events[type];
    }
    
    if (type != "removeListener")
        this.emit('removeListener', type, listener);

    return this;
};

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners = function(type) {
    if (type && this._events && this._events[type]) this._events[type] = null;
    return this;
};

EventEmitter.prototype.listeners = function(type) {
    if (!this._events) this._events = {};
    if (!this._events[type]) this._events[type] = [];
    if (!isArray(this._events[type])) {
        this._events[type] = [this._events[type]];
    }
    return this._events[type];
};
 
});

define("tern/plugin/node",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(require("../lib/tern"), require("./node_resolve"));
  if (typeof define == "function" && define.amd) // AMD
    return define(["../lib/tern", "./node_resolve"], mod);
  mod(tern, tern);
})(function(tern) {
  "use strict"

  tern.registerPlugin("node", function(server) {
    server.loadPlugin("node_resolve")
    server.on("postReset", function() {
      var mods = server.mod.modules, locals = server.cx.definitions.node
      for (var name in locals) if (/^[a-z_]*$/.test(name))
        mods.knownModules[name] = locals[name]
    })
    server.addDefs(defs)
  })

  var defs = {
    "!name": "node",
    "!define": {
      events: {
        "!url": "https://nodejs.org/api/events.html",
        "!doc": "Many objects in Node emit events: a net.Server emits an event each time a peer connects to it, a fs.readStream emits an event when the file is opened. All objects which emit events are instances of events.EventEmitter.",
        EventEmitter: {
          prototype: {
            addListener: {
              "!type": "fn(event: string, listener: fn())",
              "!url": "https://nodejs.org/api/events.html#events_emitter_addlistener_event_listener",
              "!doc": "Adds a listener to the end of the listeners array for the specified event."
            },
            on: {
              "!type": "fn(event: string, listener: fn())",
              "!url": "https://nodejs.org/api/events.html#events_emitter_on_event_listener",
              "!doc": "Adds a listener to the end of the listeners array for the specified event."
            },
            once: {
              "!type": "fn(event: string, listener: fn())",
              "!url": "https://nodejs.org/api/events.html#events_emitter_once_event_listener",
              "!doc": "Adds a one time listener for the event. This listener is invoked only the next time the event is fired, after which it is removed."
            },
            removeListener: {
              "!type": "fn(event: string, listener: fn())",
              "!url": "https://nodejs.org/api/events.html#events_emitter_removelistener_event_listener",
              "!doc": "Remove a listener from the listener array for the specified event. Caution: changes array indices in the listener array behind the listener."
            },
            removeAllListeners: {
              "!type": "fn(event: string)",
              "!url": "https://nodejs.org/api/events.html#events_emitter_removealllisteners_event",
              "!doc": "Removes all listeners, or those of the specified event."
            },
            setMaxListeners: {
              "!type": "fn(n: number)",
              "!url": "https://nodejs.org/api/events.html#events_emitter_setmaxlisteners_n",
              "!doc": "By default EventEmitters will print a warning if more than 10 listeners are added for a particular event. This is a useful default which helps finding memory leaks. Obviously not all Emitters should be limited to 10. This function allows that to be increased. Set to zero for unlimited."
            },
            listeners: {
              "!type": "fn(event: string) -> [fn()]",
              "!url": "https://nodejs.org/api/events.html#events_emitter_listeners_event",
              "!doc": "Returns an array of listeners for the specified event."
            },
            emit: {
              "!type": "fn(event: string)",
              "!url": "https://nodejs.org/api/events.html#events_emitter_emit_event_arg1_arg2",
              "!doc": "Execute each of the listeners in order with the supplied arguments."
            }
          },
          "!url": "https://nodejs.org/api/events.html#events_class_events_eventemitter",
          "!doc": "To access the EventEmitter class, require('events').EventEmitter."
        }
      },
      stream: {
        "!type": "fn()",
        prototype: {
          "!proto": "events.EventEmitter.prototype",
          pipe: {
            "!type": "fn(destination: +stream.Writable, options?: ?)",
            "!url": "https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options",
            "!doc": "Connects this readable stream to destination WriteStream. Incoming data on this stream gets written to destination. Properly manages back-pressure so that a slow destination will not be overwhelmed by a fast readable stream."
          }
        },
        Writable: {
          "!type": "fn(options?: ?)",
          prototype: {
            "!proto": "stream.prototype",
            write: {
              "!type": "fn(chunk: string|+Buffer, encoding?: string, callback?: fn()) -> bool",
              "!url": "https://nodejs.org/api/stream.html#stream_writable_write_chunk_encoding_callback_1",
              "!doc": "Writes chunk to the stream. Returns true if the data has been flushed to the underlying resource. Returns false to indicate that the buffer is full, and the data will be sent out in the future. The 'drain' event will indicate when the buffer is empty again."
            },
            cork: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/stream.html#stream_writable_cork",
              "!doc": "Forces buffering of all writes. Buffered data will be flushed either at .uncork() or at .end() call."
            },
            uncork: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/stream.html#stream_writable_uncork",
              "!doc": "Flush all data, buffered since .cork() call."
            },
            setDefaultEncoding: {
              "!type": "fn(encoding: string) -> bool",
              "!url": "https://nodejs.org/api/stream.html#stream_writable_setdefaultencoding_encoding",
              "!doc": "Sets the default encoding for a writable stream. Returns true if the encoding is valid and is set. Otherwise returns false."
            },
            end: {
              "!type": "fn(chunk?: string|+Buffer, encoding?: string, callback?: fn()) -> bool",
              "!url": "https://nodejs.org/api/stream.html#stream_writable_end_chunk_encoding_callback",
              "!doc": "Call this method to signal the end of the data being written to the stream."
            }
          },
          "!url": "https://nodejs.org/api/stream.html#stream_class_stream_writable",
          "!doc": "A Writable Stream has the following methods, members, and events."
        },
        Readable: {
          "!type": "fn(options?: ?)",
          prototype: {
            "!proto": "stream.prototype",
            setEncoding: {
              "!type": "fn(encoding: string)",
              "!url": "https://nodejs.org/api/stream.html#stream_readable_setencoding_encoding",
              "!doc": "Makes the 'data' event emit a string instead of a Buffer. encoding can be 'utf8', 'utf16le' ('ucs2'), 'ascii', or 'hex'."
            },
            pause: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/stream.html#stream_readable_pause",
              "!doc": "Switches the readable stream into \"old mode\", where data is emitted using a 'data' event rather than being buffered for consumption via the read() method."
            },
            resume: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/stream.html#stream_readable_resume",
              "!doc": "Switches the readable stream into \"old mode\", where data is emitted using a 'data' event rather than being buffered for consumption via the read() method."
            },
            destroy: "fn()",
            unpipe: {
              "!type": "fn(dest?: +stream.Writable)",
              "!url": "https://nodejs.org/api/stream.html#stream_readable_unpipe_destination",
              "!doc": "Undo a previously established pipe(). If no destination is provided, then all previously established pipes are removed."
            },
            push: {
              "!type": "fn(chunk: +Buffer) -> bool",
              "!url": "https://nodejs.org/api/stream.html#stream_readable_push_chunk",
              "!doc": "Explicitly insert some data into the read queue. If called with null, will signal the end of the data."
            },
            unshift: {
              "!type": "fn(chunk: +Buffer) -> bool",
              "!url": "https://nodejs.org/api/stream.html#stream_readable_unshift_chunk",
              "!doc": "This is the corollary of readable.push(chunk). Rather than putting the data at the end of the read queue, it puts it at the front of the read queue."
            },
            wrap: {
              "!type": "fn(stream: ?) -> +stream.Readable",
              "!url": "https://nodejs.org/api/stream.html#stream_readable_wrap_stream",
              "!doc": "If you are using an older Node library that emits 'data' events and has a pause() method that is advisory only, then you can use the wrap() method to create a Readable stream that uses the old stream as its data source."
            },
            read: {
              "!type": "fn(size?: number) -> +Buffer",
              "!url": "https://nodejs.org/api/stream.html#stream_readable_read_size_1",
              "!doc": "Call this method to consume data once the 'readable' event is emitted."
            }
          },
          "!url": "https://nodejs.org/api/stream.html#stream_class_stream_readable",
          "!doc": "A Readable Stream has the following methods, members, and events."
        },
        Duplex: {
          "!type": "fn(options?: ?)",
          prototype: {
            "!proto": "stream.Readable.prototype",
            write: "fn(chunk: +Buffer, encoding?: string, callback?: fn()) -> bool",
            end: "fn(chunk: +Buffer, encoding?: string, callback?: fn()) -> bool"
          },
          "!url": "https://nodejs.org/api/stream.html#stream_class_stream_duplex",
          "!doc": "A \"duplex\" stream is one that is both Readable and Writable, such as a TCP socket connection."
        },
        Transform: {
          "!type": "fn(options?: ?)",
          prototype: {
            "!proto": "stream.Duplex.prototype"
          },
          "!url": "https://nodejs.org/api/stream.html#stream_class_stream_transform",
          "!doc": "A \"transform\" stream is a duplex stream where the output is causally connected in some way to the input, such as a zlib stream or a crypto stream."
        },
        PassThrough: "stream.Transform",
        "!url": "https://nodejs.org/api/stream.html#stream_stream",
        "!doc": "A stream is an abstract interface implemented by various objects in Node. For example a request to an HTTP server is a stream, as is stdout. Streams are readable, writable, or both. All streams are instances of EventEmitter"
      },
      querystring: {
        "!url": "https://nodejs.org/api/querystring.html",
        "!doc": "This module provides utilities for dealing with query strings.",
        stringify: {
          "!type": "fn(obj: ?, sep?: string, eq?: string) -> string",
          "!url": "https://nodejs.org/api/querystring.html#querystring_querystring_stringify_obj_sep_eq",
          "!doc": "Serialize an object to a query string. Optionally override the default separator ('&') and assignment ('=') characters."
        },
        parse: {
          "!type": "fn(str: string, sep?: string, eq?: string, options?: ?) -> ?",
          "!url": "https://nodejs.org/api/querystring.html#querystring_querystring_parse_str_sep_eq_options",
          "!doc": "Deserialize a query string to an object. Optionally override the default separator ('&') and assignment ('=') characters."
        },
        escape: {
          "!type": "fn(string) -> string",
          "!url": "https://nodejs.org/api/querystring.html#querystring_querystring_escape",
          "!doc": "The escape function used by querystring.stringify, provided so that it could be overridden if necessary."
        },
        unescape: {
          "!type": "fn(string) -> string",
          "!url": "https://nodejs.org/api/querystring.html#querystring_querystring_unescape",
          "!doc": "The unescape function used by querystring.parse, provided so that it could be overridden if necessary."
        }
      },
      http: {
        "!url": "https://nodejs.org/api/http.html",
        "!doc": "The HTTP interfaces in Node are designed to support many features of the protocol which have been traditionally difficult to use. In particular, large, possibly chunk-encoded, messages. The interface is careful to never buffer entire requests or responses--the user is able to stream data.",
        STATUS_CODES: {},
        createServer: {
          "!type": "fn(listener?: fn(request: +http.IncomingMessage, response: +http.ServerResponse)) -> +http.Server",
          "!url": "https://nodejs.org/api/http.html#http_http_createserver_requestlistener",
          "!doc": "Returns a new web server object."
        },
        Server: {
          "!type": "fn()",
          prototype: {
            "!proto": "events.EventEmitter.prototype",
            listen: {
              "!type": "fn(port: number, hostname?: string, backlog?: number, callback?: fn())",
              "!url": "https://nodejs.org/api/http.html#http_server_listen_port_hostname_backlog_callback",
              "!doc": "Begin accepting connections on the specified port and hostname. If the hostname is omitted, the server will accept connections directed to any IPv4 address (INADDR_ANY)."
            },
            close: {
              "!type": "fn(callback?: ?)",
              "!url": "https://nodejs.org/api/http.html#http_server_close_callback",
              "!doc": "Stops the server from accepting new connections."
            },
            maxHeadersCount: {
              "!type": "number",
              "!url": "https://nodejs.org/api/http.html#http_server_maxheaderscount",
              "!doc": "Limits maximum incoming headers count, equal to 1000 by default. If set to 0 - no limit will be applied."
            },
            setTimeout: {
              "!type": "fn(timeout: number, callback?: fn())",
              "!url": "https://nodejs.org/api/http.html#http_server_settimeout_msecs_callback",
              "!doc": "Sets the timeout value for sockets, and emits a 'timeout' event on the Server object, passing the socket as an argument, if a timeout occurs."
            },
            timeout: {
              "!type": "number",
              "!url": "https://nodejs.org/api/http.html#http_server_timeout",
              "!doc": "The number of milliseconds of inactivity before a socket is presumed to have timed out."
            }
          },
          "!url": "https://nodejs.org/api/http.html#http_class_http_server",
          "!doc": "Class for HTTP server objects."
        },
        ServerResponse: {
          "!type": "fn()",
          prototype: {
            "!proto": "stream.Writable.prototype",
            writeContinue: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/http.html#http_response_writecontinue",
              "!doc": "Sends a HTTP/1.1 100 Continue message to the client, indicating that the request body should be sent."
            },
            writeHead: {
              "!type": "fn(statusCode: number, headers?: ?)",
              "!url": "https://nodejs.org/api/http.html#http_response_writehead_statuscode_reasonphrase_headers",
              "!doc": "Sends a response header to the request. The status code is a 3-digit HTTP status code, like 404. The last argument, headers, are the response headers. Optionally one can give a human-readable reasonPhrase as the second argument."
            },
            setTimeout: {
              "!type": "fn(timeout: number, callback?: fn())",
              "!url": "https://nodejs.org/api/http.html#http_response_settimeout_msecs_callback",
              "!doc": "Sets the Socket's timeout value to msecs. If a callback is provided, then it is added as a listener on the 'timeout' event on the response object."
            },
            statusCode: {
              "!type": "number",
              "!url": "https://nodejs.org/api/http.html#http_response_statuscode",
              "!doc": "When using implicit headers (not calling response.writeHead() explicitly), this property controls the status code that will be sent to the client when the headers get flushed."
            },
            setHeader: {
              "!type": "fn(name: string, value: string)",
              "!url": "https://nodejs.org/api/http.html#http_response_setheader_name_value",
              "!doc": "Sets a single header value for implicit headers. If this header already exists in the to-be-sent headers, its value will be replaced. Use an array of strings here if you need to send multiple headers with the same name."
            },
            headersSent: {
              "!type": "bool",
              "!url": "https://nodejs.org/api/http.html#http_response_headerssent",
              "!doc": "Boolean (read-only). True if headers were sent, false otherwise."
            },
            sendDate: {
              "!type": "bool",
              "!url": "https://nodejs.org/api/http.html#http_response_senddate",
              "!doc": "When true, the Date header will be automatically generated and sent in the response if it is not already present in the headers. Defaults to true."
            },
            getHeader: {
              "!type": "fn(name: string) -> string",
              "!url": "https://nodejs.org/api/http.html#http_response_getheader_name",
              "!doc": "Reads out a header that's already been queued but not sent to the client. Note that the name is case insensitive. This can only be called before headers get implicitly flushed."
            },
            removeHeader: {
              "!type": "fn(name: string)",
              "!url": "https://nodejs.org/api/http.html#http_response_removeheader_name",
              "!doc": "Removes a header that's queued for implicit sending."
            },
            addTrailers: {
              "!type": "fn(headers: ?)",
              "!url": "https://nodejs.org/api/http.html#http_response_addtrailers_headers",
              "!doc": "This method adds HTTP trailing headers (a header but at the end of the message) to the response."
            }
          },
          "!url": "https://nodejs.org/api/http.html#http_class_http_serverresponse",
          "!doc": "This object is created internally by a HTTP server--not by the user. It is passed as the second parameter to the 'request' event."
        },
        request: {
          "!type": "fn(options: ?, callback?: fn(res: +http.IncomingMessage)) -> +http.ClientRequest",
          "!url": "https://nodejs.org/api/http.html#http_http_request_options_callback",
          "!doc": "Node maintains several connections per server to make HTTP requests. This function allows one to transparently issue requests."
        },
        get: {
          "!type": "fn(options: ?, callback?: fn(res: +http.IncomingMessage)) -> +http.ClientRequest",
          "!url": "https://nodejs.org/api/http.html#http_http_get_options_callback",
          "!doc": "Since most requests are GET requests without bodies, Node provides this convenience method. The only difference between this method and http.request() is that it sets the method to GET and calls req.end() automatically."
        },
        globalAgent: {
          "!type": "+http.Agent",
          "!url": "https://nodejs.org/api/http.html#http_http_globalagent",
          "!doc": "Global instance of Agent which is used as the default for all http client requests."
        },
        Agent: {
          "!type": "fn()",
          prototype: {
            maxSockets: {
              "!type": "number",
              "!url": "https://nodejs.org/api/http.html#http_agent_maxsockets",
              "!doc": "By default set to 5. Determines how many concurrent sockets the agent can have open per host."
            },
            sockets: {
              "!type": "[+net.Socket]",
              "!url": "https://nodejs.org/api/http.html#http_agent_sockets",
              "!doc": "An object which contains arrays of sockets currently in use by the Agent. Do not modify."
            },
            requests: {
              "!type": "[+http.ClientRequest]",
              "!url": "https://nodejs.org/api/http.html#http_agent_requests",
              "!doc": "An object which contains queues of requests that have not yet been assigned to sockets. Do not modify."
            }
          },
          "!url": "https://nodejs.org/api/http.html#http_class_http_agent",
          "!doc": "In node 0.5.3+ there is a new implementation of the HTTP Agent which is used for pooling sockets used in HTTP client requests."
        },
        ClientRequest: {
          "!type": "fn()",
          prototype: {
            "!proto": "stream.Writable.prototype",
            abort: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/http.html#http_request_abort",
              "!doc": "Aborts a request. (New since v0.3.8.)"
            },
            setTimeout: {
              "!type": "fn(timeout: number, callback?: fn())",
              "!url": "https://nodejs.org/api/http.html#http_request_settimeout_timeout_callback",
              "!doc": "Once a socket is assigned to this request and is connected socket.setTimeout() will be called."
            },
            setNoDelay: {
              "!type": "fn(noDelay?: fn())",
              "!url": "https://nodejs.org/api/http.html#http_request_setnodelay_nodelay",
              "!doc": "Once a socket is assigned to this request and is connected socket.setNoDelay() will be called."
            },
            setSocketKeepAlive: {
              "!type": "fn(enable?: bool, initialDelay?: number)",
              "!url": "https://nodejs.org/api/http.html#http_request_setsocketkeepalive_enable_initialdelay",
              "!doc": "Once a socket is assigned to this request and is connected socket.setKeepAlive() will be called."
            }
          },
          "!url": "https://nodejs.org/api/http.html#http_class_http_clientrequest",
          "!doc": "This object is created internally and returned from http.request(). It represents an in-progress request whose header has already been queued. The header is still mutable using the setHeader(name, value), getHeader(name), removeHeader(name) API. The actual header will be sent along with the first data chunk or when closing the connection."
        },
        IncomingMessage: {
          "!type": "fn()",
          prototype: {
            "!proto": "stream.Readable.prototype",
            httpVersion: {
              "!type": "string",
              "!url": "https://nodejs.org/api/http.html#http_message_httpversion",
              "!doc": "In case of server request, the HTTP version sent by the client. In the case of client response, the HTTP version of the connected-to server. Probably either '1.1' or '1.0'."
            },
            headers: {
              "!type": "?",
              "!url": "https://nodejs.org/api/http.html#http_message_headers",
              "!doc": "The request/response headers object."
            },
            trailers: {
              "!type": "?",
              "!url": "https://nodejs.org/api/http.html#http_message_trailers",
              "!doc": "The request/response trailers object. Only populated after the 'end' event."
            },
            setTimeout: {
              "!type": "fn(timeout: number, callback?: fn())",
              "!url": "https://nodejs.org/api/http.html#http_message_settimeout_msecs_callback",
              "!doc": "Calls message.connection.setTimeout(msecs, callback)."
            },
            setEncoding: {
              "!type": "fn(encoding?: string)",
              "!url": "https://nodejs.org/api/http.html#http_message_setencoding_encoding",
              "!doc": "Set the encoding for data emitted by the 'data' event."
            },
            pause: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/http.html#http_message_pause",
              "!doc": "Pauses request/response from emitting events. Useful to throttle back a download."
            },
            resume: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/http.html#http_message_resume",
              "!doc": "Resumes a paused request/response."
            },
            method: {
              "!type": "string",
              "!url": "https://nodejs.org/api/http.html#http_message_method",
              "!doc": "Only valid for request obtained from http.Server."
            },
            url: {
              "!type": "string",
              "!url": "https://nodejs.org/api/http.html#http_message_url",
              "!doc": "Only valid for request obtained from http.Server."
            },
            statusCode: {
              "!type": "number",
              "!url": "https://nodejs.org/api/http.html#http_message_statuscode",
              "!doc": "Only valid for response obtained from http.ClientRequest."
            },
            socket: {
              "!type": "+net.Socket",
              "!url": "https://nodejs.org/api/http.html#http_message_socket",
              "!doc": "The net.Socket object associated with the connection."
            }
          },
          "!url": "https://nodejs.org/api/http.html#http_http_incomingmessage",
          "!doc": "An IncomingMessage object is created by http.Server or http.ClientRequest and passed as the first argument to the 'request' and 'response' event respectively. It may be used to access response status, headers and data."
        }
      },
      https: {
        "!url": "https://nodejs.org/api/http.html",
        "!doc": "HTTPS is the HTTP protocol over TLS/SSL. In Node this is implemented as a separate module.",
        Server: "http.Server",
        createServer: {
          "!type": "fn(listener?: fn(request: +http.IncomingMessage, response: +http.ServerResponse)) -> +https.Server",
          "!url": "https://nodejs.org/api/https.html#https_https_createserver_options_requestlistener",
          "!doc": "Returns a new HTTPS web server object. The options is similar to tls.createServer(). The requestListener is a function which is automatically added to the 'request' event."
        },
        request: {
          "!type": "fn(options: ?, callback?: fn(res: +http.IncomingMessage)) -> +http.ClientRequest",
          "!url": "https://nodejs.org/api/https.html#https_https_request_options_callback",
          "!doc": "Makes a request to a secure web server."
        },
        get: {
          "!type": "fn(options: ?, callback?: fn(res: +http.IncomingMessage)) -> +http.ClientRequest",
          "!url": "https://nodejs.org/api/https.html#https_https_get_options_callback",
          "!doc": "Like http.get() but for HTTPS."
        },
        Agent: "http.Agent",
        globalAgent: "http.globalAgent"
      },
      cluster: {
        "!proto": "events.EventEmitter.prototype",
        settings: {
          exec: "string",
          args: "[string]",
          silent: "bool",
          "!url": "https://nodejs.org/api/cluster.html#cluster_cluster_settings",
          "!doc": "All settings set by the .setupMaster is stored in this settings object. This object is not supposed to be changed or set manually, by you."
        },
        Worker: {
          "!type": "fn()",
          prototype: {
            "!proto": "events.EventEmitter.prototype",
            id: {
              "!type": "string",
              "!url": "https://nodejs.org/api/cluster.html#cluster_worker_id",
              "!doc": "Each new worker is given its own unique id, this id is stored in the id."
            },
            process: {
              "!type": "+child_process.ChildProcess",
              "!url": "https://nodejs.org/api/cluster.html#cluster_worker_process",
              "!doc": "All workers are created using child_process.fork(), the returned object from this function is stored in process."
            },
            suicide: {
              "!type": "bool",
              "!url": "https://nodejs.org/api/cluster.html#cluster_worker_suicide",
              "!doc": "This property is a boolean. It is set when a worker dies after calling .kill() or immediately after calling the .disconnect() method. Until then it is undefined."
            },
            send: {
              "!type": "fn(message: ?, sendHandle?: ?)",
              "!url": "https://nodejs.org/api/cluster.html#cluster_worker_send_message_sendhandle",
              "!doc": "This function is equal to the send methods provided by child_process.fork(). In the master you should use this function to send a message to a specific worker. However in a worker you can also use process.send(message), since this is the same function."
            },
            destroy: "fn()",
            disconnect: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/cluster.html#cluster_worker_disconnect",
              "!doc": "When calling this function the worker will no longer accept new connections, but they will be handled by any other listening worker. Existing connection will be allowed to exit as usual. When no more connections exist, the IPC channel to the worker will close allowing it to die graceful. When the IPC channel is closed the disconnect event will emit, this is then followed by the exit event, there is emitted when the worker finally die."
            },
            kill: {
              "!type": "fn(signal?: string)",
              "!url": "https://nodejs.org/api/cluster.html#cluster_worker_kill_signal_sigterm",
              "!doc": "This function will kill the worker, and inform the master to not spawn a new worker. The boolean suicide lets you distinguish between voluntary and accidental exit."
            }
          },
          "!url": "https://nodejs.org/api/cluster.html#cluster_class_worker",
          "!doc": "A Worker object contains all public information and method about a worker. In the master it can be obtained using cluster.workers. In a worker it can be obtained using cluster.worker."
        },
        isMaster: {
          "!type": "bool",
          "!url": "https://nodejs.org/api/cluster.html#cluster_cluster_ismaster",
          "!doc": "True if the process is a master. This is determined by the process.env.NODE_UNIQUE_ID. If process.env.NODE_UNIQUE_ID is undefined, then isMaster is true."
        },
        isWorker: {
          "!type": "bool",
          "!url": "https://nodejs.org/api/cluster.html#cluster_cluster_isworker",
          "!doc": "This boolean flag is true if the process is a worker forked from a master. If the process.env.NODE_UNIQUE_ID is set to a value, then isWorker is true."
        },
        setupMaster: {
          "!type": "fn(settings?: cluster.settings)",
          "!url": "https://nodejs.org/api/cluster.html#cluster_cluster_setupmaster_settings",
          "!doc": "setupMaster is used to change the default 'fork' behavior. The new settings are effective immediately and permanently, they cannot be changed later on."
        },
        fork: {
          "!type": "fn(env?: ?) -> +cluster.Worker",
          "!url": "https://nodejs.org/api/cluster.html#cluster_cluster_fork_env",
          "!doc": "Spawn a new worker process. This can only be called from the master process."
        },
        disconnect: {
          "!type": "fn(callback?: fn())",
          "!url": "https://nodejs.org/api/cluster.html#cluster_cluster_disconnect_callback",
          "!doc": "When calling this method, all workers will commit a graceful suicide. When they are disconnected all internal handlers will be closed, allowing the master process to die graceful if no other event is waiting."
        },
        worker: {
          "!type": "+cluster.Worker",
          "!url": "https://nodejs.org/api/cluster.html#cluster_cluster_worker",
          "!doc": "A reference to the current worker object. Not available in the master process."
        },
        workers: {
          "!type": "[+cluster.Worker]",
          "!url": "https://nodejs.org/api/cluster.html#cluster_cluster_workers",
          "!doc": "A hash that stores the active worker objects, keyed by id field. Makes it easy to loop through all the workers. It is only available in the master process."
        },
        "!url": "https://nodejs.org/api/cluster.html#cluster_cluster",
        "!doc": "A single instance of Node runs in a single thread. To take advantage of multi-core systems the user will sometimes want to launch a cluster of Node processes to handle the load."
      },
      zlib: {
        "!url": "https://nodejs.org/api/zlib.html",
        "!doc": "This provides bindings to Gzip/Gunzip, Deflate/Inflate, and DeflateRaw/InflateRaw classes. Each class takes the same options, and is a readable/writable Stream.",
        Zlib: {
          "!type": "fn()",
          prototype: {
            "!proto": "stream.Duplex.prototype",
            flush: {
              "!type": "fn(callback: fn())",
              "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_flush_callback",
              "!doc": "Flush pending data. Don't call this frivolously, premature flushes negatively impact the effectiveness of the compression algorithm."
            },
            reset: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_reset",
              "!doc": "Reset the compressor/decompressor to factory defaults. Only applicable to the inflate and deflate algorithms."
            }
          },
          "!url": "https://nodejs.org/api/zlib.html#zlib_class_zlib_zlib",
          "!doc": "Not exported by the zlib module. It is documented here because it is the base class of the compressor/decompressor classes."
        },
        deflate: {
          "!type": "fn(buf: +Buffer, callback: fn())",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_deflate_buf_callback",
          "!doc": "Compress a string with Deflate."
        },
        deflateRaw: {
          "!type": "fn(buf: +Buffer, callback: fn())",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_deflateraw_buf_callback",
          "!doc": "Compress a string with DeflateRaw."
        },
        gzip: {
          "!type": "fn(buf: +Buffer, callback: fn())",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_gzip_buf_callback",
          "!doc": "Compress a string with Gzip."
        },
        gunzip: {
          "!type": "fn(buf: +Buffer, callback: fn())",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_gunzip_buf_callback",
          "!doc": "Decompress a raw Buffer with Gunzip."
        },
        inflate: {
          "!type": "fn(buf: +Buffer, callback: fn())",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_inflate_buf_callback",
          "!doc": "Decompress a raw Buffer with Inflate."
        },
        inflateRaw: {
          "!type": "fn(buf: +Buffer, callback: fn())",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_inflateraw_buf_callback",
          "!doc": "Decompress a raw Buffer with InflateRaw."
        },
        unzip: {
          "!type": "fn(buf: +Buffer, callback: fn())",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_unzip_buf_callback",
          "!doc": "Decompress a raw Buffer with Unzip."
        },
        Gzip: {
          "!type": "fn()",
          "!url": "https://nodejs.org/api/zlib.html#zlib_class_zlib_gzip",
          "!doc": "Compress data using gzip.",
          prototype: {"!proto:": "zlib.Zlib.prototype"}
        },
        createGzip: {
          "!type": "fn(options: ?) -> +zlib.Zlib",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_creategzip_options",
          "!doc": "Returns a new Gzip object with an options."
        },
        Gunzip: {
          "!type": "fn()",
          "!url": "https://nodejs.org/api/zlib.html#zlib_class_zlib_gunzip",
          "!doc": "Decompress a gzip stream.",
          prototype: {"!proto:": "zlib.Zlib.prototype"}
        },
        createGunzip: {
          "!type": "fn(options: ?) -> +zlib.Gunzip",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_creategunzip_options",
          "!doc": "Returns a new Gunzip object with an options."
        },
        Deflate: {
          "!type": "fn()",
          "!url": "https://nodejs.org/api/zlib.html#zlib_class_zlib_deflate",
          "!doc": "Compress data using deflate.",
          prototype: {"!proto:": "zlib.Zlib.prototype"}
        },
        createDeflate: {
          "!type": "fn(options: ?) -> +zlib.Deflate",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_createdeflate_options",
          "!doc": "Returns a new Deflate object with an options."
        },
        Inflate: {
          "!type": "fn()",
          "!url": "https://nodejs.org/api/zlib.html#zlib_class_zlib_inflate",
          "!doc": "Decompress a deflate stream.",
          prototype: {"!proto:": "zlib.Zlib.prototype"}
        },
        createInflate: {
          "!type": "fn(options: ?) -> +zlib.Inflate",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_createinflate_options",
          "!doc": "Returns a new Inflate object with an options."
        },
        InflateRaw: {
          "!type": "fn()",
          "!url": "https://nodejs.org/api/zlib.html#zlib_class_zlib_inflateraw",
          "!doc": "Decompress a raw deflate stream.",
          prototype: {"!proto:": "zlib.Zlib.prototype"}
        },
        createInflateRaw: {
          "!type": "fn(options: ?) -> +zlib.InflateRaw",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_createinflateraw_options",
          "!doc": "Returns a new InflateRaw object with an options."
        },
        DeflateRaw: {
          "!type": "fn()",
          "!url": "https://nodejs.org/api/zlib.html#zlib_class_zlib_deflateraw",
          "!doc": "Compress data using deflate, and do not append a zlib header.",
          prototype: {"!proto:": "zlib.Zlib.prototype"}
        },
        createDeflateRaw: {
          "!type": "fn(options: ?) -> +zlib.DeflateRaw",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_createdeflateraw_options",
          "!doc": "Returns a new DeflateRaw object with an options."
        },
        Unzip: {
          "!type": "fn()",
          "!url": "https://nodejs.org/api/zlib.html#zlib_class_zlib_unzip",
          "!doc": "Decompress either a Gzip- or Deflate-compressed stream by auto-detecting the header.",
          prototype: {"!proto:": "zlib.Zlib.prototype"}
        },
        createUnzip: {
          "!type": "fn(options: ?) -> +zlib.Unzip",
          "!url": "https://nodejs.org/api/zlib.html#zlib_zlib_createunzip_options",
          "!doc": "Returns a new Unzip object with an options."
        },
        Z_NO_FLUSH: "number",
        Z_PARTIAL_FLUSH: "number",
        Z_SYNC_FLUSH: "number",
        Z_FULL_FLUSH: "number",
        Z_FINISH: "number",
        Z_BLOCK: "number",
        Z_TREES: "number",
        Z_OK: "number",
        Z_STREAM_END: "number",
        Z_NEED_DICT: "number",
        Z_ERRNO: "number",
        Z_STREAM_ERROR: "number",
        Z_DATA_ERROR: "number",
        Z_MEM_ERROR: "number",
        Z_BUF_ERROR: "number",
        Z_VERSION_ERROR: "number",
        Z_NO_COMPRESSION: "number",
        Z_BEST_SPEED: "number",
        Z_BEST_COMPRESSION: "number",
        Z_DEFAULT_COMPRESSION: "number",
        Z_FILTERED: "number",
        Z_HUFFMAN_ONLY: "number",
        Z_RLE: "number",
        Z_FIXED: "number",
        Z_DEFAULT_STRATEGY: "number",
        Z_BINARY: "number",
        Z_TEXT: "number",
        Z_ASCII: "number",
        Z_UNKNOWN: "number",
        Z_DEFLATED: "number",
        Z_NULL: "number"
      },
      os: {
        "!url": "https://nodejs.org/api/os.html",
        "!doc": "Provides a few basic operating-system related utility functions.",
        tmpdir: {
          "!type": "fn() -> string",
          "!url": "https://nodejs.org/api/os.html#os_os_tmpdir",
          "!doc": "Returns the operating system's default directory for temp files."
        },
        endianness: {
          "!type": "fn() -> string",
          "!url": "https://nodejs.org/api/os.html#os_os_endianness",
          "!doc": "Returns the endianness of the CPU. Possible values are \"BE\" or \"LE\"."
        },
        hostname: {
          "!type": "fn() -> string",
          "!url": "https://nodejs.org/api/os.html#os_os_hostname",
          "!doc": "Returns the hostname of the operating system."
        },
        type: {
          "!type": "fn() -> string",
          "!url": "https://nodejs.org/api/os.html#os_os_type",
          "!doc": "Returns the operating system name."
        },
        platform: {
          "!type": "fn() -> string",
          "!url": "https://nodejs.org/api/os.html#os_os_platform",
          "!doc": "Returns the operating system platform."
        },
        arch: {
          "!type": "fn() -> string",
          "!url": "https://nodejs.org/api/os.html#os_os_arch",
          "!doc": "Returns the operating system CPU architecture."
        },
        release: {
          "!type": "fn() -> string",
          "!url": "https://nodejs.org/api/os.html#os_os_release",
          "!doc": "Returns the operating system release."
        },
        uptime: {
          "!type": "fn() -> number",
          "!url": "https://nodejs.org/api/os.html#os_os_uptime",
          "!doc": "Returns the system uptime in seconds."
        },
        loadavg: {
          "!type": "fn() -> [number]",
          "!url": "https://nodejs.org/api/os.html#os_os_loadavg",
          "!doc": "Returns an array containing the 1, 5, and 15 minute load averages."
        },
        totalmem: {
          "!type": "fn() -> number",
          "!url": "https://nodejs.org/api/os.html#os_os_totalmem",
          "!doc": "Returns the total amount of system memory in bytes."
        },
        freemem: {
          "!type": "fn() -> number",
          "!url": "https://nodejs.org/api/os.html#os_os_freemem",
          "!doc": "Returns the amount of free system memory in bytes."
        },
        cpus: {
          "!type": "fn() -> [os.cpuSpec]",
          "!url": "https://nodejs.org/api/os.html#os_os_cpus",
          "!doc": "Returns an array of objects containing information about each CPU/core installed: model, speed (in MHz), and times (an object containing the number of milliseconds the CPU/core spent in: user, nice, sys, idle, and irq)."
        },
        networkInterfaces: {
          "!type": "fn() -> ?",
          "!url": "https://nodejs.org/api/os.html#os_os_networkinterfaces",
          "!doc": "Get a list of network interfaces."
        },
        EOL: {
          "!type": "string",
          "!url": "https://nodejs.org/api/os.html#os_os_eol",
          "!doc": "A constant defining the appropriate End-of-line marker for the operating system."
        }
      },
      punycode: {
        "!url": "https://nodejs.org/api/punycode.html",
        "!doc": "Punycode.js is bundled with Node.js v0.6.2+. Use require('punycode') to access it. (To use it with other Node.js versions, use npm to install the punycode module first.)",
        decode: {
          "!type": "fn(string: string) -> string",
          "!url": "https://nodejs.org/api/punycode.html#punycode_punycode_decode_string",
          "!doc": "Converts a Punycode string of ASCII code points to a string of Unicode code points."
        },
        encode: {
          "!type": "fn(string: string) -> string",
          "!url": "https://nodejs.org/api/punycode.html#punycode_punycode_encode_string",
          "!doc": "Converts a string of Unicode code points to a Punycode string of ASCII code points."
        },
        toUnicode: {
          "!type": "fn(domain: string) -> string",
          "!url": "https://nodejs.org/api/punycode.html#punycode_punycode_tounicode_domain",
          "!doc": "Converts a Punycode string representing a domain name to Unicode. Only the Punycoded parts of the domain name will be converted, i.e. it doesn't matter if you call it on a string that has already been converted to Unicode."
        },
        toASCII: {
          "!type": "fn(domain: string) -> string",
          "!url": "https://nodejs.org/api/punycode.html#punycode_punycode_toascii_domain",
          "!doc": "Converts a Unicode string representing a domain name to Punycode. Only the non-ASCII parts of the domain name will be converted, i.e. it doesn't matter if you call it with a domain that's already in ASCII."
        },
        ucs2: {
          decode: {
            "!type": "fn(string: string) -> string",
            "!url": "https://nodejs.org/api/punycode.html#punycode_punycode_ucs2_decode_string",
            "!doc": "Creates an array containing the decimal code points of each Unicode character in the string. While JavaScript uses UCS-2 internally, this function will convert a pair of surrogate halves (each of which UCS-2 exposes as separate characters) into a single code point, matching UTF-16."
          },
          encode: {
            "!type": "fn(codePoints: [number]) -> string",
            "!url": "https://nodejs.org/api/punycode.html#punycode_punycode_ucs2_encode_codepoints",
            "!doc": "Creates a string based on an array of decimal code points."
          }
        },
        version: {
          "!type": "?",
          "!url": "https://nodejs.org/api/punycode.html#punycode_punycode_version",
          "!doc": "A string representing the current Punycode.js version number."
        }
      },
      repl: {
        "!url": "https://nodejs.org/api/repl.html",
        "!doc": "A Read-Eval-Print-Loop (REPL) is available both as a standalone program and easily includable in other programs. The REPL provides a way to interactively run JavaScript and see the results. It can be used for debugging, testing, or just trying things out.",
        start: {
          "!type": "fn(options: ?) -> +events.EventEmitter",
          "!url": "https://nodejs.org/api/repl.html#repl_repl_start_options",
          "!doc": "Returns and starts a REPLServer instance."
        }
      },
      readline: {
        "!url": "https://nodejs.org/api/readline.html",
        "!doc": "Readline allows reading of a stream (such as process.stdin) on a line-by-line basis.",
        createInterface: {
          "!type": "fn(options: ?) -> +readline.Interface",
          "!url": "https://nodejs.org/api/readline.html#readline_readline_createinterface_options",
          "!doc": "Creates a readline Interface instance."
        },
        Interface: {
          "!type": "fn()",
          prototype: {
            "!proto": "events.EventEmitter.prototype",
            setPrompt: {
              "!type": "fn(prompt: string, length: number)",
              "!url": "https://nodejs.org/api/readline.html#readline_rl_setprompt_prompt_length",
              "!doc": "Sets the prompt, for example when you run node on the command line, you see > , which is node's prompt."
            },
            prompt: {
              "!type": "fn(preserveCursor?: bool)",
              "!url": "https://nodejs.org/api/readline.html#readline_rl_prompt_preservecursor",
              "!doc": "Readies readline for input from the user, putting the current setPrompt options on a new line, giving the user a new spot to write. Set preserveCursor to true to prevent the cursor placement being reset to 0."
            },
            question: {
              "!type": "fn(query: string, callback: fn())",
              "!url": "https://nodejs.org/api/readline.html#readline_rl_question_query_callback",
              "!doc": "Prepends the prompt with query and invokes callback with the user's response. Displays the query to the user, and then invokes callback with the user's response after it has been typed."
            },
            pause: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/readline.html#readline_rl_pause",
              "!doc": "Pauses the readline input stream, allowing it to be resumed later if needed."
            },
            resume: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/readline.html#readline_rl_resume",
              "!doc": "Resumes the readline input stream."
            },
            close: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/readline.html#readline_rl_close",
              "!doc": "Closes the Interface instance, relinquishing control on the input and output streams. The \"close\" event will also be emitted."
            },
            write: {
              "!type": "fn(data: ?, key?: ?)",
              "!url": "https://nodejs.org/api/readline.html#readline_rl_write_data_key",
              "!doc": "Writes data to output stream. key is an object literal to represent a key sequence; available if the terminal is a TTY."
            }
          },
          "!url": "https://nodejs.org/api/readline.html#readline_class_interface",
          "!doc": "The class that represents a readline interface with an input and output stream."
        }
      },
      vm: {
        "!url": "https://nodejs.org/api/vm.html",
        "!doc": "JavaScript code can be compiled and run immediately or compiled, saved, and run later.",
        createContext: {
          "!type": "fn(initSandbox?: ?) -> ?",
          "!url": "https://nodejs.org/api/vm.html#vm_vm_createcontext_initsandbox",
          "!doc": "vm.createContext creates a new context which is suitable for use as the 2nd argument of a subsequent call to vm.runInContext. A (V8) context comprises a global object together with a set of build-in objects and functions. The optional argument initSandbox will be shallow-copied to seed the initial contents of the global object used by the context."
        },
        Script: {
          "!type": "fn()",
          prototype: {
            runInThisContext: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/vm.html#vm_script_runinthiscontext",
              "!doc": "Similar to vm.runInThisContext but a method of a precompiled Script object. script.runInThisContext runs the code of script and returns the result. Running code does not have access to local scope, but does have access to the global object (v8: in actual context)."
            },
            runInNewContext: {
              "!type": "fn(sandbox?: ?)",
              "!url": "https://nodejs.org/api/vm.html#vm_script_runinnewcontext_sandbox",
              "!doc": "Similar to vm.runInNewContext a method of a precompiled Script object. script.runInNewContext runs the code of script with sandbox as the global object and returns the result. Running code does not have access to local scope. sandbox is optional."
            }
          },
          "!url": "https://nodejs.org/api/vm.html#vm_class_script",
          "!doc": "A class for running scripts. Returned by vm.createScript."
        },
        runInThisContext: {
          "!type": "fn(code: string, filename?: string)",
          "!url": "https://nodejs.org/api/vm.html#vm_vm_runinthiscontext_code_filename",
          "!doc": "vm.runInThisContext() compiles code, runs it and returns the result. Running code does not have access to local scope. filename is optional, it's used only in stack traces."
        },
        runInNewContext: {
          "!type": "fn(code: string, sandbox?: ?, filename?: string)",
          "!url": "https://nodejs.org/api/vm.html#vm_vm_runinnewcontext_code_sandbox_filename",
          "!doc": "vm.runInNewContext compiles code, then runs it in sandbox and returns the result. Running code does not have access to local scope. The object sandbox will be used as the global object for code. sandbox and filename are optional, filename is only used in stack traces."
        },
        runInContext: {
          "!type": "fn(code: string, context: ?, filename?: string)",
          "!url": "https://nodejs.org/api/vm.html#vm_vm_runincontext_code_context_filename",
          "!doc": "vm.runInContext compiles code, then runs it in context and returns the result. A (V8) context comprises a global object, together with a set of built-in objects and functions. Running code does not have access to local scope and the global object held within context will be used as the global object for code. filename is optional, it's used only in stack traces."
        },
        createScript: {
          "!type": "fn(code: string, filename?: string) -> +vm.Script",
          "!url": "https://nodejs.org/api/vm.html#vm_vm_createscript_code_filename",
          "!doc": "createScript compiles code but does not run it. Instead, it returns a vm.Script object representing this compiled code. This script can be run later many times using methods below. The returned script is not bound to any global object. It is bound before each run, just for that run. filename is optional, it's only used in stack traces."
        }
      },
      child_process: {
        "!url": "https://nodejs.org/api/child_process.html",
        "!doc": "Node provides a tri-directional popen(3) facility through the child_process module.",
        ChildProcess: {
          "!type": "fn()",
          prototype: {
            "!proto": "events.EventEmitter.prototype",
            stdin: {
              "!type": "+stream.Writable",
              "!url": "https://nodejs.org/api/child_process.html#child_process_child_stdin",
              "!doc": "A Writable Stream that represents the child process's stdin. Closing this stream via end() often causes the child process to terminate."
            },
            stdout: {
              "!type": "+stream.Readable",
              "!url": "https://nodejs.org/api/child_process.html#child_process_child_stdout",
              "!doc": "A Readable Stream that represents the child process's stdout."
            },
            stderr: {
              "!type": "+stream.Readable",
              "!url": "https://nodejs.org/api/child_process.html#child_process_child_stderr",
              "!doc": "A Readable Stream that represents the child process's stderr."
            },
            pid: {
              "!type": "number",
              "!url": "https://nodejs.org/api/child_process.html#child_process_child_pid",
              "!doc": "The PID of the child process."
            },
            kill: {
              "!type": "fn(signal?: string)",
              "!url": "https://nodejs.org/api/child_process.html#child_process_child_kill_signal",
              "!doc": "Send a signal to the child process. If no argument is given, the process will be sent 'SIGTERM'."
            },
            send: {
              "!type": "fn(message: ?, sendHandle?: ?)",
              "!url": "https://nodejs.org/api/child_process.html#child_process_child_send_message_sendhandle",
              "!doc": "When using child_process.fork() you can write to the child using child.send(message, [sendHandle]) and messages are received by a 'message' event on the child."
            },
            disconnect: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/child_process.html#child_process_child_disconnect",
              "!doc": "To close the IPC connection between parent and child use the child.disconnect() method. This allows the child to exit gracefully since there is no IPC channel keeping it alive. When calling this method the disconnect event will be emitted in both parent and child, and the connected flag will be set to false. Please note that you can also call process.disconnect() in the child process."
            }
          },
          "!url": "https://nodejs.org/api/child_process.html#child_process_class_childprocess",
          "!doc": "ChildProcess is an EventEmitter."
        },
        spawn: {
          "!type": "fn(command: string, args?: [string], options?: ?) -> +child_process.ChildProcess",
          "!url": "https://nodejs.org/api/child_process.html#child_process_child_process_spawn_command_args_options",
          "!doc": "Launches a new process with the given command, with command line arguments in args. If omitted, args defaults to an empty Array."
        },
        exec: {
          "!type": "fn(command: string, callback: fn(error: ?, stdout: +Buffer, stderr: +Buffer)) -> +child_process.ChildProcess",
          "!url": "https://nodejs.org/api/child_process.html#child_process_child_process_exec_command_options_callback",
          "!doc": "Runs a command in a shell and buffers the output."
        },
        execFile: {
          "!type": "fn(file: string, args: [string], options: ?, callback: fn(error: ?, stdout: +Buffer, stderr: +Buffer)) -> +child_process.ChildProcess",
          "!url": "https://nodejs.org/api/child_process.html#child_process_child_process_execfile_file_args_options_callback",
          "!doc": "This is similar to child_process.exec() except it does not execute a subshell but rather the specified file directly. This makes it slightly leaner than child_process.exec. It has the same options."
        },
        fork: {
          "!type": "fn(modulePath: string, args?: [string], options?: ?) -> +child_process.ChildProcess",
          "!url": "https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options",
          "!doc": "This is a special case of the spawn() functionality for spawning Node processes. In addition to having all the methods in a normal ChildProcess instance, the returned object has a communication channel built-in."
        }
      },
      url: {
        "!url": "https://nodejs.org/api/url.html",
        "!doc": "This module has utilities for URL resolution and parsing. ",
        parse: {
          "!type": "fn(urlStr: string, parseQueryString?: bool, slashesDenoteHost?: bool) -> url.type",
          "!url": "https://nodejs.org/api/url.html#url_url_parse_urlstr_parsequerystring_slashesdenotehost",
          "!doc": "Take a URL string, and return an object."
        },
        format: {
          "!type": "fn(url: url.type) -> string",
          "!url": "https://nodejs.org/api/url.html#url_url_format_urlobj",
          "!doc": "Take a parsed URL object, and return a formatted URL string."
        },
        resolve: {
          "!type": "fn(from: string, to: string) -> string",
          "!url": "https://nodejs.org/api/url.html#url_url_resolve_from_to",
          "!doc": "Take a base URL, and a href URL, and resolve them as a browser would for an anchor tag."
        }
      },
      dns: {
        "!url": "https://nodejs.org/api/dns.html",
        "!doc": "This module contains functions that belong to two different categories:\n1) Functions that use the underlying operating system facilities to perform name resolution, and that do not necessarily do any network communication.\n2) Functions that connect to an actual DNS server to perform name resolution, and that always use the network to perform DNS queries.",
        lookup: {
          "!type": "fn(domain: string, callback: fn(err: +Error, address: string, family: number)) -> string",
          "!url": "https://nodejs.org/api/dns.html#dns_dns_lookup_domain_family_callback",
          "!doc": "Resolves a domain (e.g. 'google.com') into the first found A (IPv4) or AAAA (IPv6) record. The family can be the integer 4 or 6. Defaults to null that indicates both Ip v4 and v6 address family."
        },
        resolve: {
          "!type": "fn(domain: string, callback: fn(err: +Error, addresses: [string])) -> [string]",
          "!url": "https://nodejs.org/api/dns.html#dns_dns_resolve_domain_rrtype_callback",
          "!doc": "Resolves a domain (e.g. 'google.com') into an array of the record types specified by rrtype. Valid rrtypes are 'A' (IPV4 addresses, default), 'AAAA' (IPV6 addresses), 'MX' (mail exchange records), 'TXT' (text records), 'SRV' (SRV records), 'PTR' (used for reverse IP lookups), 'NS' (name server records) and 'CNAME' (canonical name records)."
        },
        resolve4: {
          "!type": "fn(domain: string, callback: fn(err: +Error, addresses: [string])) -> [string]",
          "!url": "https://nodejs.org/api/dns.html#dns_dns_resolve4_domain_callback",
          "!doc": "The same as dns.resolve(), but only for IPv4 queries (A records). addresses is an array of IPv4 addresses (e.g. ['74.125.79.104', '74.125.79.105', '74.125.79.106'])."
        },
        resolve6: {
          "!type": "fn(domain: string, callback: fn(err: +Error, addresses: [string])) -> [string]",
          "!url": "https://nodejs.org/api/dns.html#dns_dns_resolve6_domain_callback",
          "!doc": "The same as dns.resolve4() except for IPv6 queries (an AAAA query)."
        },
        resolveMx: {
          "!type": "fn(domain: string, callback: fn(err: +Error, addresses: [string])) -> [string]",
          "!url": "https://nodejs.org/api/dns.html#dns_dns_resolvemx_domain_callback",
          "!doc": "The same as dns.resolve(), but only for mail exchange queries (MX records)."
        },
        resolveTxt: {
          "!type": "fn(domain: string, callback: fn(err: +Error, addresses: [string])) -> [string]",
          "!url": "https://nodejs.org/api/dns.html#dns_dns_resolvetxt_domain_callback",
          "!doc": "The same as dns.resolve(), but only for text queries (TXT records). addresses is an array of the text records available for domain (e.g., ['v=spf1 ip4:0.0.0.0 ~all'])."
        },
        resolveSrv: {
          "!type": "fn(domain: string, callback: fn(err: +Error, addresses: [string])) -> [string]",
          "!url": "https://nodejs.org/api/dns.html#dns_dns_resolvesrv_domain_callback",
          "!doc": "The same as dns.resolve(), but only for service records (SRV records). addresses is an array of the SRV records available for domain. Properties of SRV records are priority, weight, port, and name (e.g., [{'priority': 10, {'weight': 5, 'port': 21223, 'name': 'service.example.com'}, ...])."
        },
        resolveNs: {
          "!type": "fn(domain: string, callback: fn(err: +Error, addresses: [string])) -> [string]",
          "!url": "https://nodejs.org/api/dns.html#dns_dns_resolvens_domain_callback",
          "!doc": "The same as dns.resolve(), but only for name server records (NS records). addresses is an array of the name server records available for domain (e.g., ['ns1.example.com', 'ns2.example.com'])."
        },
        resolveCname: {
          "!type": "fn(domain: string, callback: fn(err: +Error, addresses: [string])) -> [string]",
          "!url": "https://nodejs.org/api/dns.html#dns_dns_resolvecname_domain_callback",
          "!doc": "The same as dns.resolve(), but only for canonical name records (CNAME records). addresses is an array of the canonical name records available for domain (e.g., ['bar.example.com'])."
        },
        reverse: {
          "!type": "fn(ip: string, callback: fn(err: +Error, domains: [string])) -> [string]",
          "!url": "https://nodejs.org/api/dns.html#dns_dns_reverse_ip_callback",
          "!doc": "Reverse resolves an ip address to an array of domain names."
        }
      },
      net: {
        "!url": "https://nodejs.org/api/net.html",
        "!doc": "The net module provides you with an asynchronous network wrapper. It contains methods for creating both servers and clients (called streams).",
        createServer: {
          "!type": "fn(options?: ?, connectionListener?: fn(socket: +net.Socket)) -> +net.Server",
          "!url": "https://nodejs.org/api/net.html#net_net_createserver_options_connectionlistener",
          "!doc": "Creates a new TCP server. The connectionListener argument is automatically set as a listener for the 'connection' event."
        },
        Server: {
          "!type": "fn()",
          prototype: {
            "!proto": "net.Socket.prototype",
            listen: {
              "!type": "fn(port: number, hostname?: string, backlog?: number, callback?: fn())",
              "!url": "https://nodejs.org/api/net.html#net_server_listen_port_host_backlog_callback",
              "!doc": "Begin accepting connections on the specified port and host. If the host is omitted, the server will accept connections directed to any IPv4 address (INADDR_ANY). A port value of zero will assign a random port."
            },
            close: {
              "!type": "fn(callback?: fn())",
              "!url": "https://nodejs.org/api/net.html#net_server_close_callback",
              "!doc": "Stops the server from accepting new connections and keeps existing connections. This function is asynchronous, the server is finally closed when all connections are ended and the server emits a 'close' event. Optionally, you can pass a callback to listen for the 'close' event."
            },
            maxConnections: {
              "!type": "number",
              "!url": "https://nodejs.org/api/net.html#net_server_maxconnections",
              "!doc": "Set this property to reject connections when the server's connection count gets high."
            },
            getConnections: {
              "!type": "fn(callback: fn(err: +Error, count: number))",
              "!url": "https://nodejs.org/api/net.html#net_server_getconnections_callback",
              "!doc": "Asynchronously get the number of concurrent connections on the server. Works when sockets were sent to forks."
            }
          },
          "!url": "https://nodejs.org/api/net.html#net_class_net_server",
          "!doc": "This class is used to create a TCP or UNIX server. A server is a net.Socket that can listen for new incoming connections."
        },
        Socket: {
          "!type": "fn(options: ?)",
          prototype: {
            "!proto": "events.EventEmitter.prototype",
            connect: {
              "!type": "fn(port: number, host?: string, connectionListener?: fn())",
              "!url": "https://nodejs.org/api/net.html#net_socket_connect_port_host_connectlistener",
              "!doc": "Opens the connection for a given socket. If port and host are given, then the socket will be opened as a TCP socket, if host is omitted, localhost will be assumed. If a path is given, the socket will be opened as a unix socket to that path."
            },
            bufferSize: {
              "!type": "number",
              "!url": "https://nodejs.org/api/net.html#net_socket_buffersize",
              "!doc": "net.Socket has the property that socket.write() always works. This is to help users get up and running quickly. The computer cannot always keep up with the amount of data that is written to a socket - the network connection simply might be too slow. Node will internally queue up the data written to a socket and send it out over the wire when it is possible. (Internally it is polling on the socket's file descriptor for being writable)."
            },
            setEncoding: {
              "!type": "fn(encoding?: string)",
              "!url": "https://nodejs.org/api/net.html#net_socket_setencoding_encoding",
              "!doc": "Set the encoding for the socket as a Readable Stream."
            },
            write: {
              "!type": "fn(data: +Buffer, encoding?: string, callback?: fn())",
              "!url": "https://nodejs.org/api/net.html#net_socket_write_data_encoding_callback",
              "!doc": "Sends data on the socket. The second parameter specifies the encoding in the case of a string--it defaults to UTF8 encoding."
            },
            end: {
              "!type": "fn(data?: +Buffer, encoding?: string)",
              "!url": "https://nodejs.org/api/net.html#net_socket_end_data_encoding",
              "!doc": "Half-closes the socket. i.e., it sends a FIN packet. It is possible the server will still send some data."
            },
            destroy: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/net.html#net_socket_destroy",
              "!doc": "Ensures that no more I/O activity happens on this socket. Only necessary in case of errors (parse error or so)."
            },
            pause: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/net.html#net_socket_pause",
              "!doc": "Pauses the reading of data. That is, 'data' events will not be emitted. Useful to throttle back an upload."
            },
            resume: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/net.html#net_socket_resume",
              "!doc": "Resumes reading after a call to pause()."
            },
            setTimeout: {
              "!type": "fn(timeout: number, callback?: fn())",
              "!url": "https://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback",
              "!doc": "Sets the socket to timeout after timeout milliseconds of inactivity on the socket. By default net.Socket do not have a timeout."
            },
            setKeepAlive: {
              "!type": "fn(enable?: bool, initialDelay?: number)",
              "!url": "https://nodejs.org/api/net.html#net_socket_setkeepalive_enable_initialdelay",
              "!doc": "Enable/disable keep-alive functionality, and optionally set the initial delay before the first keepalive probe is sent on an idle socket. enable defaults to false."
            },
            address: {
              "!type": "fn() -> net.address",
              "!url": "https://nodejs.org/api/net.html#net_socket_address",
              "!doc": "Returns the bound address, the address family name and port of the socket as reported by the operating system. Returns an object with three properties, e.g. { port: 12346, family: 'IPv4', address: '127.0.0.1' }"
            },
            unref: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/net.html#net_socket_unref",
              "!doc": "Calling unref on a socket will allow the program to exit if this is the only active socket in the event system. If the socket is already unrefd calling unref again will have no effect."
            },
            ref: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/net.html#net_socket_ref",
              "!doc": "Opposite of unref, calling ref on a previously unrefd socket will not let the program exit if it's the only socket left (the default behavior). If the socket is refd calling ref again will have no effect."
            },
            remoteAddress: {
              "!type": "string",
              "!url": "https://nodejs.org/api/net.html#net_socket_remoteaddress",
              "!doc": "The string representation of the remote IP address. For example, '74.125.127.100' or '2001:4860:a005::68'."
            },
            remotePort: {
              "!type": "number",
              "!url": "https://nodejs.org/api/net.html#net_socket_remoteport",
              "!doc": "The numeric representation of the remote port. For example, 80 or 21."
            },
            localPort: {
              "!type": "number",
              "!url": "https://nodejs.org/api/net.html#net_socket_localport",
              "!doc": "The numeric representation of the local port. For example, 80 or 21."
            },
            bytesRead: {
              "!type": "number",
              "!url": "https://nodejs.org/api/net.html#net_socket_bytesread",
              "!doc": "The amount of received bytes."
            },
            bytesWritten: {
              "!type": "number",
              "!url": "https://nodejs.org/api/net.html#net_socket_byteswritten",
              "!doc": "The amount of bytes sent."
            },
            setNoDelay: {
              "!type": "fn(noDelay?: fn())",
              "!url": "https://nodejs.org/api/net.html#net_socket_setnodelay_nodelay",
              "!doc": "Disables the Nagle algorithm. By default TCP connections use the Nagle algorithm, they buffer data before sending it off. Setting true for noDelay will immediately fire off data each time socket.write() is called. noDelay defaults to true."
            },
            localAddress: {
              "!type": "string",
              "!url": "https://nodejs.org/api/net.html#net_socket_localaddress",
              "!doc": "The string representation of the local IP address the remote client is connecting on. For example, if you are listening on '0.0.0.0' and the client connects on '192.168.1.1', the value would be '192.168.1.1'."
            }
          },
          "!url": "https://nodejs.org/api/net.html#net_class_net_socket",
          "!doc": "This object is an abstraction of a TCP or UNIX socket. net.Socket instances implement a duplex Stream interface. They can be created by the user and used as a client (with connect()) or they can be created by Node and passed to the user through the 'connection' event of a server."
        },
        connect: {
          "!type": "fn(options: ?, connectionListener?: fn()) -> +net.Socket",
          "!url": "https://nodejs.org/api/net.html#net_net_connect_options_connectionlistener",
          "!doc": "Constructs a new socket object and opens the socket to the given location. When the socket is established, the 'connect' event will be emitted."
        },
        createConnection: {
          "!type": "fn(options: ?, connectionListener?: fn()) -> +net.Socket",
          "!url": "https://nodejs.org/api/net.html#net_net_createconnection_options_connectionlistener",
          "!doc": "Constructs a new socket object and opens the socket to the given location. When the socket is established, the 'connect' event will be emitted."
        },
        isIP: {
          "!type": "fn(input: string) -> number",
          "!url": "https://nodejs.org/api/net.html#net_net_isip_input",
          "!doc": "Tests if input is an IP address. Returns 0 for invalid strings, returns 4 for IP version 4 addresses, and returns 6 for IP version 6 addresses."
        },
        isIPv4: {
          "!type": "fn(input: string) -> bool",
          "!url": "https://nodejs.org/api/net.html#net_net_isipv4_input",
          "!doc": "Returns true if input is a version 4 IP address, otherwise returns false."
        },
        isIPv6: {
          "!type": "fn(input: string) -> bool",
          "!url": "https://nodejs.org/api/net.html#net_net_isipv6_input",
          "!doc": "Returns true if input is a version 6 IP address, otherwise returns false."
        }
      },
      dgram: {
        "!url": "https://nodejs.org/api/dgram.html",
        "!doc": "UDP / Datagram Sockets",
        createSocket: {
          "!type": "fn(type: string, callback?: fn()) -> +dgram.Socket",
          "!url": "https://nodejs.org/api/dgram.html#dgram_dgram_createsocket_type_callback",
          "!doc": "Creates a datagram Socket of the specified types. Valid types are udp4 and udp6."
        },
        Socket: {
          "!type": "fn()",
          prototype: {
            "!proto": "events.EventEmitter.prototype",
            send: {
              "!type": "fn(buf: +Buffer, offset: number, length: number, port: number, address: string, callback?: fn())",
              "!url": "https://nodejs.org/api/dgram.html#dgram_socket_send_buf_offset_length_port_address_callback",
              "!doc": "For UDP sockets, the destination port and IP address must be specified. A string may be supplied for the address parameter, and it will be resolved with DNS. An optional callback may be specified to detect any DNS errors and when buf may be re-used. Note that DNS lookups will delay the time that a send takes place, at least until the next tick. The only way to know for sure that a send has taken place is to use the callback."
            },
            bind: {
              "!type": "fn(port: number, address?: string)",
              "!url": "https://nodejs.org/api/dgram.html#dgram_socket_bind_port_address_callback",
              "!doc": "For UDP sockets, listen for datagrams on a named port and optional address. If address is not specified, the OS will try to listen on all addresses."
            },
            close: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/dgram.html#dgram_socket_close",
              "!doc": "Close the underlying socket and stop listening for data on it."
            },
            address: {
              address: "string",
              family: "string",
              port: "number",
              "!url": "https://nodejs.org/api/dgram.html#dgram_socket_address",
              "!doc": "Returns an object containing the address information for a socket. For UDP sockets, this object will contain address , family and port."
            },
            setBroadcast: {
              "!type": "fn(flag: bool)",
              "!url": "https://nodejs.org/api/dgram.html#dgram_socket_setbroadcast_flag",
              "!doc": "Sets or clears the SO_BROADCAST socket option. When this option is set, UDP packets may be sent to a local interface's broadcast address."
            },
            setTTL: {
              "!type": "fn(ttl: number)",
              "!url": "https://nodejs.org/api/dgram.html#dgram_socket_setttl_ttl",
              "!doc": "Sets the IP_TTL socket option. TTL stands for \"Time to Live,\" but in this context it specifies the number of IP hops that a packet is allowed to go through. Each router or gateway that forwards a packet decrements the TTL. If the TTL is decremented to 0 by a router, it will not be forwarded. Changing TTL values is typically done for network probes or when multicasting."
            },
            setMulticastTTL: {
              "!type": "fn(ttl: number)",
              "!url": "https://nodejs.org/api/dgram.html#dgram_socket_setmulticastttl_ttl",
              "!doc": "Sets the IP_MULTICAST_TTL socket option. TTL stands for \"Time to Live,\" but in this context it specifies the number of IP hops that a packet is allowed to go through, specifically for multicast traffic. Each router or gateway that forwards a packet decrements the TTL. If the TTL is decremented to 0 by a router, it will not be forwarded."
            },
            setMulticastLoopback: {
              "!type": "fn(flag: bool)",
              "!url": "https://nodejs.org/api/dgram.html#dgram_socket_setmulticastloopback_flag",
              "!doc": "Sets or clears the IP_MULTICAST_LOOP socket option. When this option is set, multicast packets will also be received on the local interface."
            },
            addMembership: {
              "!type": "fn(multicastAddress: string, multicastInterface?: string)",
              "!url": "https://nodejs.org/api/dgram.html#dgram_socket_addmembership_multicastaddress_multicastinterface",
              "!doc": "Tells the kernel to join a multicast group with IP_ADD_MEMBERSHIP socket option."
            },
            dropMembership: {
              "!type": "fn(multicastAddress: string, multicastInterface?: string)",
              "!url": "https://nodejs.org/api/dgram.html#dgram_socket_dropmembership_multicastaddress_multicastinterface",
              "!doc": "Opposite of addMembership - tells the kernel to leave a multicast group with IP_DROP_MEMBERSHIP socket option. This is automatically called by the kernel when the socket is closed or process terminates, so most apps will never need to call this."
            }
          },
          "!url": "https://nodejs.org/api/dgram.html#dgram_class_dgram_socket",
          "!doc": "The dgram Socket class encapsulates the datagram functionality. It should be created via dgram.createSocket(type, [callback])."
        }
      },
      fs: {
        "!url": "https://nodejs.org/api/fs.html",
        "!doc": "File I/O is provided by simple wrappers around standard POSIX functions. To use this module do require('fs').\nAll the methods have asynchronous and synchronous forms.",
        rename: {
          "!type": "fn(oldPath: string, newPath: string, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_rename_oldpath_newpath_callback",
          "!doc": "Asynchronous rename(2). No arguments other than a possible exception are given to the completion callback."
        },
        renameSync: {
          "!type": "fn(oldPath: string, newPath: string)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_renamesync_oldpath_newpath",
          "!doc": "Synchronous rename(2)."
        },
        ftruncate: {
          "!type": "fn(fd: number, len: number, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_ftruncate_fd_len_callback",
          "!doc": "Asynchronous ftruncate(2). No arguments other than a possible exception are given to the completion callback."
        },
        ftruncateSync: {
          "!type": "fn(fd: number, len: number)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_ftruncatesync_fd_len",
          "!doc": "Synchronous ftruncate(2)."
        },
        truncate: {
          "!type": "fn(path: string, len: number, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_truncate_path_len_callback",
          "!doc": "Asynchronous truncate(2). No arguments other than a possible exception are given to the completion callback."
        },
        truncateSync: {
          "!type": "fn(path: string, len: number)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_truncatesync_path_len",
          "!doc": "Synchronous truncate(2)."
        },
        chown: {
          "!type": "fn(path: string, uid: number, gid: number, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_chown_path_uid_gid_callback",
          "!doc": "Asynchronous chown(2). No arguments other than a possible exception are given to the completion callback."
        },
        chownSync: {
          "!type": "fn(path: string, uid: number, gid: number)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_chownsync_path_uid_gid",
          "!doc": "Synchronous chown(2)."
        },
        fchown: {
          "!type": "fn(fd: number, uid: number, gid: number, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_fchown_fd_uid_gid_callback",
          "!doc": "Asynchronous fchown(2). No arguments other than a possible exception are given to the completion callback."
        },
        fchownSync: {
          "!type": "fn(fd: number, uid: number, gid: number)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_fchownsync_fd_uid_gid",
          "!doc": "Synchronous fchown(2)."
        },
        lchown: {
          "!type": "fn(path: string, uid: number, gid: number, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_lchown_path_uid_gid_callback",
          "!doc": "Asynchronous lchown(2). No arguments other than a possible exception are given to the completion callback."
        },
        lchownSync: {
          "!type": "fn(path: string, uid: number, gid: number)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_lchownsync_path_uid_gid",
          "!doc": "Synchronous lchown(2)."
        },
        chmod: {
          "!type": "fn(path: string, mode: string, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_chmod_path_mode_callback",
          "!doc": "Asynchronous chmod(2). No arguments other than a possible exception are given to the completion callback."
        },
        chmodSync: {
          "!type": "fn(path: string, mode: string)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_chmodsync_path_mode",
          "!doc": "Synchronous chmod(2)."
        },
        fchmod: {
          "!type": "fn(fd: number, mode: string, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_fchmod_fd_mode_callback",
          "!doc": "Asynchronous fchmod(2). No arguments other than a possible exception are given to the completion callback."
        },
        fchmodSync: {
          "!type": "fn(fd: number, mode: string)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_fchmodsync_fd_mode",
          "!doc": "Synchronous fchmod(2)."
        },
        lchmod: {
          "!type": "fn(path: string, mode: number, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_lchmod_path_mode_callback",
          "!doc": "Asynchronous lchmod(2). No arguments other than a possible exception are given to the completion callback."
        },
        lchmodSync: {
          "!type": "fn(path: string, mode: string)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_lchmodsync_path_mode",
          "!doc": "Synchronous lchmod(2)."
        },
        stat: {
          "!type": "fn(path: string, callback?: fn(err: +Error, stats: +fs.Stats) -> ?) -> +fs.Stats",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_stat_path_callback",
          "!doc": "Asynchronous stat(2). The callback gets two arguments (err, stats) where stats is a fs.Stats object."
        },
        lstat: {
          "!type": "fn(path: string, callback?: fn(err: +Error, stats: +fs.Stats) -> ?) -> +fs.Stats",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_lstat_path_callback",
          "!doc": "Asynchronous lstat(2). The callback gets two arguments (err, stats) where stats is a fs.Stats object. lstat() is identical to stat(), except that if path is a symbolic link, then the link itself is stat-ed, not the file that it refers to."
        },
        fstat: {
          "!type": "fn(fd: number, callback?: fn(err: +Error, stats: +fs.Stats) -> ?) -> +fs.Stats",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_fstat_fd_callback",
          "!doc": "Asynchronous fstat(2). The callback gets two arguments (err, stats) where stats is a fs.Stats object. fstat() is identical to stat(), except that the file to be stat-ed is specified by the file descriptor fd."
        },
        statSync: {
          "!type": "fn(path: string) -> +fs.Stats",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_statsync_path",
          "!doc": "Synchronous stat(2). Returns an instance of fs.Stats."
        },
        lstatSync: {
          "!type": "fn(path: string) -> +fs.Stats",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_lstatsync_path",
          "!doc": "Synchronous lstat(2). Returns an instance of fs.Stats."
        },
        fstatSync: {
          "!type": "fn(fd: number) -> +fs.Stats",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_fstatsync_fd",
          "!doc": "Synchronous fstat(2). Returns an instance of fs.Stats."
        },
        link: {
          "!type": "fn(srcpath: string, dstpath: string, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_link_srcpath_dstpath_callback",
          "!doc": "Asynchronous link(2). No arguments other than a possible exception are given to the completion callback."
        },
        linkSync: {
          "!type": "fn(srcpath: string, dstpath: string)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_linksync_srcpath_dstpath",
          "!doc": "Synchronous link(2)."
        },
        symlink: {
          "!type": "fn(srcpath: string, dstpath: string, type?: string, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_symlink_srcpath_dstpath_type_callback",
          "!doc": "Asynchronous symlink(2). No arguments other than a possible exception are given to the completion callback. type argument can be either 'dir', 'file', or 'junction' (default is 'file'). It is only used on Windows (ignored on other platforms). Note that Windows junction points require the destination path to be absolute. When using 'junction', the destination argument will automatically be normalized to absolute path."
        },
        symlinkSync: {
          "!type": "fn(srcpath: string, dstpath: string, type?: string)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_symlinksync_srcpath_dstpath_type",
          "!doc": "Synchronous symlink(2)."
        },
        readlink: {
          "!type": "fn(path: string, callback?: fn(err: +Error, linkString: string))",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_readlink_path_callback",
          "!doc": "Asynchronous readlink(2). The callback gets two arguments (err, linkString)."
        },
        readlinkSync: {
          "!type": "fn(path: string)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_readlinksync_path",
          "!doc": "Synchronous readlink(2). Returns the symbolic link's string value."
        },
        realpath: {
          "!type": "fn(path: string, cache: bool, callback: fn(err: +Error, resolvedPath: string))",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_realpath_path_cache_callback",
          "!doc": "Asynchronous realpath(2). The callback gets two arguments (err, resolvedPath). May use process.cwd to resolve relative paths. cache is an object literal of mapped paths that can be used to force a specific path resolution or avoid additional fs.stat calls for known real paths."
        },
        realpathSync: {
          "!type": "fn(path: string, cache?: bool) -> string",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_realpathsync_path_cache",
          "!doc": "Synchronous realpath(2). Returns the resolved path."
        },
        unlink: {
          "!type": "fn(path: string, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_unlink_path_callback",
          "!doc": "Asynchronous unlink(2). No arguments other than a possible exception are given to the completion callback."
        },
        unlinkSync: {
          "!type": "fn(path: string)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_unlinksync_path",
          "!doc": "Synchronous unlink(2)."
        },
        rmdir: {
          "!type": "fn(path: string, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_rmdir_path_callback",
          "!doc": "Asynchronous rmdir(2). No arguments other than a possible exception are given to the completion callback."
        },
        rmdirSync: {
          "!type": "fn(path: string)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_rmdirsync_path",
          "!doc": "Synchronous rmdir(2)."
        },
        mkdir: {
          "!type": "fn(path: string, mode?: ?, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_mkdir_path_mode_callback",
          "!doc": "Asynchronous mkdir(2). No arguments other than a possible exception are given to the completion callback. mode defaults to 0777."
        },
        mkdirSync: {
          "!type": "fn(path: string, mode?: string)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_mkdirsync_path_mode",
          "!doc": "Synchronous mkdir(2)."
        },
        readdir: {
          "!type": "fn(path: string, callback?: fn(err: +Error, files: [string]))",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_readdir_path_callback",
          "!doc": "Asynchronous readdir(3). Reads the contents of a directory. The callback gets two arguments (err, files) where files is an array of the names of the files in the directory excluding '.' and '..'."
        },
        readdirSync: {
          "!type": "fn(path: string) -> [string]",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_readdirsync_path",
          "!doc": "Synchronous readdir(3). Returns an array of filenames excluding '.' and '..'."
        },
        close: {
          "!type": "fn(fd: number, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_close_fd_callback",
          "!doc": "Asynchronous close(2). No arguments other than a possible exception are given to the completion callback."
        },
        closeSync: {
          "!type": "fn(fd: number)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_closesync_fd",
          "!doc": "Synchronous close(2)."
        },
        open: {
          "!type": "fn(path: string, flags: string, mode?: string, callback?: fn(err: +Error, fd: number))",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_open_path_flags_mode_callback",
          "!doc": "Asynchronous file open."
        },
        openSync: {
          "!type": "fn(path: string, flags: string, mode?: string) -> number",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_opensync_path_flags_mode",
          "!doc": "Synchronous open(2)."
        },
        utimes: {
          "!type": "fn(path: string, atime: number, mtime: number, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_utimes_path_atime_mtime_callback",
          "!doc": "Change file timestamps of the file referenced by the supplied path."
        },
        utimesSync: {
          "!type": "fn(path: string, atime: number, mtime: number)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_utimessync_path_atime_mtime",
          "!doc": "Change file timestamps of the file referenced by the supplied path."
        },
        futimes: {
          "!type": "fn(fd: number, atime: number, mtime: number, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_futimes_fd_atime_mtime_callback",
          "!doc": "Change the file timestamps of a file referenced by the supplied file descriptor."
        },
        futimesSync: {
          "!type": "fn(fd: number, atime: number, mtime: number)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_futimessync_fd_atime_mtime",
          "!doc": "Change the file timestamps of a file referenced by the supplied file descriptor."
        },
        fsync: {
          "!type": "fn(fd: number, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_fsync_fd_callback",
          "!doc": "Asynchronous fsync(2). No arguments other than a possible exception are given to the completion callback."
        },
        fsyncSync: {
          "!type": "fn(fd: number)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_fsyncsync_fd",
          "!doc": "Synchronous fsync(2)."
        },
        write: {
          "!type": "fn(fd: number, buffer: +Buffer, offset: number, length: number, position: number, callback?: fn(err: +Error, written: number, buffer: +Buffer))",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_write_fd_buffer_offset_length_position_callback",
          "!doc": "Write buffer to the file specified by fd."
        },
        writeSync: {
          "!type": "fn(fd: number, buffer: +Buffer, offset: number, length: number, position: number) -> number",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_writesync_fd_buffer_offset_length_position",
          "!doc": "Synchronous version of fs.write(). Returns the number of bytes written."
        },
        read: {
          "!type": "fn(fd: number, buffer: +Buffer, offset: number, length: number, position: number, callback?: fn(err: +Error, bytesRead: number, buffer: +Buffer))",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_read_fd_buffer_offset_length_position_callback",
          "!doc": "Read data from the file specified by fd."
        },
        readSync: {
          "!type": "fn(fd: number, buffer: +Buffer, offset: number, length: number, position: number) -> number",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_readsync_fd_buffer_offset_length_position",
          "!doc": "Synchronous version of fs.read. Returns the number of bytesRead."
        },
        readFile: {
          "!type": "fn(filename: string, callback: fn(err: +Error, data: +Buffer))",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_readfile_filename_options_callback",
          "!doc": "Asynchronously reads the entire contents of a file."
        },
        readFileSync: {
          "!type": "fn(filename: string, encoding: string) -> +Buffer",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_readfilesync_filename_options",
          "!doc": "Synchronous version of fs.readFile. Returns the contents of the filename."
        },
        writeFile: {
          "!type": "fn(filename: string, data: string|+Buffer, encoding?: string, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_writefile_filename_data_options_callback",
          "!doc": "Asynchronously writes data to a file, replacing the file if it already exists. data can be a string or a buffer."
        },
        writeFileSync: {
          "!type": "fn(filename: string, data: string|+Buffer, encoding?: string)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_writefilesync_filename_data_options",
          "!doc": "The synchronous version of fs.writeFile."
        },
        appendFile: {
          "!type": "fn(filename: string, data: string|+Buffer, encoding?: string, callback?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_appendfile_filename_data_options_callback",
          "!doc": "Asynchronously append data to a file, creating the file if it not yet exists. data can be a string or a buffer."
        },
        appendFileSync: {
          "!type": "fn(filename: string, data: string|+Buffer, encoding?: string)",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_appendfilesync_filename_data_options",
          "!doc": "The synchronous version of fs.appendFile."
        },
        watchFile: {
          "!type": "fn(filename: string, options: ?, listener: fn(current: +fs.Stats, prev: +fs.Stats))",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_watchfile_filename_options_listener",
          "!doc": "Watch for changes on filename. The callback listener will be called each time the file is accessed."
        },
        unwatchFile: {
          "!type": "fn(filename: string, listener?: fn())",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_unwatchfile_filename_listener",
          "!doc": "Stop watching for changes on filename. If listener is specified, only that particular listener is removed. Otherwise, all listeners are removed and you have effectively stopped watching filename."
        },
        watch: {
          "!type": "fn(filename: string, options?: ?, listener?: fn(event: string, filename: string)) -> +fs.FSWatcher",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_watch_filename_options_listener",
          "!doc": "Watch for changes on filename, where filename is either a file or a directory. The returned object is a fs.FSWatcher."
        },
        exists: {
          "!type": "fn(path: string, callback?: fn(exists: bool))",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_exists_path_callback",
          "!doc": "Test whether or not the given path exists by checking with the file system. Then call the callback argument with either true or false."
        },
        existsSync: {
          "!type": "fn(path: string) -> bool",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_existssync_path",
          "!doc": "Synchronous version of fs.exists."
        },
        Stats: {
          "!type": "fn()",
          prototype: {
            isFile: "fn() -> bool",
            isDirectory: "fn() -> bool",
            isBlockDevice: "fn() -> bool",
            isCharacterDevice: "fn() -> bool",
            isSymbolicLink: "fn() -> bool",
            isFIFO: "fn() -> bool",
            isSocket: "fn() -> bool",
            dev: "number",
            ino: "number",
            mode: "number",
            nlink: "number",
            uid: "number",
            gid: "number",
            rdev: "number",
            size: "number",
            blksize: "number",
            blocks: "number",
            atime: "+Date",
            mtime: "+Date",
            ctime: "+Date"
          },
          "!url": "https://nodejs.org/api/fs.html#fs_class_fs_stats",
          "!doc": "Objects returned from fs.stat(), fs.lstat() and fs.fstat() and their synchronous counterparts are of this type."
        },
        createReadStream: {
          "!type": "fn(path: string, options?: ?) -> +stream.Readable",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_createreadstream_path_options",
          "!doc": "Returns a new ReadStream object."
        },
        createWriteStream: {
          "!type": "fn(path: string, options?: ?) -> +stream.Writable",
          "!url": "https://nodejs.org/api/fs.html#fs_fs_createwritestream_path_options",
          "!doc": "Returns a new WriteStream object."
        },
        FSWatcher: {
          "!type": "fn()",
          prototype: {
            close: "fn()"
          },
          "!url": "https://nodejs.org/api/fs.html#fs_class_fs_fswatcher",
          "!doc": "Objects returned from fs.watch() are of this type."
        }
      },
      path: {
        "!url": "https://nodejs.org/api/path.html",
        "!doc": "This module contains utilities for handling and transforming file paths. Almost all these methods perform only string transformations. The file system is not consulted to check whether paths are valid.",
        normalize: {
          "!type": "fn(p: string) -> string",
          "!url": "https://nodejs.org/api/path.html#path_path_normalize_p",
          "!doc": "Normalize a string path, taking care of '..' and '.' parts."
        },
        join: {
          "!type": "fn() -> string",
          "!url": "https://nodejs.org/api/path.html#path_path_join_path1_path2",
          "!doc": "Join all arguments together and normalize the resulting path."
        },
        resolve: {
          "!type": "fn(from: string, from2: string, from3: string, from4: string, from5: string, to: string) -> string",
          "!url": "https://nodejs.org/api/path.html#path_path_resolve_from_to",
          "!doc": "Resolves to to an absolute path."
        },
        relative: {
          "!type": "fn(from: string, to: string) -> string",
          "!url": "https://nodejs.org/api/path.html#path_path_relative_from_to",
          "!doc": "Solve the relative path from from to to."
        },
        dirname: {
          "!type": "fn(p: string) -> string",
          "!url": "https://nodejs.org/api/path.html#path_path_dirname_p",
          "!doc": "Return the directory name of a path. Similar to the Unix dirname command."
        },
        basename: {
          "!type": "fn(p: string, ext?: string) -> string",
          "!url": "https://nodejs.org/api/path.html#path_path_basename_p_ext",
          "!doc": "Return the last portion of a path. Similar to the Unix basename command."
        },
        extname: {
          "!type": "fn(p: string) -> string",
          "!url": "https://nodejs.org/api/path.html#path_path_extname_p",
          "!doc": "Return the extension of the path, from the last '.' to end of string in the last portion of the path. If there is no '.' in the last portion of the path or the first character of it is '.', then it returns an empty string."
        },
        sep: {
          "!type": "string",
          "!url": "https://nodejs.org/api/path.html#path_path_sep",
          "!doc": "The platform-specific file separator. '\\\\' or '/'."
        },
        delimiter: {
          "!type": "string",
          "!url": "https://nodejs.org/api/path.html#path_path_delimiter",
          "!doc": "The platform-specific path delimiter, ; or ':'."
        }
      },
      string_decoder: {
        "!url": "https://nodejs.org/api/string_decoder.html",
        "!doc": "StringDecoder decodes a buffer to a string. It is a simple interface to buffer.toString() but provides additional support for utf8.",
        StringDecoder: {
          "!type": "fn(encoding?: string)",
          prototype: {
            write: {
              "!type": "fn(buffer: +Buffer) -> string",
              "!url": "https://nodejs.org/api/string_decoder.html#string_decoder_decoder_write_buffer",
              "!doc": "Returns a decoded string."
            },
            end: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/string_decoder.html#string_decoder_decoder_end",
              "!doc": "Returns any trailing bytes that were left in the buffer."
            }
          },
          "!url": "https://nodejs.org/api/string_decoder.html#string_decoder_class_stringdecoder",
          "!doc": "Accepts a single argument, encoding which defaults to utf8."
        }
      },
      tls: {
        "!url": "https://nodejs.org/api/tls.html",
        "!doc": "The tls module uses OpenSSL to provide Transport Layer Security and/or Secure Socket Layer: encrypted stream communication.",
        CLIENT_RENEG_LIMIT: "number",
        CLIENT_RENEG_WINDOW: "number",
        SLAB_BUFFER_SIZE: "number",
        getCiphers: {
          "!type": "fn() -> [string]",
          "!url": "https://nodejs.org/api/tls.html#tls_tls_getciphers",
          "!doc": "Returns an array with the names of the supported SSL ciphers."
        },
        Server: {
          "!type": "fn()",
          prototype: {
            "!proto": "net.Server.prototype",
            listen: {
              "!type": "fn(port: number, host?: string, callback?: fn())",
              "!url": "https://nodejs.org/api/tls.html#tls_server_listen_port_host_callback",
              "!doc": "Begin accepting connections on the specified port and host. If the host is omitted, the server will accept connections directed to any IPv4 address (INADDR_ANY)."
            },
            close: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/tls.html#tls_server_close",
              "!doc": "Stops the server from accepting new connections. This function is asynchronous, the server is finally closed when the server emits a 'close' event."
            },
            addContext: {
              "!type": "fn(hostName: string, credentials: tls.Server.credentials)",
              "!url": "https://nodejs.org/api/tls.html#tls_server_addcontext_hostname_credentials",
              "!doc": "Add secure context that will be used if client request's SNI hostname is matching passed hostname (wildcards can be used). credentials can contain key, cert and ca."
            }
          },
          "!url": "https://nodejs.org/api/tls.html#tls_class_tls_server",
          "!doc": "This class is a subclass of net.Server and has the same methods on it. Instead of accepting just raw TCP connections, this accepts encrypted connections using TLS or SSL."
        },
        createServer: {
          "!type": "fn(options?: ?, connectionListener?: fn(stream: +tls.CleartextStream)) -> +tls.Server",
          "!url": "https://nodejs.org/api/tls.html#tls_tls_createserver_options_secureconnectionlistener",
          "!doc": "Creates a new tls.Server. The connectionListener argument is automatically set as a listener for the secureConnection event."
        },
        CleartextStream: {
          "!type": "fn()",
          prototype: {
            "!proto": "stream.Duplex.prototype",
            authorized: {
              "!type": "bool",
              "!url": "https://nodejs.org/api/tls.html#tls_cleartextstream_authorized",
              "!doc": "A boolean that is true if the peer certificate was signed by one of the specified CAs, otherwise false"
            },
            authorizationError: {
              "!type": "+Error",
              "!url": "https://nodejs.org/api/tls.html#tls_cleartextstream_authorizationerror",
              "!doc": "The reason why the peer's certificate has not been verified. This property becomes available only when cleartextStream.authorized === false."
            },
            getPeerCertificate: {
              "!type": "fn() -> ?",
              "!url": "https://nodejs.org/api/tls.html#tls_cleartextstream_getpeercertificate",
              "!doc": "Returns an object representing the peer's certificate. The returned object has some properties corresponding to the field of the certificate."
            },
            getCipher: {
              "!type": "fn() -> tls.cipher",
              "!url": "https://nodejs.org/api/tls.html#tls_cleartextstream_getcipher",
              "!doc": "Returns an object representing the cipher name and the SSL/TLS protocol version of the current connection."
            },
            address: {
              "!type": "net.address",
              "!url": "https://nodejs.org/api/tls.html#tls_cleartextstream_address",
              "!doc": "Returns the bound address, the address family name and port of the underlying socket as reported by the operating system. Returns an object with three properties, e.g. { port: 12346, family: 'IPv4', address: '127.0.0.1' }"
            },
            remoteAddress: {
              "!type": "string",
              "!url": "https://nodejs.org/api/tls.html#tls_cleartextstream_remoteaddress",
              "!doc": "The string representation of the remote IP address. For example, '74.125.127.100' or '2001:4860:a005::68'."
            },
            remotePort: {
              "!type": "number",
              "!url": "https://nodejs.org/api/tls.html#tls_cleartextstream_remoteport",
              "!doc": "The numeric representation of the remote port. For example, 443."
            }
          },
          "!url": "https://nodejs.org/api/tls.html#tls_class_tls_cleartextstream",
          "!doc": "This is a stream on top of the Encrypted stream that makes it possible to read/write an encrypted data as a cleartext data."
        },
        connect: {
          "!type": "fn(port: number, host?: string, options: ?, listener: fn()) -> +tls.CleartextStream",
          "!url": "https://nodejs.org/api/tls.html#tls_tls_connect_options_callback",
          "!doc": "Creates a new client connection to the given port and host (old API) or options.port and options.host. (If host is omitted, it defaults to localhost.)"
        },
        createSecurePair: {
          "!type": "fn(credentials?: crypto.credentials, isServer?: bool, requestCert?: bool, rejectUnauthorized?: bool) -> +tls.SecurePair",
          "!url": "https://nodejs.org/api/tls.html#tls_tls_createsecurepair_credentials_isserver_requestcert_rejectunauthorized",
          "!doc": "Creates a new secure pair object with two streams, one of which reads/writes encrypted data, and one reads/writes cleartext data. Generally the encrypted one is piped to/from an incoming encrypted data stream, and the cleartext one is used as a replacement for the initial encrypted stream."
        },
        SecurePair: {
          "!type": "fn()",
          prototype: {
            "!proto": "events.EventEmitter.prototype",
            cleartext: {
              "!type": "+tls.CleartextStream",
              "!url": "https://nodejs.org/api/tls.html#tls_class_securepair",
              "!doc": "Returned by tls.createSecurePair."
            },
            encrypted: {
              "!type": "+stream.Duplex",
              "!url": "https://nodejs.org/api/tls.html#tls_class_securepair",
              "!doc": "Returned by tls.createSecurePair."
            }
          },
          "!url": "https://nodejs.org/api/tls.html#tls_class_securepair",
          "!doc": "Returned by tls.createSecurePair."
        }
      },
      crypto: {
        "!url": "https://nodejs.org/api/crypto.html",
        "!doc": "The crypto module offers a way of encapsulating secure credentials to be used as part of a secure HTTPS net or http connection.\nIt also offers a set of wrappers for OpenSSL's hash, hmac, cipher, decipher, sign and verify methods.",
        getCiphers: {
          "!type": "fn() -> [string]",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_getciphers",
          "!doc": "Returns an array with the names of the supported ciphers."
        },
        getHashes: {
          "!type": "fn() -> [string]",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_gethashes",
          "!doc": "Returns an array with the names of the supported hash algorithms."
        },
        createCredentials: {
          "!type": "fn(details?: ?) -> crypto.credentials",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_createcredentials_details",
          "!doc": "Creates a credentials object."
        },
        createHash: {
          "!type": "fn(algorithm: string) -> +crypto.Hash",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_createhash_algorithm",
          "!doc": "Creates and returns a hash object, a cryptographic hash with the given algorithm which can be used to generate hash digests."
        },
        Hash: {
          "!type": "fn()",
          prototype: {
            "!proto": "stream.Duplex.prototype",
            update: {
              "!type": "fn(data: +Buffer, encoding?: string)",
              "!url": "https://nodejs.org/api/crypto.html#crypto_hash_update_data_input_encoding",
              "!doc": "Updates the hash content with the given data, the encoding of which is given in input_encoding and can be 'utf8', 'ascii' or 'binary'. If no encoding is provided, then a buffer is expected."
            },
            digest: {
              "!type": "fn(encoding?: string) -> +Buffer",
              "!url": "https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding",
              "!doc": "Calculates the digest of all of the passed data to be hashed. The encoding can be 'hex', 'binary' or 'base64'. If no encoding is provided, then a buffer is returned."
            }
          },
          "!url": "https://nodejs.org/api/crypto.html#crypto_class_hash",
          "!doc": "The class for creating hash digests of data."
        },
        createHmac: {
          "!type": "fn(algorithm: string, key: string) -> +crypto.Hmac",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_createhmac_algorithm_key",
          "!doc": "Creates and returns a hmac object, a cryptographic hmac with the given algorithm and key."
        },
        Hmac: {
          "!type": "fn()",
          prototype: {
            update: {
              "!type": "fn(data: +Buffer)",
              "!url": "https://nodejs.org/api/crypto.html#crypto_hmac_update_data",
              "!doc": "Update the hmac content with the given data. This can be called many times with new data as it is streamed."
            },
            digest: {
              "!type": "fn(encoding?: string) -> +Buffer",
              "!url": "https://nodejs.org/api/crypto.html#crypto_hmac_digest_encoding",
              "!doc": "Calculates the digest of all of the passed data to the hmac. The encoding can be 'hex', 'binary' or 'base64'. If no encoding is provided, then a buffer is returned."
            }
          },
          "!url": "https://nodejs.org/api/crypto.html#crypto_class_hmac",
          "!doc": "Class for creating cryptographic hmac content."
        },
        createCipher: {
          "!type": "fn(algorithm: string, password: string) -> +crypto.Cipher",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_createcipher_algorithm_password",
          "!doc": "Creates and returns a cipher object, with the given algorithm and password."
        },
        createCipheriv: {
          "!type": "fn(algorithm: string, password: string, iv: string) -> +crypto.Cipher",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_createcipheriv_algorithm_key_iv",
          "!doc": "Creates and returns a cipher object, with the given algorithm, key and iv."
        },
        Cipher: {
          "!type": "fn()",
          prototype: {
            "!proto": "stream.Duplex.prototype",
            update: {
              "!type": "fn(data: +Buffer, input_encoding?: string, output_encoding?: string) -> +Buffer",
              "!url": "https://nodejs.org/api/crypto.html#crypto_cipher_update_data_input_encoding_output_encoding",
              "!doc": "Updates the cipher with data, the encoding of which is given in input_encoding and can be 'utf8', 'ascii' or 'binary'. If no encoding is provided, then a buffer is expected."
            },
            "final": {
              "!type": "fn(output_encoding?: string) -> +Buffer",
              "!url": "https://nodejs.org/api/crypto.html#crypto_cipher_final_output_encoding",
              "!doc": "Returns any remaining enciphered contents, with output_encoding being one of: 'binary', 'base64' or 'hex'. If no encoding is provided, then a buffer is returned."
            },
            setAutoPadding: {
              "!type": "fn(auto_padding: bool)",
              "!url": "https://nodejs.org/api/crypto.html#crypto_cipher_setautopadding_auto_padding_true",
              "!doc": "You can disable automatic padding of the input data to block size. If auto_padding is false, the length of the entire input data must be a multiple of the cipher's block size or final will fail. Useful for non-standard padding, e.g. using 0x0 instead of PKCS padding. You must call this before cipher.final."
            }
          },
          "!url": "https://nodejs.org/api/crypto.html#crypto_class_cipher",
          "!doc": "Class for encrypting data."
        },
        createDecipher: {
          "!type": "fn(algorithm: string, password: string) -> +crypto.Decipher",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_createdecipher_algorithm_password",
          "!doc": "Creates and returns a decipher object, with the given algorithm and key. This is the mirror of the createCipher() above."
        },
        createDecipheriv: {
          "!type": "fn(algorithm: string, key: string, iv: string) -> +crypto.Decipher",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_createdecipheriv_algorithm_key_iv",
          "!doc": "Creates and returns a decipher object, with the given algorithm, key and iv. This is the mirror of the createCipheriv() above."
        },
        Decipher: {
          "!type": "fn()",
          prototype: {
            "!proto": "stream.Duplex.prototype",
            update: {
              "!type": "fn(data: +Buffer, input_encoding?: string, output_encoding?: string)",
              "!url": "https://nodejs.org/api/crypto.html#crypto_decipher_update_data_input_encoding_output_encoding",
              "!doc": "Updates the decipher with data, which is encoded in 'binary', 'base64' or 'hex'. If no encoding is provided, then a buffer is expected."
            },
            "final": {
              "!type": "fn(output_encoding?: string) -> +Buffer",
              "!url": "https://nodejs.org/api/crypto.html#crypto_decipher_final_output_encoding",
              "!doc": "Returns any remaining plaintext which is deciphered, with output_encoding being one of: 'binary', 'ascii' or 'utf8'. If no encoding is provided, then a buffer is returned."
            },
            setAutoPadding: {
              "!type": "fn(auto_padding: bool)",
              "!url": "https://nodejs.org/api/crypto.html#crypto_decipher_setautopadding_auto_padding_true",
              "!doc": "You can disable auto padding if the data has been encrypted without standard block padding to prevent decipher.final from checking and removing it. Can only work if the input data's length is a multiple of the ciphers block size. You must call this before streaming data to decipher.update."
            }
          },
          "!url": "https://nodejs.org/api/crypto.html#crypto_class_decipher",
          "!doc": "Class for decrypting data."
        },
        createSign: {
          "!type": "fn(algorithm: string) -> +crypto.Sign",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_createsign_algorithm",
          "!doc": "Creates and returns a signing object, with the given algorithm. On recent OpenSSL releases, openssl list-public-key-algorithms will display the available signing algorithms. Examples are 'RSA-SHA256'."
        },
        Sign: {
          "!type": "fn()",
          prototype: {
            "!proto": "stream.Writable.prototype",
            update: {
              "!type": "fn(data: +Buffer)",
              "!url": "https://nodejs.org/api/crypto.html#crypto_sign_update_data",
              "!doc": "Updates the sign object with data. This can be called many times with new data as it is streamed."
            },
            sign: {
              "!type": "fn(private_key: string, output_format: string) -> +Buffer",
              "!url": "https://nodejs.org/api/crypto.html#crypto_sign_sign_private_key_output_format",
              "!doc": "Calculates the signature on all the updated data passed through the sign. private_key is a string containing the PEM encoded private key for signing."
            }
          },
          "!url": "https://nodejs.org/api/crypto.html#crypto_class_sign",
          "!doc": "Class for generating signatures."
        },
        createVerify: {
          "!type": "fn(algorith: string) -> +crypto.Verify",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_createverify_algorithm",
          "!doc": "Creates and returns a verification object, with the given algorithm. This is the mirror of the signing object above."
        },
        Verify: {
          "!type": "fn()",
          prototype: {
            "!proto": "stream.Writable.prototype",
            update: {
              "!type": "fn(data: +Buffer)",
              "!url": "https://nodejs.org/api/crypto.html#crypto_verifier_update_data",
              "!doc": "Updates the verifier object with data. This can be called many times with new data as it is streamed."
            },
            verify: {
              "!type": "fn(object: string, signature: string, signature_format?: string) -> bool",
              "!url": "https://nodejs.org/api/crypto.html#crypto_verifier_verify_object_signature_signature_format",
              "!doc": "Verifies the signed data by using the object and signature. object is a string containing a PEM encoded object, which can be one of RSA public key, DSA public key, or X.509 certificate. signature is the previously calculated signature for the data, in the signature_format which can be 'binary', 'hex' or 'base64'. If no encoding is specified, then a buffer is expected."
            }
          },
          "!url": "https://nodejs.org/api/crypto.html#crypto_class_verify",
          "!doc": "Class for verifying signatures."
        },
        createDiffieHellman: {
          "!type": "fn(prime: number, encoding?: string) -> +crypto.DiffieHellman",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_creatediffiehellman_prime_length",
          "!doc": "Creates a Diffie-Hellman key exchange object and generates a prime of the given bit length. The generator used is 2."
        },
        DiffieHellman: {
          "!type": "fn()",
          prototype: {
            generateKeys: {
              "!type": "fn(encoding?: string) -> +Buffer",
              "!url": "https://nodejs.org/api/crypto.html#crypto_diffiehellman_generatekeys_encoding",
              "!doc": "Generates private and public Diffie-Hellman key values, and returns the public key in the specified encoding. This key should be transferred to the other party. Encoding can be 'binary', 'hex', or 'base64'. If no encoding is provided, then a buffer is returned."
            },
            computeSecret: {
              "!type": "fn(other_public_key: +Buffer, input_encoding?: string, output_encoding?: string) -> +Buffer",
              "!url": "https://nodejs.org/api/crypto.html#crypto_diffiehellman_computesecret_other_public_key_input_encoding_output_encoding",
              "!doc": "Computes the shared secret using other_public_key as the other party's public key and returns the computed shared secret. Supplied key is interpreted using specified input_encoding, and secret is encoded using specified output_encoding. Encodings can be 'binary', 'hex', or 'base64'. If the input encoding is not provided, then a buffer is expected."
            },
            getPrime: {
              "!type": "fn(encoding?: string) -> +Buffer",
              "!url": "https://nodejs.org/api/crypto.html#crypto_diffiehellman_getprime_encoding",
              "!doc": "Returns the Diffie-Hellman prime in the specified encoding, which can be 'binary', 'hex', or 'base64'. If no encoding is provided, then a buffer is returned."
            },
            getGenerator: {
              "!type": "fn(encoding: string) -> +Buffer",
              "!url": "https://nodejs.org/api/crypto.html#crypto_diffiehellman_getgenerator_encoding",
              "!doc": "Returns the Diffie-Hellman prime in the specified encoding, which can be 'binary', 'hex', or 'base64'. If no encoding is provided, then a buffer is returned."
            },
            getPublicKey: {
              "!type": "fn(encoding?: string) -> +Buffer",
              "!url": "https://nodejs.org/api/crypto.html#crypto_diffiehellman_getpublickey_encoding",
              "!doc": "Returns the Diffie-Hellman public key in the specified encoding, which can be 'binary', 'hex', or 'base64'. If no encoding is provided, then a buffer is returned."
            },
            getPrivateKey: {
              "!type": "fn(encoding?: string) -> +Buffer",
              "!url": "https://nodejs.org/api/crypto.html#crypto_diffiehellman_getprivatekey_encoding",
              "!doc": "Returns the Diffie-Hellman private key in the specified encoding, which can be 'binary', 'hex', or 'base64'. If no encoding is provided, then a buffer is returned."
            },
            setPublicKey: {
              "!type": "fn(public_key: +Buffer, encoding?: string)",
              "!url": "https://nodejs.org/api/crypto.html#crypto_diffiehellman_setpublickey_public_key_encoding",
              "!doc": "Sets the Diffie-Hellman public key. Key encoding can be 'binary', 'hex' or 'base64'. If no encoding is provided, then a buffer is expected."
            },
            setPrivateKey: {
              "!type": "fn(public_key: +Buffer, encoding?: string)",
              "!url": "https://nodejs.org/api/crypto.html#crypto_diffiehellman_setprivatekey_private_key_encoding",
              "!doc": "Sets the Diffie-Hellman private key. Key encoding can be 'binary', 'hex' or 'base64'. If no encoding is provided, then a buffer is expected."
            }
          },
          "!url": "https://nodejs.org/api/crypto.html#crypto_class_diffiehellman",
          "!doc": "The class for creating Diffie-Hellman key exchanges."
        },
        getDiffieHellman: {
          "!type": "fn(group_name: string) -> +crypto.DiffieHellman",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_getdiffiehellman_group_name",
          "!doc": "Creates a predefined Diffie-Hellman key exchange object. The supported groups are: 'modp1', 'modp2', 'modp5' (defined in RFC 2412) and 'modp14', 'modp15', 'modp16', 'modp17', 'modp18' (defined in RFC 3526). The returned object mimics the interface of objects created by crypto.createDiffieHellman() above, but will not allow to change the keys (with diffieHellman.setPublicKey() for example). The advantage of using this routine is that the parties don't have to generate nor exchange group modulus beforehand, saving both processor and communication time."
        },
        pbkdf2: {
          "!type": "fn(password: string, salt: string, iterations: number, keylen: number, callback: fn(err: +Error, derivedKey: string))",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_pbkdf2_password_salt_iterations_keylen_callback",
          "!doc": "Asynchronous PBKDF2 applies pseudorandom function HMAC-SHA1 to derive a key of given length from the given password, salt and iterations. The callback gets two arguments (err, derivedKey)."
        },
        pbkdf2Sync: {
          "!type": "fn(password: string, salt: string, iterations: number, keylen: number) -> string",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_pbkdf2sync_password_salt_iterations_keylen",
          "!doc": "Synchronous PBKDF2 function. Returns derivedKey or throws error."
        },
        randomBytes: {
          "!type": "fn(size: number, callback?: fn(err: +Error, buf: +Buffer))",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback",
          "!doc": "Generates cryptographically strong pseudo-random data."
        },
        pseudoRandomBytes: {
          "!type": "fn(size: number, callback?: fn(err: +Error, buf: +Buffer))",
          "!url": "https://nodejs.org/api/crypto.html#crypto_crypto_pseudorandombytes_size_callback",
          "!doc": "Generates non-cryptographically strong pseudo-random data. The data returned will be unique if it is sufficiently long, but is not necessarily unpredictable. For this reason, the output of this function should never be used where unpredictability is important, such as in the generation of encryption keys."
        },
        DEFAULT_ENCODING: "string"
      },
      util: {
        "!url": "https://nodejs.org/api/util.html",
        "!doc": "The util module is primarily designed to support the needs of Node's internal APIs. Many of these utilities are useful for your own programs. If you find that these functions are lacking for your purposes, however, you are encouraged to write your own utilities. We are not interested in any future additions to the util module that are unnecessary for Node's internal functionality.",
        format: {
          "!type": "fn(format: string) -> string",
          "!url": "https://nodejs.org/api/util.html#util_util_format_format",
          "!doc": "Returns a formatted string using the first argument as a printf-like format."
        },
        debug: {
          "!type": "fn(msg: string)",
          "!url": "https://nodejs.org/api/util.html#util_util_debug_string",
          "!doc": "A synchronous output function. Will block the process and output string immediately to stderr."
        },
        error: {
          "!type": "fn(msg: string)",
          "!url": "https://nodejs.org/api/util.html#util_util_error",
          "!doc": "Same as util.debug() except this will output all arguments immediately to stderr."
        },
        puts: {
          "!type": "fn(data: string)",
          "!url": "https://nodejs.org/api/util.html#util_util_puts",
          "!doc": "A synchronous output function. Will block the process and output all arguments to stdout with newlines after each argument."
        },
        print: {
          "!type": "fn(data: string)",
          "!url": "https://nodejs.org/api/util.html#util_util_print",
          "!doc": "A synchronous output function. Will block the process, cast each argument to a string then output to stdout. Does not place newlines after each argument."
        },
        log: {
          "!type": "fn(string: string)",
          "!url": "https://nodejs.org/api/util.html#util_util_log_string",
          "!doc": "Output with timestamp on stdout."
        },
        inspect: {
          "!type": "fn(object: ?, options: ?) -> string",
          "!url": "https://nodejs.org/api/util.html#util_util_inspect_object_options",
          "!doc": "Return a string representation of object, which is useful for debugging."
        },
        isArray: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_isarray_object",
          "!doc": "Returns true if the given \"object\" is an Array. false otherwise."
        },
        isRegExp: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_isregexp_object",
          "!doc": "Returns true if the given \"object\" is a RegExp. false otherwise."
        },
        isDate: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_isdate_object",
          "!doc": "Returns true if the given \"object\" is a Date. false otherwise."
        },
        isError: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_iserror_object",
          "!doc": "Returns true if the given \"object\" is an Error. false otherwise."
        },
        isBoolean: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_isboolean_object",
          "!doc": "Returns true if the given \"object\" is a Boolean. false otherwise."
        },
        isNull: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_isnull_object",
          "!doc": "Returns true if the given \"object\" is strictly null. false otherwise."
        },
        isNullOrUndefined: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_isnullorundefined_object",
          "!doc": "Returns true if the given \"object\" is null or undefined. false otherwise."
        },
        isNumber: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_isnumber_object",
          "!doc": "Returns true if the given \"object\" is a Number. false otherwise."
        },
        isString: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_isstring_object",
          "!doc": "Returns true if the given \"object\" is a String. false otherwise."
        },
        isSymbol: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_issymbol_object",
          "!doc": "Returns true if the given \"object\" is a Symbol. false otherwise."
        },
        isUndefined: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_isundefined_object",
          "!doc": "Returns true if the given \"object\" is undefined. false otherwise."
        },
        isObject: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_isobject_object",
          "!doc": "Returns true if the given \"object\" is strictly an Object and not a Function. false otherwise."
        },
        isFunction: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_isfunction_object",
          "!doc": "Returns true if the given \"object\" is a Function. false otherwise."
        },
        isPrimitive: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_isprimitive_object",
          "!doc": "Returns true if the given \"object\" is a primitive type. false otherwise."
        },
        isBuffer: {
          "!type": "fn(object: ?) -> bool",
          "!url": "https://nodejs.org/api/util.html#util_util_isbuffer_object",
          "!doc": "Returns true if the given \"object\" is a Buffer. false otherwise."
        },
        inherits: {
          "!type": "fn(constructor: ?, superConstructor: ?)",
          "!url": "https://nodejs.org/api/util.html#util_util_inherits_constructor_superconstructor",
          "!doc": "Inherit the prototype methods from one constructor into another. The prototype of constructor will be set to a new object created from superConstructor."
        }
      },
      assert: {
        "!type": "fn(value: ?, message?: string)",
        fail: {
          "!type": "fn(actual: ?, expected: ?, message: string, operator: string)",
          "!url": "https://nodejs.org/api/assert.html#assert_assert_fail_actual_expected_message_operator",
          "!doc": "Throws an exception that displays the values for actual and expected separated by the provided operator."
        },
        ok: {
          "!type": "fn(value: ?, message?: string)",
          "!url": "https://nodejs.org/api/assert.html#assert_assert",
          "!doc": "This module is used for writing unit tests for your applications, you can access it with require('assert')."
        },
        equal: {
          "!type": "fn(actual: ?, expected: ?, message?: string)",
          "!url": "https://nodejs.org/api/assert.html#assert_assert_equal_actual_expected_message",
          "!doc": "Tests shallow, coercive equality with the equal comparison operator ( == )."
        },
        notEqual: {
          "!type": "fn(actual: ?, expected: ?, message?: string)",
          "!url": "https://nodejs.org/api/assert.html#assert_assert_notequal_actual_expected_message",
          "!doc": "Tests shallow, coercive non-equality with the not equal comparison operator ( != )."
        },
        deepEqual: {
          "!type": "fn(actual: ?, expected: ?, message?: string)",
          "!url": "https://nodejs.org/api/assert.html#assert_assert_deepequal_actual_expected_message",
          "!doc": "Tests for deep equality."
        },
        notDeepEqual: {
          "!type": "fn(acutal: ?, expected: ?, message?: string)",
          "!url": "https://nodejs.org/api/assert.html#assert_assert_notdeepequal_actual_expected_message",
          "!doc": "Tests for any deep inequality."
        },
        strictEqual: {
          "!type": "fn(actual: ?, expected: ?, message?: string)",
          "!url": "https://nodejs.org/api/assert.html#assert_assert_strictequal_actual_expected_message",
          "!doc": "Tests strict equality, as determined by the strict equality operator ( === )"
        },
        notStrictEqual: {
          "!type": "fn(actual: ?, expected: ?, message?: string)",
          "!url": "https://nodejs.org/api/assert.html#assert_assert_notstrictequal_actual_expected_message",
          "!doc": "Tests strict non-equality, as determined by the strict not equal operator ( !== )"
        },
        "throws": {
          "!type": "fn(block: fn(), error?: ?, messsage?: string)",
          "!url": "https://nodejs.org/api/assert.html#assert_assert_throws_block_error_message",
          "!doc": "Expects block to throw an error. error can be constructor, regexp or validation function."
        },
        doesNotThrow: {
          "!type": "fn(block: fn(), error?: ?, messsage?: string)",
          "!url": "https://nodejs.org/api/assert.html#assert_assert_doesnotthrow_block_message",
          "!doc": "Expects block not to throw an error."
        },
        ifError: {
          "!type": "fn(value: ?)",
          "!url": "https://nodejs.org/api/assert.html#assert_assert_iferror_value",
          "!doc": "Tests if value is not a false value, throws if it is a true value. Useful when testing the first argument, error in callbacks."
        },
        "!url": "https://nodejs.org/api/assert.html#assert_assert",
        "!doc": "This module is used for writing unit tests for your applications, you can access it with require('assert')."
      },
      tty: {
        "!url": "https://nodejs.org/api/tty.html",
        "!doc": "The tty module houses the tty.ReadStream and tty.WriteStream classes. In most cases, you will not need to use this module directly.",
        isatty: {
          "!type": "fn(fd: number) -> bool",
          "!url": "https://nodejs.org/api/tty.html#tty_tty_isatty_fd",
          "!doc": "Returns true or false depending on if the fd is associated with a terminal."
        }
      },
      domain: {
        "!url": "https://nodejs.org/api/domain.html",
        "!doc": "Domains provide a way to handle multiple different IO operations as a single group. If any of the event emitters or callbacks registered to a domain emit an error event, or throw an error, then the domain object will be notified, rather than losing the context of the error in the process.on('uncaughtException') handler, or causing the program to exit immediately with an error code.",
        create: {
          "!type": "fn() -> +events.EventEmitter",
          "!url": "https://nodejs.org/api/domain.html#domain_domain_create",
          "!doc": "Returns a new Domain object."
        },
        Domain: {
          "!type": "fn()",
          prototype: {
            "!proto": "events.EventEmitter.prototype",
            run: {
              "!type": "fn(fn: fn())",
              "!url": "https://nodejs.org/api/domain.html#domain_domain_run_fn",
              "!doc": "Run the supplied function in the context of the domain, implicitly binding all event emitters, timers, and lowlevel requests that are created in that context."
            },
            members: {
              "!type": "[+events.EventEmitter]",
              "!url": "https://nodejs.org/api/domain.html#domain_domain_members",
              "!doc": "An array of timers and event emitters that have been explicitly added to the domain."
            },
            add: {
              "!type": "fn(emitter: +events.EventEmitter)",
              "!url": "https://nodejs.org/api/domain.html#domain_domain_add_emitter",
              "!doc": "Explicitly adds an emitter to the domain. If any event handlers called by the emitter throw an error, or if the emitter emits an error event, it will be routed to the domain's error event, just like with implicit binding."
            },
            remove: {
              "!type": "fn(emitter: +events.EventEmitter)",
              "!url": "https://nodejs.org/api/domain.html#domain_domain_remove_emitter",
              "!doc": "The opposite of domain.add(emitter). Removes domain handling from the specified emitter."
            },
            bind: {
              "!type": "fn(callback: fn(err: +Error, data: ?)) -> !0",
              "!url": "https://nodejs.org/api/domain.html#domain_domain_bind_callback",
              "!doc": "The returned function will be a wrapper around the supplied callback function. When the returned function is called, any errors that are thrown will be routed to the domain's error event."
            },
            intercept: {
              "!type": "fn(cb: fn(data: ?)) -> !0",
              "!url": "https://nodejs.org/api/domain.html#domain_domain_intercept_callback",
              "!doc": "This method is almost identical to domain.bind(callback). However, in addition to catching thrown errors, it will also intercept Error objects sent as the first argument to the function."
            },
            dispose: {
              "!type": "fn()",
              "!url": "https://nodejs.org/api/domain.html#domain_domain_dispose",
              "!doc": "The dispose method destroys a domain, and makes a best effort attempt to clean up any and all IO that is associated with the domain. Streams are aborted, ended, closed, and/or destroyed. Timers are cleared. Explicitly bound callbacks are no longer called. Any error events that are raised as a result of this are ignored."
            }
          },
          "!url": "https://nodejs.org/api/domain.html#domain_class_domain",
          "!doc": "The Domain class encapsulates the functionality of routing errors and uncaught exceptions to the active Domain object."
        }
      },
      "os.cpuSpec": {
        model: "string",
        speed: "number",
        times: {
          user: "number",
          nice: "number",
          sys: "number",
          idle: "number",
          irq: "number"
        }
      },
      "process.memoryUsage.type": {
        rss: "number",
        heapTotal: "?",
        number: "?",
        heapUsed: "number"
      },
      "net.address": {
        port: "number",
        family: "string",
        address: "string"
      },
      "url.type": {
        href: "string",
        protocol: "string",
        auth: "string",
        hostname: "string",
        port: "string",
        host: "string",
        pathname: "string",
        search: "string",
        query: "string",
        slashes: "bool",
        hash: "string"
      },
      "tls.Server.credentials": {
        key: "string",
        cert: "string",
        ca: "string"
      },
      "tls.cipher": {
        name: "string",
        version: "string"
      },
      "crypto.credentials": {
        pfx: "string",
        key: "string",
        passphrase: "string",
        cert: "string",
        ca: "string",
        crl: "string",
        ciphers: "string"
      },
      buffer: {
        Buffer: "Buffer",
        INSPECT_MAX_BYTES: "number",
        SlowBuffer: "Buffer"
      },
      module: {},
      timers: {
        setTimeout: {
          "!type": "fn(callback: fn(), ms: number) -> timers.Timer",
          "!url": "https://nodejs.org/api/globals.html#globals_settimeout_cb_ms",
          "!doc": "Run callback cb after at least ms milliseconds. The actual delay depends on external factors like OS timer granularity and system load."
        },
        clearTimeout: {
          "!type": "fn(id: timers.Timer)",
          "!url": "https://nodejs.org/api/globals.html#globals_cleartimeout_t",
          "!doc": "Stop a timer that was previously created with setTimeout(). The callback will not execute."
        },
        setInterval: {
          "!type": "fn(callback: fn(), ms: number) -> timers.Timer",
          "!url": "https://nodejs.org/api/globals.html#globals_setinterval_cb_ms",
          "!doc": "Run callback cb repeatedly every ms milliseconds. Note that the actual interval may vary, depending on external factors like OS timer granularity and system load. It's never less than ms but it may be longer."
        },
        clearInterval: {
          "!type": "fn(id: timers.Timer)",
          "!url": "https://nodejs.org/api/globals.html#globals_clearinterval_t",
          "!doc": "Stop a timer that was previously created with setInterval(). The callback will not execute."
        },
        setImmediate: {
          "!type": "fn(callback: fn()) -> timers.Timer",
          "!url": "https://nodejs.org/api/timers.html#timers_setimmediate_callback_arg",
          "!doc": "Schedule the 'immediate' execution of callback after I/O events callbacks."
        },
        clearImmediate: {
          "!type": "fn(id: timers.Timer)",
          "!url": "https://nodejs.org/api/timers.html#timers_clearimmediate_immediateid",
          "!doc": "Stops an immediate from triggering."
        },
        Timer: {
          unref: {
            "!type": "fn()",
            "!url": "https://nodejs.org/api/timers.html#timers_unref",
            "!doc": "Create a timer that is active but if it is the only item left in the event loop won't keep the program running."
          },
          ref: {
            "!type": "fn()",
            "!url": "https://nodejs.org/api/timers.html#timers_unref",
            "!doc": "Explicitly request the timer hold the program open (cancel the effect of 'unref')."
          }
        }
      }
    },
    process: {
      stdout: {
        "!type": "+stream.Writable",
        "!url": "https://nodejs.org/api/process.html#process_process_stdout",
        "!doc": "A Writable Stream to stdout."
      },
      stderr: {
        "!type": "+stream.Writable",
        "!url": "https://nodejs.org/api/process.html#process_process_stderr",
        "!doc": "A writable stream to stderr."
      },
      stdin: {
        "!type": "+stream.Readable",
        "!url": "https://nodejs.org/api/process.html#process_process_stdin",
        "!doc": "A Readable Stream for stdin. The stdin stream is paused by default, so one must call process.stdin.resume() to read from it."
      },
      argv: {
        "!type": "[string]",
        "!url": "https://nodejs.org/api/process.html#process_process_argv",
        "!doc": "An array containing the command line arguments. The first element will be 'node', the second element will be the name of the JavaScript file. The next elements will be any additional command line arguments."
      },
      execPath: {
        "!type": "string",
        "!url": "https://nodejs.org/api/process.html#process_process_execpath",
        "!doc": "This is the absolute pathname of the executable that started the process."
      },
      abort: {
        "!type": "fn()",
        "!url": "https://nodejs.org/api/process.html#process_process_abort",
        "!doc": "This causes node to emit an abort. This will cause node to exit and generate a core file."
      },
      chdir: {
        "!type": "fn(directory: string)",
        "!url": "https://nodejs.org/api/process.html#process_process_chdir_directory",
        "!doc": "Changes the current working directory of the process or throws an exception if that fails."
      },
      cwd: {
        "!type": "fn()",
        "!url": "https://nodejs.org/api/process.html#process_process_cwd",
        "!doc": "Returns the current working directory of the process."
      },
      env: {
        "!url": "https://nodejs.org/api/process.html#process_process_env",
        "!doc": "An object containing the user environment."
      },
      exit: {
        "!type": "fn(code?: number)",
        "!url": "https://nodejs.org/api/process.html#process_process_exit_code",
        "!doc": "Ends the process with the specified code. If omitted, exit uses the 'success' code 0."
      },
      getgid: {
        "!type": "fn() -> number",
        "!url": "https://nodejs.org/api/process.html#process_process_getgid",
        "!doc": "Gets the group identity of the process. This is the numerical group id, not the group name."
      },
      setgid: {
        "!type": "fn(id: number)",
        "!url": "https://nodejs.org/api/process.html#process_process_setgid_id",
        "!doc": "Sets the group identity of the process. This accepts either a numerical ID or a groupname string. If a groupname is specified, this method blocks while resolving it to a numerical ID."
      },
      getuid: {
        "!type": "fn() -> number",
        "!url": "https://nodejs.org/api/process.html#process_process_getuid",
        "!doc": "Gets the user identity of the process. This is the numerical userid, not the username."
      },
      setuid: {
        "!type": "fn(id: number)",
        "!url": "https://nodejs.org/api/process.html#process_process_setuid_id",
        "!doc": "Sets the user identity of the process. This accepts either a numerical ID or a username string. If a username is specified, this method blocks while resolving it to a numerical ID."
      },
      version: {
        "!type": "string",
        "!url": "https://nodejs.org/api/process.html#process_process_version",
        "!doc": "A compiled-in property that exposes NODE_VERSION."
      },
      versions: {
        http_parser: "string",
        node: "string",
        v8: "string",
        ares: "string",
        uv: "string",
        zlib: "string",
        openssl: "string",
        "!url": "https://nodejs.org/api/process.html#process_process_versions",
        "!doc": "A property exposing version strings of node and its dependencies."
      },
      config: {
        target_defaults: {
          cflags: "[?]",
          default_configuration: "string",
          defines: "[string]",
          include_dirs: "[string]",
          libraries: "[string]"
        },
        variables: {
          clang: "number",
          host_arch: "string",
          node_install_npm: "bool",
          node_install_waf: "bool",
          node_prefix: "string",
          node_shared_openssl: "bool",
          node_shared_v8: "bool",
          node_shared_zlib: "bool",
          node_use_dtrace: "bool",
          node_use_etw: "bool",
          node_use_openssl: "bool",
          target_arch: "string",
          v8_no_strict_aliasing: "number",
          v8_use_snapshot: "bool",
          visibility: "string"
        },
        "!url": "https://nodejs.org/api/process.html#process_process_config",
        "!doc": "An Object containing the JavaScript representation of the configure options that were used to compile the current node executable. This is the same as the \"config.gypi\" file that was produced when running the ./configure script."
      },
      kill: {
        "!type": "fn(pid: number, signal?: string)",
        "!url": "https://nodejs.org/api/process.html#process_process_kill_pid_signal",
        "!doc": "Send a signal to a process. pid is the process id and signal is the string describing the signal to send. Signal names are strings like 'SIGINT' or 'SIGUSR1'. If omitted, the signal will be 'SIGTERM'."
      },
      pid: {
        "!type": "number",
        "!url": "https://nodejs.org/api/process.html#process_process_pid",
        "!doc": "The PID of the process."
      },
      title: {
        "!type": "string",
        "!url": "https://nodejs.org/api/process.html#process_process_title",
        "!doc": "Getter/setter to set what is displayed in 'ps'."
      },
      arch: {
        "!type": "string",
        "!url": "https://nodejs.org/api/process.html#process_process_arch",
        "!doc": "What processor architecture you're running on: 'arm', 'ia32', or 'x64'."
      },
      platform: {
        "!type": "string",
        "!url": "https://nodejs.org/api/process.html#process_process_platform",
        "!doc": "What platform you're running on: 'darwin', 'freebsd', 'linux', 'sunos' or 'win32'"
      },
      memoryUsage: {
        "!type": "fn() -> process.memoryUsage.type",
        "!url": "https://nodejs.org/api/process.html#process_process_memoryusage",
        "!doc": "Returns an object describing the memory usage of the Node process measured in bytes."
      },
      nextTick: {
        "!type": "fn(callback: fn())",
        "!url": "https://nodejs.org/api/process.html#process_process_nexttick_callback",
        "!doc": "On the next loop around the event loop call this callback. This is not a simple alias to setTimeout(fn, 0), it's much more efficient. It typically runs before any other I/O events fire, but there are some exceptions."
      },
      maxTickDepth: {
        "!type": "number",
        "!url": "https://nodejs.org/api/process.html#process_process_maxtickdepth",
        "!doc": "The maximum depth of nextTick-calling nextTick-callbacks that will be evaluated before allowing other forms of I/O to occur."
      },
      umask: {
        "!type": "fn(mask?: number) -> number",
        "!url": "https://nodejs.org/api/process.html#process_process_umask_mask",
        "!doc": "Sets or reads the process's file mode creation mask. Child processes inherit the mask from the parent process. Returns the old mask if mask argument is given, otherwise returns the current mask."
      },
      uptime: {
        "!type": "fn() -> number",
        "!url": "https://nodejs.org/api/process.html#process_process_uptime",
        "!doc": "Number of seconds Node has been running."
      },
      hrtime: {
        "!type": "fn() -> [number]",
        "!url": "https://nodejs.org/api/process.html#process_process_hrtime",
        "!doc": "Returns the current high-resolution real time in a [seconds, nanoseconds] tuple Array. It is relative to an arbitrary time in the past. It is not related to the time of day and therefore not subject to clock drift. The primary use is for measuring performance between intervals."
      },
      "!url": "https://nodejs.org/api/globals.html#globals_process",
      "!doc": "The process object."
    },
    global: {
      "!type": "<top>",
      "!url": "https://nodejs.org/api/globals.html#globals_global",
      "!doc": "In browsers, the top-level scope is the global scope. That means that in browsers if you're in the global scope var something will define a global variable. In Node this is different. The top-level scope is not the global scope; var something inside a Node module will be local to that module."
    },
    console: {
      log: {
        "!type": "fn(text: string)",
        "!url": "https://nodejs.org/api/stdio.html#stdio_console_log_data",
        "!doc": "Prints to stdout with newline. This function can take multiple arguments in a printf()-like way."
      },
      info: {
        "!type": "fn(text: string)",
        "!url": "https://nodejs.org/api/stdio.html#stdio_console_info_data",
        "!doc": "Same as console.log."
      },
      error: {
        "!type": "fn(text: string)",
        "!url": "https://nodejs.org/api/stdio.html#stdio_console_error_data",
        "!doc": "Same as console.log but prints to stderr."
      },
      warn: {
        "!type": "fn(text: string)",
        "!url": "https://nodejs.org/api/stdio.html#stdio_console_warn_data",
        "!doc": "Same as console.error."
      },
      dir: {
        "!type": "fn(obj: ?)",
        "!url": "https://nodejs.org/api/stdio.html#stdio_console_dir_obj",
        "!doc": "Uses util.inspect on obj and prints resulting string to stdout."
      },
      time: {
        "!type": "fn(label: string)",
        "!url": "https://nodejs.org/api/stdio.html#stdio_console_time_label",
        "!doc": "Mark a time."
      },
      timeEnd: {
        "!type": "fn(label: string)",
        "!url": "https://nodejs.org/api/stdio.html#stdio_console_timeend_label",
        "!doc": "Finish timer, record output."
      },
      trace: {
        "!type": "fn(label: string)",
        "!url": "https://nodejs.org/api/stdio.html#stdio_console_trace_label",
        "!doc": "Print a stack trace to stderr of the current position."
      },
      assert: {
        "!type": "fn(expression: bool)",
        "!url": "https://nodejs.org/api/stdio.html#stdio_console_assert_expression_message",
        "!doc": "Same as assert.ok() where if the expression evaluates as false throw an AssertionError with message."
      },
      "!url": "https://nodejs.org/api/globals.html#globals_console",
      "!doc": "Used to print to stdout and stderr."
    },
    __filename: {
      "!type": "string",
      "!url": "https://nodejs.org/api/globals.html#globals_filename",
      "!doc": "The filename of the code being executed. This is the resolved absolute path of this code file. For a main program this is not necessarily the same filename used in the command line. The value inside a module is the path to that module file."
    },
    __dirname: {
      "!type": "string",
      "!url": "https://nodejs.org/api/globals.html#globals_dirname",
      "!doc": "The name of the directory that the currently executing script resides in."
    },
    setTimeout: "timers.setTimeout",
    clearTimeout: "timers.clearTimeout",
    setInterval: "timers.setInterval",
    clearInterval: "timers.clearInterval",
    Buffer: {
      "!type": "fn(str: string, encoding?: string) -> +Buffer",
      prototype: {
        "!proto": "String.prototype",
        write: "fn(string: string, offset?: number, length?: number, encoding?: string) -> number",
        toString: "fn(encoding?: string, start?: number, end?: number) -> string",
        length: "number",
        copy: "fn(targetBuffer: +Buffer, targetStart?: number, sourceStart?: number, sourceEnd?: number)",
        slice: "fn(start?: number, end?: number) -> +Buffer",
        readUInt8: "fn(offset: number, noAssert?: bool) -> number",
        readUInt16LE: "fn(offset: number, noAssert?: bool) -> number",
        readUInt16BE: "fn(offset: number, noAssert?: bool) -> number",
        readUInt32LE: "fn(offset: number, noAssert?: bool) -> number",
        readUInt32BE: "fn(offset: number, noAssert?: bool) -> number",
        readInt8: "fn(offset: number, noAssert?: bool) -> number",
        readInt16LE: "fn(offset: number, noAssert?: bool) -> number",
        readInt16BE: "fn(offset: number, noAssert?: bool) -> number",
        readInt32LE: "fn(offset: number, noAssert?: bool) -> number",
        readInt32BE: "fn(offset: number, noAssert?: bool) -> number",
        readFloatLE: "fn(offset: number, noAssert?: bool) -> number",
        readFloatBE: "fn(offset: number, noAssert?: bool) -> number",
        readDoubleLE: "fn(offset: number, noAssert?: bool) -> number",
        readDoubleBE: "fn(offset: number, noAssert?: bool) -> number",
        writeUInt8: "fn(value: number, offset: number, noAssert?: bool)",
        writeUInt16LE: "fn(value: number, offset: number, noAssert?: bool)",
        writeUInt16BE: "fn(value: number, offset: number, noAssert?: bool)",
        writeUInt32LE: "fn(value: number, offset: number, noAssert?: bool)",
        writeUInt32BE: "fn(value: number, offset: number, noAssert?: bool)",
        writeInt8: "fn(value: number, offset: number, noAssert?: bool)",
        writeInt16LE: "fn(value: number, offset: number, noAssert?: bool)",
        writeInt16BE: "fn(value: number, offset: number, noAssert?: bool)",
        writeInt32LE: "fn(value: number, offset: number, noAssert?: bool)",
        writeInt32BE: "fn(value: number, offset: number, noAssert?: bool)",
        writeFloatLE: "fn(value: number, offset: number, noAssert?: bool)",
        writeFloatBE: "fn(value: number, offset: number, noAssert?: bool)",
        writeDoubleLE: "fn(value: number, offset: number, noAssert?: bool)",
        writeDoubleBE: "fn(value: number, offset: number, noAssert?: bool)",
        fill: "fn(value: ?, offset?: number, end?: number)"
      },
      isBuffer: "fn(obj: ?) -> bool",
      byteLength: "fn(string: string, encoding?: string) -> number",
      concat: "fn(list: [+Buffer], totalLength?: number) -> +Buffer",
      "!url": "https://nodejs.org/api/globals.html#globals_class_buffer",
      "!doc": "Used to handle binary data."
    }
  };
});

});

define("tern/plugin/requirejs",[], function(require, exports, module) {
var $build_deps$ = {require: require, exports: exports, module: module};
exports = undefined; module = undefined;
function define(name, deps, m) {
    if (typeof name == "function") {
        m = name; deps = ["require", "exports", "module"]; name = $build_deps$.module.id
    }
    if (typeof name !== "string") {
        m = deps; deps = name; name = $build_deps$.module.id
    }
    if (!m) {
        m = deps; deps = [];
    }
    var ret = typeof m == "function" ?
        m.apply($build_deps$.module, deps.map(function(n){return $build_deps$[n] || require(n)})) : m
    if (ret != undefined) $build_deps$.module.exports = ret;
    if (name != $build_deps$.module.id && $build_deps$.module.define) {
        $build_deps$.module.define(name, [], function() { return $build_deps$.module.exports });
    }
}
define.amd = true;
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(require("../lib/infer"), require("../lib/tern"));
  if (typeof define == "function" && define.amd) // AMD
    return define(["../lib/infer", "../lib/tern"], mod);
  mod(tern, tern);
})(function(infer, tern) {
  "use strict";

  function flattenPath(path) {
    if (!/(^|\/)(\.\/|[^\/]+\/\.\.\/)/.test(path)) return path;
    var parts = path.split("/");
    for (var i = 0; i < parts.length; ++i) {
      if (parts[i] == "." || !parts[i]) parts.splice(i--, 1);
      else if (i && parts[i] == "..") parts.splice(i-- - 1, 2);
    }
    return parts.join("/");
  }

  function resolveName(name, data) {
    var excl = name.indexOf("!");
    if (excl > -1) name = name.slice(0, excl);

    var opts = data.options;
    var hasExt = /\.js$/.test(name);
    if (hasExt || /^(?:\w+:|\/)/.test(name))
      return name + (hasExt ? "" : ".js");

    var base = opts.baseURL || "";
    if (base && base.charAt(base.length - 1) != "/") base += "/";
    if (opts.paths) {
      var known = opts.paths[name];
      if (known) return flattenPath(base + known + ".js");
      var dir = name.match(/^([^\/]+)(\/.*)$/);
      if (dir) {
        var known = opts.paths[dir[1]];
        if (known) return flattenPath(base + known + dir[2] + ".js");
      }
    }
    return flattenPath(base + name + ".js");
  }

  function getRequire(data) {
    if (!data.require) {
      data.require = new infer.Fn("require", infer.ANull, [infer.cx().str], ["module"], new infer.AVal);
      data.require.computeRet = function(_self, _args, argNodes) {
        if (argNodes.length && argNodes[0].type == "Literal" && typeof argNodes[0].value == "string")
          return getInterface(path.join(path.dirname(data.currentFile), argNodes[0].value), data);
        return infer.ANull;
      };
    }
    return data.require;
  }

  function getModuleInterface(data, exports) {
    var mod = new infer.Obj(infer.cx().definitions.requirejs.module, "module");
    var expProp = mod.defProp("exports");
    expProp.propagate(getModule(data.currentFile, data));
    exports.propagate(expProp, EXPORT_OBJ_WEIGHT);
    return mod;
  }

  function getExports(data) {
    var exports = new infer.Obj(true, "exports");
    getModule(data.currentFile, data).addType(exports, EXPORT_OBJ_WEIGHT);
    return exports;
  }

  function getInterface(name, data) {
    if (data.options.override && Object.prototype.hasOwnProperty.call(data.options.override, name)) {
      var over = data.options.override[name];
      if (typeof over == "string" && over.charAt(0) == "=") return infer.def.parsePath(over.slice(1));
      if (typeof over == "object") {
        var known = getKnownModule(name, data);
        if (known) return known;
        var scope = data.interfaces[stripJSExt(name)] = new infer.Obj(null, stripJSExt(name));
        infer.def.load(over, scope);
        return scope;
      }
      name = over;
    }

    if (!/^(https?:|\/)|\.js$/.test(name))
      name = resolveName(name, data);
    name = flattenPath(name);

    var known = getKnownModule(name, data);

    if (!known) {
      known = getModule(name, data);
      data.server.addFile(name, null, data.currentFile);
    }
    return known;
  }

  function getKnownModule(name, data) {
    return data.interfaces[stripJSExt(name)];
  }

  function getModule(name, data) {
    var known = getKnownModule(name, data);
    if (!known) {
      known = data.interfaces[stripJSExt(name)] = new infer.AVal;
      known.origin = name;
    }
    return known;
  }

  var EXPORT_OBJ_WEIGHT = 50;

  function stripJSExt(f) {
    return f.replace(/\.js$/, '');
  }

  var path = {
    dirname: function(path) {
      var lastSep = path.lastIndexOf("/");
      return lastSep == -1 ? "" : path.slice(0, lastSep);
    },
    relative: function(from, to) {
      if (to.indexOf(from) == 0) return to.slice(from.length);
      else return to;
    },
    join: function(a, b) {
      if (b && b.charAt(0) != ".") return b;
      if (a && b) return a + "/" + b;
      else return (a || "") + (b || "");
    }
  };

  function runModule(server, args, argNodes, out) {
    var data = server.mod.requireJS;
    var deps = [], fn, exports, mod;

    function interf(name) {
      if (name == "require") return getRequire(data);
      if (name == "exports") return exports || (exports = getExports(data));
      if (name == "module") return mod || (mod = getModuleInterface(data, exports || (exports = getExports(data))));
      return getInterface(name, data);
    }

    if (argNodes && args.length > 1) {
      var node = argNodes[args.length == 2 ? 0 : 1];
      var base = path.relative(server.projectDir, path.dirname(node.sourceFile.name));
      if (node.type == "Literal" && typeof node.value == "string") {
        node.required = interf(path.join(base, node.value), data);
        deps.push(node.required);
      } else if (node.type == "ArrayExpression") for (var i = 0; i < node.elements.length; ++i) {
        var elt = node.elements[i];
        if (elt.type == "Literal" && typeof elt.value == "string") {
          elt.required = interf(path.join(base, elt.value), data);
          deps.push(elt.required);
        }
      }
    } else if (argNodes && args.length == 1 &&
               /FunctionExpression/.test(argNodes[0].type) &&
               argNodes[0].params.length) {
      deps.push(interf("require", data), interf("exports", data), interf("module", data));
      fn = args[0];
    }

    if (!fn) {
      fn = args[Math.min(args.length - 1, 2)];
      if (!fn.isEmpty() && !fn.getFunctionType()) fn = null;
    }

    if (fn) {
      fn.propagate(new infer.IsCallee(infer.ANull, deps, null, out || infer.ANull));
      if (out) out.originNode = fn.originNode;
    } else if (out) {
      args[0].propagate(out)
    }

    return infer.ANull;
  }

  infer.registerFunction("requirejs_define", function(_self, args, argNodes) {
    if (!args.length) return infer.ANull

    var server = infer.cx().parent, data = server.mod.requireJS
    return runModule(server, args, argNodes, getModule(data.currentFile, data))
  });

  infer.registerFunction("requirejs_require", function(_self, args, argNodes) {
    if (!args.length) return infer.ANull
    return runModule(infer.cx().parent, args, argNodes)
  });
  function parseExprNode(node) {
    switch (node.type) {
    case "ArrayExpression":
      return node.elements.map(parseExprNode);
    case "Literal":
      return node.value;
    case "ObjectExpression":
      var obj = {};
      node.properties.forEach(function(prop) {
        var key = prop.key.name || prop.key.value;
        obj[key] = parseExprNode(prop.value);
      });
      return obj;
    }
  }

  infer.registerFunction("requirejs_config", function(_self, _args, argNodes) {
    var server = infer.cx().parent, data = server && server.mod.requireJS;
    if (data && argNodes && argNodes.length && argNodes[0].type == "ObjectExpression") {
      var config = parseExprNode(argNodes[0]);
      for (var key in config) if (config.hasOwnProperty(key)) {
        var value = config[key], exists = data.options[key];
        if (!exists) {
          data.options[key] = value;
        } else if (key == "paths") {
          for (var path in value) if (value.hasOwnProperty(path) && !data.options.paths[path])
            data.options.paths[path] = value[path];
        }
      }
    }
    return infer.ANull;
  });

  function preCondenseReach(state) {
    var interfaces = infer.cx().parent.mod.requireJS.interfaces;
    var rjs = state.roots["!requirejs"] = new infer.Obj(null);
    for (var name in interfaces) {
      var prop = rjs.defProp(name.replace(/\./g, "`"));
      interfaces[name].propagate(prop);
      prop.origin = interfaces[name].origin;
    }
  }

  function postLoadDef(data) {
    var cx = infer.cx(), interfaces = cx.definitions[data["!name"]]["!requirejs"];
    var data = cx.parent.mod.requireJS;
    if (interfaces) for (var name in interfaces.props) {
      interfaces.props[name].propagate(getInterface(name, data));
    }
  }

  tern.registerPlugin("requirejs", function(server, options) {
    server.mod.requireJS = {
      interfaces: Object.create(null),
      options: options || {},
      currentFile: null,
      server: server
    };

    server.on("beforeLoad", function(file) {
      this.mod.requireJS.currentFile = file.name;
    });
    server.on("reset", function() {
      this.mod.requireJS.interfaces = Object.create(null);
      this.mod.requireJS.require = null;
    });

    server.on("preCondenseReach", preCondenseReach)
    server.on("postLoadDef", postLoadDef)
    server.on("typeAt", findTypeAt)
    server.on("completion", findCompletions)

    server.addDefs(defs)
  });

  function findTypeAt(_file, _pos, expr, type) {
    if (!expr || expr.node.type != "Literal" ||
        typeof expr.node.value != "string" || !expr.node.required)
      return type;
    type = Object.create(type);
    var exportedType = expr.node.required;
    type.origin = exportedType.origin;
    type.originNode = exportedType.originNode;
    if (exportedType.doc) type.doc = exportedType.doc
    if (exportedType.url) type.url = exportedType.url
    return type;
  }

  function findCompletions(file, query) {
    var wordEnd = tern.resolvePos(file, query.end);
    var callExpr = infer.findExpressionAround(file.ast, null, wordEnd, file.scope, "CallExpression");
    if (!callExpr) return;
    var callNode = callExpr.node;
    if (callNode.callee.type != "Identifier" ||
        !(callNode.callee.name == "define" || callNode.callee.name == "require" || callNode.callee.name == "requirejs")||
        callNode.arguments.length < 1 || callNode.arguments[0].type != "ArrayExpression") return;
    var argNode = findRequireModule(callNode.arguments[0].elements, wordEnd);
    if (!argNode) return;
    var word = argNode.raw.slice(1, wordEnd - argNode.start), quote = argNode.raw.charAt(0);
    if (word && word.charAt(word.length - 1) == quote)
      word = word.slice(0, word.length - 1);
    var completions = completeModuleName(query, word, file.name);
    if (argNode.end == wordEnd + 1 && file.text.charAt(wordEnd) == quote)
      ++wordEnd;
    return {
      start: tern.outputPos(query, file, argNode.start),
      end: tern.outputPos(query, file, wordEnd),
      isProperty: false,
      isObjectKey: false,
      completions: completions.map(function(rec) {
        var name = typeof rec == "string" ? rec : rec.name;
        var string = JSON.stringify(name);
        if (quote == "'") string = quote + string.slice(1, string.length -1).replace(/'/g, "\\'") + quote;
        if (typeof rec == "string") return string;
        rec.displayName = name;
        rec.name = string;
        return rec;
      })
    };
  }

  function findRequireModule(argsNode, wordEnd) {
    for (var i = 0; i < argsNode.length; i++) {
      var argNode = argsNode[i];
      if (argNode.type == "Literal" && typeof argNode.value == "string" &&
          argNode.start < wordEnd && argNode.end > wordEnd) return argNode;
    }
  }

  function completeModuleName(query, word, parentFile) {
    var cx = infer.cx(), server = cx.parent, data = server.mod.requireJS;
    var currentName = stripJSExt(parentFile);
    var base = data.options.baseURL || "";
    if (base && base.charAt(base.length - 1) != "/") base += "/";

    if (query.caseInsensitive) word = word.toLowerCase();

    var completions = [], modules = data.interfaces;
    for (var name in modules) {
      if (name == currentName || !modules[name].getType()) continue;

      var moduleName = name.substring(base.length, name.length);
      if (moduleName &&
          !(query.filter !== false && word &&
            (query.caseInsensitive ? moduleName.toLowerCase() : moduleName).indexOf(word) !== 0))
        tern.addCompletion(query, completions, moduleName, modules[name]);
    }
    return completions;
  }

  var defs = {
    "!name": "requirejs",
    "!define": {
      module: {
        id: "string",
        uri: "string",
        config: "fn() -> ?"
      },
      config: {
        "!url": "http://requirejs.org/docs/api.html#config",
        baseUrl: {
          "!type": "string",
          "!doc": "the root path to use for all module lookups",
          "!url": "http://requirejs.org/docs/api.html#config-baseUrl"
        },
        paths: {
          "!type": "?",
          "!doc": "path mappings for module names not found directly under baseUrl. The path settings are assumed to be relative to baseUrl, unless the paths setting starts with a '/' or has a URL protocol in it ('like http:').",
          "!url": "http://requirejs.org/docs/api.html#config-paths"
        },
        shim: {
          "!type": "?",
          "!doc": "Configure the dependencies, exports, and custom initialization for older, traditional 'browser globals' scripts that do not use define() to declare the dependencies and set a module value.",
          "!url": "http://requirejs.org/docs/api.html#config-shim"
        },
        map: {
          "!type": "?",
          "!doc": "For the given module prefix, instead of loading the module with the given ID, substitute a different module ID.",
          "!url": "http://requirejs.org/docs/api.html#config-map"
        },
        config: {
          "!type": "?",
          "!doc": "There is a common need to pass configuration info to a module. That configuration info is usually known as part of the application, and there needs to be a way to pass that down to a module. In RequireJS, that is done with the config option for requirejs.config(). Modules can then read that info by asking for the special dependency 'module' and calling module.config().",
          "!url": "http://requirejs.org/docs/api.html#config-moduleconfig"
        },
        packages: {
          "!type": "?",
          "!doc": "configures loading modules from CommonJS packages. See the packages topic for more information.",
          "!url": "http://requirejs.org/docs/api.html#config-packages"
        },
        nodeIdCompat: {
          "!type": "?",
          "!doc": "Node treats module ID example.js and example the same. By default these are two different IDs in RequireJS. If you end up using modules installed from npm, then you may need to set this config value to true to avoid resolution issues.",
          "!url": "http://requirejs.org/docs/api.html#config-nodeIdCompat"
        },
        waitSeconds: {
          "!type": "number",
          "!doc": "The number of seconds to wait before giving up on loading a script. Setting it to 0 disables the timeout. The default is 7 seconds.",
          "!url": "http://requirejs.org/docs/api.html#config-waitSeconds"
        },
        context: {
          "!type": "number",
          "!doc": "A name to give to a loading context. This allows require.js to load multiple versions of modules in a page, as long as each top-level require call specifies a unique context string. To use it correctly, see the Multiversion Support section.",
          "!url": "http://requirejs.org/docs/api.html#config-context"
        },
        deps: {
          "!type": "?",
          "!doc": "An array of dependencies to load. Useful when require is defined as a config object before require.js is loaded, and you want to specify dependencies to load as soon as require() is defined. Using deps is just like doing a require([]) call, but done as soon as the loader has processed the configuration. It does not block any other require() calls from starting their requests for modules, it is just a way to specify some modules to load asynchronously as part of a config block.",
          "!url": "http://requirejs.org/docs/api.html#config-deps"
        },
        callback: {
          "!type": "fn()",
          "!doc": "A function to execute after deps have been loaded. Useful when require is defined as a config object before require.js is loaded, and you want to specify a function to require after the configuration's deps array has been loaded.",
          "!url": "http://requirejs.org/docs/api.html#config-callback"
        },
        enforceDefine: {
          "!type": "bool",
          "!doc": "If set to true, an error will be thrown if a script loads that does not call define() or have a shim exports string value that can be checked. See Catching load failures in IE for more information.",
          "!url": "http://requirejs.org/docs/api.html#config-enforceDefine"
        },
        xhtml: {
          "!type": "bool",
          "!doc": "If set to true, document.createElementNS() will be used to create script elements.",
          "!url": "http://requirejs.org/docs/api.html#config-xhtml"
        },
        urlArgs: {
          "!type": "string",
          "!doc": "Extra query string arguments appended to URLs that RequireJS uses to fetch resources. Most useful to cache bust when the browser or server is not configured correctly.",
          "!url": "http://requirejs.org/docs/api.html#config-urlArgs"
        },
        scriptType: {
          "!type": "string",
          "!doc": "Specify the value for the type='' attribute used for script tags inserted into the document by RequireJS. Default is 'text/javascript'. To use Firefox's JavaScript 1.8 features, use 'text/javascript;version=1.8'.",
          "!url": "http://requirejs.org/docs/api.html#config-scriptType"
        },
        skipDataMain: {
          "!type": "bool",
          "!doc": "Introduced in RequireJS 2.1.9: If set to true, skips the data-main attribute scanning done to start module loading. Useful if RequireJS is embedded in a utility library that may interact with other RequireJS library on the page, and the embedded version should not do data-main loading.",
          "!url": "http://requirejs.org/docs/api.html#config-skipDataMain"
        }
      },
      RequireJSError: {
        "prototype" : {
          "!proto": "Error.prototype",
          "requireType": {
            "!type": "string",
            "!doc": "A string value with a general classification, like 'timeout', 'nodefine', 'scripterror'.",
            "!url": "http://requirejs.org/docs/api.html#errors"
          },
          "requireModules": {
            "!type": "[string]",
            "!doc": "An array of module names/URLs that timed out.",
            "!url": "http://requirejs.org/docs/api.html#errors"
          }
        }
      }
    },
    requirejs: {
      "!type": "fn(deps: [string], callback: fn(), errback?: fn(err: +RequireJSError)) -> !custom:requirejs_require",
      onError: {
        "!type": "fn(err: +RequireJSError)",
        "!doc": "To detect errors that are not caught by local errbacks, you can override requirejs.onError()",
        "!url": "http://requirejs.org/docs/api.html#requirejsonerror"
      },
      load: {
        "!type": "fn(context: ?, moduleName: string, url: string)"
      },
      config: "fn(config: config) -> !custom:requirejs_config",
      version: "string",
      isBrowser: "bool"
    },
    require: "requirejs",
    define: {
      "!type": "fn(deps: [string], callback: fn()) -> !custom:requirejs_define",
      amd: {
        jQuery: "bool"
      }
    }
  };
});

});

define("plugins/c9.ide.language.javascript.tern/worker/tern_worker",[], function(require, exports, module) {
var acornHelper = require("./acorn_helper");
var tern = require("tern/lib/tern");
var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');
var handler = module.exports = Object.create(baseLanguageHandler);
var tree = require("treehugger/tree");
var util = require("plugins/c9.ide.language/worker_util");
var completeUtil = require("plugins/c9.ide.language/complete_util");
var filterDocumentation = require("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_util").filterDocumentation;
var getParameterDocs = require("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_util").getParameterDocs;
var architectResolver = null;
var inferCompleter = require("plugins/c9.ide.language.javascript.infer/infer_completer");

var TERN_DEFS = [];
var BUILTIN_PLUGINS = {
    doc_comment: require("tern/plugin/doc_comment"),
    es_modules: require("tern/plugin/es_modules"),
    modules: require("tern/plugin/modules"),
    node: require("tern/plugin/node"),
    node_resolve: require("tern/plugin/node_resolve"),
    requirejs: require("tern/plugin/requirejs"),
    architect_resolver: architectResolver,
};

var ternWorker;
var ternServerOptions = {};
var ternRequestOptions = {};
var fileCache = {};
var dirCache = {};
var firstClassDefs = [];
var lastAddPath;
var lastAddValue;
var lastCacheRead = 0;
var MAX_CACHE_AGE = 60 * 1000 * 10;
var MAX_FILE_SIZE = 200 * 1024;
var PRIORITY_DEFAULT = 5;
var PRIORITY_LIBRARY_GLOBAL = 0;
function mix() {
    var arg, prop, child = {};
    for (arg = 0; arg < arguments.length; arg += 1) {
        if (!arguments[arg]) {
            continue;
        }
        for (prop in arguments[arg]) {
            if (arguments[arg].hasOwnProperty(prop)) {
                child[prop] = arguments[arg][prop];
            }
        }
    }
    return child;
}


handler.handlesLanguage = function(language) {
    return language === "javascript" || language === "jsx";
};

handler.getCompletionRegex = function() {
    return (/^[\.]$/);
};

handler.getMaxFileSizeSupported = function() {
    return .25 * 10 * 1000 * 80;
};

handler.$recacheCompletionLength = 3;

handler.init = function(callback) {
    initTern();
    inferCompleter.setExtraModules(ternWorker.cx.definitions.node);

    ternWorker.on("beforeLoad", function(e) {
        var file = e.name;
        var dir = dirname(e.name);

        if (dir[0] != "/")
            return;

        if (!dirCache[dir])
            util.$watchDir(dir, handler);

        fileCache[file] = fileCache[file] || {};
        dirCache[dir] = dirCache[dir] || {};
        dirCache[dir].used = Date.now();
        dirCache[dir][file] = true;
        lastCacheRead = Date.now();
    });

    handler.sender.on("tern_set_def_enabled", function(e) {
        setDefEnabled(e.data.name, e.data.def, e.data.enabled, e.data.options);
    });

    handler.sender.on("tern_set_server_options", function(e) {
        setOptions(e.data);
    });

    handler.sender.on("tern_set_request_options", function(e) {
        if (e.data) {
            ternRequestOptions = e.data;
        }
    });

    handler.sender.on("tern_get_plugins", function(e) {
        var pluginName;
        var plugins = [];
        var pluginToList;
        for (pluginName in ternWorker.options.plugins) {
            pluginToList = {
                name: pluginName,
                enabled: ternWorker.options.plugins[pluginName]
            };
            plugins.push(pluginToList);
        }
        handler.sender.emit("tern_read_plugins", plugins);
    });

    handler.sender.on("tern_update_plugins", function(e) {
        updatePlugins(e.data);
    });

    util.$onWatchDirChange(onWatchDirChange);
    setInterval(garbageCollect, 60000);
    callback();
};

function initTern() {
    ternWorker = new tern.Server({
        async: ternServerOptions.async !== undefined ? ternServerOptions.async : true,
        defs: ternServerOptions.defs !== undefined ? ternServerOptions.defs : TERN_DEFS,
        plugins: ternServerOptions.plugins !== undefined ? ternServerOptions.plugins : {},
        dependencyBudget: ternServerOptions.dependencyBudget !== undefined ? ternServerOptions.dependencyBudget : MAX_FILE_SIZE,
        reuseInstances: ternServerOptions.reuseInstances !== undefined ? ternServerOptions.reuseInstances : true,
        normalizeFilename: function(file) {
            if (file[0] != "/")
                file = "/" + file;
            if (!file.match(/[\/\\][^/\\]*\.[^/\\]*$/))
                file += ".js";
            return file;
        },
        getFile: ternServerOptions.getFile !== undefined ? ternServerOptions.getFile : function(file, callback) {
            if (file == handler.path)
                return done(null, handler.doc.getValue());

            util.stat(file, function(err, stat) {
                if (stat && stat.size > MAX_FILE_SIZE) {
                    err = new Error("File is too large to include");
                    err.code = "ESIZE";
                }

                if (err)
                    return done(err);

                fileCache[file] = fileCache[file] || {};
                fileCache[file].mtime = stat.mtime;

                util.readFile(file, { allowUnsaved: true }, function(err, data) {
                    if (err) return done(err);

                    lastAddPath = null; // invalidate cache
                    done(null, data);
                });
            });

            function done(err, result) {
                try {
                    callback(err, result);
                }
                catch (err) {
                    console.error(err.stack);
                }
            }
        }
    });
}

var setOptions = module.exports.setOptions = function(options) {
    for (var o in options) {
        ternWorker.options[o] = ternServerOptions[o] = options[o];
    }
};
var updatePlugins = module.exports.updatePlugins = function(plugins) {
    var requiresReset = false;
    for (var p in plugins) {
        var targetPlugin = plugins[p];
        var plugin = ternWorker.options.plugins[targetPlugin.name];
        if (targetPlugin.name == "angular")
            continue;
        if (targetPlugin.firstClass)
            firstClassDefs.push(targetPlugin.name);
        if (typeof plugin === "undefined" && typeof targetPlugin.path === "string") {
            var loaded = require(targetPlugin.path);
            if (!loaded) {
                console.error("Could not load", targetPlugin.path);
                continue;
            }
            
            ternServerOptions.plugins = ternServerOptions.plugins || {};
            ternServerOptions.plugins[targetPlugin.name] = targetPlugin.enabled;

            if (targetPlugin.name === "architect_resolver")
                architectResolver = loaded;

            requiresReset = true;
        }
        else {
            if (plugin !== targetPlugin.enabled) {
                ternServerOptions.plugins = ternServerOptions.plugins || {};
                ternServerOptions.plugins[targetPlugin.name] = targetPlugin.enabled;
                requiresReset = true;
            }
        }
    }
    if (requiresReset)
        initTern();
    ternWorker.defs.forEach(function(d) {
        if (d["!name"] === "node")
            delete d.console;
    });
};

function onWatchDirChange(e) {
    var dir = e.data.path.replace(/\/?$/, "/");
    e.data.files.forEach(function(stat) {
        var file = dir + stat.name;
        if (!fileCache[file] || fileCache[file].mtime >= stat.mtime)
            return;
        ternWorker.delFile(file);
        delete fileCache[file];
        lastAddPath = null; // invalidate local file cache
    });
}

function garbageCollect() {
    var minAge = lastCacheRead - MAX_CACHE_AGE;

    for (var file in fileCache) {
        if (fileCache[file].used < minAge) {
            ternWorker.delFile(file);
            delete fileCache[file];
            if (lastAddPath === file)
                lastAddPath = null;
        }
    }

    for (var dir in dirCache) {
        if (dirCache[dir].used < minAge) {
            handler.sender.emit("unwatchDir", { path: dir });
            delete dirCache[file];
        }
    }
}

handler.onDocumentOpen = function(path, doc, oldPath, callback) {
    setJSXMode(path);
    callback();
};

handler.analyze = function(value, ast, options, callback) {
    if (fileCache[this.path])
        return callback();
    fileCache[this.path] = {
        mtime: 0, // prefer reloading since we may be unsaved
        used: Date.now()
    };
    addTernFile(this.path, value);

    if (!architectResolver)
        return callback();

    architectResolver.onceReady(function() {
        handler.$flush(function(err) {
            if (err) console.error(err.stack || err);
            callback();
        });
    });
};

handler.complete = function(doc, fullAst, pos, options, callback) {
    var node = options.node;
    if (!node ||
        ["FArg", "Function", "Arrow", "VarDecl", "VarDeclInit", "ConstDecl", "ConstDeclInit",
        "LetDecl", "LetDeclInit", "PropertyInit", "Label", "String"].indexOf(node.cons) > -1)
        return callback();

    addTernFile(this.path, doc.getValue());

    var line = doc.getLine(pos.row);
    var prefix = util.getPrecedingIdentifier(line, pos.column);
    var defaultOptions = {
        type: "completions",
        pos: pos,
        types: true,
        origins: true,
        docs: true,
        urls: true,
        guess: true,
        caseInsensitive: false,
    };
    var ternOptions = mix(defaultOptions, ternRequestOptions[defaultOptions.type]);
    handler.$request(ternOptions, function(err, result) {
        if (err) {
            console.error(err.stack || err);
            return callback();
        }

        callback(result.completions.map(function(match) {
            if (match.guess && match.type && match.type !== "fn()?)")
               return;
            if (match.type === "?")
                delete match.type;

            var isContextual = node.cons === "PropAccess" && !match.guess;

            if (!isContextual && match.origin === "browser" && prefix.length < 3)
                return; // skip completions like onchange (from window.onchange)

            var isFromLibrary = match.origin && match.origin[0] !== "/" && firstClassDefs.indexOf(match.origin) === -1;
            var priority = PRIORITY_DEFAULT;
            var icon = getIcon(match, priority);
            if (match.name[0] === '"') {
                if (match.origin !== "node")
                    return;
                match.name = match.name.replace(/"(.*)"/, "$1");
                icon = "package";
            }

            var isFunction = match.type && match.type.match(/^fn\(/);
            var isAnonymous = match.type && match.type.match(/^{/);
            var fullName;
            var fullNameTyped;
            if (isFunction) {
                var sig = getSignature(match);
                var parameters = sig.parameters;
                fullName = match.name + "(" + parameters.map(function(p) {
                    return p.name;
                }).join(", ") + ")";
                fullNameTyped = match.name + "(" + parameters.map(function(p) {
                    return p.name + (p.type ? " : " + p.type : "");
                }).join(", ") + ")";
                if (sig.returnType)
                    fullNameTyped = fullNameTyped + " : " + sig.returnType;
            }
            else {
                fullName = fullNameTyped = match.name;
                if (match.type)
                    fullNameTyped = fullNameTyped + " : " + match.type;
            }

            var doc = (match.type && !isFunction && !isAnonymous ? "Type: " + match.type + "<p>" : "")
                    + (match.doc ? filterDocumentation(match.doc) : "");
            if (match.doc === "Every function in JavaScript is actually a Function object.")
                doc = "";
            return {
                id: match.name,
                name: fullName,
                replaceText: match.name + (isFunction ? "(^^)" : ""),
                icon: icon,
                priority: priority,
                isContextual: isContextual,
                docHead: fullNameTyped,
                doc: (match.origin && isFromLibrary ? "Origin: " + match.origin + "<p>" : "") + doc,
                docUrl: match.url,
                isFunction: isFunction,
                url: match.url
            };
        }).filter(function(c) {
            return c;
        }));
    });
};

handler.jumpToDefinition = function(doc, fullAst, pos, options, callback) {
    addTernFile(this.path, doc.getValue());
    var defaultOptions = {
        type: "definition",
        pos: pos,
        types: true,
        origins: true,
        docs: true,
        urls: true,
        caseInsensitive: false,
    };
    var ternOptions = mix(defaultOptions, ternRequestOptions[defaultOptions.type]);
    this.$request(ternOptions, function(err, result) {
        if (err) {
            console.error(err.stack || err);
            return callback();
        }
        if (!result.file)
            return callback();
        if (!result.file.match(/[\/\\][^/\\]*\.[^/\\]*$/))
            result.file += ".js";
        callback({
            path: result.file,
            row: result.start.line,
            column: result.start.ch,
            icon: getIcon(result, PRIORITY_DEFAULT)
        });
    });
};

handler.tooltip = function(doc, fullAst, cursorPos, options, callback) {
    var node = options.node;
    if (!node)
        return callback();
    var argIndex = -1;

    var callNode = getCallNode(node, cursorPos);
    var displayPos;

    if (callNode) {
        var argPos = { row: callNode[1].getPos().sl, column: callNode[1].getPos().sc };
        if (argPos.row >= 9999999999)
            argPos = cursorPos;

        var endLine = callNode.getPos().el;
        if (callNode[1].length && callNode[1].getPos().el !== callNode.getPos().el)
            endLine--; // put tooltip near end of arguments, not end of call
        displayPos = { row: endLine, column: callNode[1].getPos().sc };
        argIndex = this.getArgIndex(callNode, doc, cursorPos);
    }
    else if (node.isMatch('Var(_)')) {
        displayPos = { row: node.getPos().sl, column: node.getPos().sc };
        argIndex = -1;
        if (cursorPos.column === node.getPos().ec)
            return callback();
    }
    else {
        return callback();
    }

    if (argIndex === -1 && callNode)
        return callback();

    if (!callNode)
        return callback(); // TODO: support this case??

    addTernFile(this.path, doc.getValue());
    var defaultOptions = {
        type: "type",
        pos: { row: callNode[0].getPos().el, column: callNode[0].getPos().ec },
        types: true,
        origins: true,
        docs: true,
        urls: true,
        caseInsensitive: false,
        preferFunction: true,
    };
    var ternOptions = mix(defaultOptions, ternRequestOptions[defaultOptions.type]);
    this.$request(ternOptions, function(err, result) {
        if (err) {
            console.error(err.stack || err);
            return callback();
        }
        if (!result.type || !result.name || !result.type.match(/^fn\(/))
            return callback();

        var rangeNode = callNode && callNode.getPos().sc < 99999 ? callNode : node;
        var sig = getSignature(result);
        if (sig.parameters[argIndex])
            sig.parameters[argIndex].active = true;

        var parameterDocs = getParameterDocs(result.doc);
        sig.parameters.forEach(function(p) {
            if (p.type === "?")
                delete p.type;
            if (parameterDocs["_" + p.name])
                p.docHtml = parameterDocs["_" + p.name];
        });
        if (sig.returnType === "?")
            delete sig.returnType;
        if (sig.returnType === "[]")
            sig.returnType = "Array";

        callback({
            hint: {
                signatures: [{
                    name: result.name.replace(/.*\./, ""),
                    docHtml: result.doc && result.doc.replace(/^\* /g, ""),
                    parameters: sig.parameters,
                    returnType: sig.returnType
                }],
            },
            displayPos: displayPos,
            pos: rangeNode.getPos()
        });
    });
};
handler.getArgIndex = function(node, doc, cursorPos) {
    var cursorTreePos = { line: cursorPos.row, col: cursorPos.column };
    var result = -1;
    node.rewrite(
        'Call(e, args)', "New(e, args)", function(b) {
            result = -1;
            var line = doc.getLine(cursorPos.row);
            if (line[b.args.getPos().ec + 1] && line[b.args.getPos().ec + 1].match(/[ ,]/))
                b.args.getPos().ec++;

            if (b.args.length === 0 && this.getPos().ec - 1 === cursorPos.column) {
                result = 0;
            }
            else if (b.args.length === 0 && line.substr(cursorPos.column).match(/^\s*\)/)) {
                result = 0;
            }
            else if (!tree.inRange(this.getPos(), cursorTreePos, true)) {
                return this;
            }
            else if (cursorPos.row === this.getPos().sl && line.substr(0, cursorPos.column + 1).match(/,\s*\)$/)) {
                result = b.args.length;
                return this;
            }
            for (var i = 0; i < b.args.length; i++) {
                if (b.args[i].cons === "ERROR" && result === -1) {
                    result = i;
                    break;
                }
                b.args[i].traverseTopDown(function() {
                    var pos = this.getPos();
                    if (this === node) {
                        result = i;
                        return this;
                    }
                    else if (pos && pos.sl <= cursorPos.row && pos.sc <= cursorPos.column) {
                        if (pos.sl === cursorPos.row && pos.ec === cursorPos.column - 1 && line[pos.ec] === ")")
                            return result = -1;
                        result = i;
                    }
                });
            }
            return this;
        }
    );
    return result;
};

function getCallNode(currentNode, cursorPos) {
    var result;
    var previous;
    currentNode.traverseUp(
        'Call(e, args)', 'New(e, args)', function(b, node) {
            if (b.e === previous)
                return;
            result = node;
            return node;
        },
        'Function(x, args, body)', 'Arrow(args, body)', function(b, node) {
            if (node !== currentNode)
                return node;
            previous = node;
        },
        'PropertyInit(x, _)', 'Method(x, body)', function(b, node) {
            return node;
        },
        function(node) {
            previous = node;
        }
    );
    return result;
}

function getIcon(property, priority) {
    if (property.guess || !property.type || property.type === "fn()?") {
        return property.type ? "method2" : "property2";
    }
    else if (property.type.match(/^fn\(/)) {
        return priority ? "method" : "method2";
    }
    else {
        return priority ? "property" : "property2";
    }
}

function addTernFile(path, value) {
    if (lastAddPath === path && lastAddValue === value)
        return;
    lastAddPath = path;
    lastAddValue = value;
    setJSXMode(path);
    ternWorker.addFile(path, value);
}

function dirname(path) {
    return path.replace(/[\/\\][^\/\\]*$/, "");
}
function getSignature(property) {
    if (!property.type || !property.type.match(/^fn\(/))
        return { parameters: []};
    var sig = property.type;
    var parameters = [{ name: "", type: "" }];
    var parameterIndex = 0;
    var returnType = "";
    var depth = 0;
    var inType = false;
    var inReturn = false;
    for (var i = "fn(".length; i < sig.length; i++) {
        switch (sig[i]) {
            case "(": case "{":
                depth++; break;
            case ")": case "}":
                depth--; break;
            case ":":
                inType = true; break;
            case ",":
                if (depth)
                    break;
                inType = false;
                parameters.push({ name: "", type: "" });
                parameterIndex++;
                break;
            case " ":
                break;
            case "-": // ->
                if (depth >= 0)
                    break;
                i++;
                depth++;
                inType = false;
                inReturn = true;
                break;
            case "?":
                if (!depth && inType && parameters[parameterIndex].type)
                    parameters[parameterIndex].name = "[" + parameters[parameterIndex].name + "]";
                break;
            default:
                if (sig[i] === "]")
                    depth--;
                if (!depth && inReturn)
                    returnType += sig[i];
                else if (!depth && !inType)
                    parameters[parameterIndex].name += sig[i];
                else if (!depth && inType)
                    parameters[parameterIndex].type += sig[i];
                if (sig[i] === "[")
                    depth++;
        }
    }

    parameters.forEach(function(p) {
        if (p.type === "?")
            delete p.type;
        if (p.type === "[]")
            p.type = "Array";
        if (p.type)
            p.type = p.type.replace(/\.prototype$/, "").replace(/.*\./, "");
    });


    if (parameters[0].name === "")
        parameters.shift();

    return {
        parameters: parameters,
        returnType: returnType && returnType.replace(/\.prototype$/, "").replace(/.*\./, "")
    };
}

handler.$request = function(query, callback) {
    query.file = this.path;
    setJSXMode(this.path);

    if (query.pos)
        query.end = query.start = {
            line: query.pos.row || query.pos.sl || 0,
            ch: query.pos.column || query.pos.sc || 0
        };
    query.lineCharPositions = true;

    try {
        ternWorker.request(
            {
                query: query,
            },
            done
        );
    }
    catch (err) {
        if (isDone) throw err;
        return done(err);
    }

    var isDone;
    function done(err, result) {
        isDone = true;
        callback(err, result);
    }
};

handler.$flush = function(callback) {
    try {
        ternWorker.flush(done);
    }
    catch (err) {
        if (isDone) throw err;
        return done(err);
    }

    var isDone;
    function done(err, result) {
        isDone = true;
        callback(err, result);
    }
};
function setDefEnabled(name, def, enabled, options) {
    if (options && options.firstClass)
        firstClassDefs.push(name);
    
    var i;
    if (!enabled) {
        ternWorker.defs = ternWorker.defs.filter(function(d) {
            return d["!name"] !== name;
        });
        ternWorker.reset();
        ternServerOptions.defs = ternWorker.defs;
        return;
    }

    var defs = def instanceof Array ? def : [def];
    var downloaded = 0;
    defs.forEach(function(def) {
        if (typeof def !== "string") {
            ternWorker.defs.push(def);
            return checkDone();
        }
            
        completeUtil.fetchText(def, function(err, result) {
            if (err) console.error(err);
            try {
                result = JSON.parse(result);
            }
            catch (err) {
                console.error(err);
                result = null;
            }

            ternWorker.defs.push(result);
            checkDone();
        });
    });
    function checkDone() {
        if (++downloaded < defs.length)
            return;
        ternServerOptions.defs = ternWorker.defs;
        ternWorker.reset();
    }
}

function setJSXMode(path) {
    acornHelper.setLanguage(/\.jsx$/.test(path) ? "jsx" : null);
}

});

define("plugins/c9.ide.language.css/css_handler",[], function(require, exports, module) {

var baseLanguageHandler = require("plugins/c9.ide.language/base_handler");
var CSSLint = null;
var handler = module.exports = Object.create(baseLanguageHandler);

handler.handlesLanguage = function(language) {
    return language === "css" || language === "less";
};

handler.analyze = function(value, ast, options, callback) {
    if (this.language === "less")
        return callback();
    
    if (!CSSLint) {
        return require(["ace/mode/css/csslint"], function(m) {
            CSSLint = m.CSSLint;
            callback(handler.analyzeSync(value, ast));
        });
    }
    
    callback(handler.analyzeSync(value, ast));
};
var CSSLint_RULESET = {
    "adjoining-classes": 0,
    "box-model": 1,
    "box-sizing": 1,
    "compatible-vendor-prefixes": 3,
    "display-property-grouping": 1,
    "duplicate-background-images": 1,
    "duplicate-properties": 1,
    "empty-rules": 1,
    "errors": 2,
    "fallback-colors": 3,
    "floats": 1,
    "font-faces": 1,
    "font-sizes": 1,
    "gradients": 3,
    "ids": 0,
    "import": 0,
    "important": 3,
    "known-properties": 1,
    "outline-none": 3,
    "overqualified-elements": 1,
    "qualified-headings": 3,
    "regex-selectors": 1,
    "rules-count": 1,
    "shorthand": 1,
    "star-property-hack": 1,
    "text-indent": 1,
    "underscore-property-hack": 1,
    "unique-headings": 1,
    "universal-selector": 1,
    "unqualified-attributes": 1,
    "vendor-prefix": 3,
    "zero-units": 0
};

handler.analyzeSync = function(value, ast) {
    value = value.replace(/^(#!.*\n)/, "//$1");

    if (!CSSLint)
        return;
    
    var results = value && CSSLint.verify(value, CSSLint_RULESET);
    var warnings = results ? results.messages : [];

    return warnings.map(function(warning) {
        if (CSSLint_RULESET[warning.rule.id] === 3)
            warning.type = "info";
        return {
            pos: {
                sl: warning.line - 1,
                sc: warning.col - 1
            },
            type: warning.type,
            level: warning.type,
            message: warning.message
        };
    });
};

handler.getIdentifierRegex = function() {
    return (/[_a-zA-Z0-9-]/);
};

});

define("plugins/c9.ide.language.html/snippets",[], function(require, exports, module) {

module.exports = {
    "script": "<script type=\"text/javascript\" src=\"^^\"></script>",
    "csslink": "<link rel=\"stylesheet\" href=\"^^\" type=\"text/css\" />",
    "link": "<link rel=\"stylesheet\" href=\"^^\" type=\"text/css\" />",
    "style": "<style type=\"text/css\">\n\t^^\n</style>",
    "amailto": "<a href=\"mailto:^^\"></a>",
    "html": "<!DOCTYPE html>\n<html>\n\t^^\n</html>",
    "body": "<body>\n\t^^\n</body>",
    "head": "<head>\n\t^^\n</head>",
    "table": "<table>\n\t<tr>\n\t\t<td>^^</td>\n\t</tr>\n</table>",
    "th": "<th>\n\t^^\n</th>",
    "tr": "<tr>\n\t^^\n</tr>",
    "td": "<td>^^</td>",
    "divc": "<div class=\"^^\"></div>",
    "div": "<div>^^</div>",
    "spanc": "<span class=\"^^\"></span>",
    "span": "<span>^^</span>",
    "form": "<form>\n\t<input type=\"text\" name=\"^^\"/>\n\t<input type=\"submit\" value=\"Submit\"/>\n</form>",
    "input": "<input type=\"text\" name=\"^^\"/>",
    "password": "<input type=\"password\" name=\"^^\"/>",
    "textarea": "<input type=\"textarea\" name=\"^^\"/>",
    "img": "<img src=\"^^\"></img>",
    "label": "<label for=\"\">^^</label>",
    "lorem": "Lorem ipsum dolor sit amet, consectetuer adipiscing elit,\nsed diam nonummy nibh euismod tincidunt ut laoreet dolore\nmagna aliquam erat volutpat. Ut wisi enim ad minim veniam,\nquis nostrud exerci tation ullamcorper suscipit lobortis nisl\nut aliquip ex ea commodo consequat. Duis autem vel eum iriure\ndolor in hendrerit in vulputate velit esse molestie consequat,\nvel illum dolore eu feugiat nulla facilisis at vero eros et\naccumsan et iusto odio dignissim qui blandit praesent luptatum\nzzril delenit augue duis dolore te feugait nulla facilisi.\nNam liber tempor cum soluta nobis eleifend option congue\nnihil imperdiet doming id quod mazim placerat facer possim\nassum. Typi non habent claritatem insitam; est usus legentis\nin iis qui facit eorum claritatem. Investigationes\ndemonstraverunt lectores legere me lius quod ii legunt saepius.\nClaritas est etiam processus dynamicus, qui sequitur mutationem\nconsuetudium lectorum. Mirum est notare quam littera gothica,\nquam nunc putamus parum claram, anteposuerit litterarum formas\nhumanitatis per seacula quarta decima et quinta decima. Eodem\nmodo typi, qui nunc nobis videntur parum clari, fiant sollemnes\nin futurum.^^"
};

});

define("plugins/c9.ide.language.html/html_completer",[], function(require, exports, module) {

var completeUtil = require("plugins/c9.ide.language/complete_util");
var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');
var htmlSnippets = require("./snippets");

var completer = module.exports = Object.create(baseLanguageHandler);

completer.handlesLanguage = function(language) {
    return language === "html";
};

var JADE_REGEX = /.*?([a-zA-Z]*)([.#])([\w]+)/;
var JADE_ID_REGEX = /[a-zA-Z_0-9\$\_.#]/;

completer.getCompletionRegex = function() {
    return /[<=A-Za-z:_$\-]/;
};

completer.getIdentifierRegex = function() {
    return JADE_ID_REGEX;
};

completer.complete = function(doc, fullAst, pos, options, callback) {
    var line = doc.getLine(pos.row);
    var match = JADE_REGEX.exec(line.substring(0, pos.column));
    if (match) {
        var replaceText;
        var snippet = htmlSnippets[match[1]];
        if (snippet) {
            replaceText = snippet.replace("<" + match[1] + ">",
                ["<", match[1], match[2] === "." ? " class=\"" : " id=\"",
                    match[3], "\">"].join(""));
        }
        else {
            replaceText = ["<", match[1] || "div",
                match[2] === "." ? " class=\"" : " id=\"", match[3],
                "\">^^", "</", match[1] || "div", ">"].join("");
        }
        callback([{
              name: match[1] + match[2] + match[3],
              replaceText: replaceText,
              doc: "<pre>" + replaceText.replace("\^\^", "&#9251;").replace(/</g, "&lt;") + "</pre>",
              icon: null,
              meta: "Jade-Haml",
              identifierRegex: JADE_ID_REGEX,
              priority: 100
        }]);
    }
    else {
        var identifier = completeUtil.retrievePrecedingIdentifier(line, pos.column);
        var allIdentifiers = Object.keys(htmlSnippets);
        var matches = completeUtil.findCompletions(identifier, allIdentifiers);
        callback(matches.map(function(m) {
            return {
              name: m,
              replaceText: htmlSnippets[m],
              doc: "<pre>" + htmlSnippets[m].replace("\^\^", "&#9251;").replace(/</g, "&lt;") + "</pre>",
              icon: null,
              meta: "snippet",
              priority: 2
            };
        }));
    }
};


});

define("plugins/c9.ide.language.codeintel/worker/codeintel_worker",[], function(require, exports, module) {

var baseHandler = require("plugins/c9.ide.language/base_handler");
var workerUtil = require("plugins/c9.ide.language/worker_util");

var DAEMON_PORT = 10881;
var ERROR_PORT_IN_USE = 98;
var ERROR_NO_SERVER = 7;
var LANGUAGES = {
    c_cpp: "C++",
    css: "CSS",
    django: "Django",
    perl: "Perl",
    php: "PHP",
    ruby: "Ruby",
    tcl: "Tcl",
    html4: "HTML",
    html: "HTML5",
    rhtml: "RHTML",
    templatetoolkit: "TemplateToolkit",
    smarty: "Smarty",
    twig: "Twig",
    xslt: "XSLT",
    xul: "XUL",
    python: "Python",
    python3: "Python3",
    golang: "Go",
    javascript: "JavaScript",
    less: "Less",
    mason: "Mason",
    mustache: "Mustache",
    mxml: "MXML",
    nodejs: "Node.js",
    xbl: "XBL",
    xml: "XML",
};

var handler = module.exports = Object.create(baseHandler);
var languages = [];
var paths = {};
var server;
var launchCommand;
var enabled;
var daemon;
var lastInfoTimer;
var lastInfoPopup;

handler.handlesLanguage = function(language) {
    return languages.indexOf(language) > -1;
};

handler.addLanguage = function(language) {
    languages.push(language);
};

handler.$disableZeroLengthCompletion = true;

handler.init = function(callback) {
    var emitter = handler.getEmitter();
    emitter.on("setup", function(e) {
        server = e.server;
        launchCommand = e.launchCommand;
        paths = e.paths;
        enabled = e.enabled;
    });
    callback();
};

handler.onDocumentOpen = function(path, doc, oldPath, callback) {
    if (!launchCommand) return callback();
    
    ensureDaemon(callback);
};
handler.complete = function(doc, fullAst, pos, options, callback) {
    if (!enabled) return callback();
    
    if (options.language === "PHP" && !options.identifierPrefix && (!options.line[pos.column - 1] || " " === options.line[pos.column - 1]))
        return callback(new Error("Warning: codeintel doesn't support empty-prefix completions"));
    
    callDaemon("completions", handler.path, doc, pos, options, function(err, results, meta) {
        if (err) return callback(err);
        
        results && results.forEach(function beautifyCompletion(r) {
            r.isContextual = true;
            r.guessTooltip = true;
            r.nodoc = "always";
            r.replaceText = r.replaceText || r.name;
            r.priority = r.name[0] === "_" || r.replaceText === r.replaceText.toUpperCase() ? 3 : 4;
            r.icon = r.name[0] === "_" ? r.icon.replace(/2?$/, "2") : r.icon;
        });
        callback(null, results);
    });
};
handler.jumpToDefinition = function(doc, fullAst, pos, options, callback) {
    if (!enabled) return callback();
    
    callDaemon("definitions", handler.path, doc, pos, options, callback);
};
function callDaemon(command, path, doc, pos, options, callback) {
    ensureDaemon(function(err, dontRetry) {
        if (daemon && daemon.notInstalled)
            handler.getEmitter().emit("not_installed", { language: options.language });
        if (err) return callback(err);
        
        var start = Date.now();
        workerUtil.execAnalysis(
            "curl",
            {
                mode: "stdin",
                json: true,
                args: [
                    "-H", "Expect:", // don't wait for "100-Continue"
                    "-s", "--data-binary", "@-", // get input from stdin
                    "localhost:" + DAEMON_PORT + "?mode=" + command
                    + "&row=" + pos.row + "&column=" + pos.column
                    + "&language=" + LANGUAGES[options.language]
                    + "&path=" + encodeURIComponent(path.replace(/^\//, ""))
                    + "&dirs=" + (paths[options.language] || "").replace(/:/g, ",")
                    + (options.noDoc ? "&nodoc=1" : ""),
                ],
            },
            function onResult(err, stdout, stderr, meta) {
                if (err) {
                    if (err.code === ERROR_NO_SERVER && !dontRetry)
                        return callDaemon(command, path, doc, pos, options, callback);
                        
                    return callback(new Error("codeintel_server failed, not responding, or not installed yet"));
                }
                
                if (typeof stdout !== "object")
                    return callback(new Error("Couldn't parse codeintel output: " + stdout));
                
                console.log("[codeintel_worker] " + command + " in " + (Date.now() - start)
                    + "ms (ci: " + meta.serverTime + "ms): "
                    + doc.getLine(pos.row).substr(0, pos.column));

                callback(null, stdout, meta);
            }
        );
    });
}
function ensureDaemon(callback) {
    if (daemon)
        return done(daemon.err, true);

    daemon = {
        err: new Error("Still starting daemon, enhance your calm"),
        kill: function() {
            this.killed = true;
        },
        notInstalled: false,
    };
    
    workerUtil.spawn(
        "bash",
        {
            args: [
                "-c", launchCommand,
                "--", "$PYTHON -c '" + server + "' daemon --port " + DAEMON_PORT
            ],
        },
        function(err, child) {
            var output = "";
            if (err) {
                daemon.err = err;
                return workerUtil.showError("Could not start python completion daemon. Please reload to try again.");
            }
            daemon = child;
            daemon.err = null;
            
            if (daemon.killed)
                daemon.kill();
            var killTimer = setTimeout(daemon.kill.bind(daemon), 30 * 60 * 1000);
            
            child.stderr.on("data", function(data) {
                output += data;
                if (/!!Daemon listening/.test(data)) {
                    done();
                }
                else if (/^!!(Updating .*|Installing .*)/.test(data)) {
                    var message = RegExp.$1;
                    clearTimeout(lastInfoTimer);
                    lastInfoTimer = setTimeout(function() {
                        lastInfoPopup = workerUtil.showInfo(message, 5000);
                    }, 3000);
                }
                else if (/^!!Done(.*)/.test(data)) {
                    if (lastInfoPopup)
                        workerUtil.showInfo(RegExp.$1, 3000);
                    lastInfoPopup = null;
                }
                else if (/^!!Not installed/.test(data)) {
                    daemon.notInstalled = true;
                }
                else if (/^!!/.test(data)) {
                    workerUtil.showError(data);
                }
                else {
                    console.log("[codeintel_worker] " + data);
                }
            });
            child.on("exit", function(code) {
                clearInfoPopup();
                if (code === ERROR_PORT_IN_USE) // someone else running daemon?
                    return done(null, true);
                if (!code || /Daemon listening/.test(output)) // everything ok, try again later
                    daemon = null;
                clearTimeout(killTimer);
                done(code && new Error("[codeintel_worker] Daemon failed: " + output), true);
            });
        }
    );
    
    function clearInfoPopup() {
        clearTimeout(lastInfoTimer);
        lastInfoPopup && lastInfoPopup.hide();
    }
    
    function done(err, dontRetry) {
        callback && callback(err, dontRetry);
        callback = null;
        handler.sender.emit("codeintel_ready", { err: err && err.stack });
    }
}

});

define("plugins/c9.ide.language.codeintel/worker/ruby_completer",[], function(require, exports, module) {

var baseHandler = require("plugins/c9.ide.language/base_handler");
var codeintel = require("plugins/c9.ide.language.codeintel/worker/codeintel_worker");

var handler = module.exports = Object.create(baseHandler);
codeintel.addLanguage("ruby");

handler.handlesLanguage = function(language) {
    return language === "ruby";
};

handler.getIdentifierRegex = function() {
    return (/[a-zA-Z0-9_\x7f-\xff]/);
};

handler.getCompletionRegex = function() {
    return /[\.]/;
};

handler.getCacheCompletionRegex = function() {
    return new RegExp(
        "(\\b(if|while|for|switch)\\s*\\("
        + "|\\b\\w+\\s+"
        + "|(===?|!==?|[-+]=|[-+*%>?!|&{[])"
        + "|\\s)+"
    );
};

});

define("plugins/c9.ide.language.codeintel/worker/css_less_completer",[], function(require, exports, module) {

var baseHandler = require("plugins/c9.ide.language/base_handler");
var codeintel = require("plugins/c9.ide.language.codeintel/worker/codeintel_worker");

var handler = module.exports = Object.create(baseHandler);
codeintel.addLanguage("css");
codeintel.addLanguage("less");

handler.handlesLanguage = function(language) {
    return language === "css" || language === "less";
};

handler.getIdentifierRegex = function() {
    return (/[a-zA-Z0-9_\x7f-\xff\-]/);
};

handler.getCompletionRegex = function() {
    return /: $/;
};

handler.predictNextCompletion = function(doc, ast, pos, options, callback) {
    if (options.line[pos.column - 1] === ":")
        return callback({ predicted: " " });
    callback();
};

handler.getCacheCompletionRegex = function() {
    return new RegExp(
        "(\\b[\\.@\\w]+\\s+"
        + "|\\s)+"
    );
};

});

define("plugins/c9.ide.language.codeintel/worker/php_completer",[], function(require, exports, module) {

var baseHandler = require("plugins/c9.ide.language/base_handler");
var codeintel = require("plugins/c9.ide.language.codeintel/worker/codeintel_worker");

var handler = module.exports = Object.create(baseHandler);
codeintel.addLanguage("php");

handler.handlesLanguage = function(language) {
    return language === "php";
};

handler.$recacheCompletionLength = 3;

handler.getIdentifierRegex = function() {
    return (/[$$a-zA-Z0-9_\x7f-\xff]/);
};

handler.getCompletionRegex = function() {
    return (/(\$|->|::)$/);
};

handler.getCacheCompletionRegex = function() {
    return new RegExp(
        "(\\b(if|while|for|switch)\\s*\\("
        + "|\\b\\w+\\s+"
        + "|(===?|!==?|[-+]=|[-+*%>?!|&{[])"
        + "|\\s)+"
    );
};

handler.predictNextCompletion = function(doc, ast, pos, options, callback) {
    if (/\$[a-zA-Z0-9_\x7f-\xff]+-/.test(options.line.substr(0, pos.colomn)))
        return callback({ predicted: ">" });
    if (/\$[a-zA-Z0-9_\x7f-\xff]+:/.test(options.line.substr(0, pos.colomn)))
        return callback({ predicted: ":" });
    callback();
};

});

define("plugins/c9.ide.language.go/worker/go_completer",[], function(require, exports, module) {

var baseHandler = require("plugins/c9.ide.language/base_handler");
var workerUtil = require("plugins/c9.ide.language/worker_util");

var handler = module.exports = Object.create(baseHandler);
var daemon;
var enabled = true;

handler.handlesLanguage = function(language) {
    return language === "golang";
};

handler.init = function(callback) {
    var emitter = handler.getEmitter();
    emitter.on("set_go_config", function(e) {
        enabled = e.enabled;
    });
    callback();
};

handler.onDocumentOpen = function(path, doc, oldPath, callback) {
    ensureDaemon(callback);
};
handler.getCompletionRegex = function() {
    return (/^[\.]$/);
};
handler.getExpressionPrefixRegex = function() {
    return new RegExp(
        "(\\b(if|while|for|switch)\\s*\\("
        + "|\\b\\w+\\s+"
        + "|(==|!=|[-+]=|[-+*%<>?!|&{[])\\s*)+"
    );
};
handler.complete = function(doc, fullAst, pos, options, callback) {
    if (!enabled) return callback();
    
    ensureDaemon(function(err) {
        if (err) return callback(err);
        
        var start = Date.now();
        workerUtil.execAnalysis(
            "bash", // TODO: don't use bash here, better GOPATH handling
            {
                args: [
                    "-c",
                    "GOPATH=$HOME/.c9/gocode:$GOPATH ~/.c9/gocode/bin/gocode -f=json autocomplete " + getOffset(doc, pos)
                ],
                mode: "stdin",
                json: true,
            },
            function(err, response, responseErr, meta) {
                if (err) return callback(err);
                
                var results = response && response[1] && response[1].map(
                    function beautifyCompletion(r) {
                        r.isContextual = true;
                        r.guessTooltip = true;
                        if (/func\(/.test(r.type)) {
                            r.replaceText = r.name + "(^^)";
                            r.name += "()";
                            r.icon = "method";
                        }
                        else if (r.class === "package") {
                            r.icon = "package";
                        }
                        else {
                            r.icon = "property";
                        }
                        r.docHead = r.type;
                        r.priority = 4;
                        return r;
                    }
                );
                
                console.log("[go_completer] completed in " + (Date.now() - start)
                    + "ms (gocode: " + meta.serverTime + "ms): "
                    + doc.getLine(pos.row).substr(0, pos.column));
                callback(null, results);
            }
        );
    });
};

function getOffset(doc, pos) {
    var result = 0;
    var lines = doc.getAllLines();
    for (var i = 0; i < lines.length; i++) {
        if (i === pos.row)
            return result + pos.column;
        
        result += lines[i].length + 1;
    }
}

handler.predictNextCompletion = function(doc, fullAst, pos, options, callback) {
    if (!options.matches.length) {
        if (options.line[pos.column - 1] && /(?![{;})\]\s"'\+\-\*])./.test(options.line[pos.column - 1]))
            return callback(null, { predicted: "" });
    }
    var predicted = options.matches.filter(function(m) {
        return m.isContextual;
    });
    if (predicted.length !== 1 || predicted[0].icon === "method")
        return callback();
    console.log("[go_completer] Predicted our next completion will be for " + predicted[0].replaceText + ".");
    callback(null, {
        predicted: predicted[0].replaceText + ".",
        showEarly: predicted[0].class === "package"
    });
};
function ensureDaemon(callback) {
    if (daemon)
        return done(daemon.err);

    var loadingErr = new Error("Still starting daemon, enhance your calm");
    loadingErr.code = "ELOADING";
    daemon = {
        err: loadingErr,
        kill: function() {
            this.killed = true;
        }
    };
    
    workerUtil.spawn(
        "bash",
        {
            args: [
                "-c", "mkdir -p ~/.c9/gocode; GOPATH=$HOME/.c9/gocode go get -u github.com/nsf/gocode && ~/.c9/gocode/bin/gocode"
            ]
        },
        function(err, child) {
            if (err) return done(err);
            
            daemon = child;
            daemon.err = null;
            
            if (daemon.killed)
                daemon.kill();
            
            child.stderr.on("data", function(data) {
                console.log("[stderr]", data);
            });
            child.on("exit", function(code) {
                var tip = code === 127 ? " Please make sure go is on your PATH for bash." : "";
                done(code && "Error " + code + " starting daemon. " + tip);
            });
        }
    );
    
    function done(err) {
        if (err) {
            daemon.err = err;
            if (err.code !== "ELOADING")
                workerUtil.showError("Could not setup or start Go completion daemon. Please reload to try again.");
            return callback(err);
        }
        callback();
    }
}

});

define("plugins/c9.ide.language.python/worker/python_jsonalyzer",[], function(require, exports, module) {

var jsonalyzer = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_worker");
var PluginBase = require("plugins/c9.ide.language.jsonalyzer/worker/jsonalyzer_base_handler");
var ctagsUtil = require("plugins/c9.ide.language.jsonalyzer/worker/ctags/ctags_util");

var TAGS = [
    { regex: /(?:^|\n)\s*class\s+([^ \(:]+)/g, kind: "unknown2" },
    { regex: /(?:^|\n)\s*def\s+(?!_)([^ \(:]+)/g, kind: "method2", indent: 1 },
    { regex: /(?:^|\n)\s*def\s+(?!__[^ \(:]+__)(_[^ \(]*)/g, kind: "method2", indent: 1 },
    { regex: /(?:^|\n)\s*def\s+(__[^ \(:]+__)/g, kind: "property2", indent: 1 },
    {
        regex: new RegExp(
            "(?:^|\\n)\\s*import\\s+([^ \\(]+)"
        ),
        kind: "import"
    }
];
var GUESS_FARGS = true;
var EXTRACT_DOCS = true;

var handler = module.exports = Object.create(PluginBase);

handler.languages = ["py"];

handler.extensions = ["py"];

handler.analyzeCurrent = function(path, doc, ast, options, callback) {
    if (doc === "")
        return callback(null, {});
        
    if (doc.length > jsonalyzer.getMaxFileSizeSupported())
        return callback(null, {});
    
    var results = {};
    TAGS.forEach(function(tag) {
        if (tag.kind === "import")
            return;
        ctagsUtil.findMatchingTags(path, doc, tag, GUESS_FARGS, EXTRACT_DOCS, results);
    });

    return callback(null, { properties: results });
};

handler.analyzeOthers = handler.analyzeCurrentAll;

handler.findImports = function(path, doc, ast, options, callback) {
    callback(null, ctagsUtil.findMatchingOpenFiles(path));
};

});

define("plugins/c9.ide.language.python/worker/python_completer",[], function(require, exports, module) {

var baseHandler = require("plugins/c9.ide.language/base_handler");
var workerUtil = require("plugins/c9.ide.language/worker_util");

var KEYWORD_REGEX = new RegExp(
    "^(and|as|assert|break|class|continue|def|del|elif|else|except|exec|"
    + "finally|for|from|global|if|import|in|is|lambda|not|or|pass|print|"
    + "raise|return|try|while|with|yield)$"
);
var DAEMON_PORT = 10880;
var ERROR_PORT_IN_USE = 98;
var ERROR_NO_SERVER = 7;

var handler = module.exports = Object.create(baseHandler);
var pythonVersion = "python2";
var enabled;
var pythonPath = "";
var jediServer;
var launchCommand;
var showedJediError;
var daemon;

handler.handlesLanguage = function(language) {
    return language === "python";
};

handler.init = function(callback) {
    var emitter = handler.getEmitter();
    emitter.on("set_python_config", function(e) {
        pythonVersion = e.pythonVersion;
        pythonPath = e.pythonPath;
        enabled = e.completion;
        if (daemon) {
            daemon.kill();
            daemon = null;
        }
    });
    emitter.on("set_python_scripts", function(e) {
        jediServer = e.jediServer;
        launchCommand = e.launchCommand;
    });
    callback();
};

handler.getIdentifierRegex = function() {
    return /\w/;
};

handler.getCompletionRegex = function() {
    return (/(\.|\b(import|from|if|while|from|raise|return) |% )$/); 
};

handler.getCacheCompletionRegex = function() {
    return / ?(\b\w+\s+|\b(if|while|for|print)\s*\(|([{[\-+*%<>!|&/,%]|==|!=)\s*)*/;
};

handler.onDocumentOpen = function(path, doc, oldPath, callback) {
    if (!enabled) return callback();
    ensureDaemon(callback);
};
handler.complete = function(doc, fullAst, pos, options, callback) {
    if (!enabled) return callback();
    
    callDaemon("completions", handler.path, doc, pos, options, function(err, results, meta) {
        if (err) return callback(err);
        
        results && results.forEach(function beautifyCompletion(r) {
            r.isContextual = true;
            r.guessTooltip = true;
            r.replaceText = r.replaceText || r.name;
            r.priority = r.name[0] === "_" || r.replaceText === r.replaceText.toUpperCase() ? 3 : 4;
            r.icon = r.icon || "property";
            r.icon = r.name[0] === "_" ? r.icon.replace(/2?$/, "2") : r.icon;
            r.noDoc = options.noDoc;
            if (!r.doc)
                return;
            if (r.replaceText === "print(^^)" && pythonVersion === "python2" && !/\.[^ ]*$/.test(options.line.substr(pos.column)))
                r.replaceText = "print";
            var docLines = r.doc.split(/\r\n|\n|\r/);
            var docBody = docLines.slice(2).join("\n");
            r.docHeadHtml = workerUtil.filterDocumentation(docLines[0]).replace(/^([A-Za-z0-9$_]+\()self, /, "$1");
            r.doc = workerUtil.filterDocumentation(docBody.replace(/``/g, "'"));
        });
        callback(null, results);
    });
};
handler.jumpToDefinition = function(doc, fullAst, pos, options, callback) {
    if (!enabled) return callback();
    
    callDaemon("goto_definitions", handler.path, doc, pos, options, callback);
};
handler.predictNextCompletion = function(doc, fullAst, pos, options, callback) {
    var line = options.line;
    if (!options.matches.length) {
        if (line[pos.column - 1] && /(?![:)}\]\s"'\+\-\*])./.test(line[pos.column - 1]))
            return callback(null, { predicted: "" });
    }
    var predicted = options.matches.filter(function(m) {
        return m.isContextual
            && !m.replaceText.match(KEYWORD_REGEX);
    });
    if (predicted.length > 0 && "import".substr(0, line.length) === line)
        return callback(null, { predicted: "import " });
    if (predicted.length !== 1 || predicted[0].icon === "method")
        return callback();
    if (/^\s+import /.test(line))
        return callback();
    console.log("[python_completer] Predicted our next completion will be for " + predicted[0].replaceText + ".");
    callback(null, {
        predicted: predicted[0].replaceText + ".",
        showEarly: predicted[0].replaceText === "self" || predicted[0].icon === "package"
    });
};
function callDaemon(command, path, doc, pos, options, callback) {
    ensureDaemon(function(err, dontRetry) {
        if (err) return callback(err);
        
        var start = Date.now();
        workerUtil.execAnalysis(
            "curl",
            {
                mode: "stdin",
                json: true,
                args: [
                    "-s", "--data-binary", "@-", // get input from stdin
                    "-H", "Expect:", // don't wait for "100-Continue"
                    "localhost:" + DAEMON_PORT + "?mode=" + command
                    + "&row=" + (pos.row + 1) + "&column=" + pos.column
                    + "&path=" + encodeURIComponent(path.replace(/^\//, ""))
                    + (options.noDoc ? "&nodoc=1" : ""),
                ],
            },
            function onResult(err, stdout, stderr, meta) {
                if (err) {
                    if (err.code === ERROR_NO_SERVER && !dontRetry)
                        return callDaemon(command, path, doc, pos, options, callback);
                    return callback(new Error("jedi_server failed or not responding"));
                }
                
                if (typeof stdout !== "object")
                    return callback(new Error("Couldn't parse python-jedi output: " + stdout));
                
                console.log("[python_completer] " + command + " in " + (Date.now() - start)
                    + "ms (jedi: " + meta.serverTime + "ms): "
                    + doc.getLine(pos.row).substr(0, pos.column));

                callback(null, stdout, meta);
            }
        );
    });
}
function ensureDaemon(callback) {
    if (daemon)
        return done(daemon.err, true);

    daemon = {
        err: new Error("Still starting daemon, enhance your calm"),
        kill: function() {
            this.killed = true;
        }
    };
    
    workerUtil.spawn(
        "bash",
        {
            args: [
                "-c", launchCommand, "--", pythonVersion,
                "$PYTHON -c '" + jediServer + "' daemon --port " + DAEMON_PORT
            ],
            env: { PYTHONPATH: pythonPath },
        },
        function(err, child) {
            var output = "";
            if (err) {
                daemon.err = err;
                return workerUtil.showError("Could not start python completion daemon. Please reload to try again.");
            }
            daemon = child;
            daemon.err = null;
            
            if (daemon.killed)
                daemon.kill();
            var killTimer = setTimeout(daemon.kill.bind(daemon), 30 * 60 * 1000);
            
            child.stderr.on("data", function(data) {
                output += data;
                if (/Daemon listening/.test(data))
                    done();
            });
            child.on("exit", function(code) {
                if (code === ERROR_PORT_IN_USE) // someone else running daemon?
                    return done(null, true);
                if (!code || /Daemon listening/.test(output)) // everything ok, try again later
                    daemon = null;
                clearTimeout(killTimer);
                done(code && new Error("[python_completer] Daemon failed: " + output), true);
            });
        }
    );
    
    function done(err, dontRetry) {
        if (err && /No module named jedi/.test(err.message) && !showedJediError) {
            workerUtil.showError("Jedi not found. Please run 'pip install jedi' or 'sudo pip install jedi' to enable Python code completion.");
            showedJediError = true;
        }
        callback && callback(err, dontRetry);
        handler.sender.emit("python_completer_ready");
        callback = null;
    }
}

});

define("plugins/c9.ide.language.python/worker/python_linter",[], function(require, exports, module) {

var baseHandler = require("plugins/c9.ide.language/base_handler");
var workerUtil = require("plugins/c9.ide.language/worker_util");

var handler = module.exports = Object.create(baseHandler);
var pythonVersion = "python2";
var pythonPath = "";
var pylintFlags = "";
var launchCommand;
var hosted;
var PYLINT_DEFAULTS = [
    "-d", "all",
    "-e", "E", 
    "-e", "F", 
    "-e", "W0101", // Unreachable code
    "-e", "W0109", // Duplicate key in dictionary
    "-e", "W0199", // Assert called on a 2-tuple. Did you mean \'assert x,y\'?
    "-e", "W0612", // Unused variable
    "-e", "W0602", // Used global without assignment
];
var PYLINT_CONFIG = [
    "-r", "n", 
    "--msg-template={line}:{column}:\\ [{msg_id}]\\ {msg}",
    "--load-plugins", "pylint_flask,pylint_django",
];

handler.handlesLanguage = function(language) {
    return language === "python";
};

handler.init = function(callback) {
    var emitter = handler.getEmitter();
    emitter.on("set_python_config", function(e) {
        pythonVersion = e.pythonVersion;
        pythonPath = e.pythonPath;
        pylintFlags = e.pylintFlags;
    });
    emitter.on("set_python_scripts", function(e) {
        launchCommand = e.launchCommand;
        hosted = e.hosted;
    });
    callback();
};

handler.analyze = function(docValue, fullAst, options, callback) {
    var commands = hosted
        ? ["-c", pythonVersion === "python2" ? "pylint2" : "pylint3"]
        : ["-c", launchCommand, "--", pythonVersion, "$ENV/bin/pylint"];
    commands[commands.length - 1] += " " + (pylintFlags || PYLINT_DEFAULTS.join(" "))
        + " " + PYLINT_CONFIG.join(" ")
        + " '$FILE'";
    if (!launchCommand)
        return callback(new Error("Warning: python_linter not initialized yet"));

    var hasStarImports = /from\s+[^\s]+\s+import\s+\*/.test(docValue);
    var markers = [];
    workerUtil.execAnalysis(
        "bash",
        {
            mode: "local-tempfile",
            args: commands,
            maxCallInterval: 800,
            env: {
                PYTHONPATH: pythonPath,
                PYLINTHOME: "/tmp/.pylint.d",
            }
        },
        function(err, stdout, stderr) {
            if (err && !stdout) return callback(err);

            stdout.split("\n").forEach(function(line) {
                var marker = parseLine(line, hasStarImports);
                marker && markers.push(marker);
            });
            
            callback(null, markers);
        }
    );
};

function parseLine(line, hasStarImports) {
    var match = line.match(/(\d+):(\d+): \[([^\]]+)\] (.*)/);
    if (!match)
        return;
    var row = match[1];
    var column = match[2];
    var code = match[3];
    var message = match[4];
    var level = getLevel(code);
    
    if (/print statement used/.test(message))
        return;
    if (hasStarImports && /undefined variable/i.test(message)) {
        level = "info";
        message += "?";
    }
    if (/E0632/.test(code))
        level = "info";
    if (/E1128|E0633/.test(code))
        level = "warning";
    if (/E0401/.test(code))
        return;
    if (/Django is not available on/.test(message))
        return;
        
    return {
        pos: {
            sl: parseInt(row, 10) - 1,
            sc: parseInt(column, 10)
        },
        message: message,
        code: code,
        level: level
    };
}

function getLevel(code) {
    if (code[0] === "E" || code[0] === "F")
        return "error";
    if (code === "W0612") // unused variable
        return "info";
    if (code === "W0602") // global without assignment
        return "info";
    return "warning";
}

});

define("plugins/c9.ide.language.javascript.infer/infer_jumptodef",[], function(require, exports, module) {

var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');
var handler = module.exports = Object.create(baseLanguageHandler);
var infer = require("./infer");
var path = require("./path");
var astUpdater = require("./ast_updater");

handler.handlesLanguage = function(language) {
    return language === "javascript" || language === "jsx";
};

handler.jumpToDefinition = function(doc, fullAst, pos, options, callback) {
    if (!fullAst || !options.node)
        return callback();
    
    var results = [];
    var basePath = path.getBasePath(handler.path, handler.workspaceDir);
    var filePath = path.canonicalizePath(handler.path, basePath);
    
    astUpdater.updateOrReanalyze(doc, fullAst, filePath, basePath, pos, function(fullAst, currentNode) {
        if (!currentNode)
            return callback();
        
        currentNode.rewrite(
            'PropAccess(o, p)', function(b, node) {
                var values = infer.inferValues(b.o);
                values.forEach(function(v) {
                    jumpToProperty(v, b.p.value, results);
                });
            },
            'Var(v)', function(b, node) {
                jumpToVar(node, results);
            },
            'Call(Var("require"), [String(_)])', function(b, node) {
                jumpToRequire(node, results);
            },
            'Var("require")', function(b, node) {
                if (node.parent &&
                    node.parent.isMatch('Call(Var("require"), [_])'))
                jumpToRequire(node.parent, results);
            },
            'String(_)', function(b, node) {
                if (node.parent && node.parent.parent &&
                    node.parent.parent.isMatch('Call(Var("require"), [_])'))
                jumpToRequire(node.parent.parent, results);
            }
        );
    });
        
    callback(results);
};

var jumpToRequire = function(node, results) {
    var values = infer.inferValues(node);
    values.forEach(function(v) {
        if (v.path)
            results.push({
                path: v.path,
                row: v.row,
                icon: "package"
            });
    });
};

var jumpToProperty = module.exports.jumpToProperty = function(value, property, results) {
    var prop = value.properties && value.properties["_" + property];
    if (prop && prop[0])
        prop = prop[0];
    if (!prop || (!value.path && !prop.path && !prop.row))
        return;
    results.push({
        row: prop.row,
        column: prop.column,
        path: prop.path || value.path,
        icon: "property"
    });
};

var jumpToVar = function(node, results) {
    var values = infer.inferValues(node);
    values.forEach(function(v) {
        if (!v.path && !v.row)
            return;
        results.push({
            row: v.row,
            path: v.path,
            icon: "property"
        });
    });
};

});

define("plugins/c9.ide.language.javascript.immediate/immediate_complete_static",[], function(require, exports, module) {

var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');

var handler = module.exports = Object.create(baseLanguageHandler);

var scopeAnalyzer = require("plugins/c9.ide.language.javascript/scope_analyzer");
var inferCompleter = require("plugins/c9.ide.language.javascript.infer/infer_completer");
    
handler.handlesLanguage = function(language) {
    return language === "javascript";
};

handler.handlesEditor = function() {
    return this.HANDLES_IMMEDIATE;
};

handler.complete = function(doc, fullAst, pos, options, callback) {
    return scopeAnalyzer.complete(doc, fullAst, pos, options, function(results) {
        var allResults = results || [];
        inferCompleter.complete(doc, fullAst, pos, options, function(results) {
            callback(allResults.concat(results || []));
        });
    });
};

});

define("plugins/c9.ide.language.javascript.immediate/immediate_complete",[], function(require, exports, module) {

var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');

var handler = module.exports = Object.create(baseLanguageHandler);
    
handler.handlesLanguage = function(language) {
    return language === "javascript";
};

handler.handlesEditor = function() {
    return this.HANDLES_IMMEDIATE;
};

var requestId = 0;
handler.complete = function(doc, fullAst, pos, options, callback) {
    var currentNode = options.node;
    if (!currentNode || !currentNode.getPos())
        return callback();
    
    if (!isSafe(currentNode))
        return callback();
    
    var expr = getExpression(doc, currentNode.getPos());
    var myRequestId = ++requestId;
    
    this.sender.once("js_immediate_complete_results", function(e) {
        if (myRequestId !== e.data.id)
            return;
        callback(e.data.results);
    });
    this.sender.emit(
        "js_immediate_complete",
        {
            immediateWindow: this.immediateWindow,
            expr: expr,
            id: myRequestId
        }
    );
};

function isSafe(node) {
    var badNodes = node.collectTopDown(
        "Call(x, _)", function(b) {
            return !b.x.rewrite('Var("require")');
        }
    );
    return !badNodes.length && ["Call", "PropAccess", "Var"].indexOf(node.cons) > -1;
}

function getExpression(doc, pos) {
    if (pos.sl === pos.el) {
        return doc.getLine(pos.sl).substring(pos.sc, pos.ec);
    }
    var result = doc.getLine(pos.sl).substr(pos.sc);
    for (var i = pos.sl + 1; i < pos.el; i++) {
        result += doc.getLine(i);
    }
    result += doc.getLine(pos.el).substr(0, pos.ec);
    return result;
}


});

define("plugins/c9.ide.language.javascript/jumptodef",[], function(require, exports, module) {

var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');
var handler = module.exports = Object.create(baseLanguageHandler);
var scopes = require("plugins/c9.ide.language.javascript/scope_analyzer");

handler.handlesLanguage = function(language) {
    return language === "javascript" || language === "jsx";
};

handler.jumpToDefinition = function(doc, ast, pos, options, callback) {
    if (!ast || !options.node)
        return callback();
    scopes.analyze(doc.getValue(), ast, function() {
        scopes.getRenamePositions(doc, ast, pos, options, function (data) {
            if (!data || !data.declarations || data.declarations.length === 0) {
                return callback(null);
            }
            
            callback(data.declarations);
        });
    }, true);
};

});

define("plugins/c9.ide.language.javascript/outline",[], function(require, exports, module) {

require("treehugger/traverse"); // add traversal functions to trees

var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');

var outlineHandler = module.exports = Object.create(baseLanguageHandler);

var ID_REGEX = /[a-zA-Z_0-9\$\_]/;
var EVENT_REGEX = /[a-zA-Z_0-9\$\_\ \(\)\[\]\/@]/;

var NOT_EVENT_HANDLERS = {
    addMarker: true,
    traverseUp: true,
    traverse: true,
    topdown: true,
    traverseTopDown: true,
    rewrite: true,
    traverseAll: true
};

outlineHandler.handlesLanguage = function(language) {
    return language === "javascript";
};
    
outlineHandler.outline = function(doc, ast, callback) {
    if (!ast)
        return callback();
    callback({ items: outlineSync(doc, ast) });
};
    
function fargsToString(fargs) {
    var str = '(';
    for (var i = 0; i < fargs.length; i++) {
        str += fargs[i][0].value + ', ';
    }
    if (fargs.length > 0)
        str = str.substring(0, str.length - 2);
    str += ')';
    return str;
}

function expressionToName(node) {
    var name;
    node.rewrite(
        'Var(x)', function(b) { name = b.x.value; },
        'PropAccess(e, x)', function(b) { name = (b.e.cons === "Var" ? b.e[0].value + "." : "") + b.x.value; },
        'Index(e, x)', function(b) {
            var parent = (b.e[1] || b.e[0]).value || "";
            if (b.x[0])
                name = parent + "[" + b.x[0].value + "]";
        }
    );
    return name;
}
var outlineSync = outlineHandler.outlineSync = function(doc, node, includeProps) {
    var results = [];
    node.traverseTopDown(
        'Assign(e, Function(name, fargs, body))', function(b) {
            var name = expressionToName(b.e);
            if (!name) return false;
            results.push({
                icon: 'method',
                name: name + fargsToString(b.fargs),
                pos: this[1].getPos(),
                displayPos: (b.e[1] || b.e[0] || b.e).getPos(),
                items: outlineSync(doc, b.body, includeProps)
            });
            return this;
        },
        'VarDeclInit(x, Function(name, fargs, body))', 'ConstDeclInit(x, Function(name, fargs, body))',
        function(b) {
            results.push({
                icon: 'method',
                name: b.x.value + fargsToString(b.fargs),
                pos: this[1].getPos(),
                displayPos: b.x.getPos(),
                items: outlineSync(doc, b.body, includeProps)
            });
            return this;
        },
        'PropertyInit(x, Function(name, fargs, body))', 'Method(x, Function(name, fargs, body))', function(b) {
            results.push({
                icon: 'method',
                name: b.x.value + fargsToString(b.fargs),
                pos: this[1].getPos(),
                displayPos: b.x.getPos(),
                items: outlineSync(doc, b.body, includeProps)
            });
            return this;
        },
        'VarDeclInit(x, e)', 'ConstDeclInit(x, e)', function(b) {
            var items = outlineSync(doc, b.e, includeProps);
            if (items.length === 0)
                return this;
            results.push({
                icon: 'property',
                name: b.x.value,
                pos: this[1].getPos(),
                displayPos: b.x.getPos(),
                items: items
            });
            return this;
        },
        'PropertyInit(x, e)', function(b) {
            var items = outlineSync(doc, b.e, includeProps);
            if (items.length === 0 && !includeProps)
                return this;
            results.push({
                icon: 'property',
                name: b.x.value,
                pos: items.length ? this[1].getPos() : this.getPos(),
                displayPos: b.x.getPos(),
                items: items
            });
            return this;
        },
        'Assign(x, e)', function(b) {
            var name = expressionToName(b.x);
            if (!name)
                return false;
            var items = outlineSync(doc, b.e, includeProps);
            if (items.length === 0)
                return this;
            results.push({
                icon: 'property',
                name: name,
                pos: this[1].getPos(),
                displayPos: (b.x[1] || b.x[0] || b.x).getPos(),
                items: items
            });
            return this;
        },
        'Call(e, args)', function(b) {
            var eventHandler = tryExtractEventHandler(this);
            if (!eventHandler)
                return false;
            var object = b.e.rewrite("PropAccess(Var(x), _)", function(b) { return b.x.value; });
            results.push({
                icon: 'event',
                name: (object ? object + "." : "") + eventHandler.s[0].value,
                pos: this.getPos(),
                displayPos: eventHandler.s.getPos(),
                items: eventHandler.body && outlineSync(doc, eventHandler.body, includeProps)
            });
            return this;
        },
        'Class(x, y, body)', function(b) {
            results.push({
                icon: 'event',
                name: b.x.value + (b.y.value ? " extends " + b.y.value : ""),
                pos: this.getPos(),
                displayPos: b.x.getPos(),
                items: b.body && outlineSync(doc, b.body, includeProps)
            });
            return this;
        },
        'Function(name, fargs, body)', function(b) {
            if (!b.name.value)
                return false;
            results.push({
                icon: 'method',
                name: b.name.value + fargsToString(b.fargs),
                pos: this.getPos(),
                displayPos: b.name.getPos(),
                items: outlineSync(doc, b.body, includeProps)
            });
            return this;
        }
    );
    return results;
};

var tryExtractEventHandler = outlineHandler.tryExtractEventHandler = function(node, ignoreBind) {
    var result;
    node.rewrite('Call(e, args)', function(b) {
        var name = expressionToName(b.e);
        if (!name || b.args.length < 2 || NOT_EVENT_HANDLERS[name])
            return false;
        var s;
        var fun;
        if (b.args[0] && b.args[0].cons === 'String' && isCallbackArg(b.args[1], ignoreBind)) {
            s = b.args[0];
            fun = b.args[1];
        }
        else if (b.args[1] && b.args[1].cons === 'String' && isCallbackArg(b.args[2], ignoreBind)) {
            s = b.args[1];
            fun = b.args[2];
        }
        else {
            return false;
        }
        if (!s[0].value.match(EVENT_REGEX))
            return false;
        if (b.args.length >= 4 && b.args[2].cons === 'String' && b.args[3].cons === 'Function')
            return false;
        result = {
            s: s,
            fargs: fun[1],
            body: fun[2]
        };
    });
    return result;
};

var isCallbackArg = function(node, ignoreBind) {
    if (!node)
        return false;
    var result;
    node.rewrite(
        'Function(_, _, _)', function() { result = true; },
        'Call(PropAccess(_, "bind"), [_])', function() { result = !ignoreBind; }
    );
    return result;
};

});

define("plugins/c9.ide.language.javascript/debugger",[], function(require, exports, module) {

    var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');
    
    var expressionBuilder = module.exports = Object.create(baseLanguageHandler);
    
    expressionBuilder.handlesLanguage = function(language) {
        return language === "javascript" || language === "jsx";
    };
    expressionBuilder.getInspectExpression = function(doc, fullAst, pos, options, callback) {
        if (!options.node) return callback();
        
        callback(getExpression(options.node));
    };
    var getExpression = function(node) {
        if (node.value)
            return { value: node.value, pos: node.getPos() };
        
        var result;
        node.rewrite(
            'VarDeclInit(x, _)', 'ConstDeclInit(x, _)', function(b) {
                node = b.x;
                result = b.x.value;
            },
            'VarDecl(x)', 'ConstDecl(x)', function(b) {
                node = b.x;
                result = b.x.value;
            },
            'PropAccess(e, x)', function(b) {
                result = getExpression(b.e) + "." + b.x.value;
            },
            'Var(x)', function(b) {
                result = b.x.value;
            },
            'Num(n)', function(b) {
                result = b.n.value;
            },
            'Index(e, idx)', function(b) {
                result = getExpression(b.e) + "[" + getExpression(b.idx) + "]";
            },
            'New(e, args)', function(b) {
                var method = getExpression(b.e);
                var args = b.args.toArray().map(getExpression).join(", ");
                result = "new " + method + "(" + args + ")";
            },
            'FArg(x)', function(b) {
                result = b.x.value;
            },
            'Op(op, e1, e2)', function(b) {
                result = getExpression(b.e1) + " " + b.op.value + " " + getExpression(b.e2);
            },
            function() {
                if (!result)
                    result = "";
            }
        );
        
        if (result === "")
            return;
        
        return { value: result, pos: node.getPos() };
    };

});

define("plugins/c9.ide.language.javascript/parse",[], function(require, exports, module) {

var parser = require("treehugger/js/parse");
var traverse = require("treehugger/traverse");
var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');

var handler = module.exports = Object.create(baseLanguageHandler);

handler.handlesLanguage = function(language) {
    return language === "javascript" || language === "jsx";
};

handler.handlesEditor = function() {
    return this.HANDLES_ANY;
};

handler.parse = function(code, callback) {
    var result;
    try {
        code = code.replace(/^(#!.*\n)/, "//$1");
        result = parser.parse(code);
        traverse.addParentPointers(result);
    } catch (e) {
        result = null;
    }
    
    callback(result);
};

handler.getMaxFileSizeSupported = function() {
    return .25 * 10 * 1000 * 80;
};

handler.findNode = function(ast, pos, callback) {
    var treePos = { line: pos.row, col: pos.column };
    callback(ast.findNode(treePos));
};

handler.getPos = function(node, callback) {
    callback(node.getPos());
};

handler.getMaxFileSizeSupported = function() {
    return 1000 * 1000;
};

});

define("plugins/c9.ide.language.generic/simple/shell",[], function(require, exports, module) {

var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');

var handler = module.exports = Object.create(baseLanguageHandler);
    
handler.handlesLanguage = function(language) {
    return language === "sh";
};

handler.getIdentifierRegex = function() {
    return (/[a-zA-Z_0-9\.\-\~]/);
};

handler.getCompletionRegex = function() {
    return (/\$/);
};


});

define("plugins/c9.ide.language.generic/simple/make",[], function(require, exports, module) {

var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');

var handler = module.exports = Object.create(baseLanguageHandler);
    
handler.handlesLanguage = function(language) {
    return language === "makefile";
};

handler.getIdentifierRegex = function() {
    return (/[a-zA-Z_0-9\/\.\-\~]/);
};


});

define("plugins/c9.ide.language.generic/mode_completer",[], function(require, exports, module) {

var completeUtil = require("plugins/c9.ide.language/complete_util");
var workerUtil = require("plugins/c9.ide.language/worker_util");
var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');

var completer = module.exports = Object.create(baseLanguageHandler);

var modeCache = {}; // extension -> static data
var iconLanglist = ["php", "css"];

completer.handlesLanguage = function(language) {
    return ["css"/*, "php"*/].indexOf(language) !== -1;
};

completer.getMaxFileSizeSupported = function() {
    return Infinity;
};

completer.complete = function(doc, fullAst, pos, options, callback) {
    var language = this.language;
    var line = doc.getLine(pos.row);
    var idRegex = workerUtil.getIdentifierRegex(pos);
    var identifier = options.identifierPrefix;
    if (line[pos.column - 1] === ".")
        return callback([]);

    var mode = modeCache[language];

    if (mode === undefined) {
        var text;
        if (language)
            text = completeUtil.fetchTextSync('plugins/c9.ide.language.generic/modes/' + this.language + '.json');
        try {
            mode = text ? JSON.parse(text) : {};
        } catch (e) {
            console.error(e);
            mode = {};
        }
        modeCache[language] = mode;
    }

    function getIcon(type) {
        if (iconLanglist.indexOf(language) === -1)
            return null;
        var iconMap = {
            "variable": "property",
            "type": "property2",
            "constant": "method2",
            "color": "method2",
            "font": "method2",
            "function": "method2",
            "pseudo.element": "event",
            "pseudo.class": "event"
        };
        var subs = Object.keys(iconMap);
        for (var i = 0; i < subs.length; i++)
            if (type.indexOf(subs[i]) !== -1)
                return iconMap[subs[i]];
        return null;
    }
    var types = Object.keys(mode);
    var matches = [];
    types.forEach(function (type) {
        var icon = getIcon(type);
        var nameAppend = "", replaceAppend = "";
        if (type.indexOf("function") !== -1) {
            nameAppend = "()";
            replaceAppend = "(^^)";
        }
        var deprecated = type.indexOf("deprecated") === -1 ? 0 : 1;
        var compls = completeUtil.findCompletions(identifier, mode[type]);
        matches.push.apply(matches, compls.map(function(m) {
            return {
                name: m + nameAppend,
                replaceText: m + replaceAppend,
                doc: deprecated ? ("Deprecated: <del>" + m + nameAppend + "</del>") : null,
                icon: icon,
                meta: type,
                identifierRegex: idRegex,
                priority: 2 - deprecated
            };
        }));
    });
    
    callback(matches);
};


});

define("plugins/c9.ide.language.generic/snippet_completer",[], function(require, exports, module) {

var completeUtil = require("plugins/c9.ide.language/complete_util");
var baseLanguageHandler = require('plugins/c9.ide.language/base_handler');

var completer = module.exports = Object.create(baseLanguageHandler);

var snippetCache = {}; // extension -> snippets
    
completer.handlesLanguage = function(language) {
    language = language && language.slice(language.lastIndexOf("/") + 1);
    return snippetCache[language] || snippetCache._;
};

completer.getMaxFileSizeSupported = function() {
    return Infinity;
};

completer.complete = function(doc, fullAst, pos, options, callback) {
    var line = doc.getLine(pos.row);
    var identifier = completeUtil.retrievePrecedingIdentifier(line, pos.column, completer.$getIdentifierRegex());
    if (line[pos.column - identifier.length - 1] === '.') // No snippet completion after "."
        return callback([]);
    
    var language = this.language && this.language.slice(this.language.lastIndexOf("/") + 1);
    var snippets = snippetCache[language];
    
    var allIdentifiers = Object.keys(snippets || {});
    
    var matches = completeUtil.findCompletions(identifier, allIdentifiers);
    callback(matches.map(function(m) {
        var snippet = snippets[m];
        return {
            name: snippet.name,
            snippet: snippet.content,
            replaceText: snippet.name,
            doc: "<pre>" + snippet.content + "</pre>",
            icon: "package",
            meta: "snippet",
            isGeneric: true,
            priority: 0 // todo change this back to 2 once snippets are cleaned up
        };
    }));
};

completer.init = function(callback) {
    this.sender.on("loadSnippets", function(e) {
        snippetCache[e.data.language] = e.data.snippets;
    });
    callback();
};

});
